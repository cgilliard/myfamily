1.) FatPtr (total overhead 8 bytes - no change from existing FatPtr)
1 bitflag - global (built using global allocator)
1 bitflag - pin (if set, fam_realloc fails)
1 bitflag - copy (whether it can be copied)
3 bytes - size (max 2^24 bytes)
4 bytes - id (up to 2^32 ids per size)

do we merge object/rc?
2.) Rc - rc_build(FatPtr data) // builds based on FatPtr (sets atomic based on 'global'). 
// If copy set, copies, otherwise moves.

// Reference counter with cleanup function
3.) Object {
	Rc rc; // Reference counter
	// additional parameters to handle tracking borrow checking counts
	// consumed flag
	// no-cleanup flag
	// is mutably borrowed flag (go in Rc?)
	// immutable borrow count - u32 (go in Rc?)
}

4.) Macros
Move(Object *dst, Object *src); // implicitly copies Objects whose FatPtr is marked 'copy'.
Ref(Object *dst, Object *src); // create an immutable reference to src in dst.
MutRef(Object *dst, Object *src); // create a mutable reference to src in dst.
Send(Object *obj, Channel *channel); // send an object to a channel intra-thread passing (check global).

Channel channel = channel_build(1);

void test() {
	let x = spawn({
		int v = 123;
		info("test");
		let y = Recv(channel);
		info("s={}", y);
		let ret = _(U64, 1);
		ret;
	});

	let s = _(String, "hi", with(send, true));
	Send(channel, s);

	let ret = join(&x);
	info("complete!");
}
