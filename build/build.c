// Copyright (c) 2024, The MyFamily Developers
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <base/misc.h>
#include <base/path.h>
#include <base/resources.h>
#include <build/build.h>
#include <glob.h>
#include <stdlib.h>
#include <toml/toml.h>
#include <util/proc_executor.h>

void build_libs(const char *base_dir)
{
	printf("build libs: %s\n", base_dir);
	Path lib_h;
	path_for(&lib_h, base_dir);
	path_push(&lib_h, "lib.h");
	if (path_exists(&lib_h)) {
		printf("found lib.h!\n");
	}
}

int proc_build(const char *base_dir)
{
	Path base;
	path_for(&base, base_dir);
	if (path_canonicalize(&base)) {
		exit_error("Directory ('%s') not found.", base_dir);
	}
	Path toml;
	path_for(&toml, base_dir);
	path_push(&toml, "fam.toml");
	if (path_canonicalize(&toml)) {
		exit_error("Toml file ('%s') not found.", path_to_string(&toml));
	}

	FILE *toml_fp = myfopen(path_to_string(&toml), "r");
	char errbuf[1024];
	toml_table_t *table = toml_parse_file(toml_fp, errbuf, sizeof(errbuf));

	if (table == NULL) {
		exit_error("Could not parse toml file due to '%s'", errbuf);
	}

	myfclose(toml_fp);

	toml_raw_t raw_fam_version = toml_raw_in(table, "fam_version");
	char *fam_version;
	if (raw_fam_version) {
		toml_rtos(raw_fam_version, &fam_version);
		fprintf(stderr, "Toml generated by fam version: %s\n", fam_version);
		free((void *)fam_version); // Clean up after toml_rtos
	}

	toml_table_t *package_table = toml_table_in(table, "package");
	if (package_table) {
		toml_raw_t raw_name = toml_raw_in(package_table, "name");
		char *name;
		if (raw_name) {
			toml_rtos(raw_name, &name);
			fprintf(stderr, "Building Project: '%s'\n", name);

			Path target;
			path_for(&target, base_dir);
			path_push(&target, "target");
			if (!path_exists(&target)) {
				if (path_mkdir(&target, 0700))
					exit_error("Could not create directory '%s'.", path_to_string(&target));
				path_push(&target, "objs");
				if (path_mkdir(&target, 0700))
					exit_error("Could not create directory '%s'.", path_to_string(&target));
			}

			build_libs(base_dir);

			char *args[] = { "cc", "-c", "-o", "target/objs/main.o", "main.c", NULL };
			if (execute_process(args)) {
				exit_error("execution of process '%s' failed", args[0]);
			}

			glob_t glob_result;
			glob("target/objs/*.o", 0, NULL, &glob_result);

			// Construct the argument array for exec
			char *link[5 + glob_result.gl_pathc + 1];
			Path output_file;
			path_for(&output_file, "target");
			path_push(&output_file, name);
			link[0] = "cc";
			link[1] = "-o";
			link[2] = path_to_string(&output_file);

			// Add all the .o files from glob to the argument list
			for (size_t i = 0; i < glob_result.gl_pathc; i++) {
				link[3 + i] = glob_result.gl_pathv[i];
			}
			link[3 + glob_result.gl_pathc] = NULL; // Terminate the argument list

			if (execute_process(link)) {
				exit_error("execution of process '%s' failed", link[0]);
			}

			free((void *)name); // Cleanup after toml_rtos
			// Free the TOML table when done
			toml_free(table);
		} else {
			exit_error("project name not found!");
		}
	} else {
		exit_error("[package] directive not found!");
	}

	return 0;
}
