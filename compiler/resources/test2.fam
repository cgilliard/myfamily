// TODO: move to -> return type syntax.
// rust equiv: use abc::def::ghi as ghi2;
@abc::def::ghi(ghi2);
// rust equiv: use ghi::abc::{x, y as y2};
@ghi::abc::{x, y(y2)};
// rust equiv: use xyz::*;
@xyz::*;

// incomplete class
Clone {
	// immutable. '_' is a special return type which means it returns an instance of itself.
	@_ clone();
}

// incomlete class that requires completion of another class.
SuperClone: Clone {
	@_ super_clone();
}

EnumTest {
	V1,
	V2,
}


// To call each of these, you'd do: EnumTest2::V1::test_enums(); or EnumTest2::V2::test_enums();
// let mut x1 = EnumTest2::V1 { x: 10 }; x1.incr(); x1.display(); // prints 11
// let mut x2 = EnumTest2::V2 { x: 20 }; x2.incr(); x2.display(); // prints 22
EnumTest2 {
	V1: Clone {
		x: i32;
		test_enums() {
			println!("enum v1 printing");
		}
		@display() {
			println!("x={}", @x);
		}
		@mut incr() {
			@x += 1;
		}

		@_ clone() {
			@ { x }
		}
	},
	V2: Clone {
		x: u64;
		test_enums() {
			println!("enum v2 printing");
		}
		@display() {
			println!("x={}", @x);
		}
		@mut incr() {
			@x += 2;
		}

		@_ clone() {
                        @ { x }
                }
	},
}

// to implement code that applies to all variants create another block. The secondary block can only
// have functions, no data. It also cannot implement traits. That must be done at the variant level as seen above.
EnumTest2 {
	@display2() {
		println!("x2={}", @x);
	}
}

TupleTest {
	x: (u32, i32, u64);
	// arrays any type followed by size
	my_arr: u32[100];
	// raw pointer type. Can use alloc!(&mut *, usize) and dealloc!(&mut *
	my_arr2: * u32;
	@(u32, i32, u64) get_x() {
		@x
	}

	// this function is implicitly returning (i32, u64).
	@get_tuple2() {
		let ret = (0i32, @x.2);
		ret
	}

	// mutable function that sets part of the tuple based on the input param
	@mut set_partial(u32 v) {
		@x.0 = v;
	}
}

MyClosureHolder {
	// when included in a function or a class, the type annotations are required.
	a: |x: i32, y: EnumTest|: i32;
}

// MyClass is a single variant enum and functions can be called as MyClass::my_fun1(0); For example. It also gets a default enumeration for
// it's implicit single variant '_'. So you could call: MyClass::_::my_fun1(0); and the result would be the same.
MyClass <T: Clone + SuperClone>: SuperClone, Clone {
	x: i32;
	y: u64;
	z: SuperClone;
	cloned: T;

	@_ super_clone() {
		@ {
			x,
			y,
			z: z.clone(),
			cloned: cloned.clone(),
		}
	}

	// no specifiers. It's a static function since it did not access the @ params.
	// the return type is implicitly u64.
	my_fun1(x: i32) {
		// closure syntax
		// all closures are FnMut and 'move'.
		// types can be determined implicitly. i32 is the return type in this case. The syntax is the : 'i32'.
		// If nothing specified '$' (Unit) is implicit. Unless there is a returned value other than '$'.
		let mut cl = |a: u32, b|: i32 { a + b };
		let v: u64 = 0;

		v
	}

	// no specifiers. It's implicitly not static. It's implicitly immutable. Implicitly returns $ (unit type).
	my_fun2(x: &i32) {
		let y = x + @x;
		// the '!' symbol indicates this is a native function that calls C code which is specified in the confiuration
		// file (TODO).
		println!("y={}", y);
	}

	// no specifiers. It's implicitly not static. It's implicitly mutable. It implicitly returns u64.
	my_fun3(x: &mut u64) {
		@y = *x;
		@y
	}

	// While it would implicitly be static, since the @ symbol is used, it is not static.
	// implicitly returns ()
	@my_fun3(x: i128) {
		println!("test");
	}

	//  It's explicitly mutable non-static. Implicitly returns i32.
	@mut my_fun4(x: i8) {
		if(x == 0)
			return -1i32;
		@x += 1;
		return 100;
	}

	// It's explicitly mutable non-static. Explicitly returns i32.
	@mut i32 my_fun4() {
		1
	}
	

	// this function is static and the parameters are not applicable.
	_ build(x: i32, y: u64) {
		MyClass {
			x,
			y
		}
	}

	@mut do_stuff(x: &i32) {
		@x = *x;
	}

	@do_stuff2(x: &mut i32) {
		*x = @x;
	}

	// static returns $ implicitly
	test_references() {
		mut x: i32 = 1; // mutable
		let y = 2; // immutable defaults to i32
		let z = &mut x;
		
		MyClass v = MyClass::build(1,2);
		v.do_stuff(&x);
		v.do_stuff2(&mut x);
		
		y = 2;
	}
} 

MyClass2 {
	Rc<MyClass> x;
	MyClass2 build(mc: MyClass) {
		let x = Rc::new(mc2);
		@ {
			x 
		}
	}
}

MyClass3 {
	test() {
		let mc: MyClass = MyClass::build(1, 2);
		let x = MyClass2::build(mc);
	}
}
