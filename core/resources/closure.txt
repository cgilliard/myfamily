
let a = _(String, "testing 123");
let b = _(U32, 123);
mut closure = _(Captured(a, b), {
	// do some computation
	Ok(v);
});

let v = execute_closure(&closure);
// use v


let x = _(MyHugeObject);
// process x.
// we are done with x.

// do some other things.

let a = _(String, "testing 123");
let b = _(U32, 123);
mut closure = _(Captured(a, b), {
// do some computation
        Ok(v);
});

// use v.

// park thread and do other stuff

@FnMut(T[Tuple], S[Self], R) {
	@mut call(&S, args: T) -> R;
}

@Fn(T[Tuple], S[Self], R) {
        @call(&S, args: T) -> R;
}

MyClosure(T, R) {

}

impl MyClosure(T[(u32, i32, u64)], R[Result[i32]]) FnMut(T, R);

let a = _(String, "testing 123");
let b = _(U32, 123);
mut closure = _(Captured(a, b), {
// do some computation
        Ok(0);
});

let r = Exec(closure, 1, -1, 100);


// built-in trait
@FnMut(T[Tuple], S[Self], R) {
        @mut call(&S, args: T) -> R;
}

// derive with this tuple as the param list
#[Derive(FnMut(u32, i32, u64)]
MyClosureType(T) {
}


let a = _(String, "testing 123");
let b = _(U32, 123);
mut closure = _(MyClosureType, Params(u32, i32, u64), Captured(a, b), {
    Ok(v); // some computation
});

let result = Exec(closure, 1,2,3); // Execute with specific arguments

