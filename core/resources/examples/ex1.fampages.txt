// This is a proposal of a universal prototype data structure.
// It is meant to serve the purpose of both a class like structure which can be instantiated into
// an object and a interface like structure that specifies what the implementing class must provide.
// The prototype can be a combiation of each (interface-like and class-like) as well. If a prototype
// has any aspect that is 'inferface-like', it is considered 'incomplete'. Any prototype may complete
// another prototype which is incomplete. Incomplete prototypes may not be instantiated.
// The syntax of the prototype is as follows:
// Example 1: Base type definition

// This prototype uses the struct-like syntax to define two named parameters ('x' and 'y') as fields.
// They are of the primitive types i32 and u64 respectively.
ProtoTest1 {
	@x: i32;
	@y: u64;
}

// This prototype uses the tuple-like syntax to define two unnamed fields of the type i32 and u64 respectively.
ProtoTest2 (i32, u64)

// This prototype uses the unit-like syntax. It has no fields.
ProtoTest3

// Example 2: single vs multi variant enums

// Below is an example of a multi variant enum. This prototype has 3 variants. They are V1, V2, and V3.
// They use the three syntax types previously described. When an enum has no variants specified and uses
// the struct-like syntax (as is the case in the ProtoTest1 example), it implicitly is a single variant enum.
// In an implicit single variant enum, the single variant is unnamed.
ProtoTest4 {
	V1 {
		@x: i32;
		@y: u64;
	},
	V2(u32),
	V3
}

// Example 3: nested enums

// in this example, variant V1 defines another enum inside of itself. V2 is a tuple-like variant.
ProtoTest5 {
	V1 {
		NestV1 {
			@x: i32;
			@y: u128;
		},
		NestV2(i32, bool),
		NestV3
	},
	V2(u32)
}

// Example 4: accessing variants and instantiation.
ProtoTest6 {
	test() {
		// single variant struct-like prototypes are instantiated using standard syntax
		// for creating structs.
		var v1 = ProtoTest1 { x: 1, y: 2 };

		// tuple-like prototypes are instantiated using standard syntax for creating tuples
		var v2 = ProtoTest2(10, 20);

		// unit-like prototypes are instantiated using standard syntax for unit types
		var v3 = ProtoTest3;

		// likewise multi-variant prototypes that are defined in a struct like manner use
		// standard syntax to instantiate as well.
		var v4 = ProtoTest4::V1 { x: 1, y: 2 };

		// tuple-like
		var v5 = ProtoTest4::V2(0);

		// unit-like
		var v6 = ProtoTest4::V3;

		// below demonstrates how to instantiate nested variants
		var v7 = ProtoTest5::V1::NestV1 { x: 1, y: 2 };
		var v8 = ProtoTest5::V1::NestV2(1, false);
		var v9 = ProtoTest5::V1::NestV3;
		var v10 = ProtoTest5::V2(10);

		// To access a variant/field the following syntax is used:
		// a unnamed single variant struct-like syntax is accessed in a way
		// one might expect to access the fields of a struct;
		var x1 = v1.x;
		var x2 = v1.y;

		// tuple like
		var x3 = v2.0; // this refers to the 0th element in v2 which is a 2 element tuple;
		var x4 = v2.1; // second element

		// In the case of v4, it was instantiated as a struct-like variant of ProtoTest4, so
		// it is accessed in a struct-like manner.
		var x5 = v4.x;
		var x6 = v4.y;

		// v5 is a special case of the tuple-like syntax. If a tuple only has a single field,
		// we do not require the index to be specified and it is assumed that the single element
		// is being referenced. The example below demonstrates this syntax.
		var x7 = v5; // x7 contians the value of the 0th element in v5 which is 0.

		// The remaining types would be accessed in the same maner. The inner most nesting applies.
		// So, if the inner-most variant is described in a struct-like manner, you access it as above.
		// same goes for tuple-like.
	}
}

// Example 5: static and member functions

// Prototypes may have 0 or more static and 0 or more member functions.
// The below example shows the static functions do_things2 and do_all and the member
// function do_thing1. The '@' indicates that this function is a member function.
// member functions have an implicit reference to themselves that can be accessed within
// the function via the '@' symbol. This symbol is similar to the 'self' variable in rust.
// In the case below, The @value is set to one when the variable 'obj' is instantiated.
// Then when obj.do_thing1 is called with the parameter 10 specified, @value (1) is added to x (10).
// So, the return value of this function is 11. Fucntions may optionally specify a return type. If
// no return type is specified they are assumed to have no return type. As in rust, the last statement
// is the return value. So in the example, below the function returns @value + x. Functions with
// the '!' at the end are native functions which are implemented in C. The details of their implementation
// is beyond the scope of the discussion for now.
ProtoTest7 {
	// member function with one parameter and a return type both i32.
	@do_thing1(x: i32) -> i32 { println!("show: {}", x); @value + x }
	// static function that calls a native function with a string literal as the argument.
	do_thing2() { println!("hello world!"); }
	// static function with no parameters or return type.
	do_all() {
		// instantiate the object with the specified value.
		var obj = ProtoTest7 { value: 1 };
		// call member function do_thing1.
		let i32 v = obj.do_thing1(10);
		// print result
		println!("v={}", v);
		// call the static function do_thing2.
		ProtoTest7::do_thing2();
	}
	// the single field for this prototype
	@value: i32;
}

// Example 6: incomplete prototypes

// incomelete prototype
Greet {
	@greet();
}

// Cat completes the greet prototype
Cat: Greet {
	// implement the required greet function
	@greet() {
		println!("meow!");
	}
}

// Dog completes the greet prototype
Dog: Greet {
	// implement the required greet function
        @greet() {
                println!("bark!");
        }
}

TestGreet {
	test() {
		var cat = Cat {};
		var dog = Dog {};
		cat.greet();
		dog.greet();
		// output:
		// meow!
		// bark!
	}
}

// Example 7: Mutability
TestMutability {
	@mut update_x(x: i32) {
		@x = x;
	}
	@mut update_y(y: u32) {
		@y = y;
	}
        @mut update_y(z: u64) {
                @z = z;
        }

	@get_x() -> i32 {
		@x
	}

	@get_y() -> u32 {
                @y
        }

	@get_z() -> u64 {
                @z
        }

	test() {
		var v = TestMutability { x: 1, y: 2, z: 3 };
		v.update_x(10);
		v.update_y(20);
 		v.update_z(30);

		let v = TestMutability { x: 1, y: 2, z: 3 };
		println!("v.x={},v.y={},v.z={}", v.get_x(), v.get_y(), v.get_z());
		// would result in a compiler error because let syntax indicates immutabillity:
		// v.update_x(100);
	}

	@x: i32;
	@y: u32;
	@z: u64;
}

// Example8: Implicit mutability and static/member status

// functions need to explicitly state their mutability. Based on the body of the function, the mutability
// and static / member status is implied. If a function is implicitly mutable the mutability rules apply.
// likewise for implicit member functions.
TestImplicitMutability {
	// although this function is not speicified as @mut test1(), it is implicitly a mutable member
	// function due to the fact that it mutably accesses the '@' variable in its body.
	test1() {
		@x += 1;
	}

	// this function is a static fucntion as it does not access the '@' variable.
	test2() {
		println!("ok");
	}

	// this function immutably accesses the '@' variable so it is implicitly @test3() -> u64.
	test3() -> u64 {
		@y
	}
	@x: i32;
	@y: u64;
}

// Example 9: dynamically vs statically sized arrays and memory management

// drop prototype is a built-in incomplete prototype which, when implemented by a complete prototype
// is executed when the instance goes out of scope or has no more references.
Drop {
	@drop();
}

TestArrays: Drop {
	test() {
		// build an instance of a TestArrays prototype
		var te = TestArrays::build(200);
	}

	build(capacity: u64) -> @ {
		// allocate memory to the dynamically sized array 'value1'.
		// allocate is a native function that returns a dynamically sized array insance.
		// user is responsible for deallocation.
		var value1: [u8] = allocate!(capacity);
		// declare the appropriate sized statically sized array.
		let value2: [u8; 100];

		// initialize both arrays
		for i in 0..capacity {
			value1[i] = 0;
		}
		for i in 0..100 {
                        value2[i] = 0;
                }

		// return the @ with initialized values.
		@ {
                        value1, 
                        value2
                }
	}

	// this drop implementation deallocates all memory assigned to value1 via the native function deallocate.
	@drop() {
		deallocate!(value1);
	}

	@value1: [u8]; // a dynamically sized array
	@value2: [u8; 100]; // a statically sized array with 100 elements
}

// Example 10: Pattern matching

EnumMatch1 {
	@x: u32;
	@y: i64;
}

EnumMatch2 {
	V1,
	V2(u32, i64),
	V3 {
		@x: u64;
		@y: i32;
	},
}

EnumMatch3 {
        V1 {
                NestV1 {
                        @x: i32;
                        @y: u128;
                },
                NestV2(i32, bool),
                NestV3
        },
        V2(u32)
}

TestMatch {
	test() {
                let v1 = EnumMatch1 { x: 1, y: 2 };

		// recall that single member struct-like prototypes have an implicit single
		// unnamed variant. Since they have no name, they cannot be matched by name in
		// a match so they can only be referred to by the '_' wild card operator. See
		// below.

		var test1 = false;
		var test1 = match v1 {
			_ => { true }
		};
		assert(test1);


		// the below example demonstrates matching on a multi-variant prototype
		var v2 = EnumMatch2::V2(1, -1);
		var test2 = match v2 {
			V1 => { false }, // this is not a match since we are 'V2'
			// matching a tuple-like syntax requires the same number of arguments as specified
			V2(x, y) => {
				// assert expected values
				assert_eq(x, 1);
				assert_eq(y, -1);
				true
			},
			V3(x) => { false } // this is not a match since we are 'V2'
		};
		assert(test2);

		var v3 = EnumMatch2::V3 { x: 100; y: -100 };
		var test3 = match v3 {
			V1 => { false },
			V3(v) => {
				// v will hold the value of the struct-like syntax here
				// do assertions for expected values
				assert_eq(v.x, 100);
				assert_eq(v.y, -100);
			}
			_ => false, // wild card notation can be used to match all remaining variants.
		};
		assert(test3);

		// matching a unit-like variant.
		var v4 = EnumMatch2::V1;
		var test4 = match v4 {
			V1 => true,
			_ => false,
		};
		assert(test4);

		// demonstration of matching nested enums
		var v5 = EnumMatch3::V1::NestV1 { x: 1, y: 2 };
                var v6 = EnumMatch3::V1::NestV2(1, false);
                var v7 = EnumMatch3::V1::NestV3;

		// match v5 which is of the EnumMatch3::V1::NestV1 variant.
		let test5 = match v5 {
			// match and do assertions
			EnumMatch3::V1::NestV1(v) => { assert_eq(v.x, 1); assert_eq(v.y, 2); true },
			_ => false,
		};
		assert(test5);

		// match v6 which is of the EnumMatch3::V1::NestV2 variant.
		let test6 = match v6 {
			// match and do assertions
			EnumMatch3::V1::NestV2(x,y) => { assert_eq(x, 1); assert_eq(y, false); true },
			_ => false,
		};
		assert(test6);

		// match v7 which is of the EnumMatch3::V1::NestV3 variant.
		let test7 = match v7 {
			// match and do assertions
			EnumMatch3::V1::NestV3 => true,
			_ => false,
		};
		assert(test7);
	}
}

// Example 11: modules and imports

// import module path abc::def::ghi use it as the name 'ghi2'
@abc::def::ghi(ghi2);
// import ghi::abc::x and ghi::abc::y use it as 'y2'
@ghi::abc::{x, y(y2)};
// import everything in the xyz module
@xyz::*;

mod mymod; // file based mod maps to either mymod.fam or mymod/mod.fam

// inline module definition
mod mymod2 {
        // example prototype which just has a single member for each primitive type
        // no current support for 'char' unicode or usize/isize type values. The
        // system is currently limited to 64 bit architectures.
        // @ syntax is used to represent a member field of this class.
        // without the @, these variables are 'static'
        MyMod2Class {
                @a: i8
                @b: i16
                @c: i32
                @d: i64
                @e: i128
                @f: u8
                @h: u16
                @i: u32
                @j: u64
                @k: u128
                @l: f32
                @m: f64
                @o: bool
                static_test: u32
        }
}

// Example 12: simplicity of standard traits/interfaces
// This would be similar to the clone trait in rust. Note simplified syntax to define
// the incomplete prototype here.
Clone {
        @clone() -> @;
}

// copy marker has Clone as a super trait
Copy: Clone {}

// Example 13: autoboxing attribute
// in this example we introduce prototype attributes which is a key value pair list of attributes as seen below.
// These attributes are of the form: [a=b,c=d,...]. In this instance auto-boxing is set to true. The default value
// for autoboxing is false. If set to true, variants of this prototype will be 'autoboxed' meaning internally they
// be stored on the heap. Thus the size of the largest variant of this enum will be much smaller since it only needs
// to store a pointer and some metadata for each instance. This reduces size of the object when instantiating a smaller
// variant. In this case, the size of memory required to store VariantA is reduced from one megabyte to a few 10s
// of bytes.
AutoBoxedEnum [auto-boxing=true] {
	VariantA(i32),
	VariantB {
		arr: [u8; 1_000_000];
	}
}
