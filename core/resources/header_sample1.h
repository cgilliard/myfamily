// 1.) Imports

$abc::def::t1;			 // import from module path abc::def the type 't1';
$abc::def::t2(TestType); // import from module path abc::def the type 't2' as 'TestType';
$abc::def::mymod::*;	 // import from the module path abc::def::mymod all types.

// 2.) Modules
// Modules can be define in two ways:
// - Inline: using the 'mod' keyword:
MyOuterType {
}
mod testmod {
	$..::MyOuterType; // import up one level to get a type from the outer
					  // namespace.
	MyInnerType(u32 x, MyOuterType y);
}

// - External modules

mod mymod; // This imports mymod.h or mymod/mod.h (only one must exist)

// 3.) Types
// declare a type name MyTestType
MyTestType {
	i8 a;	// i8 instance field
	i16 b;	// i16 instance field
	i32 c;	// i32 instance field
	i64 d;	// i64 instance field
	i128 e; // i128 instance field
	u8 f;	// u8 instance field
	u16 g;	// u16 instance field
	u32 h;	// u32 instance field
	u64 i;	// u64 instance field
	u128 j; // u128 instance field
	f32 k;	// f32 instance field
	f64 l;	// f64 instance field
	bool m; // bool instance field
}

// 4.) Incomplete types
// Incomplete types are types that have one or more incomplete methods.
// Incomplete methods are methods that are not implemented for the defined type.
// They must be 'completed' by other Types that implement the 'incomplete' Type.
// This concept makes incomplete types similar to interfaces or traits in other
// programming languages. Incomplete types may NOT have fields. 'incomplete'
// types are denoted with the '@' symbol. This indicates that the type is
// 'incomplete'.
@MyIncompleteType {
	// This method which is also marked with the '@' must be implemented by
	// the completing type. Note that there is an implicit 'self' variable
	// that is not listed here but will be the first parameter passed to
	// this method.
	@my_required_method()->i32;
	// This method which is NOT marked with the '@' provides a default
	// which is implemented in the corresponding C file for the incomplete
	// type (MyIncompleteType). The parameter list follows C conventions.
	// This method also has an implicit self parameter.
	my_default_implemented_method(u32 value)->i64;
}

// This type completes MyIncompleteType. This type must implement the required
// methods of the types it completes. In this case, 'my_required_method'. It can
// optionally override the default method  'my_default_implemented_method'. All
// of this is done in MyCompleteType's .c file.
MyCompleteType {
	i32 my_data;
	i64 my_other_data;
	// In 'complete' (or concrete) types, we use the '$' to indicate which
	// fields are instance fields as opposed to type global. Similarly for
	// methods, we do the same. This method is an instance method.
	i32 my_method() -> i32;

	// This is a 'type global' method which does not have an associated self
	// value.
	u64 type_global_method() -> u64;

	// Note that void is implied here if not type is specified.
	$my_void_method();

	// This also works for 'type global' methods.
	my_void_type_global_method();
}

// This line indicates that MyCompleteType completes the incomplete type of MyIncompleteType.
// The required functions must be implemented by the completing type.
MyCompleteType::MyIncompleteType;

// 5.) Mutability - the keyword mut can be used to indicate a method is mutable.
// The default is that a function is immutable if 'mut' is not specified.
MyType {
	$mut insert(i32 key, i32 value) -> bool;
	$mut remove(i32 key, i32 value) -> bool;
	$ get(i32 key) -> i32;
}

// 6.) Parameter mutability - parameters may also be mutable or immutable.
MyType {
	// In this example the instance method 'do_thing1 has four parameters.
	// The two primitive parameters are marked mutable and implicitly
	// immutable respectively. The same is the case for the 'MyOtherType'
	// parameters.
	$do_thing1(mut i32 v1, i32 v2, mut MyOtherType v3, MyOtherType v4);
}

// 7.) References - We replace the '*' syntax from C with '&' syntax here in
// methods.
MyType {
	// In this example we demonstrate the notation for passing by reference
	// vs. passing by value. The '&' is used to denote that these values are
	// passed by reference. If a type instance is passed by value, the
	// parameter is consumed and any further usage of the instance will
	// result in a runtime error. Parameters passed by reference are not
	// consumed.
	$do_thing1(mut i32 & v1, i32 & v2, mut MyOtherType & v3, MyOtherType & v4);
}

// 8.) Visibility - At the type internal level, all methods are visible
// publicly. The encapsulated .c file for a type can include private functions
// which are not accessible other than to the type itself. Each Type will have
// its own .c file that is generated by the build tool. So let's take the above
// example. The generated function signature to implement 'do_thing1' would be:
// void do_thing1(const Obj *self, i32 v1, const i32 v2, MyOtherType v3, const
// MyOtherType v4); A helper function (or other structures could be defined
// within the associated .c file to assist in processing 'do_thing1'. Perhaps,
// you have a function: void do_thing1_helper(const Obj *self, MyOtherType v3,
// const MyOtherType v4); which processed something with respect to v3/v4. In
// this sense these are 'private' functions to the type. Regarding types at the
// external level and modules, the keyword 'pub' can be used to indicate that a
// type or module can be imported into another module. See the following example
// to illustrate:
pub mod mymod {
	MySubType {
		i64 v;
	}

	pub MyType {
		i32 x;
		u64 y;
		MySubType z;
	}
}

$mymod::MyType;	   // this is ok because MyType is 'pub'
$mymod::MySubType; // this is not ok because MySubType is not 'pub'

// Imports may also use the keyword 'pub' to indicate a type from another
// module should be publicly accessible from other modules.
pub $mymod::MyType; // now MyType can be accessed from other modules,
					// directly from the current module.

// 9.) Special symbols in incomplete types used to indicate the name of the
// completing type.

// This example shows how to refer to the completing type from an incomplete
// type. Since it is not known by the incomplete type and could be different if
// multiple types complete the incomplete type.
@Clone {
	// The symbol '$' is used to denote the unknown completing type.
	@clone()->$;

	// This mutable function has a default implementation so no '@'. 'source' is of type '$'
	// (completing type) and it is passed by reference '&'.
	mut clone_from($ & source);
}

// In addition to $ there are two other special symbols that may be used in incomplete types:
// $Config and $Bindings. These have special meanings and are typically used in the Build
// trait to pass in a configuration and generic bindings for the specific Type.
@Build {
	@build($Config & config, $Bindings & bindings);
}

// Here's what drop would look like.
@Drop {
	@mut drop();
}

// 10.) Multi-variant types - types may contain more than one variant. So far, the
// types described all have a single variant. Here's an example of a multi-variant type
// Multi-variant types must be complete, they may complete incomplete types, and they may specify
// their own methods. Method specification occurs at the outer most level of the type as below.
MyEnum {
	// struct like syntax supported
	Variant1 {
		i32 x;
		u64 y;
	};
	// unit like syntax supported
	Variant2;
	// tuple like syntax supported
	Variant3(i32 c, u64 b, i16 c);
	// type like syntax
	Variant4 i64;
	// nested
	Variant5 {
		Nested1 {
			i32 inner_value;
		};
		Netsted2;
		Nested3 {
			DoubleNested1;
			DoubleNested2(i32 x, u64 y);
		}
	};
	$print(); // this method applies to all variants and is implemented in the .c file.
}

MyEnum::Equal; // My enum completes the Equal incomplete type.

// 11.) Arrays/Vectors (we support built-in types of arrays and dynamic arrays (Vector-like
// structures)
TestArrays {
	static_size_arr[u8; 100]; // a statically sized array of 100 u8 elements
	dynamic_arr[u64];		  // a dynamically sized array of u64 elements
}

// since the special incomplete type Builder is specified, we must specify a builder config
// these are passed to the 'build' function and can be used to configure the instance.
// The allowed types are primtives and char[].
Builder::Options((u64, size), (u32, value), (char[], name));

TestArrays::Build;
TestArrays::TryBuild;

// In the .c file in the 'build' method, memory could be allocated for the dynamically sized array
// using the resize macro:
// resize($(dynamic_arr), 100); // this allocates size for 100 u64 elements
// when the instance of TestArrays goes out of scope, this memory would be deallocated
// automatically. If sufficient memory cannot be allocated a thread panic will occur. In addition to
// 'resize' in methods that return a type that implements the Try trait, the try_resize() macro
// could be used. This macro has the same parameters as resize and would return an error if the
// requested memory could not be allocated instead of panicking. Finally, the wrapped_resize() macro
// could be used. The difference between wrapped_resize and try_resize is that wrapped returns a
// Result<Unit, Error> which can be processed using match functionality.

// 12.) Arrays with types - The previous works with Types as well as primitive arrays:
TestTypedArrays {
	static_size_arr[MyType; 100]; // a statically sized array of 100 MyType elements
	dynamic_arr[MyOtherType];	  // a dynamically sized array of MyOtherType elements
}

// The additional specifications on build indicate build options for the build spec.
// When additional specification pairs are added in this manner they may be retreived
// by using the special variable $Config in the incomplete class method spec. See Build above for
// an example.
TestArrays::Build((u64, size), (u32, value), (char[], name));
TestArrays::TryBuild; // TryBuild requires Build and uses its options

// 13.) Generics
// Types (both complete and incomplete may specify generics). Functions may also specify generics.
// Complete type example:
MyType<T> {
	T gen_field;
	i32 other_field;
	$mut set_gen_field(T gen_field);
}

MyType::Build((u64, size), (u32, value), (char[], name));
MyType::Drop;

// Incomplete type example (with bound)
// In this example T is bound types that complete the Clone incomplete type.
@ClonableIterator<T : Clone> {
	// This method is required and returns the Type Option<T>. The <T> syntax mirrors that of
	// languages like C++ and Rust for generics.
	@mut next() -> Option<T>;
	// Count has a default implementation and also specifies the function attribute
	// 'consume=true'. This attribute indicates that when called, the count method will consume
	// the instance it is called on.
	count[consume = true]()->u64;
}

// This generic refers to the type's own generic
MyClonableIterator<R : Equal> {
	R x;
	i32 y;
}

// This statement indicates that MyClonableIterator completes ClonableIterator with T left as
// generic. The .c file must implement 'next'. It's function signature will be generated as: Obj
// MyClonableItterator_ClonableIterator(Obj *self); // The returned 'Obj' would be typed checked at
// runtime to ensure it conforms to the specified Option<T> specs of the incomplete type.
MyClonableItterator::ClonableIterator;

// Alternatively type specific implementations can be implemented using this syntax:
MyClonableItterator::ClonableIterator where T : String;
MyClonableItterator::ClonableIterator where T : I32;
// If this syntax is used, the generic implementation cannot be specified and the type
// specific statements must be on unique complete types.

// Function level generics syntax
Test {
	$my_fun<T : Equal, R : Clone>(T value, R clonable)->i32;
}

// 14.) Tuples - standard tuple syntax. Tuples can be a field within a Type.
Test {
	(i32, MyTestType) x;
	(i32, Test2, Abc) y;
}

// nested generics
Test {
	HashMap<String, LinkedList<(u32, u64, MyType)>> hash;
}

// 15.) Doc comments
/// Doc comment here. We pass the parameters from doxygen through this to document types:
/// @param, @return, ...

// 16.) Attributes
// #[name] and #[function(param1, param2, ...)] is allowed.
