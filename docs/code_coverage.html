<!DOCTYPE html>
<html>
	<head>
		<title>Code Coverage Report</title>
		<script src="chart.js"></script>
		<style>
			.chart {
				width: 900px;
			}
			.textarea {
				overflow:auto;
				resize:none;
			}
		</style>
	</head>
	<body>
		 <p align="center">
                        Code Coverage is currently 14.94%.
                </p>
		<center>
			<div class="chart">
				<canvas id="chart"></canvas>
			</div>
		</center>
		<script>
			function format_date(timestamp, time_frame) {
				var date = new Date(timestamp);
				var day_of_month = date.getDate();
				var full_year = date.getFullYear();
				var month = 1 + date.getMonth();
				var hours = date.getHours();
				var minutes = date.getMinutes();
				var seconds = date.getSeconds();
				var am_pm = 'AM';

				if(seconds < 10) {
					seconds = '0' + seconds;
				}
				if(minutes < 10) {
					minutes = '0' + minutes;
				}
				if(hours == 12) {
					am_pm = 'PM';
				} else if(hours > 12) {
					hours -= 12;
					am_pm = 'PM';
				}
				if(hours == 0) {
					hours = 12;
				}

				return month + '/' + day_of_month + '/' + full_year + ' ' +
					hours + ':' + minutes + ':' + seconds + ' ' + am_pm;
			}

			let raw_data = [86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
0.00,
0.00,
0.00,
85.57,
85.57,
86.81,
84.76,
94.15,
94.15,
94.39,
96.83,
96.83,
85.76,
90.32,
87.80,
11.83,
11.83,
11.94,
0.00,
12.06,
12.06,
12.06,
12.11,
12.11,
12.11,
0.00,
12.11,
12.11,
12.17,
12.17,
12.23,
12.51,
12.49,
12.57,
12.57,
12.59,
12.70,
12.70,
0.00,
0.00,
0.00,
12.76,
12.56,
12.62,
12.62,
12.62,
12.62,
0.00,
12.73,
12.78,
12.78,
12.90,
12.90,
12.90,
12.95,
12.95,
13.24,
14.04,
14.94,];
			let labels = [format_date(1716876818 * 1000 ),
format_date(1716876822 * 1000 ),
format_date(1716904488 * 1000 ),
format_date(1716905952 * 1000 ),
format_date(1716905990 * 1000 ),
format_date(1716906171 * 1000 ),
format_date(1716906235 * 1000 ),
format_date(1716906333 * 1000 ),
format_date(1716906629 * 1000 ),
format_date(1716906787 * 1000 ),
format_date(1716907183 * 1000 ),
format_date(1716907441 * 1000 ),
format_date(1716907910 * 1000 ),
format_date(1716908379 * 1000 ),
format_date(1716909018 * 1000 ),
format_date(1716909696 * 1000 ),
format_date(1716920268 * 1000 ),
format_date(1717294283 * 1000 ),
format_date(1717311812 * 1000 ),
format_date(1717380318 * 1000 ),
format_date(1717381641 * 1000 ),
format_date(1717398065 * 1000 ),
format_date(1717484462 * 1000 ),
format_date(1717570913 * 1000 ),
format_date(1717657365 * 1000 ),
format_date(1724191151 * 1000 ),
format_date(1724195435 * 1000 ),
format_date(1724195552 * 1000 ),
format_date(1724195738 * 1000 ),
format_date(1724195748 * 1000 ),
format_date(1724195820 * 1000 ),
format_date(1724195952 * 1000 ),
format_date(1724195975 * 1000 ),
format_date(1724195998 * 1000 ),
format_date(1724196018 * 1000 ),
format_date(1724196213 * 1000 ),
format_date(1724196222 * 1000 ),
format_date(1724196289 * 1000 ),
format_date(1724196352 * 1000 ),
format_date(1724196416 * 1000 ),
format_date(1724196464 * 1000 ),
format_date(1724196866 * 1000 ),
format_date(1724196936 * 1000 ),
format_date(1724196965 * 1000 ),
format_date(1724197065 * 1000 ),
format_date(1724197251 * 1000 ),
format_date(1724197924 * 1000 ),
format_date(1724198116 * 1000 ),
format_date(1724198154 * 1000 ),
format_date(1724198186 * 1000 ),
format_date(1724198195 * 1000 ),
format_date(1724198223 * 1000 ),
format_date(1724201199 * 1000 ),
format_date(1724201211 * 1000 ),
format_date(1724201239 * 1000 ),
format_date(1724201319 * 1000 ),
format_date(1724201364 * 1000 ),
format_date(1724201440 * 1000 ),
format_date(1724201458 * 1000 ),
format_date(1724201517 * 1000 ),
format_date(1724201542 * 1000 ),
format_date(1724201632 * 1000 ),
format_date(1724201659 * 1000 ),
format_date(1724201690 * 1000 ),
format_date(1724201715 * 1000 ),
format_date(1724201729 * 1000 ),
format_date(1724202880 * 1000 ),
format_date(1724206885 * 1000 ),
format_date(1724213360 * 1000 ),];

			const data = {
				labels: labels,
				datasets: [{
					label: 'Code Coverage',
					backgroundColor: 'rgb(31,176,245)',
					borderColor: 'rgb(31,176,245)',
					data: raw_data,
				}]
			};

			const config = {
				type: 'line',
				data: data,
				options: {}
			};

			const chart = new Chart(
				document.getElementById('chart'),
				config
			);

		</script>

		<p align="center">
			Raw gcov output:<br/>
			<textarea readonly class="textarea" rows="50" cols="100">        -:    0:Source:heap.c
        -:    0:Graph:./heap.gcno
        -:    0:Data:./heap.gcda
        -:    0:Runs:9
        -:    0:Programs:1
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/heap.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:
        -:   19:typedef struct HeapDataParams {
        -:   20:	HeapDataParamsConfig config;
        -:   21:	u32 free_list_head;
        -:   22:} HeapDataParams;
        -:   23:
        -:   24:typedef struct HeapData {
        -:   25:	void **data;
        -:   26:	u32 *free_list;
        -:   27:	u32 count;
        -:   28:	u32 cur_slabs;
        -:   29:	HeapDataParams hdp;
        -:   30:} HeapData;
        -:   31:
        -:   32:typedef struct HeapAllocatorImpl {
        -:   33:	u32 hd_size;
        -:   34:	HeapAllocatorConfig config;
        -:   35:	HeapData *hd_arr;
        -:   36:} HeapAllocatorImpl;
        -:   37:
        -:   38:// debugging options/counters
        -:   39:u64 __malloc_count = 0;
        -:   40:u64 __free_count = 0;
        -:   41:bool __debug_build_allocator_malloc_fail1 = false;
        -:   42:bool __debug_build_allocator_malloc_fail2 = false;
        -:   43:bool __debug_build_allocator_malloc_fail3 = false;
        -:   44:bool __debug_build_allocator_malloc_fail4 = false;
        -:   45:bool __debug_build_allocator_malloc_fail5 = false;
        -:   46:bool __debug_build_allocator_malloc_fail6 = false;
        -:   47:bool __debug_build_allocator_malloc_fail7 = false;
        -:   48:
       94:   49:void *do_malloc(size_t size) {
       94:   50:	__malloc_count += 1;
       94:   51:	void *ret = malloc(size);
        -:   52:	// printf("malloc %zu [%p (%llu)]\n", size, ret, __malloc_count);
      188:   53:	return ret;
       94:   54:}
        -:   55:
       94:   56:void do_free(void *ptr) {
       94:   57:	__free_count += 1;
        -:   58:	// printf("free %p (%llu)\n", ptr, __free_count);
       94:   59:	free(ptr);
       94:   60:}
        -:   61:
       21:   62:void *do_realloc(void *ptr, size_t size) {
       21:   63:	void *ret = realloc(ptr, size);
        -:   64:	// printf("realloc %zu [old=%p,new=%p]\n", size, ptr, ret);
       42:   65:	return ret;
       21:   66:}
        -:   67:
        1:   68:void *fat_ptr_data(FatPtr *ptr) { return ptr->data; }
        -:   69:
        1:   70:u64 fat_ptr_len(FatPtr *ptr) { return ptr->len; }
        -:   71:
    #####:   72:u64 fat_ptr_id(FatPtr *ptr) { return ptr->id; }
        -:   73:
       27:   74:int heap_allocator_init_free_list(HeapData *hd, u64 index, u32 slabs,
        -:   75:				  bool last_is_uint_max) {
       27:   76:	hd->data[index] = NULL;
       27:   77:	if (!__debug_build_allocator_malloc_fail4)
       25:   78:		hd->data[index] = do_malloc(hd->hdp.config.slab_size * slabs);
       27:   79:	if (hd->data[index] == NULL)
        2:   80:		return -1;
        -:   81:
       25:   82:	void *tmp = NULL;
        -:   83:
       25:   84:	if (!__debug_build_allocator_malloc_fail5) {
       23:   85:		if (index == 0)
       13:   86:			tmp = do_malloc(sizeof(u32) * slabs);
        -:   87:		else {
       20:   88:			tmp = do_realloc(hd->free_list,
       10:   89:					 sizeof(u32) * (hd->cur_slabs + slabs));
        -:   90:		}
       23:   91:	}
        -:   92:
       25:   93:	if (!tmp) {
        2:   94:		do_free(hd->data[index]);
        2:   95:		return -1;
        -:   96:	}
        -:   97:
       23:   98:	hd->free_list = tmp;
        -:   99:
       23:  100:	u32 offset = index * hd->hdp.config.slabs_per_resize;
      361:  101:	for (u64 i = 0; i < slabs; i++) {
      338:  102:		if ((i == (slabs - 1)) && last_is_uint_max)
       22:  103:			hd->free_list[i + offset] = UINT32_MAX;
        -:  104:		else
      316:  105:			hd->free_list[i + offset] = offset + i + 1;
      338:  106:	}
        -:  107:
       23:  108:	return 0;
       27:  109:}
        -:  110:
        3:  111:int heap_data_compare(const void *p1, const void *p2) {
        3:  112:	int ret = 0;
        -:  113:
        3:  114:	HeapData d1 = *(HeapData *)p1;
        3:  115:	HeapData d2 = *(HeapData *)p2;
        -:  116:
        3:  117:	if (d1.hdp.config.slab_size > d2.hdp.config.slab_size)
        1:  118:		ret = 1;
        2:  119:	else if (d1.hdp.config.slab_size < d2.hdp.config.slab_size)
        2:  120:		ret = -1;
        -:  121:
        6:  122:	return ret;
        3:  123:}
        -:  124:
       17:  125:int heap_allocator_init_hdp(HeapAllocator *ptr, HeapDataParamsConfig *hdp,
        -:  126:			    u64 index) {
        -:  127:
       17:  128:	int ret = 0;
       17:  129:	ptr->impl->hd_arr[index].hdp.config = *hdp;
       17:  130:	ptr->impl->hd_arr[index].hdp.free_list_head = 0;
       17:  131:	ptr->impl->hd_arr[index].cur_slabs = 0;
       17:  132:	ptr->impl->hd_arr[index].count =
       17:  133:	    ptr->impl->hd_arr[index].hdp.config.initial_chunks;
       17:  134:	if (ptr->impl->hd_arr[index].hdp.config.initial_chunks) {
       14:  135:		ptr->impl->hd_arr[index].data = NULL;
        -:  136:
       14:  137:		ptr->impl->hd_arr[index].data = do_malloc(
       14:  138:		    ptr->impl->hd_arr[index].hdp.config.initial_chunks *
        -:  139:		    sizeof(void *));
       14:  140:		if (ptr->impl->hd_arr[index].data == NULL)
    #####:  141:			return -1;
       14:  142:		ptr->impl->hd_arr[index].cur_slabs =
       28:  143:		    ptr->impl->hd_arr[index].hdp.config.initial_chunks *
       14:  144:		    ptr->impl->hd_arr[index].hdp.config.slabs_per_resize;
       14:  145:		bool last_is_uint_max = false;
       14:  146:		ptr->impl->hd_arr[index].free_list = NULL;
       29:  147:		for (u64 i = 0;
       29:  148:		     i < ptr->impl->hd_arr[index].hdp.config.initial_chunks;
       15:  149:		     i++) {
        -:  150:
       30:  151:			if (i ==
       15:  152:			    ptr->impl->hd_arr[index].hdp.config.initial_chunks -
        -:  153:				1)
       14:  154:				last_is_uint_max = true;
       15:  155:			if (heap_allocator_init_free_list(
       15:  156:				&ptr->impl->hd_arr[index], i,
       15:  157:				ptr->impl->hd_arr[index]
       15:  158:				    .hdp.config.slabs_per_resize,
       15:  159:				last_is_uint_max))
        2:  160:				ret = -1;
       15:  161:		}
       14:  162:	} else
        3:  163:		ptr->impl->hd_arr[index].data = NULL;
       17:  164:	return ret;
       17:  165:}
        -:  166:
       18:  167:int heap_allocator_build(HeapAllocator *ptr, HeapAllocatorConfig *config,
        -:  168:			 int heap_data_params_count, ...) {
        -:  169:
        -:  170:	// check inputs
       18:  171:	if (ptr == NULL || config == NULL) {
        1:  172:		errno = EINVAL;
        1:  173:		return -1;
        -:  174:	}
        -:  175:
        -:  176:	// allocate the HeapAllocatorImpl
       17:  177:	if (!__debug_build_allocator_malloc_fail1)
       16:  178:		ptr->impl = do_malloc(sizeof(HeapAllocatorImpl));
       17:  179:	if (ptr->impl == NULL || __debug_build_allocator_malloc_fail1)
        1:  180:		return -1;
        -:  181:
       16:  182:	ptr->impl->hd_size = 0;
        -:  183:
        -:  184:	// copy the config
       16:  185:	ptr->impl->config = *config;
        -:  186:
        -:  187:	// allocate heap data array
       16:  188:	ptr->impl->hd_arr = NULL;
       16:  189:	if (!__debug_build_allocator_malloc_fail2)
       15:  190:		ptr->impl->hd_arr =
       15:  191:		    do_malloc(sizeof(HeapData) * heap_data_params_count);
       16:  192:	if (ptr->impl->hd_arr == NULL || __debug_build_allocator_malloc_fail2) {
        1:  193:		heap_allocator_cleanup(ptr);
        1:  194:		return -1;
        -:  195:	}
       15:  196:	ptr->impl->hd_size = heap_data_params_count;
        -:  197:
        -:  198:	// iterate through specified heap data params
       15:  199:	va_list hdps;
       15:  200:	va_start(hdps, heap_data_params_count);
       33:  201:	for (u64 i = 0; i < heap_data_params_count; i++) {
       18:  202:		HeapDataParamsConfig hdp = va_arg(hdps, HeapDataParamsConfig);
       18:  203:		ptr->impl->hd_arr[i].count = 0; // init to 0 for safe cleanup
       18:  204:		ptr->impl->hd_arr[i].data = NULL;
       18:  205:		if ((__debug_build_allocator_malloc_fail3 && i > 0) ||
       16:  206:		    heap_allocator_init_hdp(ptr, &hdp, i)) {
        3:  207:			ptr->impl->hd_size = i; // update for cleanup, others
        -:  208:						// did not get allocated
        3:  209:			if (ptr->impl->hd_arr[i].data) {
        2:  210:				do_free(ptr->impl->hd_arr[i].data);
        2:  211:			}
        3:  212:			heap_allocator_cleanup(ptr);
        3:  213:			return -1;
        -:  214:		}
       18:  215:	}
        -:  216:
       12:  217:	if (heap_data_params_count) {
       11:  218:		qsort(ptr->impl->hd_arr, heap_data_params_count,
        -:  219:		      sizeof(HeapData), heap_data_compare);
       11:  220:	}
        -:  221:
       12:  222:	va_end(hdps);
        -:  223:
       12:  224:	return 0;
       18:  225:}
        -:  226:
        -:  227:// binary search for the correct slab size
      385:  228:int heap_allocator_index(HeapAllocator *ptr, u64 size) {
      385:  229:	int ret = -1;
      385:  230:	if (ptr->impl->hd_size == 0)
        1:  231:		return ret;
        -:  232:
      384:  233:	int left = 0;
      384:  234:	int right = ptr->impl->hd_size - 1;
        -:  235:
      480:  236:	while (left <= right) {
      443:  237:		int mid = left + (right - left) / 2;
      443:  238:		u64 slab_size = ptr->impl->hd_arr[mid].hdp.config.slab_size;
      443:  239:		if (slab_size == size) {
      347:  240:			ret = mid;
      347:  241:			break;
       96:  242:		} else if (slab_size > size)
       40:  243:			right = mid - 1;
        -:  244:		else
       56:  245:			left = mid + 1;
      443:  246:	}
        -:  247:
      384:  248:	if (ret == -1 && right + 1 <= ptr->impl->hd_size - 1) {
       29:  249:		return right + 1;
        -:  250:	}
        -:  251:
      355:  252:	return ret;
      385:  253:}
        -:  254:
       20:  255:int heap_data_resize(u64 index, HeapData *hd) {
       20:  256:	if (hd->cur_slabs < hd->hdp.config.max_slabs) {
       26:  257:		u32 nslabs_count =
       13:  258:		    hd->hdp.config.slabs_per_resize + hd->cur_slabs;
       13:  259:		if (nslabs_count > hd->hdp.config.max_slabs)
        2:  260:			nslabs_count = hd->hdp.config.max_slabs;
        -:  261:
       13:  262:		u32 slabs_to_alloc = nslabs_count - hd->cur_slabs;
       13:  263:		void *tmp = NULL;
       13:  264:		if (!__debug_build_allocator_malloc_fail7) {
       12:  265:			if (hd->data)
       11:  266:				tmp = do_realloc(hd->data, (hd->count + 1) *
        -:  267:							       sizeof(void *));
        -:  268:			else
        1:  269:				tmp = do_malloc((hd->count + 1) *
        -:  270:						sizeof(void **));
       12:  271:		}
        -:  272:
       13:  273:		if (tmp == NULL)
        1:  274:			return -1;
       12:  275:		hd->data = tmp;
        -:  276:
       12:  277:		if (heap_allocator_init_free_list(hd, hd->count, slabs_to_alloc,
        -:  278:						  true))
        2:  279:			return -1;
       10:  280:		hd->hdp.free_list_head = hd->cur_slabs;
       10:  281:		hd->cur_slabs = nslabs_count;
       10:  282:		hd->count += 1;
       10:  283:		return 0;
       13:  284:	}
        7:  285:	return -1;
       20:  286:}
        -:  287:
      385:  288:int heap_data_allocate(u64 index, HeapData *hd, FatPtr *fptr) {
      385:  289:	if (hd->cur_slabs == 0) {
        -:  290:		// this hd initially had 0 slabs
        -:  291:		// resize it
        2:  292:		if (heap_data_resize(index, hd))
        1:  293:			return -1;
        1:  294:	}
        -:  295:
      384:  296:	if (hd->hdp.free_list_head == UINT32_MAX)
       17:  297:		return -1;
      367:  298:	u64 id = hd->hdp.free_list_head;
      367:  299:	hd->hdp.free_list_head = hd->free_list[id];
      367:  300:	fptr->id = id | (index << 56);
      367:  301:	fptr->len = hd->hdp.config.slab_size;
        -:  302:
      367:  303:	u64 heap_data_index = id / hd->hdp.config.slabs_per_resize;
      367:  304:	u64 offset_mod = id % hd->hdp.config.slabs_per_resize;
        -:  305:
      367:  306:	fptr->data =
      367:  307:	    hd->data[heap_data_index] + offset_mod * hd->hdp.config.slab_size;
        -:  308:
      367:  309:	return 0;
      385:  310:}
        -:  311:
      119:  312:int heap_data_free(u64 index, HeapData *hd, FatPtr *fptr) {
      119:  313:	u64 rel = fptr->id & 0x00FFFFFFFFFFFFFF; // Extract the relative ID
        -:  314:
      119:  315:	if (rel >= hd->cur_slabs)
        1:  316:		return -1;
        -:  317:
      118:  318:	u64 head = hd->hdp.free_list_head;
      118:  319:	hd->hdp.free_list_head = rel;
      118:  320:	hd->free_list[rel] = head;
        -:  321:
      118:  322:	return 0;
      119:  323:}
        -:  324:
      385:  325:int heap_allocator_allocate(HeapAllocator *ptr, u64 size, FatPtr *fptr) {
      385:  326:	int ret = -1;
      385:  327:	int index = heap_allocator_index(ptr, size);
        -:  328:
      385:  329:	if (index < 0) {
        9:  330:		if (!ptr->impl->config.no_malloc) {
        7:  331:			fptr->data = NULL;
        7:  332:			if (!__debug_build_allocator_malloc_fail6)
        7:  333:				fptr->data = do_malloc(size);
        7:  334:			if (fptr->data == NULL) {
    #####:  335:				fptr->len = 0;
    #####:  336:				ret = -1;
    #####:  337:			} else {
        7:  338:				fptr->len = size;
        7:  339:				fptr->id = UINT64_MAX;
        7:  340:				ret = 0;
        -:  341:			}
        7:  342:		}
        9:  343:	} else {
      376:  344:		HeapData *hd = &ptr->impl->hd_arr[index];
      376:  345:		ret = heap_data_allocate(index, hd, fptr);
      376:  346:		if (ret) {
        -:  347:			// there are no more slabs. Try to resize
       18:  348:			if (!heap_data_resize(index, hd)) {
        -:  349:				// successful resize, allocate should always
        -:  350:				// succeed here
        9:  351:				ret = heap_data_allocate(index, hd, fptr);
       18:  352:			} else if (!ptr->impl->config.no_malloc) {
        -:  353:				// could not allocate, so we fall back to malloc
        -:  354:				// if configured
        4:  355:				fptr->data = NULL;
        4:  356:				if (!__debug_build_allocator_malloc_fail6)
        3:  357:					fptr->data = do_malloc(size);
        4:  358:				if (fptr->data == NULL) {
        1:  359:					fptr->len = 0;
        1:  360:					ret = -1;
        1:  361:				} else {
        3:  362:					fptr->len = size;
        3:  363:					fptr->id = UINT64_MAX;
        3:  364:					ret = 0;
        -:  365:				}
        4:  366:			}
       18:  367:		}
      376:  368:	}
        -:  369:
      770:  370:	return ret;
      385:  371:}
        -:  372:
      130:  373:int heap_allocator_free(HeapAllocator *ptr, FatPtr *fptr) {
      130:  374:	if (fptr->id == UINT64_MAX) {
        -:  375:		// malloc allocated
        -:  376:
       10:  377:		if (fptr->data) {
       10:  378:			do_free(fptr->data);
       10:  379:			fptr->data = NULL;
       10:  380:		}
        -:  381:
       10:  382:		return 0;
        -:  383:	}
        -:  384:
      120:  385:	u64 index = (fptr->id >> 56) & 0xFF; // Extract the index
        -:  386:
      120:  387:	if (index >= ptr->impl->hd_size) {
        1:  388:		errno = EINVAL;
        1:  389:		return -1; // Invalid index
        -:  390:	}
        -:  391:
      119:  392:	HeapData *hd = &ptr->impl->hd_arr[index];
      119:  393:	return heap_data_free(index, hd, fptr);
      130:  394:}
        -:  395:
       16:  396:int heap_allocator_cleanup(HeapAllocator *ptr) {
        -:  397:	// check for impl and deallocate
       16:  398:	if (ptr->impl) {
       31:  399:		for (u32 i = 0; i < ptr->impl->hd_size; i++) {
       15:  400:			if (ptr->impl->hd_arr[i].count) {
        -:  401:				// check that it's not an unallocated heap data
       13:  402:				if (ptr->impl->hd_arr[i].free_list) {
       13:  403:					do_free(ptr->impl->hd_arr[i].free_list);
       13:  404:					ptr->impl->hd_arr[i].free_list = NULL;
       13:  405:				}
       36:  406:				for (u64 j = 0; j < ptr->impl->hd_arr[i].count;
       23:  407:				     j++) {
       23:  408:					do_free(ptr->impl->hd_arr[i].data[j]);
       23:  409:				}
       13:  410:				if (ptr->impl->hd_arr[i].data) {
       13:  411:					do_free(ptr->impl->hd_arr[i].data);
       13:  412:					ptr->impl->hd_arr[i].data = NULL;
       13:  413:				}
       13:  414:			}
       15:  415:		}
        -:  416:
       16:  417:		if (ptr->impl->hd_arr) {
       15:  418:			do_free(ptr->impl->hd_arr);
       15:  419:			ptr->impl->hd_arr = NULL;
       15:  420:		}
       16:  421:		do_free(ptr->impl);
       16:  422:		ptr->impl = NULL;
       16:  423:	}
       16:  424:	return 0;
        -:  425:}
        -:    0:Source:panic.c
        -:    0:Graph:./panic.gcno
        -:    0:Data:./panic.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/panic.h>
        -:   16:#include <stdarg.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:
    #####:   20:void panic(const char *fmt, ...) {
    #####:   21:	va_list args;
        -:   22:
    #####:   23:	fprintf(stderr, "thread panicked: ");
    #####:   24:	va_start(args, fmt);
    #####:   25:	vfprintf(stderr, fmt, args);
    #####:   26:	va_end(args);
    #####:   27:	fprintf(stderr, "\n");
        -:   28:
    #####:   29:	exit(-1);
        -:   30:}
        -:    0:Source:main.c
        -:    0:Graph:./main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
    #####:   16:int main(int argc, char **argv) { return 0; }
        -:    0:Source:toml.c
        -:    0:Graph:./toml.gcno
        -:    0:Data:./toml.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:
        -:    3:  MIT License
        -:    4:
        -:    5:  Copyright (c) CK Tan
        -:    6:  https://github.com/cktan/tomlc99
        -:    7:
        -:    8:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    9:  of this software and associated documentation files (the "Software"), to deal
        -:   10:  in the Software without restriction, including without limitation the rights
        -:   11:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   12:  copies of the Software, and to permit persons to whom the Software is
        -:   13:  furnished to do so, subject to the following conditions:
        -:   14:
        -:   15:  The above copyright notice and this permission notice shall be included in all
        -:   16:  copies or substantial portions of the Software.
        -:   17:
        -:   18:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   19:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   20:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   21:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   22:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   23:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   24:  SOFTWARE.
        -:   25:
        -:   26:*/
        -:   27:#define _POSIX_C_SOURCE 200809L
        -:   28:#include <assert.h>
        -:   29:#include <ctype.h>
        -:   30:#include <errno.h>
        -:   31:#include <stdbool.h>
        -:   32:#include <stdint.h>
        -:   33:#include <stdio.h>
        -:   34:#include <stdlib.h>
        -:   35:#include <string.h>
        -:   36:#include <toml/toml.h>
        -:   37:
        -:   38:static void *(*ppmalloc)(size_t) = malloc;
        -:   39:static void (*ppfree)(void *) = free;
        -:   40:
    #####:   41:void toml_set_memutil(void *(*xxmalloc)(size_t), void (*xxfree)(void *)) {
    #####:   42:	if (xxmalloc)
    #####:   43:		ppmalloc = xxmalloc;
    #####:   44:	if (xxfree)
    #####:   45:		ppfree = xxfree;
    #####:   46:}
        -:   47:
        -:   48:#define ALIGN8(sz) (((sz) + 7) & ~7)
        -:   49:#define MALLOC(a) ppmalloc(a)
        -:   50:#define FREE(a) ppfree(a)
        -:   51:
        -:   52:#define malloc(x) error - forbidden - use MALLOC instead
        -:   53:#define free(x) error - forbidden - use FREE instead
        -:   54:#define calloc(x, y) error - forbidden - use CALLOC instead
        -:   55:
    #####:   56:static void *CALLOC(size_t nmemb, size_t sz) {
    #####:   57:	int nb = ALIGN8(sz) * nmemb;
    #####:   58:	void *p = MALLOC(nb);
    #####:   59:	if (p) {
    #####:   60:		memset(p, 0, nb);
    #####:   61:	}
    #####:   62:	return p;
    #####:   63:}
        -:   64:
        -:   65:// some old platforms define strdup macro -- drop it.
        -:   66:#undef strdup
        -:   67:#define strdup(x) error - forbidden - use STRDUP instead
        -:   68:
    #####:   69:static char *STRDUP(const char *s) {
    #####:   70:	int len = strlen(s);
    #####:   71:	char *p = MALLOC(len + 1);
    #####:   72:	if (p) {
    #####:   73:		memcpy(p, s, len);
    #####:   74:		p[len] = 0;
    #####:   75:	}
    #####:   76:	return p;
    #####:   77:}
        -:   78:
        -:   79:// some old platforms define strndup macro -- drop it.
        -:   80:#undef strndup
        -:   81:#define strndup(x) error - forbiden - use STRNDUP instead
        -:   82:
    #####:   83:static char *STRNDUP(const char *s, size_t n) {
    #####:   84:	size_t len = strnlen(s, n);
    #####:   85:	char *p = MALLOC(len + 1);
    #####:   86:	if (p) {
    #####:   87:		memcpy(p, s, len);
    #####:   88:		p[len] = 0;
    #####:   89:	}
    #####:   90:	return p;
    #####:   91:}
        -:   92:
        -:   93:/**
        -:   94: * Convert a char in utf8 into UCS, and store it in *ret.
        -:   95: * Return #bytes consumed or -1 on failure.
        -:   96: */
    #####:   97:int toml_utf8_to_ucs(const char *orig, int len, int64_t *ret) {
    #####:   98:	const unsigned char *buf = (const unsigned char *)orig;
    #####:   99:	unsigned i = *buf++;
    #####:  100:	int64_t v;
        -:  101:
        -:  102:	/* 0x00000000 - 0x0000007F:
        -:  103:	   0xxxxxxx
        -:  104:	*/
    #####:  105:	if (0 == (i >> 7)) {
    #####:  106:		if (len < 1)
    #####:  107:			return -1;
    #####:  108:		v = i;
    #####:  109:		return *ret = v, 1;
        -:  110:	}
        -:  111:	/* 0x00000080 - 0x000007FF:
        -:  112:	   110xxxxx 10xxxxxx
        -:  113:	*/
    #####:  114:	if (0x6 == (i >> 5)) {
    #####:  115:		if (len < 2)
    #####:  116:			return -1;
    #####:  117:		v = i & 0x1f;
    #####:  118:		for (int j = 0; j < 1; j++) {
    #####:  119:			i = *buf++;
    #####:  120:			if (0x2 != (i >> 6))
    #####:  121:				return -1;
    #####:  122:			v = (v << 6) | (i & 0x3f);
    #####:  123:		}
    #####:  124:		return *ret = v, (const char *)buf - orig;
        -:  125:	}
        -:  126:
        -:  127:	/* 0x00000800 - 0x0000FFFF:
        -:  128:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  129:	*/
    #####:  130:	if (0xE == (i >> 4)) {
    #####:  131:		if (len < 3)
    #####:  132:			return -1;
    #####:  133:		v = i & 0x0F;
    #####:  134:		for (int j = 0; j < 2; j++) {
    #####:  135:			i = *buf++;
    #####:  136:			if (0x2 != (i >> 6))
    #####:  137:				return -1;
    #####:  138:			v = (v << 6) | (i & 0x3f);
    #####:  139:		}
    #####:  140:		return *ret = v, (const char *)buf - orig;
        -:  141:	}
        -:  142:
        -:  143:	/* 0x00010000 - 0x001FFFFF:
        -:  144:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  145:	*/
    #####:  146:	if (0x1E == (i >> 3)) {
    #####:  147:		if (len < 4)
    #####:  148:			return -1;
    #####:  149:		v = i & 0x07;
    #####:  150:		for (int j = 0; j < 3; j++) {
    #####:  151:			i = *buf++;
    #####:  152:			if (0x2 != (i >> 6))
    #####:  153:				return -1;
    #####:  154:			v = (v << 6) | (i & 0x3f);
    #####:  155:		}
    #####:  156:		return *ret = v, (const char *)buf - orig;
        -:  157:	}
        -:  158:
        -:  159:	/* 0x00200000 - 0x03FFFFFF:
        -:  160:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  161:	*/
    #####:  162:	if (0x3E == (i >> 2)) {
    #####:  163:		if (len < 5)
    #####:  164:			return -1;
    #####:  165:		v = i & 0x03;
    #####:  166:		for (int j = 0; j < 4; j++) {
    #####:  167:			i = *buf++;
    #####:  168:			if (0x2 != (i >> 6))
    #####:  169:				return -1;
    #####:  170:			v = (v << 6) | (i & 0x3f);
    #####:  171:		}
    #####:  172:		return *ret = v, (const char *)buf - orig;
        -:  173:	}
        -:  174:
        -:  175:	/* 0x04000000 - 0x7FFFFFFF:
        -:  176:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  177:	*/
    #####:  178:	if (0x7e == (i >> 1)) {
    #####:  179:		if (len < 6)
    #####:  180:			return -1;
    #####:  181:		v = i & 0x01;
    #####:  182:		for (int j = 0; j < 5; j++) {
    #####:  183:			i = *buf++;
    #####:  184:			if (0x2 != (i >> 6))
    #####:  185:				return -1;
    #####:  186:			v = (v << 6) | (i & 0x3f);
    #####:  187:		}
    #####:  188:		return *ret = v, (const char *)buf - orig;
        -:  189:	}
    #####:  190:	return -1;
    #####:  191:}
        -:  192:
        -:  193:/**
        -:  194: *	Convert a UCS char to utf8 code, and return it in buf.
        -:  195: *	Return #bytes used in buf to encode the char, or
        -:  196: *	-1 on error.
        -:  197: */
    #####:  198:int toml_ucs_to_utf8(int64_t code, char buf[6]) {
        -:  199:	/* http://stackoverflow.com/questions/6240055/manually-converting-unicode-codepoints-into-utf-8-and-utf-16
        -:  200:	 */
        -:  201:	/* The UCS code values 0xd800–0xdfff (UTF-16 surrogates) as well
        -:  202:	 * as 0xfffe and 0xffff (UCS noncharacters) should not appear in
        -:  203:	 * conforming UTF-8 streams.
        -:  204:	 */
    #####:  205:	if (0xd800 <= code && code <= 0xdfff)
    #####:  206:		return -1;
    #####:  207:	if (0xfffe <= code && code <= 0xffff)
    #####:  208:		return -1;
        -:  209:
        -:  210:	/* 0x00000000 - 0x0000007F:
        -:  211:	   0xxxxxxx
        -:  212:	*/
    #####:  213:	if (code < 0)
    #####:  214:		return -1;
    #####:  215:	if (code <= 0x7F) {
    #####:  216:		buf[0] = (unsigned char)code;
    #####:  217:		return 1;
        -:  218:	}
        -:  219:
        -:  220:	/* 0x00000080 - 0x000007FF:
        -:  221:	   110xxxxx 10xxxxxx
        -:  222:	*/
    #####:  223:	if (code <= 0x000007FF) {
    #####:  224:		buf[0] = (unsigned char)(0xc0 | (code >> 6));
    #####:  225:		buf[1] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  226:		return 2;
        -:  227:	}
        -:  228:
        -:  229:	/* 0x00000800 - 0x0000FFFF:
        -:  230:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  231:	*/
    #####:  232:	if (code <= 0x0000FFFF) {
    #####:  233:		buf[0] = (unsigned char)(0xe0 | (code >> 12));
    #####:  234:		buf[1] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  235:		buf[2] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  236:		return 3;
        -:  237:	}
        -:  238:
        -:  239:	/* 0x00010000 - 0x001FFFFF:
        -:  240:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  241:	*/
    #####:  242:	if (code <= 0x001FFFFF) {
    #####:  243:		buf[0] = (unsigned char)(0xf0 | (code >> 18));
    #####:  244:		buf[1] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  245:		buf[2] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  246:		buf[3] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  247:		return 4;
        -:  248:	}
        -:  249:
        -:  250:	/* 0x00200000 - 0x03FFFFFF:
        -:  251:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  252:	*/
    #####:  253:	if (code <= 0x03FFFFFF) {
    #####:  254:		buf[0] = (unsigned char)(0xf8 | (code >> 24));
    #####:  255:		buf[1] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  256:		buf[2] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  257:		buf[3] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  258:		buf[4] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  259:		return 5;
        -:  260:	}
        -:  261:
        -:  262:	/* 0x04000000 - 0x7FFFFFFF:
        -:  263:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  264:	*/
    #####:  265:	if (code <= 0x7FFFFFFF) {
    #####:  266:		buf[0] = (unsigned char)(0xfc | (code >> 30));
    #####:  267:		buf[1] = (unsigned char)(0x80 | ((code >> 24) & 0x3f));
    #####:  268:		buf[2] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  269:		buf[3] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  270:		buf[4] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  271:		buf[5] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  272:		return 6;
        -:  273:	}
        -:  274:
    #####:  275:	return -1;
    #####:  276:}
        -:  277:
        -:  278:/*
        -:  279: *	TOML has 3 data structures: value, array, table.
        -:  280: *	Each of them can have identification key.
        -:  281: */
        -:  282:typedef struct toml_keyval_t toml_keyval_t;
        -:  283:struct toml_keyval_t {
        -:  284:	const char *key; /* key to this value */
        -:  285:	const char *val; /* the raw value */
        -:  286:};
        -:  287:
        -:  288:typedef struct toml_arritem_t toml_arritem_t;
        -:  289:struct toml_arritem_t {
        -:  290:	int valtype; /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring,
        -:  291:			't'ime, 'D'ate, 'T'imestamp */
        -:  292:	char *val;
        -:  293:	toml_array_t *arr;
        -:  294:	toml_table_t *tab;
        -:  295:};
        -:  296:
        -:  297:struct toml_array_t {
        -:  298:	const char *key; /* key to this array */
        -:  299:	int kind; /* element kind: 'v'alue, 'a'rray, or 't'able, 'm'ixed */
        -:  300:	int type; /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring, 't'ime,
        -:  301:		     'D'ate, 'T'imestamp, 'm'ixed */
        -:  302:
        -:  303:	int nitem; /* number of elements */
        -:  304:	toml_arritem_t *item;
        -:  305:};
        -:  306:
        -:  307:struct toml_table_t {
        -:  308:	const char *key; /* key to this table */
        -:  309:	bool implicit;	 /* table was created implicitly */
        -:  310:	bool readonly;	 /* no more modification allowed */
        -:  311:
        -:  312:	/* key-values in the table */
        -:  313:	int nkval;
        -:  314:	toml_keyval_t **kval;
        -:  315:
        -:  316:	/* arrays in the table */
        -:  317:	int narr;
        -:  318:	toml_array_t **arr;
        -:  319:
        -:  320:	/* tables in the table */
        -:  321:	int ntab;
        -:  322:	toml_table_t **tab;
        -:  323:};
        -:  324:
    #####:  325:static inline void xfree(const void *x) {
    #####:  326:	if (x)
    #####:  327:		FREE((void *)(intptr_t)x);
    #####:  328:}
        -:  329:
        -:  330:enum tokentype_t {
        -:  331:	INVALID,
        -:  332:	DOT,
        -:  333:	COMMA,
        -:  334:	EQUAL,
        -:  335:	LBRACE,
        -:  336:	RBRACE,
        -:  337:	NEWLINE,
        -:  338:	LBRACKET,
        -:  339:	RBRACKET,
        -:  340:	STRING,
        -:  341:};
        -:  342:typedef enum tokentype_t tokentype_t;
        -:  343:
        -:  344:typedef struct token_t token_t;
        -:  345:struct token_t {
        -:  346:	tokentype_t tok;
        -:  347:	int lineno;
        -:  348:	char *ptr; /* points into context->start */
        -:  349:	int len;
        -:  350:	int eof;
        -:  351:};
        -:  352:
        -:  353:typedef struct context_t context_t;
        -:  354:struct context_t {
        -:  355:	char *start;
        -:  356:	char *stop;
        -:  357:	char *errbuf;
        -:  358:	int errbufsz;
        -:  359:
        -:  360:	token_t tok;
        -:  361:	toml_table_t *root;
        -:  362:	toml_table_t *curtab;
        -:  363:
        -:  364:	struct {
        -:  365:		int top;
        -:  366:		char *key[10];
        -:  367:		token_t tok[10];
        -:  368:	} tpath;
        -:  369:};
        -:  370:
        -:  371:#define STRINGIFY(x) #x
        -:  372:#define TOSTRING(x) STRINGIFY(x)
        -:  373:#define FLINE __FILE__ ":" TOSTRING(__LINE__)
        -:  374:
        -:  375:static int next_token(context_t *ctx, int dotisspecial);
        -:  376:
        -:  377:/*
        -:  378:  Error reporting. Call when an error is detected. Always return -1.
        -:  379:*/
    #####:  380:static int e_outofmemory(context_t *ctx, const char *fline) {
    #####:  381:	snprintf(ctx->errbuf, ctx->errbufsz, "ERROR: out of memory (%s)",
        -:  382:		 fline);
    #####:  383:	return -1;
        -:  384:}
        -:  385:
    #####:  386:static int e_internal(context_t *ctx, const char *fline) {
    #####:  387:	snprintf(ctx->errbuf, ctx->errbufsz, "internal error (%s)", fline);
    #####:  388:	return -1;
        -:  389:}
        -:  390:
    #####:  391:static int e_syntax(context_t *ctx, int lineno, const char *msg) {
    #####:  392:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  393:	return -1;
        -:  394:}
        -:  395:
    #####:  396:static int e_badkey(context_t *ctx, int lineno) {
    #####:  397:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: bad key", lineno);
    #####:  398:	return -1;
        -:  399:}
        -:  400:
    #####:  401:static int e_keyexists(context_t *ctx, int lineno) {
    #####:  402:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: key exists", lineno);
    #####:  403:	return -1;
        -:  404:}
        -:  405:
    #####:  406:static int e_forbid(context_t *ctx, int lineno, const char *msg) {
    #####:  407:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  408:	return -1;
        -:  409:}
        -:  410:
    #####:  411:static void *expand(void *p, int sz, int newsz) {
    #####:  412:	void *s = MALLOC(newsz);
    #####:  413:	if (!s)
    #####:  414:		return 0;
        -:  415:
    #####:  416:	if (p) {
    #####:  417:		memcpy(s, p, sz);
    #####:  418:		FREE(p);
    #####:  419:	}
    #####:  420:	return s;
    #####:  421:}
        -:  422:
    #####:  423:static void **expand_ptrarr(void **p, int n) {
    #####:  424:	void **s = MALLOC((n + 1) * sizeof(void *));
    #####:  425:	if (!s)
    #####:  426:		return 0;
        -:  427:
    #####:  428:	s[n] = 0;
    #####:  429:	if (p) {
    #####:  430:		memcpy(s, p, n * sizeof(void *));
    #####:  431:		FREE(p);
    #####:  432:	}
    #####:  433:	return s;
    #####:  434:}
        -:  435:
    #####:  436:static toml_arritem_t *expand_arritem(toml_arritem_t *p, int n) {
    #####:  437:	toml_arritem_t *pp = expand(p, n * sizeof(*p), (n + 1) * sizeof(*p));
    #####:  438:	if (!pp)
    #####:  439:		return 0;
        -:  440:
    #####:  441:	memset(&pp[n], 0, sizeof(pp[n]));
    #####:  442:	return pp;
    #####:  443:}
        -:  444:
    #####:  445:static char *norm_lit_str(const char *src, int srclen, int multiline,
        -:  446:			  char *errbuf, int errbufsz) {
    #####:  447:	char *dst = 0; /* will write to dst[] and return it */
    #####:  448:	int max = 0;   /* max size of dst[] */
    #####:  449:	int off = 0;   /* cur offset in dst[] */
    #####:  450:	const char *sp = src;
    #####:  451:	const char *sq = src + srclen;
    #####:  452:	int ch;
        -:  453:
        -:  454:	/* scan forward on src */
    #####:  455:	for (;;) {
    #####:  456:		if (off >= max - 10) { /* have some slack for misc stuff */
    #####:  457:			int newmax = max + 50;
    #####:  458:			char *x = expand(dst, max, newmax);
    #####:  459:			if (!x) {
    #####:  460:				xfree(dst);
    #####:  461:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  462:				return 0;
        -:  463:			}
    #####:  464:			dst = x;
    #####:  465:			max = newmax;
    #####:  466:		}
        -:  467:
        -:  468:		/* finished? */
    #####:  469:		if (sp >= sq)
    #####:  470:			break;
        -:  471:
    #####:  472:		ch = *sp++;
        -:  473:		/* control characters other than tab is not allowed */
    #####:  474:		if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) ||
    #####:  475:		    (ch == 0x7f)) {
    #####:  476:			if (!(multiline && (ch == '\r' || ch == '\n'))) {
    #####:  477:				xfree(dst);
    #####:  478:				snprintf(errbuf, errbufsz,
        -:  479:					 "invalid char U+%04x", ch);
    #####:  480:				return 0;
        -:  481:			}
    #####:  482:		}
        -:  483:
        -:  484:		// a plain copy suffice
    #####:  485:		dst[off++] = ch;
        -:  486:	}
        -:  487:
    #####:  488:	dst[off++] = 0;
    #####:  489:	return dst;
    #####:  490:}
        -:  491:
        -:  492:/*
        -:  493: * Convert src to raw unescaped utf-8 string.
        -:  494: * Returns NULL if error with errmsg in errbuf.
        -:  495: */
    #####:  496:static char *norm_basic_str(const char *src, int srclen, int multiline,
        -:  497:			    char *errbuf, int errbufsz) {
    #####:  498:	char *dst = 0; /* will write to dst[] and return it */
    #####:  499:	int max = 0;   /* max size of dst[] */
    #####:  500:	int off = 0;   /* cur offset in dst[] */
    #####:  501:	const char *sp = src;
    #####:  502:	const char *sq = src + srclen;
    #####:  503:	int ch;
        -:  504:
        -:  505:	/* scan forward on src */
    #####:  506:	for (;;) {
    #####:  507:		if (off >= max - 10) { /* have some slack for misc stuff */
    #####:  508:			int newmax = max + 50;
    #####:  509:			char *x = expand(dst, max, newmax);
    #####:  510:			if (!x) {
    #####:  511:				xfree(dst);
    #####:  512:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  513:				return 0;
        -:  514:			}
    #####:  515:			dst = x;
    #####:  516:			max = newmax;
    #####:  517:		}
        -:  518:
        -:  519:		/* finished? */
    #####:  520:		if (sp >= sq)
    #####:  521:			break;
        -:  522:
    #####:  523:		ch = *sp++;
    #####:  524:		if (ch != '\\') {
        -:  525:			/* these chars must be escaped: U+0000 to U+0008, U+000A
        -:  526:			 * to U+001F, U+007F
        -:  527:			 */
    #####:  528:			if ((0 <= ch && ch <= 0x08) ||
    #####:  529:			    (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f)) {
    #####:  530:				if (!(multiline &&
    #####:  531:				      (ch == '\r' || ch == '\n'))) {
    #####:  532:					xfree(dst);
    #####:  533:					snprintf(errbuf, errbufsz,
        -:  534:						 "invalid char U+%04x", ch);
    #####:  535:					return 0;
        -:  536:				}
    #####:  537:			}
        -:  538:
        -:  539:			// a plain copy suffice
    #####:  540:			dst[off++] = ch;
    #####:  541:			continue;
        -:  542:		}
        -:  543:
        -:  544:		/* ch was backslash. we expect the escape char. */
    #####:  545:		if (sp >= sq) {
    #####:  546:			snprintf(errbuf, errbufsz, "last backslash is invalid");
    #####:  547:			xfree(dst);
    #####:  548:			return 0;
        -:  549:		}
        -:  550:
        -:  551:		/* for multi-line, we want to kill line-ending-backslash ... */
    #####:  552:		if (multiline) {
        -:  553:
        -:  554:			// if there is only whitespace after the backslash ...
    #####:  555:			if (sp[strspn(sp, " \t\r")] == '\n') {
        -:  556:				/* skip all the following whitespaces */
    #####:  557:				sp += strspn(sp, " \t\r\n");
    #####:  558:				continue;
        -:  559:			}
    #####:  560:		}
        -:  561:
        -:  562:		/* get the escaped char */
    #####:  563:		ch = *sp++;
    #####:  564:		switch (ch) {
        -:  565:		case 'u':
        -:  566:		case 'U': {
    #####:  567:			int64_t ucs = 0;
    #####:  568:			int nhex = (ch == 'u' ? 4 : 8);
    #####:  569:			for (int i = 0; i < nhex; i++) {
    #####:  570:				if (sp >= sq) {
    #####:  571:					snprintf(errbuf, errbufsz,
        -:  572:						 "\\%c expects %d hex chars",
        -:  573:						 ch, nhex);
    #####:  574:					xfree(dst);
    #####:  575:					return 0;
        -:  576:				}
    #####:  577:				ch = *sp++;
    #####:  578:				int v = ('0' <= ch && ch <= '9')
    #####:  579:					    ? ch - '0'
    #####:  580:					    : (('A' <= ch && ch <= 'F')
    #####:  581:						   ? ch - 'A' + 10
        -:  582:						   : -1);
    #####:  583:				if (-1 == v) {
    #####:  584:					snprintf(
        -:  585:					    errbuf, errbufsz,
        -:  586:					    "invalid hex chars for \\u or \\U");
    #####:  587:					xfree(dst);
    #####:  588:					return 0;
        -:  589:				}
    #####:  590:				ucs = ucs * 16 + v;
    #####:  591:			}
    #####:  592:			int n = toml_ucs_to_utf8(ucs, &dst[off]);
    #####:  593:			if (-1 == n) {
    #####:  594:				snprintf(errbuf, errbufsz,
        -:  595:					 "illegal ucs code in \\u or \\U");
    #####:  596:				xfree(dst);
    #####:  597:				return 0;
        -:  598:			}
    #####:  599:			off += n;
    #####:  600:		}
    #####:  601:			continue;
        -:  602:
        -:  603:		case 'b':
    #####:  604:			ch = '\b';
    #####:  605:			break;
        -:  606:		case 't':
    #####:  607:			ch = '\t';
    #####:  608:			break;
        -:  609:		case 'n':
    #####:  610:			ch = '\n';
    #####:  611:			break;
        -:  612:		case 'f':
    #####:  613:			ch = '\f';
    #####:  614:			break;
        -:  615:		case 'r':
    #####:  616:			ch = '\r';
    #####:  617:			break;
        -:  618:		case '"':
    #####:  619:			ch = '"';
    #####:  620:			break;
        -:  621:		case '\\':
    #####:  622:			ch = '\\';
    #####:  623:			break;
        -:  624:		default:
    #####:  625:			snprintf(errbuf, errbufsz, "illegal escape char \\%c",
        -:  626:				 ch);
    #####:  627:			xfree(dst);
    #####:  628:			return 0;
        -:  629:		}
        -:  630:
    #####:  631:		dst[off++] = ch;
        -:  632:	}
        -:  633:
        -:  634:	// Cap with NUL and return it.
    #####:  635:	dst[off++] = 0;
    #####:  636:	return dst;
    #####:  637:}
        -:  638:
        -:  639:/* Normalize a key. Convert all special chars to raw unescaped utf-8 chars. */
    #####:  640:static char *normalize_key(context_t *ctx, token_t strtok) {
    #####:  641:	const char *sp = strtok.ptr;
    #####:  642:	const char *sq = strtok.ptr + strtok.len;
    #####:  643:	int lineno = strtok.lineno;
    #####:  644:	char *ret;
    #####:  645:	int ch = *sp;
    #####:  646:	char ebuf[80];
        -:  647:
        -:  648:	/* handle quoted string */
    #####:  649:	if (ch == '\'' || ch == '\"') {
        -:  650:		/* if ''' or """, take 3 chars off front and back. Else, take 1
        -:  651:		 * char off. */
    #####:  652:		int multiline = 0;
    #####:  653:		if (sp[1] == ch && sp[2] == ch) {
    #####:  654:			sp += 3, sq -= 3;
    #####:  655:			multiline = 1;
    #####:  656:		} else
    #####:  657:			sp++, sq--;
        -:  658:
    #####:  659:		if (ch == '\'') {
        -:  660:			/* for single quote, take it verbatim. */
    #####:  661:			if (!(ret = STRNDUP(sp, sq - sp))) {
    #####:  662:				e_outofmemory(ctx, FLINE);
    #####:  663:				return 0;
        -:  664:			}
    #####:  665:		} else {
        -:  666:			/* for double quote, we need to normalize */
    #####:  667:			ret = norm_basic_str(sp, sq - sp, multiline, ebuf,
        -:  668:					     sizeof(ebuf));
    #####:  669:			if (!ret) {
    #####:  670:				e_syntax(ctx, lineno, ebuf);
    #####:  671:				return 0;
        -:  672:			}
        -:  673:		}
        -:  674:
        -:  675:		/* newlines are not allowed in keys */
    #####:  676:		if (strchr(ret, '\n')) {
    #####:  677:			xfree(ret);
    #####:  678:			e_badkey(ctx, lineno);
    #####:  679:			return 0;
        -:  680:		}
    #####:  681:		return ret;
    #####:  682:	}
        -:  683:
        -:  684:	/* for bare-key allow only this regex: [A-Za-z0-9_-]+ */
    #####:  685:	const char *xp;
    #####:  686:	for (xp = sp; xp != sq; xp++) {
    #####:  687:		int k = *xp;
    #####:  688:		if (isalnum(k))
    #####:  689:			continue;
    #####:  690:		if (k == '_' || k == '-')
    #####:  691:			continue;
    #####:  692:		e_badkey(ctx, lineno);
    #####:  693:		return 0;
    #####:  694:	}
        -:  695:
        -:  696:	/* dup and return it */
    #####:  697:	if (!(ret = STRNDUP(sp, sq - sp))) {
    #####:  698:		e_outofmemory(ctx, FLINE);
    #####:  699:		return 0;
        -:  700:	}
    #####:  701:	return ret;
    #####:  702:}
        -:  703:
        -:  704:/*
        -:  705: * Look up key in tab. Return 0 if not found, or
        -:  706: * 'v'alue, 'a'rray or 't'able depending on the element.
        -:  707: */
    #####:  708:static int check_key(toml_table_t *tab, const char *key,
        -:  709:		     toml_keyval_t **ret_val, toml_array_t **ret_arr,
        -:  710:		     toml_table_t **ret_tab) {
    #####:  711:	int i;
    #####:  712:	void *dummy;
        -:  713:
    #####:  714:	if (!ret_tab)
    #####:  715:		ret_tab = (toml_table_t **)&dummy;
    #####:  716:	if (!ret_arr)
    #####:  717:		ret_arr = (toml_array_t **)&dummy;
    #####:  718:	if (!ret_val)
    #####:  719:		ret_val = (toml_keyval_t **)&dummy;
        -:  720:
    #####:  721:	*ret_tab = 0;
    #####:  722:	*ret_arr = 0;
    #####:  723:	*ret_val = 0;
        -:  724:
    #####:  725:	for (i = 0; i < tab->nkval; i++) {
    #####:  726:		if (0 == strcmp(key, tab->kval[i]->key)) {
    #####:  727:			*ret_val = tab->kval[i];
    #####:  728:			return 'v';
        -:  729:		}
    #####:  730:	}
    #####:  731:	for (i = 0; i < tab->narr; i++) {
    #####:  732:		if (0 == strcmp(key, tab->arr[i]->key)) {
    #####:  733:			*ret_arr = tab->arr[i];
    #####:  734:			return 'a';
        -:  735:		}
    #####:  736:	}
    #####:  737:	for (i = 0; i < tab->ntab; i++) {
    #####:  738:		if (0 == strcmp(key, tab->tab[i]->key)) {
    #####:  739:			*ret_tab = tab->tab[i];
    #####:  740:			return 't';
        -:  741:		}
    #####:  742:	}
    #####:  743:	return 0;
    #####:  744:}
        -:  745:
    #####:  746:static int key_kind(toml_table_t *tab, const char *key) {
    #####:  747:	return check_key(tab, key, 0, 0, 0);
        -:  748:}
        -:  749:
        -:  750:/* Create a keyval in the table.
        -:  751: */
    #####:  752:static toml_keyval_t *create_keyval_in_table(context_t *ctx, toml_table_t *tab,
        -:  753:					     token_t keytok) {
        -:  754:	/* first, normalize the key to be used for lookup.
        -:  755:	 * remember to free it if we error out.
        -:  756:	 */
    #####:  757:	char *newkey = normalize_key(ctx, keytok);
    #####:  758:	if (!newkey)
    #####:  759:		return 0;
        -:  760:
        -:  761:	/* if key exists: error out. */
    #####:  762:	toml_keyval_t *dest = 0;
    #####:  763:	if (key_kind(tab, newkey)) {
    #####:  764:		xfree(newkey);
    #####:  765:		e_keyexists(ctx, keytok.lineno);
    #####:  766:		return 0;
        -:  767:	}
        -:  768:
        -:  769:	/* make a new entry */
    #####:  770:	int n = tab->nkval;
    #####:  771:	toml_keyval_t **base;
    #####:  772:	if (0 ==
    #####:  773:	    (base = (toml_keyval_t **)expand_ptrarr((void **)tab->kval, n))) {
    #####:  774:		xfree(newkey);
    #####:  775:		e_outofmemory(ctx, FLINE);
    #####:  776:		return 0;
        -:  777:	}
    #####:  778:	tab->kval = base;
        -:  779:
    #####:  780:	if (0 == (base[n] = (toml_keyval_t *)CALLOC(1, sizeof(*base[n])))) {
    #####:  781:		xfree(newkey);
    #####:  782:		e_outofmemory(ctx, FLINE);
    #####:  783:		return 0;
        -:  784:	}
    #####:  785:	dest = tab->kval[tab->nkval++];
        -:  786:
        -:  787:	/* save the key in the new value struct */
    #####:  788:	dest->key = newkey;
    #####:  789:	return dest;
    #####:  790:}
        -:  791:
        -:  792:/* Create a table in the table.
        -:  793: */
    #####:  794:static toml_table_t *create_keytable_in_table(context_t *ctx, toml_table_t *tab,
        -:  795:					      token_t keytok) {
        -:  796:	/* first, normalize the key to be used for lookup.
        -:  797:	 * remember to free it if we error out.
        -:  798:	 */
    #####:  799:	char *newkey = normalize_key(ctx, keytok);
    #####:  800:	if (!newkey)
    #####:  801:		return 0;
        -:  802:
        -:  803:	/* if key exists: error out */
    #####:  804:	toml_table_t *dest = 0;
    #####:  805:	if (check_key(tab, newkey, 0, 0, &dest)) {
    #####:  806:		xfree(newkey); /* don't need this anymore */
        -:  807:
        -:  808:		/* special case: if table exists, but was created implicitly ...
        -:  809:		 */
    #####:  810:		if (dest && dest->implicit) {
        -:  811:			/* we make it explicit now, and simply return it. */
    #####:  812:			dest->implicit = false;
    #####:  813:			return dest;
        -:  814:		}
    #####:  815:		e_keyexists(ctx, keytok.lineno);
    #####:  816:		return 0;
        -:  817:	}
        -:  818:
        -:  819:	/* create a new table entry */
    #####:  820:	int n = tab->ntab;
    #####:  821:	toml_table_t **base;
    #####:  822:	if (0 ==
    #####:  823:	    (base = (toml_table_t **)expand_ptrarr((void **)tab->tab, n))) {
    #####:  824:		xfree(newkey);
    #####:  825:		e_outofmemory(ctx, FLINE);
    #####:  826:		return 0;
        -:  827:	}
    #####:  828:	tab->tab = base;
        -:  829:
    #####:  830:	if (0 == (base[n] = (toml_table_t *)CALLOC(1, sizeof(*base[n])))) {
    #####:  831:		xfree(newkey);
    #####:  832:		e_outofmemory(ctx, FLINE);
    #####:  833:		return 0;
        -:  834:	}
    #####:  835:	dest = tab->tab[tab->ntab++];
        -:  836:
        -:  837:	/* save the key in the new table struct */
    #####:  838:	dest->key = newkey;
    #####:  839:	return dest;
    #####:  840:}
        -:  841:
        -:  842:/* Create an array in the table.
        -:  843: */
    #####:  844:static toml_array_t *create_keyarray_in_table(context_t *ctx, toml_table_t *tab,
        -:  845:					      token_t keytok, char kind) {
        -:  846:	/* first, normalize the key to be used for lookup.
        -:  847:	 * remember to free it if we error out.
        -:  848:	 */
    #####:  849:	char *newkey = normalize_key(ctx, keytok);
    #####:  850:	if (!newkey)
    #####:  851:		return 0;
        -:  852:
        -:  853:	/* if key exists: error out */
    #####:  854:	if (key_kind(tab, newkey)) {
    #####:  855:		xfree(newkey); /* don't need this anymore */
    #####:  856:		e_keyexists(ctx, keytok.lineno);
    #####:  857:		return 0;
        -:  858:	}
        -:  859:
        -:  860:	/* make a new array entry */
    #####:  861:	int n = tab->narr;
    #####:  862:	toml_array_t **base;
    #####:  863:	if (0 ==
    #####:  864:	    (base = (toml_array_t **)expand_ptrarr((void **)tab->arr, n))) {
    #####:  865:		xfree(newkey);
    #####:  866:		e_outofmemory(ctx, FLINE);
    #####:  867:		return 0;
        -:  868:	}
    #####:  869:	tab->arr = base;
        -:  870:
    #####:  871:	if (0 == (base[n] = (toml_array_t *)CALLOC(1, sizeof(*base[n])))) {
    #####:  872:		xfree(newkey);
    #####:  873:		e_outofmemory(ctx, FLINE);
    #####:  874:		return 0;
        -:  875:	}
    #####:  876:	toml_array_t *dest = tab->arr[tab->narr++];
        -:  877:
        -:  878:	/* save the key in the new array struct */
    #####:  879:	dest->key = newkey;
    #####:  880:	dest->kind = kind;
    #####:  881:	return dest;
    #####:  882:}
        -:  883:
    #####:  884:static toml_arritem_t *create_value_in_array(context_t *ctx,
        -:  885:					     toml_array_t *parent) {
    #####:  886:	const int n = parent->nitem;
    #####:  887:	toml_arritem_t *base = expand_arritem(parent->item, n);
    #####:  888:	if (!base) {
    #####:  889:		e_outofmemory(ctx, FLINE);
    #####:  890:		return 0;
        -:  891:	}
    #####:  892:	parent->item = base;
    #####:  893:	parent->nitem++;
    #####:  894:	return &parent->item[n];
    #####:  895:}
        -:  896:
        -:  897:/* Create an array in an array
        -:  898: */
    #####:  899:static toml_array_t *create_array_in_array(context_t *ctx,
        -:  900:					   toml_array_t *parent) {
    #####:  901:	const int n = parent->nitem;
    #####:  902:	toml_arritem_t *base = expand_arritem(parent->item, n);
    #####:  903:	if (!base) {
    #####:  904:		e_outofmemory(ctx, FLINE);
    #####:  905:		return 0;
        -:  906:	}
    #####:  907:	toml_array_t *ret = (toml_array_t *)CALLOC(1, sizeof(toml_array_t));
    #####:  908:	if (!ret) {
    #####:  909:		e_outofmemory(ctx, FLINE);
    #####:  910:		return 0;
        -:  911:	}
    #####:  912:	base[n].arr = ret;
    #####:  913:	parent->item = base;
    #####:  914:	parent->nitem++;
    #####:  915:	return ret;
    #####:  916:}
        -:  917:
        -:  918:/* Create a table in an array
        -:  919: */
    #####:  920:static toml_table_t *create_table_in_array(context_t *ctx,
        -:  921:					   toml_array_t *parent) {
    #####:  922:	int n = parent->nitem;
    #####:  923:	toml_arritem_t *base = expand_arritem(parent->item, n);
    #####:  924:	if (!base) {
    #####:  925:		e_outofmemory(ctx, FLINE);
    #####:  926:		return 0;
        -:  927:	}
    #####:  928:	toml_table_t *ret = (toml_table_t *)CALLOC(1, sizeof(toml_table_t));
    #####:  929:	if (!ret) {
    #####:  930:		e_outofmemory(ctx, FLINE);
    #####:  931:		return 0;
        -:  932:	}
    #####:  933:	base[n].tab = ret;
    #####:  934:	parent->item = base;
    #####:  935:	parent->nitem++;
    #####:  936:	return ret;
    #####:  937:}
        -:  938:
    #####:  939:static int skip_newlines(context_t *ctx, int isdotspecial) {
    #####:  940:	while (ctx->tok.tok == NEWLINE) {
    #####:  941:		if (next_token(ctx, isdotspecial))
    #####:  942:			return -1;
    #####:  943:		if (ctx->tok.eof)
    #####:  944:			break;
        -:  945:	}
    #####:  946:	return 0;
    #####:  947:}
        -:  948:
        -:  949:static int parse_keyval(context_t *ctx, toml_table_t *tab);
        -:  950:
    #####:  951:static inline int eat_token(context_t *ctx, tokentype_t typ, int isdotspecial,
        -:  952:			    const char *fline) {
    #####:  953:	if (ctx->tok.tok != typ)
    #####:  954:		return e_internal(ctx, fline);
        -:  955:
    #####:  956:	if (next_token(ctx, isdotspecial))
    #####:  957:		return -1;
        -:  958:
    #####:  959:	return 0;
    #####:  960:}
        -:  961:
        -:  962:/* We are at '{ ... }'.
        -:  963: * Parse the table.
        -:  964: */
    #####:  965:static int parse_inline_table(context_t *ctx, toml_table_t *tab) {
    #####:  966:	if (eat_token(ctx, LBRACE, 1, FLINE))
    #####:  967:		return -1;
        -:  968:
    #####:  969:	for (;;) {
    #####:  970:		if (ctx->tok.tok == NEWLINE)
    #####:  971:			return e_syntax(ctx, ctx->tok.lineno,
        -:  972:					"newline not allowed in inline table");
        -:  973:
        -:  974:		/* until } */
    #####:  975:		if (ctx->tok.tok == RBRACE)
    #####:  976:			break;
        -:  977:
    #####:  978:		if (ctx->tok.tok != STRING)
    #####:  979:			return e_syntax(ctx, ctx->tok.lineno,
        -:  980:					"expect a string");
        -:  981:
    #####:  982:		if (parse_keyval(ctx, tab))
    #####:  983:			return -1;
        -:  984:
    #####:  985:		if (ctx->tok.tok == NEWLINE)
    #####:  986:			return e_syntax(ctx, ctx->tok.lineno,
        -:  987:					"newline not allowed in inline table");
        -:  988:
        -:  989:		/* on comma, continue to scan for next keyval */
    #####:  990:		if (ctx->tok.tok == COMMA) {
    #####:  991:			if (eat_token(ctx, COMMA, 1, FLINE))
    #####:  992:				return -1;
    #####:  993:			continue;
        -:  994:		}
    #####:  995:		break;
        -:  996:	}
        -:  997:
    #####:  998:	if (eat_token(ctx, RBRACE, 1, FLINE))
    #####:  999:		return -1;
        -: 1000:
    #####: 1001:	tab->readonly = 1;
        -: 1002:
    #####: 1003:	return 0;
    #####: 1004:}
        -: 1005:
    #####: 1006:static int valtype(const char *val) {
    #####: 1007:	toml_timestamp_t ts;
    #####: 1008:	if (*val == '\'' || *val == '"')
    #####: 1009:		return 's';
    #####: 1010:	if (0 == toml_rtob(val, 0))
    #####: 1011:		return 'b';
    #####: 1012:	if (0 == toml_rtoi(val, 0))
    #####: 1013:		return 'i';
    #####: 1014:	if (0 == toml_rtod(val, 0))
    #####: 1015:		return 'd';
    #####: 1016:	if (0 == toml_rtots(val, &ts)) {
    #####: 1017:		if (ts.year && ts.hour)
    #####: 1018:			return 'T'; /* timestamp */
    #####: 1019:		if (ts.year)
    #####: 1020:			return 'D'; /* date */
    #####: 1021:		return 't';	    /* time */
        -: 1022:	}
    #####: 1023:	return 'u'; /* unknown */
    #####: 1024:}
        -: 1025:
        -: 1026:/* We are at '[...]' */
    #####: 1027:static int parse_array(context_t *ctx, toml_array_t *arr) {
    #####: 1028:	if (eat_token(ctx, LBRACKET, 0, FLINE))
    #####: 1029:		return -1;
        -: 1030:
    #####: 1031:	for (;;) {
    #####: 1032:		if (skip_newlines(ctx, 0))
    #####: 1033:			return -1;
        -: 1034:
        -: 1035:		/* until ] */
    #####: 1036:		if (ctx->tok.tok == RBRACKET)
    #####: 1037:			break;
        -: 1038:
    #####: 1039:		switch (ctx->tok.tok) {
        -: 1040:		case STRING: {
        -: 1041:			/* set array kind if this will be the first entry */
    #####: 1042:			if (arr->kind == 0)
    #####: 1043:				arr->kind = 'v';
    #####: 1044:			else if (arr->kind != 'v')
    #####: 1045:				arr->kind = 'm';
        -: 1046:
    #####: 1047:			char *val = ctx->tok.ptr;
    #####: 1048:			int vlen = ctx->tok.len;
        -: 1049:
        -: 1050:			/* make a new value in array */
    #####: 1051:			toml_arritem_t *newval =
    #####: 1052:			    create_value_in_array(ctx, arr);
    #####: 1053:			if (!newval)
    #####: 1054:				return e_outofmemory(ctx, FLINE);
        -: 1055:
    #####: 1056:			if (!(newval->val = STRNDUP(val, vlen)))
    #####: 1057:				return e_outofmemory(ctx, FLINE);
        -: 1058:
    #####: 1059:			newval->valtype = valtype(newval->val);
        -: 1060:
        -: 1061:			/* set array type if this is the first entry */
    #####: 1062:			if (arr->nitem == 1)
    #####: 1063:				arr->type = newval->valtype;
    #####: 1064:			else if (arr->type != newval->valtype)
    #####: 1065:				arr->type = 'm'; /* mixed */
        -: 1066:
    #####: 1067:			if (eat_token(ctx, STRING, 0, FLINE))
    #####: 1068:				return -1;
    #####: 1069:			break;
    #####: 1070:		}
        -: 1071:
        -: 1072:		case LBRACKET: { /* [ [array], [array] ... ] */
        -: 1073:			/* set the array kind if this will be the first entry */
    #####: 1074:			if (arr->kind == 0)
    #####: 1075:				arr->kind = 'a';
    #####: 1076:			else if (arr->kind != 'a')
    #####: 1077:				arr->kind = 'm';
        -: 1078:
    #####: 1079:			toml_array_t *subarr = create_array_in_array(ctx, arr);
    #####: 1080:			if (!subarr)
    #####: 1081:				return -1;
    #####: 1082:			if (parse_array(ctx, subarr))
    #####: 1083:				return -1;
    #####: 1084:			break;
    #####: 1085:		}
        -: 1086:
        -: 1087:		case LBRACE: { /* [ {table}, {table} ... ] */
        -: 1088:			/* set the array kind if this will be the first entry */
    #####: 1089:			if (arr->kind == 0)
    #####: 1090:				arr->kind = 't';
    #####: 1091:			else if (arr->kind != 't')
    #####: 1092:				arr->kind = 'm';
        -: 1093:
    #####: 1094:			toml_table_t *subtab = create_table_in_array(ctx, arr);
    #####: 1095:			if (!subtab)
    #####: 1096:				return -1;
    #####: 1097:			if (parse_inline_table(ctx, subtab))
    #####: 1098:				return -1;
    #####: 1099:			break;
    #####: 1100:		}
        -: 1101:
        -: 1102:		default:
    #####: 1103:			return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1104:		}
        -: 1105:
    #####: 1106:		if (skip_newlines(ctx, 0))
    #####: 1107:			return -1;
        -: 1108:
        -: 1109:		/* on comma, continue to scan for next element */
    #####: 1110:		if (ctx->tok.tok == COMMA) {
    #####: 1111:			if (eat_token(ctx, COMMA, 0, FLINE))
    #####: 1112:				return -1;
    #####: 1113:			continue;
        -: 1114:		}
    #####: 1115:		break;
        -: 1116:	}
        -: 1117:
    #####: 1118:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1119:		return -1;
    #####: 1120:	return 0;
    #####: 1121:}
        -: 1122:
        -: 1123:/* handle lines like these:
        -: 1124:   key = "value"
        -: 1125:   key = [ array ]
        -: 1126:   key = { table }
        -: 1127:*/
    #####: 1128:static int parse_keyval(context_t *ctx, toml_table_t *tab) {
    #####: 1129:	if (tab->readonly) {
    #####: 1130:		return e_forbid(ctx, ctx->tok.lineno,
        -: 1131:				"cannot insert new entry into existing table");
        -: 1132:	}
        -: 1133:
    #####: 1134:	token_t key = ctx->tok;
    #####: 1135:	if (eat_token(ctx, STRING, 1, FLINE))
    #####: 1136:		return -1;
        -: 1137:
    #####: 1138:	if (ctx->tok.tok == DOT) {
        -: 1139:		/* handle inline dotted key.
        -: 1140:		   e.g.
        -: 1141:		   physical.color = "orange"
        -: 1142:		   physical.shape = "round"
        -: 1143:		*/
    #####: 1144:		toml_table_t *subtab = 0;
        -: 1145:		{
    #####: 1146:			char *subtabstr = normalize_key(ctx, key);
    #####: 1147:			if (!subtabstr)
    #####: 1148:				return -1;
        -: 1149:
    #####: 1150:			subtab = toml_table_in(tab, subtabstr);
    #####: 1151:			xfree(subtabstr);
    #####: 1152:		}
    #####: 1153:		if (!subtab) {
    #####: 1154:			subtab = create_keytable_in_table(ctx, tab, key);
    #####: 1155:			if (!subtab)
    #####: 1156:				return -1;
    #####: 1157:		}
    #####: 1158:		if (next_token(ctx, 1))
    #####: 1159:			return -1;
    #####: 1160:		if (parse_keyval(ctx, subtab))
    #####: 1161:			return -1;
    #####: 1162:		return 0;
    #####: 1163:	}
        -: 1164:
    #####: 1165:	if (ctx->tok.tok != EQUAL) {
    #####: 1166:		return e_syntax(ctx, ctx->tok.lineno, "missing =");
        -: 1167:	}
        -: 1168:
    #####: 1169:	if (next_token(ctx, 0))
    #####: 1170:		return -1;
        -: 1171:
    #####: 1172:	switch (ctx->tok.tok) {
        -: 1173:	case STRING: { /* key = "value" */
    #####: 1174:		toml_keyval_t *keyval = create_keyval_in_table(ctx, tab, key);
    #####: 1175:		if (!keyval)
    #####: 1176:			return -1;
    #####: 1177:		token_t val = ctx->tok;
        -: 1178:
    #####: 1179:		assert(keyval->val == 0);
    #####: 1180:		if (!(keyval->val = STRNDUP(val.ptr, val.len)))
    #####: 1181:			return e_outofmemory(ctx, FLINE);
        -: 1182:
    #####: 1183:		if (next_token(ctx, 1))
    #####: 1184:			return -1;
        -: 1185:
    #####: 1186:		return 0;
    #####: 1187:	}
        -: 1188:
        -: 1189:	case LBRACKET: { /* key = [ array ] */
    #####: 1190:		toml_array_t *arr = create_keyarray_in_table(ctx, tab, key, 0);
    #####: 1191:		if (!arr)
    #####: 1192:			return -1;
    #####: 1193:		if (parse_array(ctx, arr))
    #####: 1194:			return -1;
    #####: 1195:		return 0;
    #####: 1196:	}
        -: 1197:
        -: 1198:	case LBRACE: { /* key = { table } */
    #####: 1199:		toml_table_t *nxttab = create_keytable_in_table(ctx, tab, key);
    #####: 1200:		if (!nxttab)
    #####: 1201:			return -1;
    #####: 1202:		if (parse_inline_table(ctx, nxttab))
    #####: 1203:			return -1;
    #####: 1204:		return 0;
    #####: 1205:	}
        -: 1206:
        -: 1207:	default:
    #####: 1208:		return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1209:	}
        -: 1210:	return 0;
    #####: 1211:}
        -: 1212:
        -: 1213:typedef struct tabpath_t tabpath_t;
        -: 1214:struct tabpath_t {
        -: 1215:	int cnt;
        -: 1216:	token_t key[10];
        -: 1217:};
        -: 1218:
        -: 1219:/* at [x.y.z] or [[x.y.z]]
        -: 1220: * Scan forward and fill tabpath until it enters ] or ]]
        -: 1221: * There will be at least one entry on return.
        -: 1222: */
    #####: 1223:static int fill_tabpath(context_t *ctx) {
    #####: 1224:	int lineno = ctx->tok.lineno;
    #####: 1225:	int i;
        -: 1226:
        -: 1227:	/* clear tpath */
    #####: 1228:	for (i = 0; i < ctx->tpath.top; i++) {
    #####: 1229:		char **p = &ctx->tpath.key[i];
    #####: 1230:		xfree(*p);
    #####: 1231:		*p = 0;
    #####: 1232:	}
    #####: 1233:	ctx->tpath.top = 0;
        -: 1234:
    #####: 1235:	for (;;) {
    #####: 1236:		if (ctx->tpath.top >= 10)
    #####: 1237:			return e_syntax(
    #####: 1238:			    ctx, lineno,
        -: 1239:			    "table path is too deep; max allowed is 10.");
        -: 1240:
    #####: 1241:		if (ctx->tok.tok != STRING)
    #####: 1242:			return e_syntax(ctx, lineno, "invalid or missing key");
        -: 1243:
    #####: 1244:		char *key = normalize_key(ctx, ctx->tok);
    #####: 1245:		if (!key)
    #####: 1246:			return -1;
    #####: 1247:		ctx->tpath.tok[ctx->tpath.top] = ctx->tok;
    #####: 1248:		ctx->tpath.key[ctx->tpath.top] = key;
    #####: 1249:		ctx->tpath.top++;
        -: 1250:
    #####: 1251:		if (next_token(ctx, 1))
    #####: 1252:			return -1;
        -: 1253:
    #####: 1254:		if (ctx->tok.tok == RBRACKET)
    #####: 1255:			break;
        -: 1256:
    #####: 1257:		if (ctx->tok.tok != DOT)
    #####: 1258:			return e_syntax(ctx, lineno, "invalid key");
        -: 1259:
    #####: 1260:		if (next_token(ctx, 1))
    #####: 1261:			return -1;
    #####: 1262:	}
        -: 1263:
    #####: 1264:	if (ctx->tpath.top <= 0)
    #####: 1265:		return e_syntax(ctx, lineno, "empty table selector");
        -: 1266:
    #####: 1267:	return 0;
    #####: 1268:}
        -: 1269:
        -: 1270:/* Walk tabpath from the root, and create new tables on the way.
        -: 1271: * Sets ctx->curtab to the final table.
        -: 1272: */
    #####: 1273:static int walk_tabpath(context_t *ctx) {
        -: 1274:	/* start from root */
    #####: 1275:	toml_table_t *curtab = ctx->root;
        -: 1276:
    #####: 1277:	for (int i = 0; i < ctx->tpath.top; i++) {
    #####: 1278:		const char *key = ctx->tpath.key[i];
        -: 1279:
    #####: 1280:		toml_keyval_t *nextval = 0;
    #####: 1281:		toml_array_t *nextarr = 0;
    #####: 1282:		toml_table_t *nexttab = 0;
    #####: 1283:		switch (check_key(curtab, key, &nextval, &nextarr, &nexttab)) {
        -: 1284:		case 't':
        -: 1285:			/* found a table. nexttab is where we will go next. */
        -: 1286:			break;
        -: 1287:
        -: 1288:		case 'a':
        -: 1289:			/* found an array. nexttab is the last table in the
        -: 1290:			 * array. */
    #####: 1291:			if (nextarr->kind != 't')
    #####: 1292:				return e_internal(ctx, FLINE);
        -: 1293:
    #####: 1294:			if (nextarr->nitem == 0)
    #####: 1295:				return e_internal(ctx, FLINE);
        -: 1296:
    #####: 1297:			nexttab = nextarr->item[nextarr->nitem - 1].tab;
    #####: 1298:			break;
        -: 1299:
        -: 1300:		case 'v':
    #####: 1301:			return e_keyexists(ctx, ctx->tpath.tok[i].lineno);
        -: 1302:
        -: 1303:		default: { /* Not found. Let's create an implicit table. */
    #####: 1304:			int n = curtab->ntab;
    #####: 1305:			toml_table_t **base = (toml_table_t **)expand_ptrarr(
    #####: 1306:			    (void **)curtab->tab, n);
    #####: 1307:			if (0 == base)
    #####: 1308:				return e_outofmemory(ctx, FLINE);
        -: 1309:
    #####: 1310:			curtab->tab = base;
        -: 1311:
    #####: 1312:			if (0 == (base[n] = (toml_table_t *)CALLOC(
        -: 1313:				      1, sizeof(*base[n]))))
    #####: 1314:				return e_outofmemory(ctx, FLINE);
        -: 1315:
    #####: 1316:			if (0 == (base[n]->key = STRDUP(key)))
    #####: 1317:				return e_outofmemory(ctx, FLINE);
        -: 1318:
    #####: 1319:			nexttab = curtab->tab[curtab->ntab++];
        -: 1320:
        -: 1321:			/* tabs created by walk_tabpath are considered implicit
        -: 1322:			 */
    #####: 1323:			nexttab->implicit = true;
    #####: 1324:		} break;
        -: 1325:		}
        -: 1326:
        -: 1327:		/* switch to next tab */
    #####: 1328:		curtab = nexttab;
    #####: 1329:	}
        -: 1330:
        -: 1331:	/* save it */
    #####: 1332:	ctx->curtab = curtab;
        -: 1333:
    #####: 1334:	return 0;
    #####: 1335:}
        -: 1336:
        -: 1337:/* handle lines like [x.y.z] or [[x.y.z]] */
    #####: 1338:static int parse_select(context_t *ctx) {
    #####: 1339:	assert(ctx->tok.tok == LBRACKET);
        -: 1340:
        -: 1341:	/* true if [[ */
    #####: 1342:	int llb = (ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == '[');
        -: 1343:	/* need to detect '[[' on our own because next_token() will skip
        -: 1344:	   whitespace, and '[ [' would be taken as '[[', which is wrong. */
        -: 1345:
        -: 1346:	/* eat [ or [[ */
    #####: 1347:	if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1348:		return -1;
    #####: 1349:	if (llb) {
    #####: 1350:		assert(ctx->tok.tok == LBRACKET);
    #####: 1351:		if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1352:			return -1;
    #####: 1353:	}
        -: 1354:
    #####: 1355:	if (fill_tabpath(ctx))
    #####: 1356:		return -1;
        -: 1357:
        -: 1358:	/* For [x.y.z] or [[x.y.z]], remove z from tpath.
        -: 1359:	 */
    #####: 1360:	token_t z = ctx->tpath.tok[ctx->tpath.top - 1];
    #####: 1361:	xfree(ctx->tpath.key[ctx->tpath.top - 1]);
    #####: 1362:	ctx->tpath.top--;
        -: 1363:
        -: 1364:	/* set up ctx->curtab */
    #####: 1365:	if (walk_tabpath(ctx))
    #####: 1366:		return -1;
        -: 1367:
    #####: 1368:	if (!llb) {
        -: 1369:		/* [x.y.z] -> create z = {} in x.y */
    #####: 1370:		toml_table_t *curtab =
    #####: 1371:		    create_keytable_in_table(ctx, ctx->curtab, z);
    #####: 1372:		if (!curtab)
    #####: 1373:			return -1;
    #####: 1374:		ctx->curtab = curtab;
    #####: 1375:	} else {
        -: 1376:		/* [[x.y.z]] -> create z = [] in x.y */
    #####: 1377:		toml_array_t *arr = 0;
        -: 1378:		{
    #####: 1379:			char *zstr = normalize_key(ctx, z);
    #####: 1380:			if (!zstr)
    #####: 1381:				return -1;
    #####: 1382:			arr = toml_array_in(ctx->curtab, zstr);
    #####: 1383:			xfree(zstr);
    #####: 1384:		}
    #####: 1385:		if (!arr) {
    #####: 1386:			arr =
    #####: 1387:			    create_keyarray_in_table(ctx, ctx->curtab, z, 't');
    #####: 1388:			if (!arr)
    #####: 1389:				return -1;
    #####: 1390:		}
    #####: 1391:		if (arr->kind != 't')
    #####: 1392:			return e_syntax(ctx, z.lineno, "array mismatch");
        -: 1393:
        -: 1394:		/* add to z[] */
    #####: 1395:		toml_table_t *dest;
        -: 1396:		{
    #####: 1397:			toml_table_t *t = create_table_in_array(ctx, arr);
    #####: 1398:			if (!t)
    #####: 1399:				return -1;
        -: 1400:
    #####: 1401:			if (0 == (t->key = STRDUP("__anon__")))
    #####: 1402:				return e_outofmemory(ctx, FLINE);
        -: 1403:
    #####: 1404:			dest = t;
    #####: 1405:		}
        -: 1406:
    #####: 1407:		ctx->curtab = dest;
    #####: 1408:	}
        -: 1409:
    #####: 1410:	if (ctx->tok.tok != RBRACKET) {
    #####: 1411:		return e_syntax(ctx, ctx->tok.lineno, "expects ]");
        -: 1412:	}
    #####: 1413:	if (llb) {
    #####: 1414:		if (!(ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == ']')) {
    #####: 1415:			return e_syntax(ctx, ctx->tok.lineno, "expects ]]");
        -: 1416:		}
    #####: 1417:		if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1418:			return -1;
    #####: 1419:	}
        -: 1420:
    #####: 1421:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1422:		return -1;
        -: 1423:
    #####: 1424:	if (ctx->tok.tok != NEWLINE)
    #####: 1425:		return e_syntax(ctx, ctx->tok.lineno,
        -: 1426:				"extra chars after ] or ]]");
        -: 1427:
    #####: 1428:	return 0;
    #####: 1429:}
        -: 1430:
    #####: 1431:toml_table_t *toml_parse(char *conf, char *errbuf, int errbufsz) {
    #####: 1432:	context_t ctx;
        -: 1433:
        -: 1434:	// clear errbuf
    #####: 1435:	if (errbufsz <= 0)
    #####: 1436:		errbufsz = 0;
    #####: 1437:	if (errbufsz > 0)
    #####: 1438:		errbuf[0] = 0;
        -: 1439:
        -: 1440:	// init context
    #####: 1441:	memset(&ctx, 0, sizeof(ctx));
    #####: 1442:	ctx.start = conf;
    #####: 1443:	ctx.stop = ctx.start + strlen(conf);
    #####: 1444:	ctx.errbuf = errbuf;
    #####: 1445:	ctx.errbufsz = errbufsz;
        -: 1446:
        -: 1447:	// start with an artificial newline of length 0
    #####: 1448:	ctx.tok.tok = NEWLINE;
    #####: 1449:	ctx.tok.lineno = 1;
    #####: 1450:	ctx.tok.ptr = conf;
    #####: 1451:	ctx.tok.len = 0;
        -: 1452:
        -: 1453:	// make a root table
    #####: 1454:	if (0 == (ctx.root = CALLOC(1, sizeof(*ctx.root)))) {
    #####: 1455:		e_outofmemory(&ctx, FLINE);
        -: 1456:		// Do not goto fail, root table not set up yet
    #####: 1457:		return 0;
        -: 1458:	}
        -: 1459:
        -: 1460:	// set root as default table
    #####: 1461:	ctx.curtab = ctx.root;
        -: 1462:
        -: 1463:	/* Scan forward until EOF */
    #####: 1464:	for (token_t tok = ctx.tok; !tok.eof; tok = ctx.tok) {
    #####: 1465:		switch (tok.tok) {
        -: 1466:
        -: 1467:		case NEWLINE:
    #####: 1468:			if (next_token(&ctx, 1))
    #####: 1469:				goto fail;
    #####: 1470:			break;
        -: 1471:
        -: 1472:		case STRING:
    #####: 1473:			if (parse_keyval(&ctx, ctx.curtab))
    #####: 1474:				goto fail;
        -: 1475:
    #####: 1476:			if (ctx.tok.tok != NEWLINE) {
    #####: 1477:				e_syntax(&ctx, ctx.tok.lineno,
        -: 1478:					 "extra chars after value");
    #####: 1479:				goto fail;
        -: 1480:			}
        -: 1481:
    #####: 1482:			if (eat_token(&ctx, NEWLINE, 1, FLINE))
    #####: 1483:				goto fail;
    #####: 1484:			break;
        -: 1485:
        -: 1486:		case LBRACKET: /* [ x.y.z ] or [[ x.y.z ]] */
    #####: 1487:			if (parse_select(&ctx))
    #####: 1488:				goto fail;
    #####: 1489:			break;
        -: 1490:
        -: 1491:		default:
    #####: 1492:			e_syntax(&ctx, tok.lineno, "syntax error");
    #####: 1493:			goto fail;
        -: 1494:		}
    #####: 1495:	}
        -: 1496:
        -: 1497:	/* success */
    #####: 1498:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1499:		xfree(ctx.tpath.key[i]);
    #####: 1500:	return ctx.root;
        -: 1501:
        -: 1502:fail:
        -: 1503:	// Something bad has happened. Free resources and return error.
    #####: 1504:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1505:		xfree(ctx.tpath.key[i]);
    #####: 1506:	toml_free(ctx.root);
    #####: 1507:	return 0;
    #####: 1508:}
        -: 1509:
    #####: 1510:toml_table_t *toml_parse_file(FILE *fp, char *errbuf, int errbufsz) {
    #####: 1511:	int bufsz = 0;
    #####: 1512:	char *buf = 0;
    #####: 1513:	int off = 0;
        -: 1514:
        -: 1515:	/* read from fp into buf */
    #####: 1516:	while (!feof(fp)) {
        -: 1517:
    #####: 1518:		if (off == bufsz) {
    #####: 1519:			int xsz = bufsz + 1000;
    #####: 1520:			char *x = expand(buf, bufsz, xsz);
    #####: 1521:			if (!x) {
    #####: 1522:				snprintf(errbuf, errbufsz, "out of memory");
    #####: 1523:				xfree(buf);
    #####: 1524:				return 0;
        -: 1525:			}
    #####: 1526:			buf = x;
    #####: 1527:			bufsz = xsz;
    #####: 1528:		}
        -: 1529:
    #####: 1530:		errno = 0;
    #####: 1531:		int n = fread(buf + off, 1, bufsz - off, fp);
    #####: 1532:		if (ferror(fp)) {
    #####: 1533:			snprintf(errbuf, errbufsz, "%s",
        -: 1534:				 errno ? strerror(errno)
        -: 1535:				       : "Error reading file");
    #####: 1536:			xfree(buf);
    #####: 1537:			return 0;
        -: 1538:		}
    #####: 1539:		off += n;
    #####: 1540:	}
        -: 1541:
        -: 1542:	/* tag on a NUL to cap the string */
    #####: 1543:	if (off == bufsz) {
    #####: 1544:		int xsz = bufsz + 1;
    #####: 1545:		char *x = expand(buf, bufsz, xsz);
    #####: 1546:		if (!x) {
    #####: 1547:			snprintf(errbuf, errbufsz, "out of memory");
    #####: 1548:			xfree(buf);
    #####: 1549:			return 0;
        -: 1550:		}
    #####: 1551:		buf = x;
    #####: 1552:		bufsz = xsz;
    #####: 1553:	}
    #####: 1554:	buf[off] = 0;
        -: 1555:
        -: 1556:	/* parse it, cleanup and finish */
    #####: 1557:	toml_table_t *ret = toml_parse(buf, errbuf, errbufsz);
    #####: 1558:	xfree(buf);
    #####: 1559:	return ret;
    #####: 1560:}
        -: 1561:
    #####: 1562:static void xfree_kval(toml_keyval_t *p) {
    #####: 1563:	if (!p)
    #####: 1564:		return;
    #####: 1565:	xfree(p->key);
    #####: 1566:	xfree(p->val);
    #####: 1567:	xfree(p);
    #####: 1568:}
        -: 1569:
        -: 1570:static void xfree_tab(toml_table_t *p);
        -: 1571:
    #####: 1572:static void xfree_arr(toml_array_t *p) {
    #####: 1573:	if (!p)
    #####: 1574:		return;
        -: 1575:
    #####: 1576:	xfree(p->key);
    #####: 1577:	const int n = p->nitem;
    #####: 1578:	for (int i = 0; i < n; i++) {
    #####: 1579:		toml_arritem_t *a = &p->item[i];
    #####: 1580:		if (a->val)
    #####: 1581:			xfree(a->val);
    #####: 1582:		else if (a->arr)
    #####: 1583:			xfree_arr(a->arr);
    #####: 1584:		else if (a->tab)
    #####: 1585:			xfree_tab(a->tab);
    #####: 1586:	}
    #####: 1587:	xfree(p->item);
    #####: 1588:	xfree(p);
    #####: 1589:}
        -: 1590:
    #####: 1591:static void xfree_tab(toml_table_t *p) {
    #####: 1592:	int i;
        -: 1593:
    #####: 1594:	if (!p)
    #####: 1595:		return;
        -: 1596:
    #####: 1597:	xfree(p->key);
        -: 1598:
    #####: 1599:	for (i = 0; i < p->nkval; i++)
    #####: 1600:		xfree_kval(p->kval[i]);
    #####: 1601:	xfree(p->kval);
        -: 1602:
    #####: 1603:	for (i = 0; i < p->narr; i++)
    #####: 1604:		xfree_arr(p->arr[i]);
    #####: 1605:	xfree(p->arr);
        -: 1606:
    #####: 1607:	for (i = 0; i < p->ntab; i++)
    #####: 1608:		xfree_tab(p->tab[i]);
    #####: 1609:	xfree(p->tab);
        -: 1610:
    #####: 1611:	xfree(p);
    #####: 1612:}
        -: 1613:
    #####: 1614:void toml_free(toml_table_t *tab) { xfree_tab(tab); }
        -: 1615:
    #####: 1616:static void set_token(context_t *ctx, tokentype_t tok, int lineno, char *ptr,
        -: 1617:		      int len) {
    #####: 1618:	token_t t;
    #####: 1619:	t.tok = tok;
    #####: 1620:	t.lineno = lineno;
    #####: 1621:	t.ptr = ptr;
    #####: 1622:	t.len = len;
    #####: 1623:	t.eof = 0;
    #####: 1624:	ctx->tok = t;
    #####: 1625:}
        -: 1626:
    #####: 1627:static void set_eof(context_t *ctx, int lineno) {
    #####: 1628:	set_token(ctx, NEWLINE, lineno, ctx->stop, 0);
    #####: 1629:	ctx->tok.eof = 1;
    #####: 1630:}
        -: 1631:
        -: 1632:/* Scan p for n digits compositing entirely of [0-9] */
    #####: 1633:static int scan_digits(const char *p, int n) {
    #####: 1634:	int ret = 0;
    #####: 1635:	for (; n > 0 && isdigit(*p); n--, p++) {
    #####: 1636:		ret = 10 * ret + (*p - '0');
    #####: 1637:	}
    #####: 1638:	return n ? -1 : ret;
    #####: 1639:}
        -: 1640:
    #####: 1641:static int scan_date(const char *p, int *YY, int *MM, int *DD) {
    #####: 1642:	int year, month, day;
    #####: 1643:	year = scan_digits(p, 4);
    #####: 1644:	month = (year >= 0 && p[4] == '-') ? scan_digits(p + 5, 2) : -1;
    #####: 1645:	day = (month >= 0 && p[7] == '-') ? scan_digits(p + 8, 2) : -1;
    #####: 1646:	if (YY)
    #####: 1647:		*YY = year;
    #####: 1648:	if (MM)
    #####: 1649:		*MM = month;
    #####: 1650:	if (DD)
    #####: 1651:		*DD = day;
    #####: 1652:	return (year >= 0 && month >= 0 && day >= 0) ? 0 : -1;
    #####: 1653:}
        -: 1654:
    #####: 1655:static int scan_time(const char *p, int *hh, int *mm, int *ss) {
    #####: 1656:	int hour, minute, second;
    #####: 1657:	hour = scan_digits(p, 2);
    #####: 1658:	minute = (hour >= 0 && p[2] == ':') ? scan_digits(p + 3, 2) : -1;
    #####: 1659:	second = (minute >= 0 && p[5] == ':') ? scan_digits(p + 6, 2) : -1;
    #####: 1660:	if (hh)
    #####: 1661:		*hh = hour;
    #####: 1662:	if (mm)
    #####: 1663:		*mm = minute;
    #####: 1664:	if (ss)
    #####: 1665:		*ss = second;
    #####: 1666:	return (hour >= 0 && minute >= 0 && second >= 0) ? 0 : -1;
    #####: 1667:}
        -: 1668:
    #####: 1669:static int scan_string(context_t *ctx, char *p, int lineno, int dotisspecial) {
    #####: 1670:	char *orig = p;
    #####: 1671:	if (0 == strncmp(p, "'''", 3)) {
    #####: 1672:		char *q = p + 3;
        -: 1673:
    #####: 1674:		while (1) {
    #####: 1675:			q = strstr(q, "'''");
    #####: 1676:			if (0 == q) {
    #####: 1677:				return e_syntax(ctx, lineno,
        -: 1678:						"unterminated triple-s-quote");
        -: 1679:			}
    #####: 1680:			while (q[3] == '\'')
    #####: 1681:				q++;
    #####: 1682:			break;
        -: 1683:		}
        -: 1684:
    #####: 1685:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1686:		return 0;
    #####: 1687:	}
        -: 1688:
    #####: 1689:	if (0 == strncmp(p, "\"\"\"", 3)) {
    #####: 1690:		char *q = p + 3;
        -: 1691:
    #####: 1692:		while (1) {
    #####: 1693:			q = strstr(q, "\"\"\"");
    #####: 1694:			if (0 == q) {
    #####: 1695:				return e_syntax(ctx, lineno,
        -: 1696:						"unterminated triple-d-quote");
        -: 1697:			}
    #####: 1698:			if (q[-1] == '\\') {
    #####: 1699:				q++;
    #####: 1700:				continue;
        -: 1701:			}
    #####: 1702:			while (q[3] == '\"')
    #####: 1703:				q++;
    #####: 1704:			break;
        -: 1705:		}
        -: 1706:
        -: 1707:		// the string is [p+3, q-1]
        -: 1708:
    #####: 1709:		int hexreq = 0; /* #hex required */
    #####: 1710:		int escape = 0;
    #####: 1711:		for (p += 3; p < q; p++) {
    #####: 1712:			if (escape) {
    #####: 1713:				escape = 0;
    #####: 1714:				if (strchr("btnfr\"\\", *p))
    #####: 1715:					continue;
    #####: 1716:				if (*p == 'u') {
    #####: 1717:					hexreq = 4;
    #####: 1718:					continue;
        -: 1719:				}
    #####: 1720:				if (*p == 'U') {
    #####: 1721:					hexreq = 8;
    #####: 1722:					continue;
        -: 1723:				}
    #####: 1724:				if (p[strspn(p, " \t\r")] == '\n')
    #####: 1725:					continue; /* allow for line ending
        -: 1726:						     backslash */
    #####: 1727:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1728:			}
    #####: 1729:			if (hexreq) {
    #####: 1730:				hexreq--;
    #####: 1731:				if (strchr("0123456789ABCDEF", *p))
    #####: 1732:					continue;
    #####: 1733:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1734:			}
    #####: 1735:			if (*p == '\\') {
    #####: 1736:				escape = 1;
    #####: 1737:				continue;
        -: 1738:			}
    #####: 1739:		}
    #####: 1740:		if (escape)
    #####: 1741:			return e_syntax(ctx, lineno, "expect an escape char");
    #####: 1742:		if (hexreq)
    #####: 1743:			return e_syntax(ctx, lineno, "expected more hex char");
        -: 1744:
    #####: 1745:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1746:		return 0;
    #####: 1747:	}
        -: 1748:
    #####: 1749:	if ('\'' == *p) {
    #####: 1750:		for (p++; *p && *p != '\n' && *p != '\''; p++)
        -: 1751:			;
    #####: 1752:		if (*p != '\'') {
    #####: 1753:			return e_syntax(ctx, lineno, "unterminated s-quote");
        -: 1754:		}
        -: 1755:
    #####: 1756:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1757:		return 0;
        -: 1758:	}
        -: 1759:
    #####: 1760:	if ('\"' == *p) {
    #####: 1761:		int hexreq = 0; /* #hex required */
    #####: 1762:		int escape = 0;
    #####: 1763:		for (p++; *p; p++) {
    #####: 1764:			if (escape) {
    #####: 1765:				escape = 0;
    #####: 1766:				if (strchr("btnfr\"\\", *p))
    #####: 1767:					continue;
    #####: 1768:				if (*p == 'u') {
    #####: 1769:					hexreq = 4;
    #####: 1770:					continue;
        -: 1771:				}
    #####: 1772:				if (*p == 'U') {
    #####: 1773:					hexreq = 8;
    #####: 1774:					continue;
        -: 1775:				}
    #####: 1776:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1777:			}
    #####: 1778:			if (hexreq) {
    #####: 1779:				hexreq--;
    #####: 1780:				if (strchr("0123456789ABCDEF", *p))
    #####: 1781:					continue;
    #####: 1782:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1783:			}
    #####: 1784:			if (*p == '\\') {
    #####: 1785:				escape = 1;
    #####: 1786:				continue;
        -: 1787:			}
    #####: 1788:			if (*p == '\'') {
    #####: 1789:				if (p[1] == '\'' && p[2] == '\'') {
    #####: 1790:					return e_syntax(
    #####: 1791:					    ctx, lineno,
        -: 1792:					    "triple-s-quote inside string lit");
        -: 1793:				}
    #####: 1794:				continue;
        -: 1795:			}
    #####: 1796:			if (*p == '\n')
    #####: 1797:				break;
    #####: 1798:			if (*p == '"')
    #####: 1799:				break;
    #####: 1800:		}
    #####: 1801:		if (*p != '"') {
    #####: 1802:			return e_syntax(ctx, lineno, "unterminated quote");
        -: 1803:		}
        -: 1804:
    #####: 1805:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1806:		return 0;
    #####: 1807:	}
        -: 1808:
        -: 1809:	/* check for timestamp without quotes */
    #####: 1810:	if (0 == scan_date(p, 0, 0, 0) || 0 == scan_time(p, 0, 0, 0)) {
        -: 1811:		// forward thru the timestamp
    #####: 1812:		p += strspn(p, "0123456789.:+-Tt Zz");
        -: 1813:		// squeeze out any spaces at end of string
    #####: 1814:		for (; p[-1] == ' '; p--)
        -: 1815:			;
        -: 1816:		// tokenize
    #####: 1817:		set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 1818:		return 0;
        -: 1819:	}
        -: 1820:
        -: 1821:	/* literals */
    #####: 1822:	for (; *p && *p != '\n'; p++) {
    #####: 1823:		int ch = *p;
    #####: 1824:		if (ch == '.' && dotisspecial)
    #####: 1825:			break;
    #####: 1826:		if ('A' <= ch && ch <= 'Z')
    #####: 1827:			continue;
    #####: 1828:		if ('a' <= ch && ch <= 'z')
    #####: 1829:			continue;
    #####: 1830:		if (strchr("0123456789+-_.", ch))
    #####: 1831:			continue;
    #####: 1832:		break;
    #####: 1833:	}
        -: 1834:
    #####: 1835:	set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 1836:	return 0;
    #####: 1837:}
        -: 1838:
    #####: 1839:static int next_token(context_t *ctx, int dotisspecial) {
    #####: 1840:	int lineno = ctx->tok.lineno;
    #####: 1841:	char *p = ctx->tok.ptr;
    #####: 1842:	int i;
        -: 1843:
        -: 1844:	/* eat this tok */
    #####: 1845:	for (i = 0; i < ctx->tok.len; i++) {
    #####: 1846:		if (*p++ == '\n')
    #####: 1847:			lineno++;
    #####: 1848:	}
        -: 1849:
        -: 1850:	/* make next tok */
    #####: 1851:	while (p < ctx->stop) {
        -: 1852:		/* skip comment. stop just before the \n. */
    #####: 1853:		if (*p == '#') {
    #####: 1854:			for (p++; p < ctx->stop && *p != '\n'; p++)
        -: 1855:				;
    #####: 1856:			continue;
        -: 1857:		}
        -: 1858:
    #####: 1859:		if (dotisspecial && *p == '.') {
    #####: 1860:			set_token(ctx, DOT, lineno, p, 1);
    #####: 1861:			return 0;
        -: 1862:		}
        -: 1863:
    #####: 1864:		switch (*p) {
        -: 1865:		case ',':
    #####: 1866:			set_token(ctx, COMMA, lineno, p, 1);
    #####: 1867:			return 0;
        -: 1868:		case '=':
    #####: 1869:			set_token(ctx, EQUAL, lineno, p, 1);
    #####: 1870:			return 0;
        -: 1871:		case '{':
    #####: 1872:			set_token(ctx, LBRACE, lineno, p, 1);
    #####: 1873:			return 0;
        -: 1874:		case '}':
    #####: 1875:			set_token(ctx, RBRACE, lineno, p, 1);
    #####: 1876:			return 0;
        -: 1877:		case '[':
    #####: 1878:			set_token(ctx, LBRACKET, lineno, p, 1);
    #####: 1879:			return 0;
        -: 1880:		case ']':
    #####: 1881:			set_token(ctx, RBRACKET, lineno, p, 1);
    #####: 1882:			return 0;
        -: 1883:		case '\n':
    #####: 1884:			set_token(ctx, NEWLINE, lineno, p, 1);
    #####: 1885:			return 0;
        -: 1886:		case '\r':
        -: 1887:		case ' ':
        -: 1888:		case '\t':
        -: 1889:			/* ignore white spaces */
    #####: 1890:			p++;
    #####: 1891:			continue;
        -: 1892:		}
        -: 1893:
    #####: 1894:		return scan_string(ctx, p, lineno, dotisspecial);
        -: 1895:	}
        -: 1896:
    #####: 1897:	set_eof(ctx, lineno);
    #####: 1898:	return 0;
    #####: 1899:}
        -: 1900:
    #####: 1901:const char *toml_key_in(const toml_table_t *tab, int keyidx) {
    #####: 1902:	if (keyidx < tab->nkval)
    #####: 1903:		return tab->kval[keyidx]->key;
        -: 1904:
    #####: 1905:	keyidx -= tab->nkval;
    #####: 1906:	if (keyidx < tab->narr)
    #####: 1907:		return tab->arr[keyidx]->key;
        -: 1908:
    #####: 1909:	keyidx -= tab->narr;
    #####: 1910:	if (keyidx < tab->ntab)
    #####: 1911:		return tab->tab[keyidx]->key;
        -: 1912:
    #####: 1913:	return 0;
    #####: 1914:}
        -: 1915:
    #####: 1916:int toml_key_exists(const toml_table_t *tab, const char *key) {
    #####: 1917:	int i;
    #####: 1918:	for (i = 0; i < tab->nkval; i++) {
    #####: 1919:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 1920:			return 1;
    #####: 1921:	}
    #####: 1922:	for (i = 0; i < tab->narr; i++) {
    #####: 1923:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 1924:			return 1;
    #####: 1925:	}
    #####: 1926:	for (i = 0; i < tab->ntab; i++) {
    #####: 1927:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 1928:			return 1;
    #####: 1929:	}
    #####: 1930:	return 0;
    #####: 1931:}
        -: 1932:
    #####: 1933:toml_raw_t toml_raw_in(const toml_table_t *tab, const char *key) {
    #####: 1934:	int i;
    #####: 1935:	for (i = 0; i < tab->nkval; i++) {
    #####: 1936:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 1937:			return tab->kval[i]->val;
    #####: 1938:	}
    #####: 1939:	return 0;
    #####: 1940:}
        -: 1941:
    #####: 1942:toml_array_t *toml_array_in(const toml_table_t *tab, const char *key) {
    #####: 1943:	int i;
    #####: 1944:	for (i = 0; i < tab->narr; i++) {
    #####: 1945:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 1946:			return tab->arr[i];
    #####: 1947:	}
    #####: 1948:	return 0;
    #####: 1949:}
        -: 1950:
    #####: 1951:toml_table_t *toml_table_in(const toml_table_t *tab, const char *key) {
    #####: 1952:	int i;
    #####: 1953:	for (i = 0; i < tab->ntab; i++) {
    #####: 1954:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 1955:			return tab->tab[i];
    #####: 1956:	}
    #####: 1957:	return 0;
    #####: 1958:}
        -: 1959:
    #####: 1960:toml_raw_t toml_raw_at(const toml_array_t *arr, int idx) {
    #####: 1961:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].val : 0;
        -: 1962:}
        -: 1963:
    #####: 1964:char toml_array_kind(const toml_array_t *arr) { return arr->kind; }
        -: 1965:
    #####: 1966:char toml_array_type(const toml_array_t *arr) {
    #####: 1967:	if (arr->kind != 'v')
    #####: 1968:		return 0;
        -: 1969:
    #####: 1970:	if (arr->nitem == 0)
    #####: 1971:		return 0;
        -: 1972:
    #####: 1973:	return arr->type;
    #####: 1974:}
        -: 1975:
    #####: 1976:int toml_array_nelem(const toml_array_t *arr) { return arr->nitem; }
        -: 1977:
    #####: 1978:const char *toml_array_key(const toml_array_t *arr) {
    #####: 1979:	return arr ? arr->key : (const char *)NULL;
        -: 1980:}
        -: 1981:
    #####: 1982:int toml_table_nkval(const toml_table_t *tab) { return tab->nkval; }
        -: 1983:
    #####: 1984:int toml_table_narr(const toml_table_t *tab) { return tab->narr; }
        -: 1985:
    #####: 1986:int toml_table_ntab(const toml_table_t *tab) { return tab->ntab; }
        -: 1987:
    #####: 1988:const char *toml_table_key(const toml_table_t *tab) {
    #####: 1989:	return tab ? tab->key : (const char *)NULL;
        -: 1990:}
        -: 1991:
    #####: 1992:toml_array_t *toml_array_at(const toml_array_t *arr, int idx) {
    #####: 1993:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].arr : 0;
        -: 1994:}
        -: 1995:
    #####: 1996:toml_table_t *toml_table_at(const toml_array_t *arr, int idx) {
    #####: 1997:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].tab : 0;
        -: 1998:}
        -: 1999:
        -: 2000:static int parse_millisec(const char *p, const char **endp);
        -: 2001:
    #####: 2002:int toml_rtots(toml_raw_t src_, toml_timestamp_t *ret) {
    #####: 2003:	if (!src_)
    #####: 2004:		return -1;
        -: 2005:
    #####: 2006:	const char *p = src_;
    #####: 2007:	int must_parse_time = 0;
        -: 2008:
    #####: 2009:	memset(ret, 0, sizeof(*ret));
        -: 2010:
    #####: 2011:	int *year = &ret->__buffer.year;
    #####: 2012:	int *month = &ret->__buffer.month;
    #####: 2013:	int *day = &ret->__buffer.day;
    #####: 2014:	int *hour = &ret->__buffer.hour;
    #####: 2015:	int *minute = &ret->__buffer.minute;
    #####: 2016:	int *second = &ret->__buffer.second;
    #####: 2017:	int *millisec = &ret->__buffer.millisec;
        -: 2018:
        -: 2019:	/* parse date YYYY-MM-DD */
    #####: 2020:	if (0 == scan_date(p, year, month, day)) {
    #####: 2021:		ret->year = year;
    #####: 2022:		ret->month = month;
    #####: 2023:		ret->day = day;
        -: 2024:
    #####: 2025:		p += 10;
    #####: 2026:		if (*p) {
        -: 2027:			// parse the T or space separator
    #####: 2028:			if (*p != 'T' && *p != 't' && *p != ' ')
    #####: 2029:				return -1;
    #####: 2030:			must_parse_time = 1;
    #####: 2031:			p++;
    #####: 2032:		}
    #####: 2033:	}
        -: 2034:
        -: 2035:	/* parse time HH:MM:SS */
    #####: 2036:	if (0 == scan_time(p, hour, minute, second)) {
    #####: 2037:		ret->hour = hour;
    #####: 2038:		ret->minute = minute;
    #####: 2039:		ret->second = second;
        -: 2040:
        -: 2041:		/* optionally, parse millisec */
    #####: 2042:		p += 8;
    #####: 2043:		if (*p == '.') {
    #####: 2044:			p++; /* skip '.' */
    #####: 2045:			const char *qq;
    #####: 2046:			*millisec = parse_millisec(p, &qq);
    #####: 2047:			ret->millisec = millisec;
    #####: 2048:			p = qq;
    #####: 2049:		}
        -: 2050:
    #####: 2051:		if (*p) {
        -: 2052:			/* parse and copy Z */
    #####: 2053:			char *z = ret->__buffer.z;
    #####: 2054:			ret->z = z;
    #####: 2055:			if (*p == 'Z' || *p == 'z') {
    #####: 2056:				*z++ = 'Z';
    #####: 2057:				p++;
    #####: 2058:				*z = 0;
        -: 2059:
    #####: 2060:			} else if (*p == '+' || *p == '-') {
    #####: 2061:				*z++ = *p++;
        -: 2062:
    #####: 2063:				if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2064:					return -1;
    #####: 2065:				*z++ = *p++;
    #####: 2066:				*z++ = *p++;
        -: 2067:
    #####: 2068:				if (*p == ':') {
    #####: 2069:					*z++ = *p++;
        -: 2070:
    #####: 2071:					if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2072:						return -1;
    #####: 2073:					*z++ = *p++;
    #####: 2074:					*z++ = *p++;
    #####: 2075:				}
        -: 2076:
    #####: 2077:				*z = 0;
    #####: 2078:			}
    #####: 2079:		}
    #####: 2080:	}
    #####: 2081:	if (*p != 0)
    #####: 2082:		return -1;
        -: 2083:
    #####: 2084:	if (must_parse_time && !ret->hour)
    #####: 2085:		return -1;
        -: 2086:
    #####: 2087:	return 0;
    #####: 2088:}
        -: 2089:
        -: 2090:/* Raw to boolean */
    #####: 2091:int toml_rtob(toml_raw_t src, int *ret_) {
    #####: 2092:	if (!src)
    #####: 2093:		return -1;
    #####: 2094:	int dummy;
    #####: 2095:	int *ret = ret_ ? ret_ : &dummy;
        -: 2096:
    #####: 2097:	if (0 == strcmp(src, "true")) {
    #####: 2098:		*ret = 1;
    #####: 2099:		return 0;
        -: 2100:	}
    #####: 2101:	if (0 == strcmp(src, "false")) {
    #####: 2102:		*ret = 0;
    #####: 2103:		return 0;
        -: 2104:	}
    #####: 2105:	return -1;
    #####: 2106:}
        -: 2107:
        -: 2108:/* Raw to integer */
    #####: 2109:int toml_rtoi(toml_raw_t src, int64_t *ret_) {
    #####: 2110:	if (!src)
    #####: 2111:		return -1;
        -: 2112:
    #####: 2113:	char buf[100];
    #####: 2114:	char *p = buf;
    #####: 2115:	char *q = p + sizeof(buf);
    #####: 2116:	const char *s = src;
    #####: 2117:	int base = 0;
    #####: 2118:	int64_t dummy;
    #####: 2119:	int64_t *ret = ret_ ? ret_ : &dummy;
        -: 2120:
        -: 2121:	/* allow +/- */
    #####: 2122:	if (s[0] == '+' || s[0] == '-')
    #####: 2123:		*p++ = *s++;
        -: 2124:
        -: 2125:	/* disallow +_100 */
    #####: 2126:	if (s[0] == '_')
    #####: 2127:		return -1;
        -: 2128:
        -: 2129:	/* if 0* ... */
    #####: 2130:	if ('0' == s[0]) {
    #####: 2131:		switch (s[1]) {
        -: 2132:		case 'x':
    #####: 2133:			base = 16;
    #####: 2134:			s += 2;
    #####: 2135:			break;
        -: 2136:		case 'o':
    #####: 2137:			base = 8;
    #####: 2138:			s += 2;
    #####: 2139:			break;
        -: 2140:		case 'b':
    #####: 2141:			base = 2;
    #####: 2142:			s += 2;
    #####: 2143:			break;
        -: 2144:		case '\0':
    #####: 2145:			return *ret = 0, 0;
        -: 2146:		default:
        -: 2147:			/* ensure no other digits after it */
    #####: 2148:			if (s[1])
    #####: 2149:				return -1;
    #####: 2150:		}
    #####: 2151:	}
        -: 2152:
        -: 2153:	/* just strip underscores and pass to strtoll */
    #####: 2154:	while (*s && p < q) {
    #####: 2155:		int ch = *s++;
    #####: 2156:		if (ch == '_') {
        -: 2157:			// disallow '__'
    #####: 2158:			if (s[0] == '_')
    #####: 2159:				return -1;
        -: 2160:			// numbers cannot end with '_'
    #####: 2161:			if (s[0] == '\0')
    #####: 2162:				return -1;
    #####: 2163:			continue; /* skip _ */
        -: 2164:		}
    #####: 2165:		*p++ = ch;
    #####: 2166:	}
        -: 2167:
        -: 2168:	// if not at end-of-string or we ran out of buffer ...
    #####: 2169:	if (*s || p == q)
    #####: 2170:		return -1;
        -: 2171:
        -: 2172:	/* cap with NUL */
    #####: 2173:	*p = 0;
        -: 2174:
        -: 2175:	/* Run strtoll on buf to get the integer */
    #####: 2176:	char *endp;
    #####: 2177:	errno = 0;
    #####: 2178:	*ret = strtoll(buf, &endp, base);
    #####: 2179:	return (errno || *endp) ? -1 : 0;
    #####: 2180:}
        -: 2181:
    #####: 2182:int toml_rtod_ex(toml_raw_t src, double *ret_, char *buf, int buflen) {
    #####: 2183:	if (!src)
    #####: 2184:		return -1;
        -: 2185:
    #####: 2186:	char *p = buf;
    #####: 2187:	char *q = p + buflen;
    #####: 2188:	const char *s = src;
    #####: 2189:	double dummy;
    #####: 2190:	double *ret = ret_ ? ret_ : &dummy;
        -: 2191:
        -: 2192:	/* allow +/- */
    #####: 2193:	if (s[0] == '+' || s[0] == '-')
    #####: 2194:		*p++ = *s++;
        -: 2195:
        -: 2196:	/* disallow +_1.00 */
    #####: 2197:	if (s[0] == '_')
    #####: 2198:		return -1;
        -: 2199:
        -: 2200:	/* decimal point, if used, must be surrounded by at least one digit on
        -: 2201:	 * each side */
        -: 2202:	{
    #####: 2203:		char *dot = strchr(s, '.');
    #####: 2204:		if (dot) {
    #####: 2205:			if (dot == s || !isdigit(dot[-1]) || !isdigit(dot[1]))
    #####: 2206:				return -1;
    #####: 2207:		}
    #####: 2208:	}
        -: 2209:
        -: 2210:	/* zero must be followed by . or 'e', or NUL */
    #####: 2211:	if (s[0] == '0' && s[1] && !strchr("eE.", s[1]))
    #####: 2212:		return -1;
        -: 2213:
        -: 2214:	/* just strip underscores and pass to strtod */
    #####: 2215:	while (*s && p < q) {
    #####: 2216:		int ch = *s++;
    #####: 2217:		if (ch == '_') {
        -: 2218:			// disallow '__'
    #####: 2219:			if (s[0] == '_')
    #####: 2220:				return -1;
        -: 2221:			// disallow last char '_'
    #####: 2222:			if (s[0] == 0)
    #####: 2223:				return -1;
    #####: 2224:			continue; /* skip _ */
        -: 2225:		}
    #####: 2226:		*p++ = ch;
    #####: 2227:	}
    #####: 2228:	if (*s || p == q)
    #####: 2229:		return -1; /* reached end of string or buffer is full? */
        -: 2230:
        -: 2231:	/* cap with NUL */
    #####: 2232:	*p = 0;
        -: 2233:
        -: 2234:	/* Run strtod on buf to get the value */
    #####: 2235:	char *endp;
    #####: 2236:	errno = 0;
    #####: 2237:	*ret = strtod(buf, &endp);
    #####: 2238:	return (errno || *endp) ? -1 : 0;
    #####: 2239:}
        -: 2240:
    #####: 2241:int toml_rtod(toml_raw_t src, double *ret_) {
    #####: 2242:	char buf[100];
    #####: 2243:	return toml_rtod_ex(src, ret_, buf, sizeof(buf));
    #####: 2244:}
        -: 2245:
    #####: 2246:int toml_rtos(toml_raw_t src, char **ret) {
    #####: 2247:	int multiline = 0;
    #####: 2248:	const char *sp;
    #####: 2249:	const char *sq;
        -: 2250:
    #####: 2251:	*ret = 0;
    #####: 2252:	if (!src)
    #####: 2253:		return -1;
        -: 2254:
        -: 2255:	// for strings, first char must be a s-quote or d-quote
    #####: 2256:	int qchar = src[0];
    #####: 2257:	int srclen = strlen(src);
    #####: 2258:	if (!(qchar == '\'' || qchar == '"')) {
    #####: 2259:		return -1;
        -: 2260:	}
        -: 2261:
        -: 2262:	// triple quotes?
    #####: 2263:	if (qchar == src[1] && qchar == src[2]) {
    #####: 2264:		multiline = 1;	       // triple-quote implies multiline
    #####: 2265:		sp = src + 3;	       // first char after quote
    #####: 2266:		sq = src + srclen - 3; // first char of ending quote
        -: 2267:
    #####: 2268:		if (!(sp <= sq && sq[0] == qchar && sq[1] == qchar &&
    #####: 2269:		      sq[2] == qchar)) {
        -: 2270:			// last 3 chars in src must be qchar
    #####: 2271:			return -1;
        -: 2272:		}
        -: 2273:
        -: 2274:		/* skip new line immediate after qchar */
    #####: 2275:		if (sp[0] == '\n')
    #####: 2276:			sp++;
    #####: 2277:		else if (sp[0] == '\r' && sp[1] == '\n')
    #####: 2278:			sp += 2;
        -: 2279:
    #####: 2280:	} else {
    #####: 2281:		sp = src + 1;	       // first char after quote
    #####: 2282:		sq = src + srclen - 1; // ending quote
    #####: 2283:		if (!(sp <= sq && *sq == qchar)) {
        -: 2284:			/* last char in src must be qchar */
    #####: 2285:			return -1;
        -: 2286:		}
        -: 2287:	}
        -: 2288:
        -: 2289:	// at this point:
        -: 2290:	//     sp points to first valid char after quote.
        -: 2291:	//     sq points to one char beyond last valid char.
        -: 2292:	//     string len is (sq - sp).
    #####: 2293:	if (qchar == '\'') {
    #####: 2294:		*ret = norm_lit_str(sp, sq - sp, multiline, 0, 0);
    #####: 2295:	} else {
    #####: 2296:		*ret = norm_basic_str(sp, sq - sp, multiline, 0, 0);
        -: 2297:	}
        -: 2298:
    #####: 2299:	return *ret ? 0 : -1;
    #####: 2300:}
        -: 2301:
    #####: 2302:toml_datum_t toml_string_at(const toml_array_t *arr, int idx) {
        -: 2303:	toml_datum_t ret;
    #####: 2304:	memset(&ret, 0, sizeof(ret));
    #####: 2305:	ret.ok = (0 == toml_rtos(toml_raw_at(arr, idx), &ret.u.s));
    #####: 2306:	return ret;
        -: 2307:}
        -: 2308:
    #####: 2309:toml_datum_t toml_bool_at(const toml_array_t *arr, int idx) {
        -: 2310:	toml_datum_t ret;
    #####: 2311:	memset(&ret, 0, sizeof(ret));
    #####: 2312:	ret.ok = (0 == toml_rtob(toml_raw_at(arr, idx), &ret.u.b));
    #####: 2313:	return ret;
        -: 2314:}
        -: 2315:
    #####: 2316:toml_datum_t toml_int_at(const toml_array_t *arr, int idx) {
        -: 2317:	toml_datum_t ret;
    #####: 2318:	memset(&ret, 0, sizeof(ret));
    #####: 2319:	ret.ok = (0 == toml_rtoi(toml_raw_at(arr, idx), &ret.u.i));
    #####: 2320:	return ret;
        -: 2321:}
        -: 2322:
    #####: 2323:toml_datum_t toml_double_at(const toml_array_t *arr, int idx) {
        -: 2324:	toml_datum_t ret;
    #####: 2325:	memset(&ret, 0, sizeof(ret));
    #####: 2326:	ret.ok = (0 == toml_rtod(toml_raw_at(arr, idx), &ret.u.d));
    #####: 2327:	return ret;
        -: 2328:}
        -: 2329:
    #####: 2330:toml_datum_t toml_timestamp_at(const toml_array_t *arr, int idx) {
    #####: 2331:	toml_timestamp_t ts;
        -: 2332:	toml_datum_t ret;
    #####: 2333:	memset(&ret, 0, sizeof(ret));
    #####: 2334:	ret.ok = (0 == toml_rtots(toml_raw_at(arr, idx), &ts));
    #####: 2335:	if (ret.ok) {
    #####: 2336:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2337:		if (ret.ok) {
    #####: 2338:			*ret.u.ts = ts;
    #####: 2339:			if (ret.u.ts->year)
    #####: 2340:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2341:			if (ret.u.ts->month)
    #####: 2342:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2343:			if (ret.u.ts->day)
    #####: 2344:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2345:			if (ret.u.ts->hour)
    #####: 2346:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2347:			if (ret.u.ts->minute)
    #####: 2348:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2349:			if (ret.u.ts->second)
    #####: 2350:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2351:			if (ret.u.ts->millisec)
    #####: 2352:				ret.u.ts->millisec =
    #####: 2353:				    &ret.u.ts->__buffer.millisec;
    #####: 2354:			if (ret.u.ts->z)
    #####: 2355:				ret.u.ts->z = ret.u.ts->__buffer.z;
    #####: 2356:		}
    #####: 2357:	}
        -: 2358:	return ret;
    #####: 2359:}
        -: 2360:
    #####: 2361:toml_datum_t toml_string_in(const toml_table_t *arr, const char *key) {
        -: 2362:	toml_datum_t ret;
    #####: 2363:	memset(&ret, 0, sizeof(ret));
    #####: 2364:	toml_raw_t raw = toml_raw_in(arr, key);
    #####: 2365:	if (raw) {
    #####: 2366:		ret.ok = (0 == toml_rtos(raw, &ret.u.s));
    #####: 2367:	}
        -: 2368:	return ret;
    #####: 2369:}
        -: 2370:
    #####: 2371:toml_datum_t toml_bool_in(const toml_table_t *arr, const char *key) {
        -: 2372:	toml_datum_t ret;
    #####: 2373:	memset(&ret, 0, sizeof(ret));
    #####: 2374:	ret.ok = (0 == toml_rtob(toml_raw_in(arr, key), &ret.u.b));
    #####: 2375:	return ret;
        -: 2376:}
        -: 2377:
    #####: 2378:toml_datum_t toml_int_in(const toml_table_t *arr, const char *key) {
        -: 2379:	toml_datum_t ret;
    #####: 2380:	memset(&ret, 0, sizeof(ret));
    #####: 2381:	ret.ok = (0 == toml_rtoi(toml_raw_in(arr, key), &ret.u.i));
    #####: 2382:	return ret;
        -: 2383:}
        -: 2384:
    #####: 2385:toml_datum_t toml_double_in(const toml_table_t *arr, const char *key) {
        -: 2386:	toml_datum_t ret;
    #####: 2387:	memset(&ret, 0, sizeof(ret));
    #####: 2388:	ret.ok = (0 == toml_rtod(toml_raw_in(arr, key), &ret.u.d));
    #####: 2389:	return ret;
        -: 2390:}
        -: 2391:
    #####: 2392:toml_datum_t toml_timestamp_in(const toml_table_t *arr, const char *key) {
    #####: 2393:	toml_timestamp_t ts;
        -: 2394:	toml_datum_t ret;
    #####: 2395:	memset(&ret, 0, sizeof(ret));
    #####: 2396:	ret.ok = (0 == toml_rtots(toml_raw_in(arr, key), &ts));
    #####: 2397:	if (ret.ok) {
    #####: 2398:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2399:		if (ret.ok) {
    #####: 2400:			*ret.u.ts = ts;
    #####: 2401:			if (ret.u.ts->year)
    #####: 2402:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2403:			if (ret.u.ts->month)
    #####: 2404:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2405:			if (ret.u.ts->day)
    #####: 2406:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2407:			if (ret.u.ts->hour)
    #####: 2408:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2409:			if (ret.u.ts->minute)
    #####: 2410:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2411:			if (ret.u.ts->second)
    #####: 2412:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2413:			if (ret.u.ts->millisec)
    #####: 2414:				ret.u.ts->millisec =
    #####: 2415:				    &ret.u.ts->__buffer.millisec;
    #####: 2416:			if (ret.u.ts->z)
    #####: 2417:				ret.u.ts->z = ret.u.ts->__buffer.z;
    #####: 2418:		}
    #####: 2419:	}
        -: 2420:	return ret;
    #####: 2421:}
        -: 2422:
    #####: 2423:static int parse_millisec(const char *p, const char **endp) {
    #####: 2424:	int ret = 0;
    #####: 2425:	int unit = 100; /* unit in millisec */
    #####: 2426:	for (; '0' <= *p && *p <= '9'; p++, unit /= 10) {
    #####: 2427:		ret += (*p - '0') * unit;
    #####: 2428:	}
    #####: 2429:	*endp = p;
    #####: 2430:	return ret;
    #####: 2431:}</textarea>
		</p>
	</body>
</html>

