<!DOCTYPE html>
<html>
	<head>
		<title>Code Coverage Report</title>
		<script src="chart.js"></script>
		<style>
			.chart {
				width: 900px;
			}
			.textarea {
				overflow:auto;
				resize:none;
			}
		</style>
	</head>
	<body>
		 <p align="center">
                        Code Coverage is currently 85.76%.
                </p>
		<center>
			<div class="chart">
				<canvas id="chart"></canvas>
			</div>
		</center>
		<script>
			function format_date(timestamp, time_frame) {
				var date = new Date(timestamp);
				var day_of_month = date.getDate();
				var full_year = date.getFullYear();
				var month = 1 + date.getMonth();
				var hours = date.getHours();
				var minutes = date.getMinutes();
				var seconds = date.getSeconds();
				var am_pm = 'AM';

				if(seconds < 10) {
					seconds = '0' + seconds;
				}
				if(minutes < 10) {
					minutes = '0' + minutes;
				}
				if(hours == 12) {
					am_pm = 'PM';
				} else if(hours > 12) {
					hours -= 12;
					am_pm = 'PM';
				}
				if(hours == 0) {
					hours = 12;
				}

				return month + '/' + day_of_month + '/' + full_year + ' ' +
					hours + ':' + minutes + ':' + seconds + ' ' + am_pm;
			}

			let raw_data = [86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
0.00,
0.00,
0.00,
85.57,
85.57,
86.81,
84.76,
94.15,
94.15,
94.39,
96.83,
96.83,
85.76,];
			let labels = [format_date(1716876818 * 1000 ),
format_date(1716876822 * 1000 ),
format_date(1716904488 * 1000 ),
format_date(1716905952 * 1000 ),
format_date(1716905990 * 1000 ),
format_date(1716906171 * 1000 ),
format_date(1716906235 * 1000 ),
format_date(1716906333 * 1000 ),
format_date(1716906629 * 1000 ),
format_date(1716906787 * 1000 ),
format_date(1716907183 * 1000 ),
format_date(1716907441 * 1000 ),
format_date(1716907910 * 1000 ),
format_date(1716908379 * 1000 ),
format_date(1716909018 * 1000 ),
format_date(1716909696 * 1000 ),
format_date(1716920268 * 1000 ),
format_date(1717294283 * 1000 ),
format_date(1717311812 * 1000 ),
format_date(1717380318 * 1000 ),
format_date(1717381641 * 1000 ),
format_date(1717398065 * 1000 ),
format_date(1717484462 * 1000 ),];

			const data = {
				labels: labels,
				datasets: [{
					label: 'Code Coverage',
					backgroundColor: 'rgb(31,176,245)',
					borderColor: 'rgb(31,176,245)',
					data: raw_data,
				}]
			};

			const config = {
				type: 'line',
				data: data,
				options: {}
			};

			const chart = new Chart(
				document.getElementById('chart'),
				config
			);

		</script>

		<p align="center">
			Raw gcov output:<br/>
			<textarea readonly class="textarea" rows="50" cols="100">        -:    0:Source:log.c
        -:    0:Graph:./log.gcno
        -:    0:Data:./log.gcda
        -:    0:Runs:22
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <execinfo.h>
        -:   17:#include <inttypes.h>
        -:   18:#include <limits.h>
        -:   19:#include <log/log.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdarg.h>
        -:   22:#include <stdio.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <string.h>
        -:   25:#include <sys/time.h>
        -:   26:#include <time.h>
        -:   27:#include <unistd.h>
        -:   28:
        -:   29:const char PathSeparator =
        -:   30:#ifdef _WIN32
        -:   31:    '\\';
        -:   32:#else
        -:   33:    '/';
        -:   34:#endif
        -:   35:
        -:   36:#define _FILE_OFFSET_BITS 64
        -:   37:
       66:   38:u64 log_now()
        -:   39:{
        -:   40:    struct timeval tv;
       66:   41:    gettimeofday(&tv, NULL);
        -:   42:
       66:   43:    u64 ret = (u64)(tv.tv_sec) * 1000 + (u64)(tv.tv_usec) / 1000;
        -:   44:
       66:   45:    return ret;
        -:   46:}
        -:   47:
       92:   48:int sprintf_err(char* str, const char* string, ...)
        -:   49:{
        -:   50:    va_list args;
       92:   51:    va_start(args, string);
       92:   52:    int ret = vsprintf(str, string, args);
       92:   53:    va_end(args);
       92:   54:    return (ret > 0) ? 0 : ret;
        -:   55:}
        -:   56:
       82:   57:int set_option(Log* log, int type, void* value)
        -:   58:{
       82:   59:    if (value == NULL) {
        2:   60:        fputs("error: value pointer cannot be NULL\n", stderr);
        2:   61:        return -1;
        -:   62:    }
       80:   63:    if (type == ShowColors) {
       14:   64:        log->show_colors = *((bool*)value);
       66:   65:    } else if (type == ShowStdout) {
       10:   66:        log->show_stdout = *((bool*)value);
       56:   67:    } else if (type == ShowTimestamp) {
        3:   68:        log->show_timestamp = *((bool*)value);
       53:   69:    } else if (type == ShowMillis) {
        7:   70:        log->show_millis = *((bool*)value);
       46:   71:    } else if (type == ShowLogLevel) {
        1:   72:        log->show_log_level = *((bool*)value);
       45:   73:    } else if (type == AutoRotate) {
        2:   74:        log->auto_rotate = *((bool*)value);
       43:   75:    } else if (type == DeleteRotation) {
        1:   76:        log->delete_rotation = *((bool*)value);
       42:   77:    } else if (type == MaxSizeBytes) {
        7:   78:        if (*((u64*)value) < 1) {
        2:   79:            fputs("error: MaxSizeBytes cannot be less than 1\n", stderr);
        2:   80:            return -1;
        -:   81:        }
        5:   82:        log->max_size_bytes = *((u64*)value);
       35:   83:    } else if (type == MaxAgeMillis) {
        3:   84:        if (*((u64*)value) < 1000) {
        1:   85:            fputs("error: MaxAgeMillis cannot be less than 1,000\n", stderr);
        1:   86:            return -1;
        -:   87:        }
        2:   88:        log->max_age_millis = *((u64*)value);
       32:   89:    } else if (type == LogFilePath) {
       20:   90:        char* buf = ((char*)value);
       20:   91:        int len = strlen(buf);
       20:   92:        if (len < 1) {
        1:   93:            fputs("error: LogFilePath must be at least 1 bytes long\n", stderr);
        1:   94:            return -1;
        -:   95:        }
       19:   96:        log->path = malloc(sizeof(char) * (len + 1));
       19:   97:        if (log->path == NULL || log->debug_malloc) {
        1:   98:            if (log->path)
        1:   99:                free(log->path); // if debug_malloc is set
        1:  100:            log->path = NULL;
        1:  101:            fputs("error: Could not allocate the required memory\n", stderr);
        1:  102:            return -1;
        -:  103:        }
       18:  104:        strcpy(log->path, buf);
       12:  105:    } else if (type == FileHeader) {
       12:  106:        char* buf = ((char*)value);
       12:  107:        int len = strlen(buf);
       12:  108:        if (len < 1) {
        1:  109:            fputs("error: FileHeader must be at least 1 bytes long\n", stderr);
        1:  110:            return -1;
        -:  111:        }
       11:  112:        char* tmp = malloc(sizeof(char) * (len + 1));
       11:  113:        if (tmp == NULL || log->debug_malloc) {
        1:  114:            if (tmp)
        1:  115:                free(tmp); // if debug_malloc is set
        1:  116:            tmp = NULL;
        1:  117:            fputs("error: Could not allocate the required memory\n", stderr);
        1:  118:            return -1;
        -:  119:        }
       10:  120:        strcpy(tmp, buf);
       10:  121:        if (log->file_header != NULL)
        1:  122:            free(log->file_header);
       10:  123:        log->file_header = tmp;
        -:  124:    }
        -:  125:
       73:  126:    return 0;
        -:  127:}
        -:  128:
       30:  129:int do_logger(Log* log, int num, va_list valist)
        -:  130:{
       30:  131:    int ret = 0;
        -:  132:
        -:  133:    // set defaults
       30:  134:    log->fp = NULL;
       30:  135:    log->level = Info;
       30:  136:    log->show_colors = true;
       30:  137:    log->show_stdout = true;
       30:  138:    log->show_timestamp = true;
       30:  139:    log->show_millis = true;
       30:  140:    log->show_log_level = true;
       30:  141:    log->auto_rotate = false;
       30:  142:    log->delete_rotation = false;
       30:  143:    log->max_size_bytes = ULONG_MAX;
       30:  144:    log->max_age_millis = ULONG_MAX;
       30:  145:    log->path = NULL;
       30:  146:    log->file_header = NULL;
       30:  147:    log->off = 0;
       30:  148:    log->last_rotation = log_now();
       30:  149:    log->is_init = false;
       30:  150:    log->debug_malloc = false;
        -:  151:
        -:  152:    // iterate through arg list for overrides
       99:  153:    for (int i = 0; i < num; i++) {
       76:  154:        LogConfigOptionImpl next = va_arg(valist, LogConfigOptionImpl);
       76:  155:        if (set_option(log, next.type, next.value)) {
        7:  156:            if (log->file_header != NULL)
        1:  157:                free(log->file_header);
        7:  158:            if (log->path != NULL)
        1:  159:                free(log->path);
        7:  160:            log->path = NULL;
        7:  161:            log->file_header = NULL;
        7:  162:            ret = -1;
        7:  163:            break;
        -:  164:        }
        -:  165:    }
       30:  166:    return ret;
        -:  167:}
        -:  168:
       28:  169:int logger(Log* log, int num, ...)
        -:  170:{
        -:  171:    va_list valist;
       28:  172:    va_start(valist, num);
       28:  173:    int ret = do_logger(log, num, valist);
       28:  174:    va_end(valist);
       28:  175:    return ret;
        -:  176:}
        -:  177:
       23:  178:int get_format(Log* log, LogLevel level, char* buf)
        -:  179:{
       23:  180:    int ret = 0;
        -:  181:    char milli_buf[14];
        -:  182:    char log_level_buf[20];
        -:  183:    char dt_buf[40];
        -:  184:    char spacing[2];
       23:  185:    time_t t = time(NULL);
       23:  186:    struct tm tm = *localtime(&t);
        -:  187:
       23:  188:    if (log->show_millis) {
        -:  189:        struct timeval time;
       20:  190:        gettimeofday(&time, NULL);
       20:  191:        int millis = time.tv_usec / 1000;
       20:  192:        ret = sprintf_err(milli_buf, ".%03d", millis);
        -:  193:    } else {
        3:  194:        strcpy(milli_buf, "");
        -:  195:    }
        -:  196:
       23:  197:    if (log->show_timestamp) {
       19:  198:        strcpy(spacing, " ");
        -:  199:    } else {
        4:  200:        strcpy(spacing, "");
        -:  201:    }
        -:  202:
       23:  203:    if (log->show_log_level && ret == 0) {
       22:  204:        if (level == Trace) {
        2:  205:            if (log->show_colors) {
        1:  206:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_YELLOW "TRACE" ANSI_COLOR_RESET ")", spacing);
        -:  207:            } else {
        1:  208:                ret = sprintf_err(log_level_buf, "%s(TRACE)", spacing);
        -:  209:            }
       20:  210:        } else if (level == Debug) {
        4:  211:            if (log->show_colors) {
        1:  212:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_CYAN "DEBUG" ANSI_COLOR_RESET ")", spacing);
        -:  213:            } else {
        3:  214:                ret = sprintf_err(log_level_buf, "%s(DEBUG)", spacing);
        -:  215:            }
       16:  216:        } else if (level == Info) {
       10:  217:            if (log->show_colors) {
        4:  218:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_GREEN "INFO" ANSI_COLOR_RESET ")", spacing);
        -:  219:            } else {
        6:  220:                ret = sprintf_err(log_level_buf, "%s(INFO)", spacing);
        -:  221:            }
        6:  222:        } else if (level == Warn) {
        2:  223:            if (log->show_colors) {
        1:  224:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_MAGENTA "WARN" ANSI_COLOR_RESET ")", spacing);
        -:  225:            } else {
        1:  226:                ret = sprintf_err(log_level_buf, "%s(WARN)", spacing);
        -:  227:            }
        4:  228:        } else if (level == Error) {
        2:  229:            if (log->show_colors) {
        1:  230:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_RED "ERROR" ANSI_COLOR_RESET ")", spacing);
        -:  231:            } else {
        1:  232:                ret = sprintf_err(log_level_buf, "%s(ERROR)", spacing);
        -:  233:            }
        2:  234:        } else if (level == Fatal) {
        2:  235:            if (log->show_colors) {
        1:  236:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_BRIGHT_RED "FATAL" ANSI_COLOR_RESET ")", spacing);
        -:  237:            } else {
        1:  238:                ret = sprintf_err(log_level_buf, "%s(FATAL)", spacing);
        -:  239:            }
        -:  240:        }
        -:  241:    } else {
        1:  242:        strcpy(log_level_buf, "");
        -:  243:    }
        -:  244:
       23:  245:    if (log->show_timestamp && ret == 0) {
       19:  246:        if (log->show_colors) {
        7:  247:            ret = sprintf_err(
        -:  248:                dt_buf,
        -:  249:                "[" ANSI_COLOR_DIMMED
        -:  250:                "%d-%02d-%02d %02d:%02d:%02d%s" ANSI_COLOR_RESET
        -:  251:                "]",
        7:  252:                tm.tm_year + 1900,
        7:  253:                tm.tm_mon + 1,
        -:  254:                tm.tm_mday,
        -:  255:                tm.tm_hour,
        -:  256:                tm.tm_min,
        -:  257:                tm.tm_sec,
        -:  258:                milli_buf);
        -:  259:        } else {
       12:  260:            ret = sprintf_err(
        -:  261:                dt_buf,
        -:  262:                "["
        -:  263:                "%d-%02d-%02d %02d:%02d:%02d%s"
        -:  264:                "]",
       12:  265:                tm.tm_year + 1900,
       12:  266:                tm.tm_mon + 1,
        -:  267:                tm.tm_mday,
        -:  268:                tm.tm_hour,
        -:  269:                tm.tm_min,
        -:  270:                tm.tm_sec,
        -:  271:                milli_buf);
        -:  272:        }
        -:  273:    } else {
        4:  274:        strcpy(dt_buf, "");
        -:  275:    }
        -:  276:
       23:  277:    if ((level == Info || level == Warn) && log->show_log_level) {
       12:  278:        strcpy(spacing, ":");
        -:  279:    } else {
       11:  280:        strcpy(spacing, "");
        -:  281:    }
        -:  282:
       23:  283:    if (ret == 0) {
       23:  284:        ret = sprintf_err(
        -:  285:            buf,
        -:  286:            "%s%s%s: ",
        -:  287:            dt_buf,
        -:  288:            log_level_buf,
        -:  289:            spacing);
        -:  290:    }
       23:  291:    return ret;
        -:  292:}
        -:  293:
       90:  294:int do_log(Log* log, LogLevel level, char* line, bool is_plain, bool is_all, va_list args)
        -:  295:{
       90:  296:    int ret = 0;
       90:  297:    if (!log->is_init) {
        1:  298:        fputs("error: log has not been initialized\n", stderr);
        1:  299:        return -1;
        -:  300:    }
        -:  301:
       89:  302:    if (level >= log->level) {
        -:  303:        va_list args_copy;
       84:  304:        va_copy(args_copy, args);
        -:  305:
       84:  306:        int len = strlen(line);
       84:  307:        char fline[len + 100];
        -:  308:
       84:  309:        if (is_plain) {
       61:  310:            strcpy(fline, "");
        -:  311:        } else {
       23:  312:            ret = get_format(log, level, fline);
        -:  313:        }
       84:  314:        strcat(fline, line);
       84:  315:        strcat(fline, "\n");
        -:  316:
       84:  317:        if ((log->show_stdout || is_all) && ret == 0) {
       37:  318:            int v = vprintf(fline, args);
       37:  319:	    ret = (v > 0) ? 0 : v;
        -:  320:        }
        -:  321:
       84:  322:        if (log->fp && ret == 0) {
       81:  323:            int v = vfprintf(log->fp, fline, args_copy);
       81:  324:	    ret = (v > 0) ? 0 : v;
       81:  325:            log->off = ftello(log->fp);
        -:  326:        }
       84:  327:        if (log->auto_rotate && ret == 0) {
       12:  328:            if (log_need_rotate(log)) {
        2:  329:                ret = log_rotate(log);
        -:  330:            }
        -:  331:        }
        -:  332:    }
       89:  333:    return ret;
        -:  334:}
        -:  335:
        2:  336:int log_all(Log* log, LogLevel level, char* line, ...)
        -:  337:{
        -:  338:    va_list args;
        2:  339:    va_start(args, line);
        2:  340:    int ret = do_log(log, level, line, false, true, args);
        2:  341:    va_end(args);
        2:  342:    return ret;
        -:  343:}
        -:  344:
       60:  345:int log_plain(Log* log, LogLevel level, char* line, ...)
        -:  346:{
        -:  347:    va_list args;
       60:  348:    va_start(args, line);
       60:  349:    int ret = do_log(log, level, line, true, false, args);
       60:  350:    va_end(args);
       60:  351:    return ret;
        -:  352:}
        -:  353:
       21:  354:int log_line(Log* log, LogLevel level, char* line, ...)
        -:  355:{
        -:  356:    va_list args;
       21:  357:    va_start(args, line);
       21:  358:    int ret = do_log(log, level, line, false, false, args);
       21:  359:    va_end(args);
       21:  360:    return ret;
        -:  361:}
        -:  362:
        9:  363:void log_set_level(Log* log, LogLevel level)
        -:  364:{
        9:  365:    log->level = level;
        9:  366:}
        -:  367:
       22:  368:int log_init(Log* log)
        -:  369:{
       22:  370:    if (log->is_init) {
        1:  371:        fputs("error: log has already been initialized\n", stderr);
        1:  372:        return -1;
        -:  373:    }
       21:  374:    if (log->path) {
       17:  375:        bool write_header = false;
       17:  376:        if (log->file_header && access(log->path, F_OK) != 0) {
        6:  377:            write_header = true;
        -:  378:        }
       17:  379:        log->fp = fopen(log->path, "a");
       17:  380:        if (write_header) {
        6:  381:            fprintf(log->fp, "%s\n", log->file_header);
        -:  382:        }
       17:  383:        fseek(log->fp, 0, SEEK_END);
       17:  384:        log->off = ftello(log->fp);
        -:  385:    }
       21:  386:    log->is_init = true;
       21:  387:    return 0;
        -:  388:}
        -:  389:
        9:  390:int log_set_config_option(Log* log, LogConfigOptionImpl option)
        -:  391:{
        9:  392:    if (!log->is_init) {
        1:  393:        fputs("error: log has not been initialized\n", stderr);
        1:  394:        return -1;
        -:  395:    }
        8:  396:    if (option.type == LogFilePath && !log->debug_malloc) { // bypass this when we're debugging malloc
        2:  397:        fputs("error: cannot change log file path after initialization\n", stderr);
        2:  398:        return -1;
        -:  399:    }
        -:  400:
        6:  401:    return set_option(log, option.type, option.value);
        -:  402:}
        -:  403:
        9:  404:int log_rotate(Log* log)
        9:  405:{
        -:  406:    // format:
        -:  407:    // name.log -> name.r_<mon>_<day>_<year>_<time>_<rand>.log
        -:  408:
        9:  409:    int ret = 0;
        9:  410:    char rotation_name[strlen(log->path) + 100];
        9:  411:    time_t t = time(NULL);
        9:  412:    struct tm tm = *localtime(&t);
        -:  413:
        9:  414:    char* fname = strrchr(log->path, PathSeparator);
        9:  415:    if (fname == NULL) {
        1:  416:        fname = log->path;
        -:  417:    } else {
        8:  418:        ret = -1;
        8:  419:        if (strlen(fname) > 0) {
        8:  420:            ret = 0;
        8:  421:            fname = fname + 1;
        -:  422:        }
        -:  423:    }
        -:  424:
        9:  425:    if (!log->is_init) {
        1:  426:        fputs("error: log has not been initialized\n", stderr);
        1:  427:        ret = -1;
        -:  428:    }
        -:  429:
        -:  430:    char* ext;
        9:  431:    if (ret == 0) {
        8:  432:        strncpy(rotation_name, log->path, fname - log->path);
        8:  433:        rotation_name[fname - log->path] = 0;
        -:  434:
        8:  435:        ext = strrchr(fname, '.');
        8:  436:        if (ext == NULL) {
        1:  437:            ext = fname + strlen(fname);
        -:  438:        }
        -:  439:    }
        -:  440:
        9:  441:    if (ret == 0) {
        -:  442:        char date_format[100];
        8:  443:        strncpy(rotation_name + (fname - log->path), fname, ext - fname);
        8:  444:        rotation_name[ext - log->path] = 0;
        8:  445:        strcat(rotation_name, ".r_");
        -:  446:        u64 r;
        8:  447:        ret = rand_u64(&r);
        8:  448:        if (ret == 0) {
        8:  449:            sprintf_err(date_format,
        -:  450:                "%d_%02d_%02d_%02d_%02d_%02d_%" PRIu64,
        8:  451:                tm.tm_year + 1900,
        8:  452:                tm.tm_mon + 1,
        -:  453:                tm.tm_mday,
        -:  454:                tm.tm_hour,
        -:  455:                tm.tm_min,
        -:  456:                tm.tm_sec,
        -:  457:                r);
        8:  458:            strcat(rotation_name, date_format);
        8:  459:            strcat(rotation_name, ext);
        8:  460:            fclose(log->fp);
        8:  461:            if (log->delete_rotation) {
        1:  462:                remove(log->path);
        -:  463:            } else {
        7:  464:                rename(log->path, rotation_name);
        -:  465:            }
        -:  466:
        8:  467:            log->fp = fopen(log->path, "w");
        8:  468:            if (log->file_header)
        7:  469:                fprintf(log->fp, "%s\n", log->file_header);
        8:  470:            fseek(log->fp, 0, SEEK_END);
        8:  471:            log->off = ftello(log->fp);
        -:  472:        }
        -:  473:    }
        -:  474:
        9:  475:    if (ret == 0) {
        8:  476:        log->off = 0;
        8:  477:        log->last_rotation = log_now();
        -:  478:    }
        9:  479:    return ret;
        -:  480:}
        -:  481:
       28:  482:bool log_need_rotate(Log* log)
        -:  483:{
       28:  484:    u64 now = log_now();
       28:  485:    u64 diff = now - log->last_rotation;
       28:  486:    return log->off > log->max_size_bytes || diff > log->max_age_millis;
        -:  487:}
        -:  488:
       16:  489:int log_close(Log* log)
        -:  490:{
       16:  491:    if (log->fp) {
       16:  492:        fclose(log->fp);
       16:  493:        log->fp = NULL;
        -:  494:    }
       16:  495:    return 0;
        -:  496:}
        -:  497:
       80:  498:int _log_allocate_config_option(LogConfigOptionImpl* option, size_t size, bool debug_malloc_err, void* value)
        -:  499:{
       80:  500:    int ret = 0;
        -:  501:
       80:  502:    option->value = malloc(size);
       80:  503:    if (option->value == NULL || debug_malloc_err) {
        1:  504:        ret = -1;
        1:  505:        fputs("error: Could not allocate the required memory\n", stderr);
        -:  506:    }
        -:  507:
       80:  508:    return ret;
        -:  509:}
        -:  510:
       14:  511:int log_config_option_show_colors(LogConfigOptionImpl* option, bool value)
        -:  512:{
       14:  513:    option->type = ShowColors;
       14:  514:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
       14:  515:    if (!ret)
       14:  516:        *((bool*)option->value) = value;
       14:  517:    return ret;
        -:  518:}
        -:  519:
       10:  520:int log_config_option_show_stdout(LogConfigOptionImpl* option, bool value)
        -:  521:{
       10:  522:    option->type = ShowStdout;
       10:  523:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
       10:  524:    if (!ret)
       10:  525:        *((bool*)option->value) = value;
       10:  526:    return ret;
        -:  527:}
        -:  528:
        3:  529:int log_config_option_show_timestamp(LogConfigOptionImpl* option, bool value)
        -:  530:{
        3:  531:    option->type = ShowTimestamp;
        3:  532:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        3:  533:    if (!ret)
        3:  534:        *((bool*)option->value) = value;
        3:  535:    return ret;
        -:  536:}
        -:  537:
        7:  538:int log_config_option_show_millis(LogConfigOptionImpl* option, bool value)
        -:  539:{
        7:  540:    option->type = ShowMillis;
        7:  541:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        7:  542:    if (!ret)
        7:  543:        *((bool*)option->value) = value;
        7:  544:    return ret;
        -:  545:}
        -:  546:
        1:  547:int log_config_option_show_log_level(LogConfigOptionImpl* option, bool value)
        -:  548:{
        1:  549:    option->type = ShowLogLevel;
        1:  550:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        1:  551:    if (!ret)
        1:  552:        *((bool*)option->value) = value;
        1:  553:    return ret;
        -:  554:}
        -:  555:
        2:  556:int log_config_option_auto_rotate(LogConfigOptionImpl* option, bool value)
        -:  557:{
        2:  558:    option->type = AutoRotate;
        2:  559:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        2:  560:    if (!ret)
        2:  561:        *((bool*)option->value) = value;
        2:  562:    return ret;
        -:  563:}
        -:  564:
        1:  565:int log_config_option_delete_rotation(LogConfigOptionImpl* option, bool value)
        -:  566:{
        1:  567:    option->type = DeleteRotation;
        1:  568:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        1:  569:    if (!ret)
        1:  570:        *((bool*)option->value) = value;
        1:  571:    return ret;
        -:  572:}
        -:  573:
        6:  574:int log_config_option_max_size_bytes(LogConfigOptionImpl* option, u64 value)
        -:  575:{
        6:  576:    option->type = MaxSizeBytes;
        6:  577:    int ret = _log_allocate_config_option(option, sizeof(u64), false, &value);
        6:  578:    if (!ret)
        6:  579:        *((u64*)option->value) = value;
        6:  580:    return ret;
        -:  581:}
        -:  582:
        3:  583:int log_config_option_max_age_millis(LogConfigOptionImpl* option, u64 value)
        -:  584:{
        3:  585:    option->type = MaxAgeMillis;
        3:  586:    int ret = _log_allocate_config_option(option, sizeof(u64), false, &value);
        3:  587:    if (!ret)
        3:  588:        *((u64*)option->value) = value;
        3:  589:    return ret;
        -:  590:}
        -:  591:
       21:  592:int log_config_option_log_file_path(LogConfigOptionImpl* option, char* value)
        -:  593:{
       21:  594:    option->type = LogFilePath;
       21:  595:    int ret = 0;
       21:  596:    if (value == NULL) {
        1:  597:        option->value = NULL;
        -:  598:    } else {
       20:  599:        int len = strlen(value);
       20:  600:        ret = _log_allocate_config_option(option, sizeof(char) * (len + 1), false, &value);
       20:  601:        if (!ret)
       20:  602:            strcpy(option->value, value);
        -:  603:    }
       21:  604:    return ret;
        -:  605:}
        -:  606:
       13:  607:int log_config_option_file_header(LogConfigOptionImpl* option, char* value)
        -:  608:{
       13:  609:    option->type = FileHeader;
       13:  610:    int ret = 0;
       13:  611:    if (value == NULL) {
        1:  612:        option->value = NULL;
        -:  613:    } else {
       12:  614:        int len = strlen(value);
       12:  615:        ret = _log_allocate_config_option(option, sizeof(char) * (len + 1), false, &value);
       12:  616:        if (!ret)
       12:  617:            strcpy(option->value, value);
        -:  618:    }
       13:  619:    return ret;
        -:  620:}
        -:  621:
       72:  622:void log_config_option_free(LogConfigOptionImpl* option)
        -:  623:{
       72:  624:    if (option->value != NULL) {
       70:  625:        free(option->value);
       70:  626:	option->value = NULL;
        -:  627:    }
       72:  628:}
        -:  629:
       21:  630:void log_free(Log* log)
        -:  631:{
       21:  632:    if (log->path) {
       16:  633:        free(log->path);
       16:  634:	log->path = NULL;
        -:  635:    }
       21:  636:    if (log->file_header) {
        7:  637:        free(log->file_header);
        7:  638:	log->file_header = NULL;
        -:  639:    }
       21:  640:}
        -:  641:
        -:  642:pthread_mutex_t _global_logger_mutex__ = PTHREAD_MUTEX_INITIALIZER;
        -:  643:Log _global_logger__;
        -:  644:bool _global_logger_is_init__ = false;
        -:  645:
        7:  646:int _global_logger(bool is_plain, bool is_all, LogLevel level, LogLevel global, char* line, ...)
        -:  647:{
        7:  648:    int ret = 0;
        7:  649:    pthread_mutex_lock(&_global_logger_mutex__);
        -:  650:
        7:  651:    if (!_global_logger_is_init__) {
        1:  652:        ret = logger(&_global_logger__, 0);
        1:  653:        if (ret == 0)
        1:  654:            ret = log_init(&_global_logger__);
        1:  655:        if (ret == 0)
        1:  656:            _global_logger_is_init__ = true;
        -:  657:    }
        -:  658:
        7:  659:    if (ret == 0) {
        7:  660:        log_set_level(&_global_logger__, global);
        -:  661:
        -:  662:        va_list args;
        7:  663:        va_start(args, line);
        7:  664:        ret = do_log(&_global_logger__, level, line, is_plain, is_all, args);
        7:  665:        va_end(args);
        -:  666:    }
        -:  667:
        7:  668:    pthread_mutex_unlock(&_global_logger_mutex__);
        7:  669:    return ret;
        -:  670:}
        -:  671:
        3:  672:int init_global_logger(int num, ...)
        -:  673:{
        3:  674:    if (_global_logger_is_init__)
        1:  675:        return -1;
        2:  676:    int ret = 0;
        2:  677:    pthread_mutex_lock(&_global_logger_mutex__);
        -:  678:
        -:  679:    va_list valist;
        2:  680:    va_start(valist, num);
        2:  681:    ret = do_logger(&_global_logger__, num, valist);
        2:  682:    va_end(valist);
        -:  683:
        2:  684:    if (ret == 0)
        2:  685:        ret = log_init(&_global_logger__);
        2:  686:    if (ret == 0)
        2:  687:        _global_logger_is_init__ = true;
        -:  688:
        2:  689:    pthread_mutex_unlock(&_global_logger_mutex__);
        2:  690:    return ret;
        -:  691:}
        -:  692:
        1:  693:int global_log_rotate()
        -:  694:{
        1:  695:    pthread_mutex_lock(&_global_logger_mutex__);
        1:  696:    int ret = log_rotate(&_global_logger__);
        1:  697:    pthread_mutex_unlock(&_global_logger_mutex__);
        1:  698:    return ret;
        -:  699:}
        -:  700:
        1:  701:bool global_log_need_rotate()
        -:  702:{
        1:  703:    pthread_mutex_lock(&_global_logger_mutex__);
        1:  704:    bool ret = log_need_rotate(&_global_logger__);
        1:  705:    pthread_mutex_unlock(&_global_logger_mutex__);
        1:  706:    return ret;
        -:  707:}
        -:  708:
        2:  709:int global_log_config_option(LogConfigOptionImpl option)
        -:  710:{
        2:  711:    pthread_mutex_lock(&_global_logger_mutex__);
        2:  712:    int ret = log_set_config_option(&_global_logger__, option);
        2:  713:    pthread_mutex_unlock(&_global_logger_mutex__);
        2:  714:    return ret;
        -:  715:}
        -:  716:
        1:  717:void _debug_global_logger_is_init__()
        -:  718:{
        1:  719:    _global_logger_is_init__ = false;
        1:  720:}
        -:    0:Source:config.c
        -:    0:Graph:./config.gcno
        -:    0:Data:./config.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/config.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        2:   20:void configure_u32(uint32_t* value, uint32_t* configured, uint32_t d)
        -:   21:{
        2:   22:    if (configured == NULL) {
        1:   23:        *value = d;
        -:   24:    } else {
        1:   25:        *value = *configured;
        -:   26:    }
        2:   27:}
        -:   28:
        2:   29:void configure_u64(uint64_t* value, uint64_t* configured, uint64_t d)
        -:   30:{
        2:   31:    if (configured == NULL) {
        1:   32:        *value = d;
        -:   33:    } else {
        1:   34:        *value = *configured;
        -:   35:    }
        2:   36:}
        -:   37:
        2:   38:void configure_u128(__uint128_t* value, __uint128_t* configured, __uint128_t d)
        -:   39:{
        2:   40:    if (configured == NULL) {
        1:   41:        *value = d;
        -:   42:    } else {
        1:   43:        *value = *configured;
        -:   44:    }
        2:   45:}
        -:   46:
        2:   47:void configure_bool(bool* value, bool* configured, bool d)
        -:   48:{
        2:   49:    if (configured == NULL) {
        1:   50:        *value = d;
        -:   51:    } else {
        1:   52:        *value = *configured;
        -:   53:    }
        2:   54:}
        -:   55:
        2:   56:void configure_u8(uint8_t* value, uint8_t* configured, uint8_t d)
        -:   57:{
        2:   58:    if (configured == NULL) {
        1:   59:        *value = d;
        -:   60:    } else {
        1:   61:        *value = *configured;
        -:   62:    }
        2:   63:}
        -:   64:
        2:   65:void configure_u16(uint16_t* value, uint16_t* configured, uint16_t d)
        -:   66:{
        2:   67:    if (configured == NULL) {
        1:   68:        *value = d;
        -:   69:    } else {
        1:   70:        *value = *configured;
        -:   71:    }
        2:   72:}
        -:   73:
        2:   74:void configure_string(char* value, char* configured, char* d, int max_len)
        -:   75:{
        2:   76:    if (configured == NULL) {
        1:   77:        int len = max_len - 1;
        1:   78:        int strlen_value = strlen(d);
        1:   79:        if (strlen_value < len) {
        1:   80:            len = strlen_value;
        -:   81:        }
        1:   82:        memcpy(value, d, len);
        1:   83:        value[len] = 0;
        -:   84:    } else {
        1:   85:        int len = max_len - 1;
        1:   86:        int strlen_value = strlen(configured);
        1:   87:        if (strlen_value < len) {
        1:   88:            len = strlen_value;
        -:   89:        }
        1:   90:        memcpy(value, configured, len);
        1:   91:        value[len] = 0;
        -:   92:    }
        2:   93:}
        -:    0:Source:rand.c
        -:    0:Graph:./rand.gcno
        -:    0:Data:./rand.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <sys/random.h>
        -:   17:
        4:   18:int rand_i8(i8* v)
        -:   19:{
        -:   20:    char buf[1];
        4:   21:    int ret = getentropy(buf, 1);
        4:   22:    *v = (i8)buf[0];
        4:   23:    return ret;
        -:   24:}
        -:   25:
        4:   26:int rand_u8(u8* v)
        -:   27:{
        -:   28:    char buf[1];
        4:   29:    int ret = getentropy(buf, 1);
        4:   30:    *v = (u8)buf[0];
        4:   31:    return ret;
        -:   32:}
        -:   33:
        4:   34:int rand_i16(i16* v)
        -:   35:{
        -:   36:    char buf[2];
        4:   37:    int ret = getentropy(buf, 2);
        4:   38:    *v = ((i16)buf[0] << 8) + (i16)buf[1];
        4:   39:    return ret;
        -:   40:}
        -:   41:
        4:   42:int rand_u16(u16* v)
        -:   43:{
        -:   44:    char buf[2];
        4:   45:    int ret = getentropy(buf, 2);
        4:   46:    *v = ((u16)buf[0] << 8) + (u16)buf[1];
        4:   47:    return ret;
        -:   48:}
        -:   49:
        1:   50:int rand_i32(int32_t* v)
        -:   51:{
        -:   52:    char buf[4];
        1:   53:    int ret = getentropy(buf, 4);
        1:   54:    *v = ((int32_t)buf[0] << 24) + ((int32_t)buf[1] << 16) + ((int32_t)buf[2] << 8) + (int32_t)buf[3];
        1:   55:    return ret;
        -:   56:}
        -:   57:
        2:   58:int rand_u32(uint32_t* v)
        -:   59:{
        -:   60:    char buf[4];
        2:   61:    int ret = getentropy(buf, 4);
        2:   62:    *v = ((uint32_t)buf[0] << 24) + ((uint32_t)buf[1] << 16) + ((uint32_t)buf[2] << 8) + (uint32_t)buf[3];
        2:   63:    return ret;
        -:   64:}
        -:   65:
        1:   66:int rand_i64(int64_t* v)
        -:   67:{
        -:   68:    char buf[8];
        1:   69:    int ret = getentropy(buf, 8);
        1:   70:    *v = ((int64_t)buf[0] << 56) + ((int64_t)buf[1] << 48) + ((int64_t)buf[2] << 40) + ((int64_t)buf[3] << 32) + ((int64_t)buf[4] << 24) + ((int64_t)buf[5] << 16) + ((int64_t)buf[6] << 8) + (int64_t)buf[7];
        1:   71:    return ret;
        -:   72:}
        -:   73:
       10:   74:int rand_u64(uint64_t* v)
        -:   75:{
        -:   76:    char buf[8];
       10:   77:    int ret = getentropy(buf, 8);
       10:   78:    *v = ((uint64_t)buf[0] << 56) + ((uint64_t)buf[1] << 48) + ((uint64_t)buf[2] << 40) + ((uint64_t)buf[3] << 32) + ((uint64_t)buf[4] << 24) + ((uint64_t)buf[5] << 16) + ((uint64_t)buf[6] << 8) + (uint64_t)buf[7];
       10:   79:    return ret;
        -:   80:}
        -:   81:
        1:   82:int rand_i128(i128* v)
        -:   83:{
        -:   84:    char buf[16];
        1:   85:    int ret = getentropy(buf, 16);
        1:   86:    *v = ((i128)buf[0] << 120) + ((i128)buf[1] << 112) + ((i128)buf[2] << 104) + ((i128)buf[3] << 96) + ((i128)buf[4] << 88) + ((i128)buf[5] << 80) + ((i128)buf[6] << 72) + ((i128)buf[7] << 64) + ((i128)buf[8] << 56) + ((i128)buf[9] << 48) + ((i128)buf[10] << 40) + ((i128)buf[11] << 32) + ((i128)buf[12] << 24) + ((i128)buf[13] << 16) + ((i128)buf[14] << 8) + (i128)buf[15];
        1:   87:    return ret;
        -:   88:}
        -:   89:
        1:   90:int rand_u128(u128* v)
        -:   91:{
        -:   92:    char buf[16];
        1:   93:    int ret = getentropy(buf, 16);
        1:   94:    *v = ((u128)buf[0] << 120) + ((u128)buf[1] << 112) + ((u128)buf[2] << 104) + ((u128)buf[3] << 96) + ((u128)buf[4] << 88) + ((u128)buf[5] << 80) + ((u128)buf[6] << 72) + ((u128)buf[7] << 64) + ((u128)buf[8] << 56) + ((u128)buf[9] << 48) + ((u128)buf[10] << 40) + ((u128)buf[11] << 32) + ((u128)buf[12] << 24) + ((u128)buf[13] << 16) + ((u128)buf[14] << 8) + (u128)buf[15];
        1:   95:    return ret;
        -:   96:}
        -:   97:
        2:   98:int rand_bytes(void* buf, size_t length)
        -:   99:{
        2:  100:    return getentropy(buf, length);
        -:  101:}
        -:    0:Source:main.c
        -:    0:Graph:./main.gcno
        -:    0:Data:./main.gcda
        -:    0:Runs:1
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdio.h>
        -:   16:#include <log/log.h>
        -:   17:#include <util/misc.h>
        -:   18:
        -:   19:#define LOG_LEVEL Info
        -:   20:
        1:   21:int real_main(int argc, char** argv)
        -:   22:{
        1:   23:    LogConfigOption opt1, opt2, opt3;
        1:   24:    log_config_option_show_colors(&opt1, true);
        1:   25:    log_config_option_show_stdout(&opt2, true);
        1:   26:    log_config_option_show_timestamp(&opt3, false);
        -:   27:
        1:   28:    init_global_logger(2, opt1, opt2);
        1:   29:    info("Main currently doesn't do %s.", "anything");
        1:   30:    global_log_config_option(opt3);
        1:   31:    info("Main currently doesn't do %s.", "anything");
        1:   32:    info("end");
        -:   33:
        1:   34:    return 0;
        -:   35:}
        -:   36:
        1:   37:int main(int argc, char **argv) {
        1:   38:    return real_main(argc, argv);
        -:   39:}
        -:   40:
        -:    0:Source:misc.c
        -:    0:Graph:./misc.gcno
        -:    0:Data:./misc.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:#include <util/misc.h>
        -:   17:#include <log/log.h>
        -:   18:
        -:   19:#define LOG_LEVEL Debug
        -:   20:
    #####:   21:bool is_white_space(char ch)
        -:   22:{
    #####:   23:    debug("is whitespace '%c'", ch);
    #####:   24:    if (ch == '\n' || ch == '\t' || ch == '\r' || ch == '\v' || ch == '\f' || ch == ' ')
    #####:   25:        return true;
        -:   26:    else
    #####:   27:        return false;
        -:   28:}
        -:   29:
    #####:   30:bool is_ident_start(char ch)
        -:   31:{
    #####:   32:    if ((ch <= 'Z' && ch >= 'A') || (ch <= 'z' && ch >= 'a') || ch == '_') {
    #####:   33:        return true;
        -:   34:    } else {
    #####:   35:        return false;
        -:   36:    }
        -:   37:}
        -:   38:
    #####:   39:bool is_ident_secondary(char ch)
        -:   40:{
    #####:   41:    if (is_ident_start(ch) || (ch <= '9' && ch >= '0')) {
    #####:   42:        return true;
        -:   43:    } else {
    #####:   44:        return false;
        -:   45:    }
        -:   46:}
        -:   47:
    #####:   48:bool is_joint_possible(char ch)
        -:   49:{
    #####:   50:    if (ch == '.' || ch == '=' || ch == '/' || ch == '+' || ch == '&' || ch == '<' || ch == '-' || ch == '%' || ch == '^' || ch == '*' || ch == '>' || ch == '|' || ch == '!' || ch == ':') {
    #####:   51:        return true;
        -:   52:    } else {
    #####:   53:        return false;
        -:   54:    }
        -:   55:}
        -:    0:Source:slabs.c
        -:    0:Graph:./slabs.gcno
        -:    0:Data:./slabs.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <string.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <util/slabs.h>
        -:   18:#include <log/log.h>
        -:   19:
        -:   20:#define LOG_LEVEL Debug
        -:   21:
        1:   22:int slab_data_init(SlabData *sd, u64 len) {
        1:   23:	sd->data = NULL;
        1:   24:	return slab_data_resize(sd, len);
        -:   25:}
        -:   26:
    #####:   27:void *slab_data_read(SlabData *sd, u64 offset) {
    #####:   28:	if(offset > sd->len)
    #####:   29:		return NULL;
    #####:   30:	return sd->data + offset;
        -:   31:}
        -:   32:
    #####:   33:int slab_data_write(SlabData *sd, u64 dst_offset, void *value, u64 src_offset, u64 len) {
    #####:   34:        int ret = 0;
    #####:   35:	memcpy(sd->data + dst_offset, value + src_offset, len);
    #####:   36:        return ret;
        -:   37:}
        -:   38:
        1:   39:int slab_data_resize(SlabData *sd, u64 len) {
        1:   40:	int ret = 0;
        -:   41:
        1:   42:	if (sd->data == NULL) {
        1:   43:		sd->data = malloc(len);
        1:   44:		if(sd->data == NULL) {
    #####:   45:			error("Could not allocate the required memory.");
    #####:   46:			ret = -1;
        -:   47:		}
        -:   48:	} else {
    #####:   49:		void *tmp = realloc(sd->data, len);
    #####:   50:		if(tmp == NULL) {
    #####:   51:			error("Could not allocate the required memory.");
    #####:   52:			ret = -1;
        -:   53:		} else {
    #####:   54:			sd->data = tmp;
        -:   55:		}
        -:   56:	}
        -:   57:
        1:   58:	return ret;
        -:   59:}
        -:   60:
    #####:   61:void slab_data_free(SlabData *sd) {
    #####:   62:	if(sd->data) {
    #####:   63:		free(sd->data);
    #####:   64:		sd->data = NULL;
        -:   65:	}
    #####:   66:}
        -:   67:
    #####:   68:int init_free_list(
        -:   69:		SlabData *slab_data,
        -:   70:		u64 size,
        -:   71:		u64 offset
        -:   72:		) {
    #####:   73:	return 0;
        -:   74:}
        -:   75:
        -:   76:
        -:   77:
    #####:   78:int slab_init(SlabAllocator *sa, int num, u64 *sizes, u64 *max_slabs, u64 slabs_per_resize, bool zeroed) {
        -:   79:	// check that ordering is sorted and other configs are ok
    #####:   80:	u64 last_size = 0;
    #####:   81:	for(int i=0; i<num; i++) {
    #####:   82:		if(sizes[i] <= last_size) {
    #####:   83:			error("slab_allocator sizes must be sorted in ascending order.");
    #####:   84:			return -1;
        -:   85:		}
    #####:   86:		last_size = sizes[i];
    #####:   87:		if(max_slabs[i] == 0) {
    #####:   88:			error("max_slabs must be greater than 0");
    #####:   89:			return -1;
        -:   90:		}
        -:   91:	}
        -:   92:
    #####:   93:	if(slabs_per_resize == 0) {
    #####:   94:		error("slabs_per_resize must be greater than 0");
    #####:   95:		return -1;
        -:   96:	}
        -:   97:
    #####:   98:	int ret = 0;
    #####:   99:	sa->slab_data_array = NULL;
    #####:  100:	sa->sizes = NULL;
    #####:  101:	sa->max_slabs = NULL;
    #####:  102:	sa->zeroed = zeroed;
    #####:  103:	sa->slabs_per_resize = slabs_per_resize;
    #####:  104:	sa->slab_data_array = malloc(sizeof(SlabData) * num);
    #####:  105:	if(sa->slab_data_array == NULL) {
    #####:  106:		ret = -1;
    #####:  107:		error("Could not allocate the required memory.");
        -:  108:	}
        -:  109:	
    #####:  110:	if(ret == 0) {
    #####:  111:		sa->sizes = malloc(sizeof(u64) * num);
        -:  112:
    #####:  113:		if(sa->sizes == NULL) {
    #####:  114:			free(sa->slab_data_array);
    #####:  115:			sa->slab_data_array = NULL;
    #####:  116:			ret = -1;
    #####:  117:			error("Could not allocate the required memory.");
        -:  118:		} else {
    #####:  119:			sa->slab_data_array_len = num;
    #####:  120:			memcpy(sa->sizes, sizes, num);
        -:  121:
    #####:  122:			for(int i=0; i<num; i++) {
    #####:  123:				if(slab_data_init(
    #####:  124:					&sa->slab_data_array[i],
    #####:  125:					slabs_per_resize * sizes[i]
        -:  126:				)) {
    #####:  127:					ret = -1;
    #####:  128:					break;
        -:  129:				}
        -:  130:			}
        -:  131:		}
        -:  132:
        -:  133:	}
        -:  134:
    #####:  135:	if(ret == 0) {
    #####:  136:		sa->max_slabs = malloc(sizeof(u64) * num);
    #####:  137:		if(sa->max_slabs == NULL) {
    #####:  138:			free(sa->slab_data_array);
    #####:  139:                        sa->slab_data_array = NULL;
    #####:  140:			free(sa->sizes);
    #####:  141:			sa->sizes = NULL;
    #####:  142:			error("Could not allocate required memory.");
    #####:  143:			ret = -1;
        -:  144:		} else {
    #####:  145:			memcpy(sa->max_slabs, max_slabs, num);
        -:  146:		}
        -:  147:	}
        -:  148:
    #####:  149:	return ret;
        -:  150:}
        -:  151:</textarea>
		</p>
	</body>
</html>

