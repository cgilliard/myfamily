<!DOCTYPE html>
<html>
	<head>
		<title>Code Coverage Report</title>
		<script src="chart.js"></script>
		<style>
			.chart {
				width: 900px;
			}
			.textarea {
				overflow:auto;
				resize:none;
			}
		</style>
	</head>
	<body>
		 <p align="center">
                        Code Coverage is currently 84.76%.
                </p>
		<center>
			<div class="chart">
				<canvas id="chart"></canvas>
			</div>
		</center>
		<script>
			function format_date(timestamp, time_frame) {
				var date = new Date(timestamp);
				var day_of_month = date.getDate();
				var full_year = date.getFullYear();
				var month = 1 + date.getMonth();
				var hours = date.getHours();
				var minutes = date.getMinutes();
				var seconds = date.getSeconds();
				var am_pm = 'AM';

				if(seconds < 10) {
					seconds = '0' + seconds;
				}
				if(minutes < 10) {
					minutes = '0' + minutes;
				}
				if(hours == 12) {
					am_pm = 'PM';
				} else if(hours > 12) {
					hours -= 12;
					am_pm = 'PM';
				}
				if(hours == 0) {
					hours = 12;
				}

				return month + '/' + day_of_month + '/' + full_year + ' ' +
					hours + ':' + minutes + ':' + seconds + ' ' + am_pm;
			}

			let raw_data = [86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
0.00,
0.00,
0.00,
85.57,
85.57,
86.81,
84.76,];
			let labels = [format_date(1716876818 * 1000 ),
format_date(1716876822 * 1000 ),
format_date(1716904488 * 1000 ),
format_date(1716905952 * 1000 ),
format_date(1716905990 * 1000 ),
format_date(1716906171 * 1000 ),
format_date(1716906235 * 1000 ),
format_date(1716906333 * 1000 ),
format_date(1716906629 * 1000 ),
format_date(1716906787 * 1000 ),
format_date(1716907183 * 1000 ),
format_date(1716907441 * 1000 ),
format_date(1716907910 * 1000 ),
format_date(1716908379 * 1000 ),
format_date(1716909018 * 1000 ),
format_date(1716909696 * 1000 ),
format_date(1716920268 * 1000 ),];

			const data = {
				labels: labels,
				datasets: [{
					label: 'Code Coverage',
					backgroundColor: 'rgb(31,176,245)',
					borderColor: 'rgb(31,176,245)',
					data: raw_data,
				}]
			};

			const config = {
				type: 'line',
				data: data,
				options: {}
			};

			const chart = new Chart(
				document.getElementById('chart'),
				config
			);

		</script>

		<p align="center">
			Raw gcov output:<br/>
			<textarea readonly class="textarea" rows="50" cols="100">        -:    0:Source:parser.c
        -:    0:Graph:./parser.gcno
        -:    0:Data:./parser.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <errno.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <stdio.h>
        -:   18:#include <string.h>
        -:   19:#include <unistd.h>
        -:   20:#include <parser/parser.h>
        -:   21:#include <util/constants.h>
        -:   22:#include <util/misc.h>
        -:   23:
       11:   24:int parse(char *file_name, TokenStream *strm, int debug_flags) {
       11:   25:	FILE *file = fopen(file_name, "r");
       11:   26:	if (file == NULL) {
        1:   27:		fputs("File not found\n", stderr);
        1:   28:		return -1;
        -:   29:	}
       10:   30:    	long long file_size = 0; // File size to zero before byte check
       10:   31:       	fseek(file, 0L, SEEK_END); // seek to end
       10:   32:       	file_size = ftell(file); // find size of file by checking end
       10:   33:       	rewind(file); // back to the beginning for reading
        -:   34:    	char buffer[16]; // We will read the file 16 bytes at a time
       10:   35:    	strm->bytes = malloc(file_size);
        -:   36:
       10:   37:	if(strm->bytes == NULL || (debug_flags & DEBUG_FLAG_OOM) != 0) {
        1:   38:		fputs("Could not allocate enough memory\n", stderr);
        1:   39:		fclose(file);
        1:   40:		return -1;
        -:   41:    	}
        -:   42:
        9:   43:	int ret = fread(strm->bytes, file_size, 1, file);
        9:   44:	strm->len = file_size;
        9:   45:	fclose(file);
        9:   46:	strm->pos = 0;
        9:   47:	strm->line_num = 1;
        9:   48:	strm->start_doc = -1;
        9:   49:	strm->end_doc = -1;
        9:   50:	strm->file_path = malloc(sizeof(char)*(strlen(file_name)+1));
        9:   51:	strcpy(strm->file_path, file_name);
        9:   52:	strm->parent = NULL;
        9:   53:	strm->pos_offset = 0;
        -:   54:
        9:   55:	return 0;
        -:   56:}
        -:   57:
        5:   58:void display_span(Span *span, ErrorLevel level, char *message) {
        5:   59:	TokenStream *file_stream = span->strm;
        5:   60:        int start = span->offset;
        5:   61:        int end = span->offset;
        -:   62:
        6:   63:	while(file_stream->parent != NULL)
        1:   64:		file_stream = file_stream->parent;
        7:   65:	while(start != 0 &&  file_stream->bytes[start-1] != '\n')
        2:   66:		start -= 1;
       32:   67:	while(end < file_stream->len && file_stream->bytes[end] != '\n')
       27:   68:		end += 1;
        -:   69:
        5:   70:	int span_len = end - start;
        5:   71:	char display_str[span_len+1];
        5:   72:	memcpy(display_str, file_stream->bytes + start, span_len);
        5:   73:	display_str[span_len] = 0;
        5:   74:	int indent = 1 + (span->offset - start);
        -:   75:
        5:   76:	if(level == Error) { // ERROR
        3:   77:		printf(
        -:   78:			"\e[1m%s:%i:%i:\e[m " ANSI_COLOR_ERROR_BG "Error" ANSI_COLOR_RESET ": %s\n%s\n",
        -:   79:			file_stream->file_path,
        -:   80:			span->line_num,
        -:   81:			indent,
        -:   82:			message,
        -:   83:			display_str
        -:   84:		);
        -:   85:	} else { // WARNING
        2:   86:		printf(         
        -:   87:                        "\e[1m%s:%i:%i:\e[m " ANSI_COLOR_WARNING_BG "Warning" ANSI_COLOR_RESET ": %s\n%s\n",
        -:   88:                        file_stream->file_path,
        -:   89:                        span->line_num,
        -:   90:			indent,
        -:   91:                        message,        
        -:   92:                        display_str
        -:   93:                );
        -:   94:	}
        5:   95:	char spacing_and_up_arrow[(span->offset - start) + 2];
        5:   96:	int cur = 0;
        -:   97:
        7:   98:	for(int i=start; i<span->offset; i++) {
        2:   99:		if(file_stream->bytes[i] == '\t')
        1:  100:			spacing_and_up_arrow[cur] = '\t';
        -:  101:		else
        1:  102:			spacing_and_up_arrow[cur] = ' ';
        2:  103:		cur += 1;
        -:  104:	}
        5:  105:	spacing_and_up_arrow[cur] = '^';
        5:  106:	spacing_and_up_arrow[cur+1] = 0;
        5:  107:	printf(ANSI_COLOR_GREEN "%s\n" ANSI_COLOR_RESET, spacing_and_up_arrow);
        5:  108:}
        -:  109:
        2:  110:void process_doc(TokenStream *strm, TokenTree *next) {
        2:  111:	next->token_type = GroupType;
        2:  112:	next->group = malloc(sizeof(Group));
        2:  113:	next->group->delimiter = Bracket;
        2:  114:	next->group->strm = malloc(sizeof(TokenStream));
        2:  115:	next->group->strm->parent = strm;
        2:  116:	next->group->strm->pos_offset = strm->start_doc + strm->pos_offset;
        2:  117:	next->group->strm->file_path = NULL;
        2:  118:	next->group->strm->pos = 0;
        2:  119:	next->group->strm->line_num = strm->line_num;
        2:  120:	int group_len = (strm->end_doc - strm->start_doc) + 6;
        2:  121:	next->group->strm->bytes = malloc(sizeof(char) * group_len);
        2:  122:	next->group->strm->bytes[0] = 'd';
        2:  123:	next->group->strm->bytes[1] = 'o';
        2:  124:	next->group->strm->bytes[2] = 'c';
        2:  125:	next->group->strm->bytes[3] = '=';
        2:  126:	next->group->strm->bytes[4] = '\"';
        2:  127:	memcpy(next->group->strm->bytes + 5, strm->bytes + strm->start_doc, group_len - 6);
        2:  128:	next->group->strm->bytes[group_len-1] = '\"';
        2:  129:	next->group->strm->len = group_len;
        -:  130:
        2:  131:	next->span.line_num = strm->line_num;
        2:  132:	next->span.offset = strm->start_doc + strm->pos_offset;
        2:  133:	next->span.strm = strm;
        -:  134:
        2:  135:	strm->start_doc = -1;
        2:  136:	strm->end_doc = -1;
        2:  137:}
        -:  138:
      181:  139:int skip_comments_and_white_space(TokenStream *strm, TokenTree *next, int len) {
        -:  140:	while(TRUE) {
        -:  141:                // first loop until we're not in white space
      331:  142:                while(strm->pos < len) {
      296:  143:                        if (!is_white_space(strm->bytes[strm->pos])) {
      146:  144:                                break;
        -:  145:                        }
      150:  146:                        if(strm->bytes[strm->pos] == '\n'){
       76:  147:                                strm->line_num += 1;
        -:  148:                        }
      150:  149:                        strm->pos += 1;
        -:  150:                }
        -:  151:
        -:  152:                // next check if we're at the begining of a comment
      181:  153:                if (strm->pos < len-1 && strm->bytes[strm->pos] == '/' &&
       12:  154:                        (strm->bytes[strm->pos+1] == '/' ||
        3:  155:                         strm->bytes[strm->pos+1] == '*')) {
        -:  156:                        // we're in a comment see which kind
       11:  157:                        if(strm->bytes[strm->pos+1] == '/') {
        9:  158:                                if(strm->pos+4<len) {
        -:  159:                                        // this is a doc comment
        9:  160:                                        if(strm->bytes[strm->pos+2] == '/' && strm->bytes[strm->pos+3] == ' ') {
        2:  161:                                                strm->start_doc = strm->pos+4;
        2:  162:                                                strm->end_doc = strm->pos;
        -:  163:                                        }
        -:  164:                                }
      359:  165:                                while(strm->pos < len && strm->bytes[strm->pos] != '\n') {
      350:  166:                                        if(strm->start_doc > 0) {
       37:  167:                                                strm->end_doc += 1;
        -:  168:                                        }
      350:  169:                                        strm->pos += 1;
        -:  170:                                }
        9:  171:				if(strm->start_doc > 0) {
        2:  172:                                        next->token_type = PunctType;
        2:  173:                                        next->punct = malloc(sizeof(Punct));
        2:  174:                                        next->punct->ch = '#';
        2:  175:                                        next->punct->second_ch = 0;
        2:  176:                                        next->punct->third_ch = 0;
        2:  177:                                        next->span.strm = strm;
        2:  178:                                        next->span.line_num = strm->line_num;
        2:  179:                                        next->span.offset = strm->pos + strm->pos_offset;
        2:  180:                                        return TRUE;
        -:  181:                                }
        -:  182:                        } else {
       57:  183:                                while(strm->pos < len && (strm->bytes[strm->pos-1] != '*' || strm->bytes[strm->pos] != '/')) {
       55:  184:                                        if(strm->bytes[strm->pos] == '\n'){
        4:  185:                                                strm->line_num += 1;
        -:  186:                                        }
       55:  187:                                        strm->pos += 1;
        -:  188:                                }
        2:  189:                                strm->pos += 1;
        -:  190:                        }
        -:  191:
        -:  192:                } else {
        -:  193:                        break;
        -:  194:                }
        -:  195:	}
        -:  196:
      170:  197:	return FALSE;
        -:  198:}
        -:  199:
       35:  200:int process_group(TokenStream *strm, TokenTree *next, int ret, int len, Delimiter delimiter) {
        -:  201:	char open_ch;
        -:  202:	char close_ch;
        -:  203:
       35:  204:	if(delimiter == Parenthesis) {
       15:  205:		open_ch = '(';
       15:  206:		close_ch = ')';
       20:  207:	} else if(delimiter == Bracket) {
        5:  208:		open_ch = '[';
        5:  209:                close_ch = ']';
       15:  210:	} else if(delimiter == Brace) {
       15:  211:		open_ch = '{';
       15:  212:		close_ch = '}';
        -:  213:	}
        -:  214:
       35:  215:	strm->pos += 1;
       35:  216:	int inner_char_count = 0;
       35:  217:	int in_lit = 0;
      653:  218:	while(strm->pos < len) {
      652:  219:		if(strm->bytes[strm->pos] == close_ch && inner_char_count == 0 && !in_lit)
       34:  220:			break;
      618:  221:		if(strm->bytes[strm->pos] == open_ch && !in_lit)
       11:  222:			inner_char_count += 1;
      607:  223:		else if(strm->bytes[strm->pos] == close_ch && !in_lit)
       11:  224:			inner_char_count -= 1;
      596:  225:		else if((strm->bytes[strm->pos] == '\"' || strm->bytes[strm->pos] == '\'') && !in_lit)
        8:  226:			in_lit = 1;
      588:  227:		else if((strm->bytes[strm->pos] == '\"' || strm->bytes[strm->pos] == '\'') && in_lit)
        8:  228:			in_lit = 0;
        -:  229:
      618:  230:		if(strm->bytes[strm->pos] == '\n')
       67:  231:			strm->line_num += 1;
      618:  232:		strm->pos += 1;
        -:  233:	}
       35:  234:	if(strm->pos == len) {
        -:  235:		char msg[100];
        1:  236:		sprintf(msg, "parse error: file ended with unclosed '%c'", open_ch);
        1:  237:		display_span(&next->span, Error, msg);
        1:  238:		ret = 2;
        -:  239:	}
       35:  240:	strm->pos += 1;
        -:  241:
       35:  242:	return ret;
        -:  243:}
        -:  244:
       41:  245:int process_punct(TokenStream *strm, TokenTree *next, int len, int ret) {
       41:  246:	char ch = strm->bytes[strm->pos];
       41:  247:	if(ch == ')' || ch == ']' || ch == '}') {
        -:  248:		char err[100];
        1:  249:		next->span.line_num = strm->line_num;
        1:  250:		sprintf(err, "parse error: unexpected token, '%c'", ch);
        1:  251:		display_span(&next->span, Error, err);
        1:  252:		ret = 2;
        -:  253:	}
        -:  254:
       41:  255:	next->token_type = PunctType;
       41:  256:	next->punct = malloc(sizeof(Punct));
       41:  257:	next->punct->ch = strm->bytes[strm->pos];
       41:  258:	next->punct->second_ch = 0;
       41:  259:	next->punct->third_ch = 0;
       41:  260:	strm->pos += 1;
        -:  261:
       41:  262:	if (strm->pos < len && is_joint_possible(next->punct->ch)) {
       29:  263:		char cur = strm->bytes[strm->pos];
       29:  264:		if(next->punct->ch == '!' && cur == '=') {
        1:  265:			next->punct->second_ch = cur;
        1:  266:			strm->pos += 1;
       28:  267:		} else if(next->punct->ch == '%' && cur == '=') {
        1:  268:			next->punct->second_ch = cur;
        1:  269:			strm->pos += 1;
       27:  270:		} else if(next->punct->ch == '&' && (cur == '&' || cur == '=')) {
        1:  271:			next->punct->second_ch = cur;
        1:  272:			strm->pos += 1;
       26:  273:		} else if(next->punct->ch == '*' && cur == '=') {
        1:  274:			next->punct->second_ch = cur;
        1:  275:			strm->pos += 1;
       25:  276:		} else if(next->punct->ch == '+' && cur == '=') {
        1:  277:			next->punct->second_ch = cur;
        1:  278:			strm->pos += 1;
      24*:  279:		} else if(next->punct->ch == '-' && (cur == '=' || cur == '>')) {
        1:  280:			next->punct->second_ch = cur;
        1:  281:			strm->pos += 1;
       23:  282:		} else if(next->punct->ch == '/' && cur == '=') {
        1:  283:			next->punct->second_ch = cur;
        1:  284:			strm->pos += 1;
       22:  285:		} else if(next->punct->ch == '^' && cur == '=') {
        1:  286:			next->punct->second_ch = cur;
        1:  287:			strm->pos += 1;
      21*:  288:		} else if(next->punct->ch == '|' && (cur == '=' || cur == '|')) {
        1:  289:			next->punct->second_ch = cur;
        1:  290:			strm->pos += 1;
       20:  291:		} else if(next->punct->ch == '=' && (cur == '>' || cur == '=')) {
        1:  292:			next->punct->second_ch = cur;
        1:  293:			strm->pos += 1;
       19:  294:		} else if(next->punct->ch == ':' && cur == ':') {
        3:  295:			next->punct->second_ch = cur;
        3:  296:			strm->pos += 1;
       16:  297:		} else if(next->punct->ch == '<' && (cur == '<' || cur == '=')) {
        2:  298:			next->punct->second_ch = cur;
        2:  299:			strm->pos += 1;
        2:  300:			if(strm->pos < len && cur == '<') {
        1:  301:				cur = strm->bytes[strm->pos];
        1:  302:				if(cur == '=') {
        1:  303:					next->punct->third_ch = cur;
        1:  304:					strm->pos += 1;
        -:  305:				}
        -:  306:			}
      14*:  307:		} else if(next->punct->ch == '>' && (cur == '>' || cur == '=')) {
        1:  308:			next->punct->second_ch = cur;
        1:  309:			strm->pos += 1;
        1:  310:			if(strm->pos < len && cur == '>') {
        1:  311:				cur = strm->bytes[strm->pos];
        1:  312:				if(cur == '=') {
        1:  313:					next->punct->third_ch = cur;
        1:  314:					strm->pos += 1;
        -:  315:				}
        -:  316:			}
       13:  317:		} else if(next->punct->ch == '.' && cur == '.') {
        1:  318:			next->punct->second_ch = cur;
        1:  319:			strm->pos += 1;
        1:  320:			if(strm->pos < len) {
        1:  321:				cur = strm->bytes[strm->pos];
       1*:  322:				if(cur == '.' || cur == '=') {
        1:  323:					next->punct->third_ch = cur;
        1:  324:					strm->pos += 1;
        -:  325:				}
        -:  326:			}
        -:  327:		}
        -:  328:	}
       41:  329:	return ret;
        -:  330:}
        -:  331:
      174:  332:int next_token(TokenStream *strm, TokenTree *next) {
      174:  333:	int len = strm->len;
      174:  334:	char next_token[len+1];
      174:  335:	int itt = 0;
        -:  336:	int ret;
        -:  337:
      174:  338:	if(strm->start_doc > 0) {
        2:  339:		process_doc(strm, next);
        2:  340:		return 1;
        -:  341:	}
        -:  342:
      172:  343:	if(strm->pos >= len) {
       19:  344:                ret = 0;
        -:  345:        } else {
      153:  346:                ret = 1;
        -:  347:        }
        -:  348:
      172:  349:	if(skip_comments_and_white_space(strm, next, len))
        2:  350:		return ret;
        -:  351:
      170:  352:	next->span.line_num = strm->line_num;
      170:  353:	next->span.offset = strm->pos + strm->pos_offset;
      170:  354:	next->span.strm = strm;
        -:  355:
        -:  356:	// if we're not an ident start we must be another type
      254:  357:	if (strm->pos < len && !is_ident_start(strm->bytes[strm->pos])) {
        -:  358:		// it's either a literal, group or punct
       84:  359:		int is_literal = 0;
       84:  360:		int is_group = 0;
       84:  361:		int start_group_pos = 0;
       84:  362:		int end_group_pos = 0;
       84:  363:		Delimiter delimiter = Parenthesis;
       84:  364:		if(strm->bytes[strm->pos] == '(') {
       15:  365:			delimiter = Parenthesis;
       15:  366:			is_group = 1;
       15:  367:			start_group_pos = strm->pos + 1;
       15:  368:			ret = process_group(strm, next, ret, len, delimiter);
       15:  369:			end_group_pos = strm->pos - 1;
       69:  370:		} else if(strm->bytes[strm->pos] == '[') {
        5:  371:			delimiter = Bracket;
        5:  372:                        is_group = 1;
        5:  373:                        start_group_pos = strm->pos + 1;
        5:  374:                        ret = process_group(strm, next, ret, len, delimiter);
        5:  375:                        end_group_pos = strm->pos - 1;
       64:  376:		} else if(strm->bytes[strm->pos] == '{') {
       15:  377:			delimiter = Brace;
       15:  378:                        is_group = 1;
       15:  379:                        start_group_pos = strm->pos + 1;
       15:  380:                        ret = process_group(strm, next, ret, len, delimiter);
       15:  381:                        end_group_pos = strm->pos - 1;
       49:  382:		} else if(strm->bytes[strm->pos] == '\"') {
        5:  383:			is_literal = 1;
        5:  384:			next_token[itt] = strm->bytes[strm->pos];
        5:  385:			itt += 1;
        5:  386:			strm->pos += 1;
       43:  387:			while(strm->pos < len && strm->bytes[strm->pos] != '\"') {
       38:  388:				next_token[itt] = strm->bytes[strm->pos];
       38:  389:				strm->pos += 1;
       38:  390:				itt += 1;
        -:  391:
        -:  392:			}
        5:  393:			strm->pos += 1;
        5:  394:			next_token[itt] = '\"';
        5:  395:			itt++;
        5:  396:			next_token[itt] = 0;
       44:  397:		} else if (strm->bytes[strm->pos] >= '0' && strm->bytes[strm->pos] <= '9') {
        2:  398:			is_literal = 1;
        2:  399:			next_token[itt] = strm->bytes[strm->pos];
        2:  400:			itt += 1;
        2:  401:                        strm->pos += 1;
        2:  402:                        while(strm->pos < len &&
        5:  403:				(strm->bytes[strm->pos] >= '0' && strm->bytes[strm->pos] <= '9') ||
        2:  404:				strm->bytes[strm->pos] == '.') {
        3:  405:                                next_token[itt] = strm->bytes[strm->pos];
        3:  406:                                strm->pos += 1;
        3:  407:                                itt += 1;
        -:  408:
        -:  409:                        }
        -:  410:
        2:  411:			next_token[itt] = 0;
       42:  412:		} else if (strm->bytes[strm->pos] == '\'') {
        1:  413:			next_token[itt] = strm->bytes[strm->pos];
        1:  414:			itt += 1;
        1:  415:                        strm->pos += 1;
        5:  416:                        while(strm->pos < len && strm->bytes[strm->pos] != '\'') {
        4:  417:                                next_token[itt] = strm->bytes[strm->pos];
        4:  418:                                strm->pos += 1;
        4:  419:                                itt += 1;
        -:  420:
        -:  421:                        }
        1:  422:			strm->pos += 1;
        1:  423:                        next_token[itt] = '\'';
        1:  424:                        itt++;
        1:  425:			next_token[itt] = 0;
        1:  426:			is_literal = 1;
        -:  427:		}
        -:  428:
       84:  429:		if(is_group) {
       35:  430:			next->token_type = GroupType;
       35:  431:			next->group = malloc(sizeof(Group));
       35:  432:			next->group->delimiter = delimiter;
       35:  433:			next->group->strm = malloc(sizeof(TokenStream));
       35:  434:			next->group->strm->parent = strm;
       35:  435:			next->group->strm->pos_offset = start_group_pos + strm->pos_offset;
       35:  436:			next->group->strm->file_path = NULL;
       35:  437:			next->group->strm->line_num = strm->line_num;
       35:  438:			next->group->strm->pos = 0;
       35:  439:			int group_len = end_group_pos - start_group_pos;
       35:  440:			next->group->strm->bytes = malloc(sizeof(char) * group_len);
       35:  441:			memcpy(next->group->strm->bytes, strm->bytes + start_group_pos, group_len);
       35:  442:			next->group->strm->len = group_len;
        -:  443:
       49:  444:		} else if(is_literal) {
        8:  445:			next->token_type = LiteralType;
        8:  446:			next->literal = malloc(sizeof(Literal));
        8:  447:			next->literal->literal = malloc(sizeof(char) * itt);
        8:  448:			strcpy(next->literal->literal, next_token);
        -:  449:		} else {
        -:  450:			// punct
       41:  451:			ret = process_punct(strm, next, len, ret);
        -:  452:		}
        -:  453:	} else {
        -:  454:		// ident start
      264:  455:		while(strm->pos < len) {
      223:  456:			next_token[itt] = strm->bytes[strm->pos];
        -:  457:
      223:  458:			if (!is_ident_secondary(strm->bytes[strm->pos])) {
       45:  459:                        	break;
        -:  460:                	}
        -:  461:
      178:  462:			strm->pos += 1;
      178:  463:			itt += 1;
        -:  464:		}
        -:  465:
       86:  466:		if(itt == 0) {
       35:  467:			ret = 0;
        -:  468:		}
        -:  469:
       86:  470:		next_token[itt] = 0;
       86:  471:		next->token_type = IdentType;
       86:  472:		next->ident = malloc(sizeof(Ident));
       86:  473:		next->ident->value = malloc(sizeof(char) * itt);
       86:  474:		strcpy(next->ident->value, next_token);
        -:  475:	}
        -:  476:
      170:  477:	return ret;
        -:  478:}
        -:  479:
        9:  480:void free_token_stream(TokenStream *strm) {
        9:  481:	free(strm->bytes);
        9:  482:	if(strm->file_path != NULL)
        9:  483:		free(strm->file_path);
        9:  484:}
        -:  485:
      140:  486:void free_token_tree(TokenTree *tree) {
      140:  487:	if(tree->token_type == IdentType) {
       55:  488:		free(tree->ident->value);
       55:  489:		free(tree->ident);
       85:  490:	} else if(tree->token_type == PunctType) {
       42:  491:		free(tree->punct);
       43:  492:	} else if(tree->token_type == LiteralType) {
        7:  493:		free(tree->literal->literal);
        7:  494:		free(tree->literal);
       36:  495:	} else if(tree->token_type == GroupType) {
       36:  496:		free(tree->group->strm);
       36:  497:		free(tree->group);
        -:  498:	}
      140:  499:}
        -:  500:
        -:    0:Source:expr.c
        -:    0:Graph:./expr.gcno
        -:    0:Data:./expr.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <syn/expr.h>
        -:   16:
    #####:   17:int expr_placeholder() {
    #####:   18:        return 0;
        -:   19:}
        -:    0:Source:file.c
        -:    0:Graph:./file.gcno
        -:    0:Data:./file.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <syn/file.h>
        -:   16:
    #####:   17:int file_placeholder() {
    #####:   18:        return 0;
        -:   19:}
        -:    0:Source:item.c
        -:    0:Graph:./item.gcno
        -:    0:Data:./item.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <syn/item.h>
        -:   16:
    #####:   17:int item_placeholder() {
    #####:   18:	return 0;
        -:   19:}
        -:    0:Source:syn.c
        -:    0:Graph:./syn.gcno
        -:    0:Data:./syn.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <syn/syn.h>
        -:   19:#include <parser/parser.h>
        -:   20:#include <util/constants.h>
        -:   21:
       42:   22:int process_syn_ident(StateMachine *sm, Ident *ident, int debug_flags) {
       42:   23:	if(sm->state == StateExpectClassName) {
        6:   24:		if(sm->class_count == 0) {
        1:   25:			sm->class_array = malloc(sizeof(Class));
        1:   26:			sm->class_array[sm->class_count].fn_count = 0;
        1:   27:			sm->class_count += 1;
        -:   28:		} else {
        5:   29:			sm->class_count += 1;
        5:   30:			sm->class_array = realloc(sm->class_array, sm->class_count * sizeof(Class));
        5:   31:			sm->class_array[sm->class_count-1].fn_count = 0;
        -:   32:		}	
        6:   33:		if(sm->class_array == NULL) {
    #####:   34:                        fputs("Error: could not allocate memory in process_syn_ident\n", stderr);
    #####:   35:                	return -1;
        -:   36:                }
        6:   37:		int ident_len = strlen(ident->value);
        6:   38:		printf("copy classname: %s\n", ident->value);
        6:   39:		sm->class_array[sm->class_count-1].name = malloc(sizeof(char) * (ident_len + 1)); 
        6:   40:		sm->class_array[sm->class_count-1].impl_name = NULL;
        6:   41:		strcpy(sm->class_array[sm->class_count-1].name, ident->value);
        6:   42:		sm->state = StateAfterClassName;
       36:   43:	} else if(sm->state == StateExpectImplName) {
        2:   44:		printf("ident->value='%s'\n", ident->value);
        2:   45:		sm->class_array[sm->class_count-1].impl_name = malloc(sizeof(char) * (strlen(ident->value)+ 1));
        2:   46:		strcpy(sm->class_array[sm->class_count-1].impl_name, ident->value);
        2:   47:		sm->state = StateExpectClassBrace;
       34:   48:	} else if(sm->state == StateExpectReturnTypeOrAttribute) {
        7:   49:		printf("got a return type: %s\n", ident->value);
        7:   50:		sm->state = StateExpectFnName;
        -:   51:
        7:   52:		if(sm->class_array[sm->class_count-1].fn_count == 0) {
        6:   53:			sm->class_array[sm->class_count-1].fn_array = malloc(sizeof(Fn));
        6:   54:			sm->class_array[sm->class_count-1].fn_count += 1;
        -:   55:		} else {
        1:   56:			sm->class_array[sm->class_count-1].fn_count += 1;
        1:   57:			sm->class_array[sm->class_count-1].fn_array = realloc(
        1:   58:				sm->class_array[sm->class_count-1].fn_array,
        1:   59:				sm->class_array[sm->class_count-1].fn_count * sizeof(Fn)
        -:   60:			);
        -:   61:		}
        7:   62:		int cur = (sm->class_array[sm->class_count-1].fn_count) - 1;
        7:   63:		printf("cur fn = %i\n", cur);
        7:   64:		sm->class_array[sm->class_count-1].fn_array[cur].name = malloc(sizeof(char) * (strlen(ident->value) + 1));
        7:   65:		strcpy(sm->class_array[sm->class_count-1].fn_array[cur].name, ident->value);
       27:   66:	} else if(sm->state == StateExpectFnName) {
        7:   67:		printf("got a fn name: %s\n", ident->value);
        7:   68:		int cur = (sm->class_array[sm->class_count-1].fn_count) - 1;
        7:   69:		sm->class_array[sm->class_count-1].fn_array[cur].ret_type = malloc(sizeof(char) * (strlen(ident->value) + 1));
        7:   70:                strcpy(sm->class_array[sm->class_count-1].fn_array[cur].ret_type, ident->value);
        7:   71:		sm->class_array[sm->class_count-1].fn_array[cur].is_implemented = 1;
        7:   72:		sm->state = StateExpectParameterList;
        -:   73:	} else {
        -:   74:		
        -:   75:	}
        -:   76:
       42:   77:	return 0;
        -:   78:}
        -:   79:
       18:   80:int process_syn_punct(StateMachine *sm, Punct *punct, int debug_flags) {
       18:   81:	if(sm->state == StateAfterClassName) {
        -:   82:		// it's an implementation block
        2:   83:		if(punct->ch == ':' && punct->second_ch == ':' && punct->third_ch == 0) {
        2:   84:			printf("impl block\n");
        2:   85:			sm->state = StateExpectImplName;
        -:   86:		} else {
        -:   87:		}
       16:   88:	} else if(sm->state == StateExpectReturnTypeOrAttribute) {
        -:   89:		// doc
        2:   90:		if(punct->ch == '#') {
        2:   91:			sm->state = StateExpectAttributeBracket;
        -:   92:		} else {
        -:   93:		}
        -:   94:
       14:   95:	} else if(sm->state == StateExpectClassName) {
        1:   96:		 if(punct->ch == '#') {
        1:   97:                        sm->state = StateExpectAttributeBracket;
        -:   98:                } else {
        -:   99:                }
       13:  100:	} else if(sm->state == StateExpectFnBlockOrSemi) {
        6:  101:		if(punct->ch == ';' && sm->scope == 1) {
        1:  102:			sm->state = StateExpectReturnTypeOrAttribute;
        1:  103:			int cur = (sm->class_array[sm->class_count-1].fn_count) - 1;
        1:  104:			sm->class_array[sm->class_count-1].fn_array[cur].is_implemented = 0;
        -:  105:		}
        -:  106:	}
       18:  107:	return 0;
        -:  108:}
        -:  109:
        4:  110:int process_syn_literal(StateMachine *sm, Literal *literal, int debug_flags) {
        4:  111:	return 0;
        -:  112:}
        -:  113:
       30:  114:int process_syn_begin_group(StateMachine *sm, Delimiter delimiter, int debug_flags) {
       30:  115:	if(delimiter == Brace) {
       14:  116:		sm->scope += 1;
        -:  117:	}
       30:  118:	if(sm->state == StateAfterClassName || sm->state == StateExpectClassBrace) {
        6:  119:		if(delimiter == Brace) {
        6:  120:			sm->state = StateExpectReturnTypeOrAttribute;
        -:  121:		} else {
        -:  122:		}
       24:  123:	} else if(sm->state == StateExpectAttributeBracket) {
        3:  124:		if(delimiter == Bracket) {
        3:  125:			sm->state = StateInAttribute;
        -:  126:		} else {
        -:  127:		}
       21:  128:	} else if(sm->state == StateExpectParameterList) {
        9:  129:		sm->in_param_list = TRUE;
        -:  130:
        -:  131:	} else {
        -:  132:	}
       30:  133:	return 0;
        -:  134:}
        -:  135:
       30:  136:int process_syn_end_group(StateMachine *sm, Delimiter delimiter, int debug_flags) {
       30:  137:	if(delimiter == Brace) {
       14:  138:		sm->state = StateExpectClassName;
       14:  139:		sm->scope -= 1;
       14:  140:		printf("end scope. Scope is now %i\n", sm->scope);
       14:  141:		if(sm->scope < 0) {
        -:  142:			// err
       14:  143:		} else if(sm->scope == 1) {
        6:  144:			sm->state = StateExpectReturnTypeOrAttribute;
        -:  145:		}
       16:  146:	} else if(delimiter == Bracket) {
        5:  147:		printf("got end bracket scope = %i, in_param_list = %i\n", sm->scope, sm->in_param_list);
        5:  148:		if(sm->scope == 0) {
        1:  149:			sm->state = StateExpectClassName;
        4:  150:		} else if(sm->scope == 1 && !sm->in_param_list) {
        2:  151:			printf("expect ret or attr\n");
        2:  152:			sm->state = StateExpectReturnTypeOrAttribute;
        -:  153:		}
       11:  154:	} else if(delimiter == Parenthesis) {
       11:  155:		if(sm->scope == 1) {
        8:  156:                	sm->in_param_list = FALSE;
        -:  157:                }
       11:  158:		if(sm->state == StateExpectParameterList) {
        7:  159:			sm->state = StateExpectFnBlockOrSemi;
        -:  160:		}
        -:  161:	}
       30:  162:	return 0;
        -:  163:}
        -:  164:
       94:  165:int process_token_tree(StateMachine *sm, TokenTree *tree, int debug_flags) {
       94:  166:	if(tree->token_type == IdentType) {
       42:  167:		if((debug_flags & DEBUG_FLAG_PRINT_TOKENS) != 0)
    #####:  168:			printf("ident[%s]\n", tree->ident->value);
       42:  169:		process_syn_ident(sm, tree->ident, debug_flags);
       52:  170:	} else if(tree->token_type == PunctType) {
        -:  171:		char punct[4];
       18:  172:		punct[0] = tree->punct->ch;
       18:  173:		if(tree->punct->second_ch != 0) {
        3:  174:			punct[1] = tree->punct->second_ch;
        3:  175:			if(tree->punct->third_ch != 0) {
    #####:  176:				punct[2] = tree->punct->third_ch;
    #####:  177:				punct[3] = 0;
        -:  178:			} else {
        3:  179:				punct[2] = 0;
        -:  180:			}
        -:  181:		} else {
       15:  182:			punct[1] = 0;
        -:  183:		}
       18:  184:		if((debug_flags & DEBUG_FLAG_PRINT_TOKENS) != 0)
    #####:  185:			printf("punct[%s]\n", punct);
       18:  186:		if(process_syn_punct(sm, tree->punct, debug_flags)) {
    #####:  187:			return -1;
        -:  188:		}
       34:  189:	} else if(tree->token_type == LiteralType) {
        4:  190:		if((debug_flags & DEBUG_FLAG_PRINT_TOKENS) != 0)
    #####:  191:			printf("literal[%s]\n", tree->literal->literal);
        4:  192:		process_syn_literal(sm, tree->literal, debug_flags);
        -:  193:	} else { // GroupType
        -:  194:		TokenTree group_tree;
        -:  195:		int v;
       30:  196:		int err = 0;
       30:  197:		if((debug_flags & DEBUG_FLAG_PRINT_TOKENS) != 0)
    #####:  198:			printf("group[%u]\n", tree->group->delimiter);
       30:  199:		process_syn_begin_group(sm, tree->group->delimiter, debug_flags);
        -:  200:		while(TRUE) {
      106:  201:			v = next_token(tree->group->strm, &group_tree);
      106:  202:			if(v == 0)
       30:  203:				break;
       76:  204:			else if(v == 2) {
    #####:  205:				err = 1;
    #####:  206:				fputs("parse error! Cannot continue!\n", stderr);
    #####:  207:				break;
        -:  208:			}
        -:  209:
       76:  210:			process_token_tree(sm, &group_tree, debug_flags);
        -:  211:
       76:  212:			free_token_tree(&group_tree);
        -:  213:		}
       30:  214:		if(err) {
    #####:  215:			return -1;
        -:  216:		}
       30:  217:		if((debug_flags & DEBUG_FLAG_PRINT_TOKENS) != 0)
    #####:  218:			printf("end group[%u]\n", tree->group->delimiter);
       30:  219:		process_syn_end_group(sm, tree->group->delimiter, debug_flags);
        -:  220:	}
       94:  221:	return 0;
        -:  222:}
        -:  223:
        1:  224:int build_state(char *file, StateMachine *sm, int debug_flags) {
        1:  225:	sm->state = StateExpectClassName;
        1:  226:	sm->class_array = NULL;
        1:  227:	sm->class_count = 0;
        1:  228:	sm->scope = 0;
        1:  229:	sm->in_param_list = FALSE;
        -:  230:
        1:  231:	if(parse(file, &sm->strm, debug_flags) != 0) {
    #####:  232:		fputs("Error parsing file\n", stderr);
    #####:  233:		return -1;
        -:  234:	}
        -:  235:
        -:  236:	TokenTree tree;
        -:  237:	int v;
        -:  238:	while(TRUE) {
       19:  239:		v = next_token(&sm->strm, &tree);
       19:  240:		if(v == 0)
        1:  241:			break;
       18:  242:		else if(v == 2) {
    #####:  243:			fputs("parse error! Cannot continue!\n", stderr);
    #####:  244:			break;
        -:  245:		}
        -:  246:
       18:  247:		if(process_token_tree(sm, &tree, debug_flags) != 0) {
    #####:  248:			break;
        -:  249:		}
        -:  250:
       18:  251:		free_token_tree(&tree);
        -:  252:	}
        -:  253:
        1:  254:	free_token_stream(&sm->strm);
        -:  255:
        -:  256:
        1:  257:	return 0;
        -:  258:}
        -:    0:Source:type.c
        -:    0:Graph:./type.gcno
        -:    0:Data:./type.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <syn/type.h>
        -:   19:
        -:   20:int copy_type(Type *dst, Type *src);
        -:   21:
        1:   22:int copy_array_type_info(ArrayTypeInfo *dst, ArrayTypeInfo *src) {
        1:   23:	if(src != NULL) {
        1:   24:		dst->len = src->len;
        1:   25:		dst->type = malloc(sizeof(Type));
        1:   26:                if(dst->type == NULL)
    #####:   27:                        return -1;
        -:   28:
        1:   29:		if(copy_type(dst->type, src->type))
    #####:   30:			return -1;
        -:   31:	}
        1:   32:	return 0;
        -:   33:}
        -:   34:
        1:   35:int copy_tuple_type_info(TupleTypeInfo *dst, TupleTypeInfo *src) {
        1:   36:	if(src != NULL) {
        1:   37:                dst->len = src->len;
        1:   38:                dst->type = malloc(src->len * sizeof(Type));
        1:   39:                if(dst->type == NULL)
    #####:   40:                        return -1;
        -:   41:
        4:   42:		for(int i=0; i<src->len; i++) {
        3:   43:                	if(copy_type(&dst->type[i], &src->type[i]))
    #####:   44:                        	return -1;
        -:   45:		}
        -:   46:        }
        1:   47:        return 0;
        -:   48:}
        -:   49:
        1:   50:int copy_slice_type_info(SliceTypeInfo *dst, SliceTypeInfo *src) {
        1:   51:	if(src != NULL) {
        1:   52:                dst->type = malloc(sizeof(Type));
        1:   53:                if(dst->type == NULL)
    #####:   54:                        return -1;
        -:   55:
        1:   56:                if(copy_type(dst->type, src->type))
    #####:   57:                        return -1;
        -:   58:        }
        1:   59:        return 0;
        -:   60:}
        -:   61:
       10:   62:int copy_type(Type *dst, Type *src) {
       10:   63:	if(src->array_type_info) {
    #####:   64:		dst->array_type_info = malloc(sizeof(ArrayTypeInfo));
    #####:   65:		if(copy_array_type_info(dst->array_type_info, src->array_type_info))
    #####:   66:			return -1;
        -:   67:	} else {
       10:   68:		dst->array_type_info = NULL;
        -:   69:	}
       10:   70:	if(src->slice_type_info) {
    #####:   71:		dst->slice_type_info = malloc(sizeof(SliceTypeInfo));
    #####:   72:		if(copy_slice_type_info(dst->slice_type_info, src->slice_type_info))
    #####:   73:			return -1;
        -:   74:	} else {
       10:   75:		dst->slice_type_info = NULL;
        -:   76:	}
       10:   77:	if(src->tuple_type_info) {
    #####:   78:		dst->tuple_type_info = malloc(sizeof(TupleTypeInfo));
    #####:   79:                if(copy_tuple_type_info(dst->tuple_type_info, src->tuple_type_info))
    #####:   80:			return -1;
        -:   81:        } else {
       10:   82:		dst->tuple_type_info = NULL;
        -:   83:	}
        -:   84:
       10:   85:	if(src->name != NULL) {
       10:   86:		dst->name = malloc(sizeof(char) * (strlen(src->name) + 1));
       10:   87:		if(dst->name == NULL)
    #####:   88:			return -1;
       10:   89:		strcpy(dst->name, src->name);
        -:   90:	} else {
    #####:   91:		dst->name = NULL;
        -:   92:	}
       10:   93:	dst->is_ref = src->is_ref;
       10:   94:	dst->is_mut = src->is_mut;
       10:   95:	dst->type = src->type;
       10:   96:	return 0;
        -:   97:}
        -:   98:
        6:   99:int init_type(
        -:  100:        Type *type,
        -:  101:        char *name,
        -:  102:        int is_ref,
        -:  103:        int is_mut,
        -:  104:        ArrayTypeInfo *array_type_info,
        -:  105:        TupleTypeInfo *tuple_type_info,
        -:  106:        SliceTypeInfo *slice_type_info
        -:  107:) {
        6:  108:	int non_null_count = 0;
        6:  109:	type->type = TypeRegular;
        6:  110:	if(slice_type_info) {
        1:  111:		type->type = TypeSlice;
        1:  112:		non_null_count += 1;
        -:  113:	}
        6:  114:	if(tuple_type_info) {
        1:  115:		type->type = TypeTuple;
        1:  116:		non_null_count += 1;
        -:  117:	}
        6:  118:	if(array_type_info) {
        1:  119:		type->type = TypeArray;
        1:  120:		non_null_count += 1;
        -:  121:	}
        -:  122:
        6:  123:	if(non_null_count > 1) {
    #####:  124:		fputs(
        -:  125:		"ERROR: no more than one of ArrayTypeInfo, TupleTypeInfo, SliceTypeInfo must be specified.\n",
        -:  126:		stderr
        -:  127:		);
    #####:  128:		return -1;
        -:  129:	}
        -:  130:
        6:  131:	if(name == NULL) {
        3:  132:		type->name = NULL;
        -:  133:	} else {
        3:  134:		type->name = malloc(sizeof(char) * (strlen(name) + 1));
        -:  135:	
        3:  136:		if(type->name == NULL) {
    #####:  137:			fputs("ERROR: could not allocate memory to init_type", stderr);
    #####:  138:			return -1;
        -:  139:		}
        3:  140:		strcpy(type->name, name);
        -:  141:	}
        -:  142:
        6:  143:	if(array_type_info != NULL) {
        1:  144:		type->array_type_info = malloc(sizeof(ArrayTypeInfo));
        1:  145:                if(type->array_type_info == NULL) {
    #####:  146:                        free(type->name);
    #####:  147:                        fputs("ERROR: could not allocate memory to init_type", stderr);
    #####:  148:                        return -1;
        -:  149:                }
        1:  150:		copy_array_type_info(type->array_type_info, array_type_info);
        -:  151:	}
        -:  152:	else
        5:  153:		type->array_type_info = NULL;
        6:  154:	if(tuple_type_info) {
        1:  155:		type->tuple_type_info = malloc(sizeof(TupleTypeInfo));
        1:  156:		if(type->tuple_type_info == NULL) {
    #####:  157:                        free(type->name);
    #####:  158:                        fputs("ERROR: could not allocate memory to init_type", stderr);
    #####:  159:                        return -1;
        -:  160:                }
        1:  161:		copy_tuple_type_info(type->tuple_type_info, tuple_type_info);
        -:  162:	} else {
        5:  163:		type->tuple_type_info = NULL;
        -:  164:	}
        6:  165:	if(slice_type_info) {
        1:  166:		type->slice_type_info = malloc(sizeof(SliceTypeInfo));
        1:  167:		if(type->slice_type_info == NULL) {
    #####:  168:                        free(type->name);
    #####:  169:                        fputs("ERROR: could not allocate memory to init_type", stderr);
    #####:  170:                        return -1;
        -:  171:                }
        1:  172:		copy_slice_type_info(type->slice_type_info, slice_type_info);
        -:  173:	} else {
        5:  174:		type->slice_type_info = NULL;
        -:  175:	}
        -:  176:
        6:  177:	type->is_mut = is_mut;
        6:  178:	type->is_ref = is_ref;
        -:  179:
        6:  180:	return 0;
        -:  181:}
        -:  182:
       12:  183:void free_type(Type *type) {
       12:  184:	if(type->array_type_info) {
        1:  185:		free_array_type_info(type->array_type_info);
        1:  186:		free(type->array_type_info);
        -:  187:	}
       12:  188:        if(type->tuple_type_info) {
        1:  189:		free_tuple_type_info(type->tuple_type_info);
        1:  190:		free(type->tuple_type_info);
        -:  191:	}
       12:  192:        if(type->slice_type_info) {
        1:  193:		free_slice_type_info(type->slice_type_info);
        1:  194:		free(type->slice_type_info);
        -:  195:	}
       12:  196:	free(type->name);
       12:  197:}
        -:  198:
        1:  199:int init_array_type_info(ArrayTypeInfo *arr_type, Type *type, int len) {
        1:  200:	arr_type->type = malloc(sizeof(Type));
        1:  201:	if(arr_type->type == NULL) {
    #####:  202:		fputs("ERROR: could not allocate memory to init_array_type_info", stderr);
    #####:  203:		return -1;
        -:  204:	}
        1:  205:	copy_type(arr_type->type, type);
        1:  206:	arr_type->len = len;
        1:  207:	return 0;
        -:  208:}
        -:  209:
        2:  210:void free_array_type_info(ArrayTypeInfo *arr_type) {
        2:  211:	if(arr_type->type != NULL) {
        2:  212:		free_type(arr_type->type);
        2:  213:		free(arr_type->type);
        -:  214:	}
        2:  215:}
        -:  216:
        1:  217:int init_slice_type_info(SliceTypeInfo *slice_type, Type *type) {
        1:  218:	slice_type->type = malloc(sizeof(Type));
        1:  219:	if(slice_type->type == NULL) {
    #####:  220:                fputs("ERROR: could not allocate memory to init_slice_type_info", stderr);
    #####:  221:                return -1;
        -:  222:        }
        1:  223:	copy_type(slice_type->type, type);
        1:  224:	return 0;
        -:  225:}
        2:  226:void free_slice_type_info(SliceTypeInfo *slice_type) {
        2:  227:	if(slice_type->type != NULL) {
        2:  228:                free_type(slice_type->type);
        2:  229:                free(slice_type->type);
        -:  230:        }  
        2:  231:}
        -:  232:
        1:  233:int init_tuple_type_info(TupleTypeInfo *tuple_type, Type *type, int len) {
        1:  234:	tuple_type->type = malloc(sizeof(Type) * len);
        1:  235:	if(tuple_type->type == NULL) {
    #####:  236:		fputs("ERROR: could not allocate memory to init_tuple_type_info", stderr);
    #####:  237:		return -1;
        -:  238:	}
        4:  239:	for(int i=0; i<len; i++) {
        3:  240:		copy_type(&tuple_type->type[i], &type[i]);
        -:  241:	}
        1:  242:	tuple_type->len = len;
        1:  243:        return 0;
        -:  244:}
        -:  245:
        2:  246:void free_tuple_type_info(TupleTypeInfo *tuple_type) {
        2:  247:	if(tuple_type->type != NULL) {
        2:  248:                free_type(tuple_type->type);
        2:  249:                free(tuple_type->type);
        -:  250:        }
        2:  251:}
        -:    0:Source:main.c
        -:    0:Graph:./main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <parser/parser.h>
        -:   18:
    #####:   19:int process_token(TokenStream strm, TokenTree token) {
    #####:   20:	if(token.token_type == IdentType) {
    #####:   21:		printf("ident='%s' [file_off=%i]\n",
    #####:   22:			token.ident->value, token.span.offset
        -:   23:		);
        -:   24:		//display_span(&token.span, Warning, "invalid format");
    #####:   25:	} else if(token.token_type == PunctType) {
    #####:   26:		printf("punct='%c", token.punct->ch);
    #####:   27:		if(token.punct->second_ch != 0) {
    #####:   28:			printf("%c", token.punct->second_ch);
        -:   29:		}
    #####:   30:		if(token.punct->third_ch != 0) {
    #####:   31:                        printf("%c", token.punct->third_ch);
        -:   32:                }
    #####:   33:		printf("'\n");
        -:   34:
        -:   35:		 //display_span(&token.span, Error, "bad punct");
    #####:   36:	} else if(token.token_type == LiteralType) {
    #####:   37:		printf("literal='%s'\n", token.literal->literal);
        -:   38:		//display_span(&token.span, Error, "illegal state, no literal");
    #####:   39:	} else if(token.token_type == GroupType) {
    #####:   40:		if(token.group->delimiter == Parenthesis)
    #####:   41:			printf("group delimiter = Parenthesis\n");
    #####:   42:		else if(token.group->delimiter == Bracket)
    #####:   43:			printf("group delimiter = Bracket\n");
    #####:   44:		else if(token.group->delimiter == Brace)
    #####:   45:			printf("group delimiter = Brace\n");
        -:   46:
        -:   47:		TokenTree grp_next;
        -:   48:
        -:   49:		int v;
    #####:   50:                while((v=next_token(token.group->strm, &grp_next))) {
    #####:   51:			if (v == 2) {
    #####:   52:				printf("1 error generated.\n");
    #####:   53:                                exit(-1);
        -:   54:                        }
    #####:   55:			process_token(*(token.group->strm), grp_next);
    #####:   56:                        free_token_tree(&grp_next);
        -:   57:                }
        -:   58:
    #####:   59:		free_token_stream(token.group->strm);
        -:   60:
    #####:   61:		if(token.group->delimiter == Parenthesis)
    #####:   62:                        printf("end group delimiter = Parenthesis\n");
    #####:   63:                else if(token.group->delimiter == Bracket)
    #####:   64:                        printf("end group delimiter = Bracket\n");
    #####:   65:                else if(token.group->delimiter == Brace)
    #####:   66:                        printf("end group delimiter = Brace\n");
        -:   67:	}
    #####:   68:	return 0;
        -:   69:}
        -:   70:
    #####:   71:int main(int argc, char **argv) {
    #####:   72:	if (argc < 2) {
    #####:   73:		printf("No input file specified!\n");
    #####:   74:		exit(-1);
        -:   75:	} else {
        -:   76:		TokenStream strm;
        -:   77:		TokenTree next;
    #####:   78:		if(parse(argv[1], &strm, 0)) {
    #####:   79:			printf("error parsing file!\n");
    #####:   80:			exit(-1);
        -:   81:		}
        -:   82:
        -:   83:		int v;
    #####:   84:		while((v=next_token(&strm, &next))) {
    #####:   85:			if (v == 2) {
    #####:   86:				printf("1 error generated.\n");
    #####:   87:				exit(-1);
        -:   88:			}
    #####:   89:			process_token(strm, next);
    #####:   90:			free_token_tree(&next);
        -:   91:		}
        -:   92:
    #####:   93:		free_token_stream(&strm);
        -:   94:	}
        -:   95:
    #####:   96:	return 0;
        -:   97:}
        -:   98:
        -:    0:Source:misc.c
        -:    0:Graph:./misc.gcno
        -:    0:Data:./misc.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://              
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://                      
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://                      
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <util/misc.h>
        -:   16:#include <util/constants.h>
        -:   17:
      296:   18:int is_white_space(char ch) {
      296:   19:        if (ch == '\n' || ch == '\t' || ch == '\r' || ch == '\v' || ch == '\f' || ch == ' ')
      150:   20:                return TRUE;
        -:   21:        else
      146:   22:                return FALSE;
        -:   23:}
        -:   24:
      358:   25:int is_ident_start(char ch) {
      358:   26:        if ((ch <= 'Z' && ch >= 'A') || (ch <= 'z' && ch >= 'a') || ch == '_') {
      222:   27:                return TRUE;
        -:   28:        } else {
      136:   29:                return FALSE;
        -:   30:        }
        -:   31:}
        -:   32:
      223:   33:int is_ident_secondary(char ch) {
      223:   34:        if (is_ident_start(ch) || (ch <= '9' && ch >= '0')) {
      178:   35:                return TRUE;
        -:   36:        } else {
       45:   37:                return FALSE;
        -:   38:        }
        -:   39:}
        -:   40:
       41:   41:int is_joint_possible(char ch) {
       41:   42:        if (ch == '.' || ch == '=' || ch == '/' || ch == '+' || ch == '&' || ch == '<' ||
       21:   43:                ch == '-' || ch == '%' || ch == '^' || ch == '*' || ch == '>' || ch == '|' ||
       15:   44:		ch == '!' || ch == ':') {
       29:   45:                return TRUE;
        -:   46:        } else {
       12:   47:                return FALSE;
        -:   48:        }
        -:   49:}</textarea>
		</p>
	</body>
</html>

