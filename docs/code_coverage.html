<!DOCTYPE html>
<html>
	<head>
		<title>Code Coverage Report</title>
		<script src="chart.js"></script>
		<style>
			.chart {
				width: 900px;
			}
			.textarea {
				overflow:auto;
				resize:none;
			}
		</style>
	</head>
	<body>
		 <p align="center">
                        Code Coverage is currently 78.69%.
                </p>
		<center>
			<div class="chart">
				<canvas id="chart"></canvas>
			</div>
		</center>
		<script>
			function format_date(timestamp, time_frame) {
				var date = new Date(timestamp);
				var day_of_month = date.getDate();
				var full_year = date.getFullYear();
				var month = 1 + date.getMonth();
				var hours = date.getHours();
				var minutes = date.getMinutes();
				var seconds = date.getSeconds();
				var am_pm = 'AM';

				if(seconds < 10) {
					seconds = '0' + seconds;
				}
				if(minutes < 10) {
					minutes = '0' + minutes;
				}
				if(hours == 12) {
					am_pm = 'PM';
				} else if(hours > 12) {
					hours -= 12;
					am_pm = 'PM';
				}
				if(hours == 0) {
					hours = 12;
				}

				return month + '/' + day_of_month + '/' + full_year + ' ' +
					hours + ':' + minutes + ':' + seconds + ' ' + am_pm;
			}

			let raw_data = [86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
0.00,
0.00,
0.00,
85.57,
85.57,
86.81,
84.76,
94.15,
94.15,
94.39,
96.83,
96.83,
85.76,
90.32,
87.80,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,
78.69,];
			let labels = [format_date(1716876818 * 1000 ),
format_date(1716876822 * 1000 ),
format_date(1716904488 * 1000 ),
format_date(1716905952 * 1000 ),
format_date(1716905990 * 1000 ),
format_date(1716906171 * 1000 ),
format_date(1716906235 * 1000 ),
format_date(1716906333 * 1000 ),
format_date(1716906629 * 1000 ),
format_date(1716906787 * 1000 ),
format_date(1716907183 * 1000 ),
format_date(1716907441 * 1000 ),
format_date(1716907910 * 1000 ),
format_date(1716908379 * 1000 ),
format_date(1716909018 * 1000 ),
format_date(1716909696 * 1000 ),
format_date(1716920268 * 1000 ),
format_date(1717294283 * 1000 ),
format_date(1717311812 * 1000 ),
format_date(1717380318 * 1000 ),
format_date(1717381641 * 1000 ),
format_date(1717398065 * 1000 ),
format_date(1717484462 * 1000 ),
format_date(1717570913 * 1000 ),
format_date(1717657365 * 1000 ),
format_date(1717916596 * 1000 ),
format_date(1718002919 * 1000 ),
format_date(1718089325 * 1000 ),
format_date(1718175674 * 1000 ),
format_date(1718262092 * 1000 ),
format_date(1718348461 * 1000 ),
format_date(1718434946 * 1000 ),
format_date(1718521530 * 1000 ),
format_date(1718607703 * 1000 ),
format_date(1718694097 * 1000 ),
format_date(1718780490 * 1000 ),
format_date(1718866932 * 1000 ),
format_date(1718953284 * 1000 ),
format_date(1719039762 * 1000 ),
format_date(1719126243 * 1000 ),
format_date(1719212504 * 1000 ),
format_date(1719298862 * 1000 ),
format_date(1719385279 * 1000 ),
format_date(1719471692 * 1000 ),];

			const data = {
				labels: labels,
				datasets: [{
					label: 'Code Coverage',
					backgroundColor: 'rgb(31,176,245)',
					borderColor: 'rgb(31,176,245)',
					data: raw_data,
				}]
			};

			const config = {
				type: 'line',
				data: data,
				options: {}
			};

			const chart = new Chart(
				document.getElementById('chart'),
				config
			);

		</script>

		<p align="center">
			Raw gcov output:<br/>
			<textarea readonly class="textarea" rows="50" cols="100">        -:    0:Source:log.c
        -:    0:Graph:./log.gcno
        -:    0:Data:./log.gcda
        -:    0:Runs:28
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <execinfo.h>
        -:   17:#include <inttypes.h>
        -:   18:#include <limits.h>
        -:   19:#include <log/log.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdarg.h>
        -:   22:#include <stdio.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <string.h>
        -:   25:#include <sys/time.h>
        -:   26:#include <time.h>
        -:   27:#include <unistd.h>
        -:   28:
        -:   29:const char PathSeparator =
        -:   30:#ifdef _WIN32
        -:   31:    '\\';
        -:   32:#else
        -:   33:    '/';
        -:   34:#endif
        -:   35:
        -:   36:#define _FILE_OFFSET_BITS 64
        -:   37:
       72:   38:u64 log_now()
        -:   39:{
        -:   40:    struct timeval tv;
       72:   41:    gettimeofday(&tv, NULL);
        -:   42:
       72:   43:    u64 ret = (u64)(tv.tv_sec) * 1000 + (u64)(tv.tv_usec) / 1000;
        -:   44:
       72:   45:    return ret;
        -:   46:}
        -:   47:
      348:   48:int sprintf_err(char* str, const char* string, ...)
        -:   49:{
        -:   50:    va_list args;
      348:   51:    va_start(args, string);
      348:   52:    int ret = vsprintf(str, string, args);
      348:   53:    va_end(args);
      348:   54:    return (ret > 0) ? 0 : ret;
        -:   55:}
        -:   56:
       82:   57:int set_option(Log* log, int type, void* value)
        -:   58:{
       82:   59:    if (value == NULL) {
        2:   60:        fputs("error: value pointer cannot be NULL\n", stderr);
        2:   61:        return -1;
        -:   62:    }
       80:   63:    if (type == ShowColors) {
       14:   64:        log->show_colors = *((bool*)value);
       66:   65:    } else if (type == ShowStdout) {
       10:   66:        log->show_stdout = *((bool*)value);
       56:   67:    } else if (type == ShowTimestamp) {
        3:   68:        log->show_timestamp = *((bool*)value);
       53:   69:    } else if (type == ShowMillis) {
        7:   70:        log->show_millis = *((bool*)value);
       46:   71:    } else if (type == ShowLogLevel) {
        1:   72:        log->show_log_level = *((bool*)value);
       45:   73:    } else if (type == AutoRotate) {
        2:   74:        log->auto_rotate = *((bool*)value);
       43:   75:    } else if (type == DeleteRotation) {
        1:   76:        log->delete_rotation = *((bool*)value);
       42:   77:    } else if (type == MaxSizeBytes) {
        7:   78:        if (*((u64*)value) < 1) {
        2:   79:            fputs("error: MaxSizeBytes cannot be less than 1\n", stderr);
        2:   80:            return -1;
        -:   81:        }
        5:   82:        log->max_size_bytes = *((u64*)value);
       35:   83:    } else if (type == MaxAgeMillis) {
        3:   84:        if (*((u64*)value) < 1000) {
        1:   85:            fputs("error: MaxAgeMillis cannot be less than 1,000\n", stderr);
        1:   86:            return -1;
        -:   87:        }
        2:   88:        log->max_age_millis = *((u64*)value);
       32:   89:    } else if (type == LogFilePath) {
       20:   90:        char* buf = ((char*)value);
       20:   91:        int len = strlen(buf);
       20:   92:        if (len < 1) {
        1:   93:            fputs("error: LogFilePath must be at least 1 bytes long\n", stderr);
        1:   94:            return -1;
        -:   95:        }
       19:   96:        log->path = malloc(sizeof(char) * (len + 1));
       19:   97:        if (log->path == NULL || log->debug_malloc) {
        1:   98:            if (log->path)
        1:   99:                free(log->path); // if debug_malloc is set
        1:  100:            log->path = NULL;
        1:  101:            fputs("error: Could not allocate the required memory\n", stderr);
        1:  102:            return -1;
        -:  103:        }
       18:  104:        strcpy(log->path, buf);
       12:  105:    } else if (type == FileHeader) {
       12:  106:        char* buf = ((char*)value);
       12:  107:        int len = strlen(buf);
       12:  108:        if (len < 1) {
        1:  109:            fputs("error: FileHeader must be at least 1 bytes long\n", stderr);
        1:  110:            return -1;
        -:  111:        }
       11:  112:        char* tmp = malloc(sizeof(char) * (len + 1));
       11:  113:        if (tmp == NULL || log->debug_malloc) {
        1:  114:            if (tmp)
        1:  115:                free(tmp); // if debug_malloc is set
        1:  116:            tmp = NULL;
        1:  117:            fputs("error: Could not allocate the required memory\n", stderr);
        1:  118:            return -1;
        -:  119:        }
       10:  120:        strcpy(tmp, buf);
       10:  121:        if (log->file_header != NULL)
        1:  122:            free(log->file_header);
       10:  123:        log->file_header = tmp;
        -:  124:    }
        -:  125:
       73:  126:    return 0;
        -:  127:}
        -:  128:
       36:  129:int do_logger(Log* log, int num, va_list valist)
        -:  130:{
       36:  131:    int ret = 0;
        -:  132:
        -:  133:    // set defaults
       36:  134:    log->fp = NULL;
       36:  135:    log->level = Info;
       36:  136:    log->show_colors = true;
       36:  137:    log->show_stdout = true;
       36:  138:    log->show_timestamp = true;
       36:  139:    log->show_millis = true;
       36:  140:    log->show_log_level = true;
       36:  141:    log->auto_rotate = false;
       36:  142:    log->delete_rotation = false;
       36:  143:    log->max_size_bytes = ULONG_MAX;
       36:  144:    log->max_age_millis = ULONG_MAX;
       36:  145:    log->path = NULL;
       36:  146:    log->file_header = NULL;
       36:  147:    log->off = 0;
       36:  148:    log->last_rotation = log_now();
       36:  149:    log->is_init = false;
       36:  150:    log->debug_malloc = false;
        -:  151:
        -:  152:    // iterate through arg list for overrides
      105:  153:    for (int i = 0; i < num; i++) {
       76:  154:        LogConfigOptionImpl next = va_arg(valist, LogConfigOptionImpl);
       76:  155:        if (set_option(log, next.type, next.value)) {
        7:  156:            if (log->file_header != NULL)
        1:  157:                free(log->file_header);
        7:  158:            if (log->path != NULL)
        1:  159:                free(log->path);
        7:  160:            log->path = NULL;
        7:  161:            log->file_header = NULL;
        7:  162:            ret = -1;
        7:  163:            break;
        -:  164:        }
        -:  165:    }
       36:  166:    return ret;
        -:  167:}
        -:  168:
       34:  169:int logger(Log* log, int num, ...)
        -:  170:{
        -:  171:    va_list valist;
       34:  172:    va_start(valist, num);
       34:  173:    int ret = do_logger(log, num, valist);
       34:  174:    va_end(valist);
       34:  175:    return ret;
        -:  176:}
        -:  177:
       87:  178:int get_format(Log* log, LogLevel level, char* buf)
        -:  179:{
       87:  180:    int ret = 0;
        -:  181:    char milli_buf[14];
        -:  182:    char log_level_buf[20];
        -:  183:    char dt_buf[40];
        -:  184:    char spacing[2];
       87:  185:    time_t t = time(NULL);
       87:  186:    struct tm tm = *localtime(&t);
        -:  187:
       87:  188:    if (log->show_millis) {
        -:  189:        struct timeval time;
       84:  190:        gettimeofday(&time, NULL);
       84:  191:        int millis = time.tv_usec / 1000;
       84:  192:        ret = sprintf_err(milli_buf, ".%03d", millis);
        -:  193:    } else {
        3:  194:        strcpy(milli_buf, "");
        -:  195:    }
        -:  196:
       87:  197:    if (log->show_timestamp) {
       83:  198:        strcpy(spacing, " ");
        -:  199:    } else {
        4:  200:        strcpy(spacing, "");
        -:  201:    }
        -:  202:
       87:  203:    if (log->show_log_level && ret == 0) {
       86:  204:        if (level == Trace) {
        2:  205:            if (log->show_colors) {
        1:  206:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_YELLOW "TRACE" ANSI_COLOR_RESET ")", spacing);
        -:  207:            } else {
        1:  208:                ret = sprintf_err(log_level_buf, "%s(TRACE)", spacing);
        -:  209:            }
       84:  210:        } else if (level == Debug) {
       67:  211:            if (log->show_colors) {
       64:  212:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_CYAN "DEBUG" ANSI_COLOR_RESET ")", spacing);
        -:  213:            } else {
        3:  214:                ret = sprintf_err(log_level_buf, "%s(DEBUG)", spacing);
        -:  215:            }
       17:  216:        } else if (level == Info) {
       10:  217:            if (log->show_colors) {
        4:  218:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_GREEN "INFO" ANSI_COLOR_RESET ")", spacing);
        -:  219:            } else {
        6:  220:                ret = sprintf_err(log_level_buf, "%s(INFO)", spacing);
        -:  221:            }
        7:  222:        } else if (level == Warn) {
        2:  223:            if (log->show_colors) {
        1:  224:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_MAGENTA "WARN" ANSI_COLOR_RESET ")", spacing);
        -:  225:            } else {
        1:  226:                ret = sprintf_err(log_level_buf, "%s(WARN)", spacing);
        -:  227:            }
        5:  228:        } else if (level == Error) {
        3:  229:            if (log->show_colors) {
        2:  230:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_RED "ERROR" ANSI_COLOR_RESET ")", spacing);
        -:  231:            } else {
        1:  232:                ret = sprintf_err(log_level_buf, "%s(ERROR)", spacing);
        -:  233:            }
        2:  234:        } else if (level == Fatal) {
        2:  235:            if (log->show_colors) {
        1:  236:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_BRIGHT_RED "FATAL" ANSI_COLOR_RESET ")", spacing);
        -:  237:            } else {
        1:  238:                ret = sprintf_err(log_level_buf, "%s(FATAL)", spacing);
        -:  239:            }
        -:  240:        }
        -:  241:    } else {
        1:  242:        strcpy(log_level_buf, "");
        -:  243:    }
        -:  244:
       87:  245:    if (log->show_timestamp && ret == 0) {
       83:  246:        if (log->show_colors) {
       71:  247:            ret = sprintf_err(
        -:  248:                dt_buf,
        -:  249:                "[" ANSI_COLOR_DIMMED
        -:  250:                "%d-%02d-%02d %02d:%02d:%02d%s" ANSI_COLOR_RESET
        -:  251:                "]",
       71:  252:                tm.tm_year + 1900,
       71:  253:                tm.tm_mon + 1,
        -:  254:                tm.tm_mday,
        -:  255:                tm.tm_hour,
        -:  256:                tm.tm_min,
        -:  257:                tm.tm_sec,
        -:  258:                milli_buf);
        -:  259:        } else {
       12:  260:            ret = sprintf_err(
        -:  261:                dt_buf,
        -:  262:                "["
        -:  263:                "%d-%02d-%02d %02d:%02d:%02d%s"
        -:  264:                "]",
       12:  265:                tm.tm_year + 1900,
       12:  266:                tm.tm_mon + 1,
        -:  267:                tm.tm_mday,
        -:  268:                tm.tm_hour,
        -:  269:                tm.tm_min,
        -:  270:                tm.tm_sec,
        -:  271:                milli_buf);
        -:  272:        }
        -:  273:    } else {
        4:  274:        strcpy(dt_buf, "");
        -:  275:    }
        -:  276:
       87:  277:    if ((level == Info || level == Warn) && log->show_log_level) {
       12:  278:        strcpy(spacing, ":");
        -:  279:    } else {
       75:  280:        strcpy(spacing, "");
        -:  281:    }
        -:  282:
       87:  283:    if (ret == 0) {
       87:  284:        ret = sprintf_err(
        -:  285:            buf,
        -:  286:            "%s%s%s: ",
        -:  287:            dt_buf,
        -:  288:            log_level_buf,
        -:  289:            spacing);
        -:  290:    }
       87:  291:    return ret;
        -:  292:}
        -:  293:
      819:  294:int do_log(Log* log, LogLevel level, char* line, bool is_plain, bool is_all, va_list args)
        -:  295:{
      819:  296:    int ret = 0;
      819:  297:    if (!log->is_init) {
        1:  298:        fputs("error: log has not been initialized\n", stderr);
        1:  299:        return -1;
        -:  300:    }
        -:  301:
      818:  302:    if (level >= log->level) {
        -:  303:        va_list args_copy;
      148:  304:        va_copy(args_copy, args);
        -:  305:
      148:  306:        int len = strlen(line);
      148:  307:        char fline[len + 100];
        -:  308:
      148:  309:        if (is_plain) {
       61:  310:            strcpy(fline, "");
        -:  311:        } else {
       87:  312:            ret = get_format(log, level, fline);
        -:  313:        }
      148:  314:        strcat(fline, line);
      148:  315:        strcat(fline, "\n");
        -:  316:
      148:  317:        if ((log->show_stdout || is_all) && ret == 0) {
      101:  318:            int v = vprintf(fline, args);
      101:  319:	    ret = (v > 0) ? 0 : v;
        -:  320:        }
        -:  321:
      148:  322:        if (log->fp && ret == 0) {
       81:  323:            int v = vfprintf(log->fp, fline, args_copy);
       81:  324:	    ret = (v > 0) ? 0 : v;
       81:  325:            log->off = ftello(log->fp);
        -:  326:        }
      148:  327:        if (log->auto_rotate && ret == 0) {
       12:  328:            if (log_need_rotate(log)) {
        2:  329:                ret = log_rotate(log);
        -:  330:            }
        -:  331:        }
        -:  332:    }
      818:  333:    return ret;
        -:  334:}
        -:  335:
        2:  336:int log_all(Log* log, LogLevel level, char* line, ...)
        -:  337:{
        -:  338:    va_list args;
        2:  339:    va_start(args, line);
        2:  340:    int ret = do_log(log, level, line, false, true, args);
        2:  341:    va_end(args);
        2:  342:    return ret;
        -:  343:}
        -:  344:
       60:  345:int log_plain(Log* log, LogLevel level, char* line, ...)
        -:  346:{
        -:  347:    va_list args;
       60:  348:    va_start(args, line);
       60:  349:    int ret = do_log(log, level, line, true, false, args);
       60:  350:    va_end(args);
       60:  351:    return ret;
        -:  352:}
        -:  353:
       21:  354:int log_line(Log* log, LogLevel level, char* line, ...)
        -:  355:{
        -:  356:    va_list args;
       21:  357:    va_start(args, line);
       21:  358:    int ret = do_log(log, level, line, false, false, args);
       21:  359:    va_end(args);
       21:  360:    return ret;
        -:  361:}
        -:  362:
      738:  363:void log_set_level(Log* log, LogLevel level)
        -:  364:{
      738:  365:    log->level = level;
      738:  366:}
        -:  367:
       28:  368:int log_init(Log* log)
        -:  369:{
       28:  370:    if (log->is_init) {
        1:  371:        fputs("error: log has already been initialized\n", stderr);
        1:  372:        return -1;
        -:  373:    }
       27:  374:    if (log->path) {
       17:  375:        bool write_header = false;
       17:  376:        if (log->file_header && access(log->path, F_OK) != 0) {
        6:  377:            write_header = true;
        -:  378:        }
       17:  379:        log->fp = fopen(log->path, "a");
       17:  380:        if (write_header) {
        6:  381:            fprintf(log->fp, "%s\n", log->file_header);
        -:  382:        }
       17:  383:        fseek(log->fp, 0, SEEK_END);
       17:  384:        log->off = ftello(log->fp);
        -:  385:    }
       27:  386:    log->is_init = true;
       27:  387:    return 0;
        -:  388:}
        -:  389:
        9:  390:int log_set_config_option(Log* log, LogConfigOptionImpl option)
        -:  391:{
        9:  392:    if (!log->is_init) {
        1:  393:        fputs("error: log has not been initialized\n", stderr);
        1:  394:        return -1;
        -:  395:    }
        8:  396:    if (option.type == LogFilePath && !log->debug_malloc) { // bypass this when we're debugging malloc
        2:  397:        fputs("error: cannot change log file path after initialization\n", stderr);
        2:  398:        return -1;
        -:  399:    }
        -:  400:
        6:  401:    return set_option(log, option.type, option.value);
        -:  402:}
        -:  403:
        9:  404:int log_rotate(Log* log)
        9:  405:{
        -:  406:    // format:
        -:  407:    // name.log -> name.r_<mon>_<day>_<year>_<time>_<rand>.log
        -:  408:
        9:  409:    int ret = 0;
        9:  410:    char rotation_name[strlen(log->path) + 100];
        9:  411:    time_t t = time(NULL);
        9:  412:    struct tm tm = *localtime(&t);
        -:  413:
        9:  414:    char* fname = strrchr(log->path, PathSeparator);
        9:  415:    if (fname == NULL) {
        1:  416:        fname = log->path;
        -:  417:    } else {
        8:  418:        ret = -1;
        8:  419:        if (strlen(fname) > 0) {
        8:  420:            ret = 0;
        8:  421:            fname = fname + 1;
        -:  422:        }
        -:  423:    }
        -:  424:
        9:  425:    if (!log->is_init) {
        1:  426:        fputs("error: log has not been initialized\n", stderr);
        1:  427:        ret = -1;
        -:  428:    }
        -:  429:
        -:  430:    char* ext;
        9:  431:    if (ret == 0) {
        8:  432:        strncpy(rotation_name, log->path, fname - log->path);
        8:  433:        rotation_name[fname - log->path] = 0;
        -:  434:
        8:  435:        ext = strrchr(fname, '.');
        8:  436:        if (ext == NULL) {
        1:  437:            ext = fname + strlen(fname);
        -:  438:        }
        -:  439:    }
        -:  440:
        9:  441:    if (ret == 0) {
        -:  442:        char date_format[100];
        8:  443:        strncpy(rotation_name + (fname - log->path), fname, ext - fname);
        8:  444:        rotation_name[ext - log->path] = 0;
        8:  445:        strcat(rotation_name, ".r_");
        -:  446:        u64 r;
        8:  447:        ret = rand_u64(&r);
        8:  448:        if (ret == 0) {
        8:  449:            sprintf_err(date_format,
        -:  450:                "%d_%02d_%02d_%02d_%02d_%02d_%" PRIu64,
        8:  451:                tm.tm_year + 1900,
        8:  452:                tm.tm_mon + 1,
        -:  453:                tm.tm_mday,
        -:  454:                tm.tm_hour,
        -:  455:                tm.tm_min,
        -:  456:                tm.tm_sec,
        -:  457:                r);
        8:  458:            strcat(rotation_name, date_format);
        8:  459:            strcat(rotation_name, ext);
        8:  460:            fclose(log->fp);
        8:  461:            if (log->delete_rotation) {
        1:  462:                remove(log->path);
        -:  463:            } else {
        7:  464:                rename(log->path, rotation_name);
        -:  465:            }
        -:  466:
        8:  467:            log->fp = fopen(log->path, "w");
        8:  468:            if (log->file_header)
        7:  469:                fprintf(log->fp, "%s\n", log->file_header);
        8:  470:            fseek(log->fp, 0, SEEK_END);
        8:  471:            log->off = ftello(log->fp);
        -:  472:        }
        -:  473:    }
        -:  474:
        9:  475:    if (ret == 0) {
        8:  476:        log->off = 0;
        8:  477:        log->last_rotation = log_now();
        -:  478:    }
        9:  479:    return ret;
        -:  480:}
        -:  481:
       28:  482:bool log_need_rotate(Log* log)
        -:  483:{
       28:  484:    u64 now = log_now();
       28:  485:    u64 diff = now - log->last_rotation;
       28:  486:    return log->off > log->max_size_bytes || diff > log->max_age_millis;
        -:  487:}
        -:  488:
       16:  489:int log_close(Log* log)
        -:  490:{
       16:  491:    if (log->fp) {
       16:  492:        fclose(log->fp);
       16:  493:        log->fp = NULL;
        -:  494:    }
       16:  495:    return 0;
        -:  496:}
        -:  497:
       80:  498:int _log_allocate_config_option(LogConfigOptionImpl* option, size_t size, bool debug_malloc_err, void* value)
        -:  499:{
       80:  500:    int ret = 0;
        -:  501:
       80:  502:    option->value = malloc(size);
       80:  503:    if (option->value == NULL || debug_malloc_err) {
        1:  504:        ret = -1;
        1:  505:        fputs("error: Could not allocate the required memory\n", stderr);
        -:  506:    }
        -:  507:
       80:  508:    return ret;
        -:  509:}
        -:  510:
       14:  511:int log_config_option_show_colors(LogConfigOptionImpl* option, bool value)
        -:  512:{
       14:  513:    option->type = ShowColors;
       14:  514:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
       14:  515:    if (!ret)
       14:  516:        *((bool*)option->value) = value;
       14:  517:    return ret;
        -:  518:}
        -:  519:
       10:  520:int log_config_option_show_stdout(LogConfigOptionImpl* option, bool value)
        -:  521:{
       10:  522:    option->type = ShowStdout;
       10:  523:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
       10:  524:    if (!ret)
       10:  525:        *((bool*)option->value) = value;
       10:  526:    return ret;
        -:  527:}
        -:  528:
        3:  529:int log_config_option_show_timestamp(LogConfigOptionImpl* option, bool value)
        -:  530:{
        3:  531:    option->type = ShowTimestamp;
        3:  532:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        3:  533:    if (!ret)
        3:  534:        *((bool*)option->value) = value;
        3:  535:    return ret;
        -:  536:}
        -:  537:
        7:  538:int log_config_option_show_millis(LogConfigOptionImpl* option, bool value)
        -:  539:{
        7:  540:    option->type = ShowMillis;
        7:  541:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        7:  542:    if (!ret)
        7:  543:        *((bool*)option->value) = value;
        7:  544:    return ret;
        -:  545:}
        -:  546:
        1:  547:int log_config_option_show_log_level(LogConfigOptionImpl* option, bool value)
        -:  548:{
        1:  549:    option->type = ShowLogLevel;
        1:  550:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        1:  551:    if (!ret)
        1:  552:        *((bool*)option->value) = value;
        1:  553:    return ret;
        -:  554:}
        -:  555:
        2:  556:int log_config_option_auto_rotate(LogConfigOptionImpl* option, bool value)
        -:  557:{
        2:  558:    option->type = AutoRotate;
        2:  559:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        2:  560:    if (!ret)
        2:  561:        *((bool*)option->value) = value;
        2:  562:    return ret;
        -:  563:}
        -:  564:
        1:  565:int log_config_option_delete_rotation(LogConfigOptionImpl* option, bool value)
        -:  566:{
        1:  567:    option->type = DeleteRotation;
        1:  568:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        1:  569:    if (!ret)
        1:  570:        *((bool*)option->value) = value;
        1:  571:    return ret;
        -:  572:}
        -:  573:
        6:  574:int log_config_option_max_size_bytes(LogConfigOptionImpl* option, u64 value)
        -:  575:{
        6:  576:    option->type = MaxSizeBytes;
        6:  577:    int ret = _log_allocate_config_option(option, sizeof(u64), false, &value);
        6:  578:    if (!ret)
        6:  579:        *((u64*)option->value) = value;
        6:  580:    return ret;
        -:  581:}
        -:  582:
        3:  583:int log_config_option_max_age_millis(LogConfigOptionImpl* option, u64 value)
        -:  584:{
        3:  585:    option->type = MaxAgeMillis;
        3:  586:    int ret = _log_allocate_config_option(option, sizeof(u64), false, &value);
        3:  587:    if (!ret)
        3:  588:        *((u64*)option->value) = value;
        3:  589:    return ret;
        -:  590:}
        -:  591:
       21:  592:int log_config_option_log_file_path(LogConfigOptionImpl* option, char* value)
        -:  593:{
       21:  594:    option->type = LogFilePath;
       21:  595:    int ret = 0;
       21:  596:    if (value == NULL) {
        1:  597:        option->value = NULL;
        -:  598:    } else {
       20:  599:        int len = strlen(value);
       20:  600:        ret = _log_allocate_config_option(option, sizeof(char) * (len + 1), false, &value);
       20:  601:        if (!ret)
       20:  602:            strcpy(option->value, value);
        -:  603:    }
       21:  604:    return ret;
        -:  605:}
        -:  606:
       13:  607:int log_config_option_file_header(LogConfigOptionImpl* option, char* value)
        -:  608:{
       13:  609:    option->type = FileHeader;
       13:  610:    int ret = 0;
       13:  611:    if (value == NULL) {
        1:  612:        option->value = NULL;
        -:  613:    } else {
       12:  614:        int len = strlen(value);
       12:  615:        ret = _log_allocate_config_option(option, sizeof(char) * (len + 1), false, &value);
       12:  616:        if (!ret)
       12:  617:            strcpy(option->value, value);
        -:  618:    }
       13:  619:    return ret;
        -:  620:}
        -:  621:
       72:  622:void log_config_option_free(LogConfigOptionImpl* option)
        -:  623:{
       72:  624:    if (option->value != NULL) {
       70:  625:        free(option->value);
       70:  626:	option->value = NULL;
        -:  627:    }
       72:  628:}
        -:  629:
       21:  630:void log_free(Log* log)
        -:  631:{
       21:  632:    if (log->path) {
       16:  633:        free(log->path);
       16:  634:	log->path = NULL;
        -:  635:    }
       21:  636:    if (log->file_header) {
        7:  637:        free(log->file_header);
        7:  638:	log->file_header = NULL;
        -:  639:    }
       21:  640:}
        -:  641:
        -:  642:pthread_mutex_t _global_logger_mutex__ = PTHREAD_MUTEX_INITIALIZER;
        -:  643:Log _global_logger__;
        -:  644:bool _global_logger_is_init__ = false;
        -:  645:
      736:  646:int _global_logger(bool is_plain, bool is_all, LogLevel level, LogLevel global, char* line, ...)
        -:  647:{
      736:  648:    int ret = 0;
      736:  649:    pthread_mutex_lock(&_global_logger_mutex__);
        -:  650:
      736:  651:    if (!_global_logger_is_init__) {
        7:  652:        ret = logger(&_global_logger__, 0);
        7:  653:        if (ret == 0)
        7:  654:            ret = log_init(&_global_logger__);
        7:  655:        if (ret == 0)
        7:  656:            _global_logger_is_init__ = true;
        -:  657:    }
        -:  658:
      736:  659:    if (ret == 0) {
      736:  660:        log_set_level(&_global_logger__, global);
        -:  661:
        -:  662:        va_list args;
      736:  663:        va_start(args, line);
      736:  664:        ret = do_log(&_global_logger__, level, line, is_plain, is_all, args);
      736:  665:        va_end(args);
        -:  666:    }
        -:  667:
      736:  668:    pthread_mutex_unlock(&_global_logger_mutex__);
      736:  669:    return ret;
        -:  670:}
        -:  671:
        3:  672:int init_global_logger(int num, ...)
        -:  673:{
        3:  674:    if (_global_logger_is_init__)
        1:  675:        return -1;
        2:  676:    int ret = 0;
        2:  677:    pthread_mutex_lock(&_global_logger_mutex__);
        -:  678:
        -:  679:    va_list valist;
        2:  680:    va_start(valist, num);
        2:  681:    ret = do_logger(&_global_logger__, num, valist);
        2:  682:    va_end(valist);
        -:  683:
        2:  684:    if (ret == 0)
        2:  685:        ret = log_init(&_global_logger__);
        2:  686:    if (ret == 0)
        2:  687:        _global_logger_is_init__ = true;
        -:  688:
        2:  689:    pthread_mutex_unlock(&_global_logger_mutex__);
        2:  690:    return ret;
        -:  691:}
        -:  692:
        1:  693:int global_log_rotate()
        -:  694:{
        1:  695:    pthread_mutex_lock(&_global_logger_mutex__);
        1:  696:    int ret = log_rotate(&_global_logger__);
        1:  697:    pthread_mutex_unlock(&_global_logger_mutex__);
        1:  698:    return ret;
        -:  699:}
        -:  700:
        1:  701:bool global_log_need_rotate()
        -:  702:{
        1:  703:    pthread_mutex_lock(&_global_logger_mutex__);
        1:  704:    bool ret = log_need_rotate(&_global_logger__);
        1:  705:    pthread_mutex_unlock(&_global_logger_mutex__);
        1:  706:    return ret;
        -:  707:}
        -:  708:
        2:  709:int global_log_config_option(LogConfigOptionImpl option)
        -:  710:{
        2:  711:    pthread_mutex_lock(&_global_logger_mutex__);
        2:  712:    int ret = log_set_config_option(&_global_logger__, option);
        2:  713:    pthread_mutex_unlock(&_global_logger_mutex__);
        2:  714:    return ret;
        -:  715:}
        -:  716:
        1:  717:void _debug_global_logger_is_init__()
        -:  718:{
        1:  719:    _global_logger_is_init__ = false;
        1:  720:}
        -:    0:Source:config.c
        -:    0:Graph:./config.gcno
        -:    0:Data:./config.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/config.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        2:   20:void configure_u32(uint32_t* value, uint32_t* configured, uint32_t d)
        -:   21:{
        2:   22:    if (configured == NULL) {
        1:   23:        *value = d;
        -:   24:    } else {
        1:   25:        *value = *configured;
        -:   26:    }
        2:   27:}
        -:   28:
        2:   29:void configure_u64(uint64_t* value, uint64_t* configured, uint64_t d)
        -:   30:{
        2:   31:    if (configured == NULL) {
        1:   32:        *value = d;
        -:   33:    } else {
        1:   34:        *value = *configured;
        -:   35:    }
        2:   36:}
        -:   37:
        2:   38:void configure_u128(__uint128_t* value, __uint128_t* configured, __uint128_t d)
        -:   39:{
        2:   40:    if (configured == NULL) {
        1:   41:        *value = d;
        -:   42:    } else {
        1:   43:        *value = *configured;
        -:   44:    }
        2:   45:}
        -:   46:
        2:   47:void configure_bool(bool* value, bool* configured, bool d)
        -:   48:{
        2:   49:    if (configured == NULL) {
        1:   50:        *value = d;
        -:   51:    } else {
        1:   52:        *value = *configured;
        -:   53:    }
        2:   54:}
        -:   55:
        2:   56:void configure_u8(uint8_t* value, uint8_t* configured, uint8_t d)
        -:   57:{
        2:   58:    if (configured == NULL) {
        1:   59:        *value = d;
        -:   60:    } else {
        1:   61:        *value = *configured;
        -:   62:    }
        2:   63:}
        -:   64:
        2:   65:void configure_u16(uint16_t* value, uint16_t* configured, uint16_t d)
        -:   66:{
        2:   67:    if (configured == NULL) {
        1:   68:        *value = d;
        -:   69:    } else {
        1:   70:        *value = *configured;
        -:   71:    }
        2:   72:}
        -:   73:
        2:   74:void configure_string(char* value, char* configured, char* d, int max_len)
        -:   75:{
        2:   76:    if (configured == NULL) {
        1:   77:        int len = max_len - 1;
        1:   78:        int strlen_value = strlen(d);
        1:   79:        if (strlen_value < len) {
        1:   80:            len = strlen_value;
        -:   81:        }
        1:   82:        memcpy(value, d, len);
        1:   83:        value[len] = 0;
        -:   84:    } else {
        1:   85:        int len = max_len - 1;
        1:   86:        int strlen_value = strlen(configured);
        1:   87:        if (strlen_value < len) {
        1:   88:            len = strlen_value;
        -:   89:        }
        1:   90:        memcpy(value, configured, len);
        1:   91:        value[len] = 0;
        -:   92:    }
        2:   93:}
        -:    0:Source:rand.c
        -:    0:Graph:./rand.gcno
        -:    0:Data:./rand.gcda
        -:    0:Runs:33
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <base/types.h>
        -:   17:#include <sys/random.h>
        -:   18:
        4:   19:int rand_i8(i8* v)
        -:   20:{
        -:   21:    char buf[1];
        4:   22:    int ret = getentropy(buf, 1);
        4:   23:    *v = (i8)buf[0];
        4:   24:    return ret;
        -:   25:}
        -:   26:
        4:   27:int rand_u8(u8* v)
        -:   28:{
        -:   29:    char buf[1];
        4:   30:    int ret = getentropy(buf, 1);
        4:   31:    *v = (u8)buf[0];
        4:   32:    return ret;
        -:   33:}
        -:   34:
        4:   35:int rand_i16(i16* v)
        -:   36:{
        -:   37:    char buf[2];
        4:   38:    int ret = getentropy(buf, 2);
        4:   39:    *v = ((i16)buf[0] << 8) + (i16)buf[1];
        4:   40:    return ret;
        -:   41:}
        -:   42:
        4:   43:int rand_u16(u16* v)
        -:   44:{
        -:   45:    char buf[2];
        4:   46:    int ret = getentropy(buf, 2);
        4:   47:    *v = ((u16)buf[0] << 8) + (u16)buf[1];
        4:   48:    return ret;
        -:   49:}
        -:   50:
        1:   51:int rand_i32(i32* v)
        -:   52:{
        -:   53:    char buf[4];
        1:   54:    int ret = getentropy(buf, 4);
        1:   55:    *v = ((i32)buf[0] << 24) + ((i32)buf[1] << 16) + ((i32)buf[2] << 8) + (i32)buf[3];
        1:   56:    return ret;
        -:   57:}
        -:   58:
        2:   59:int rand_u32(u32* v)
        -:   60:{
        -:   61:    char buf[4];
        2:   62:    int ret = getentropy(buf, 4);
        2:   63:    *v = ((u32)buf[0] << 24) + ((u32)buf[1] << 16) + ((u32)buf[2] << 8) + (u32)buf[3];
        2:   64:    return ret;
        -:   65:}
        -:   66:
        1:   67:int rand_i64(i64* v)
        -:   68:{
        -:   69:    char buf[8];
        1:   70:    int ret = getentropy(buf, 8);
        1:   71:    *v = ((i64)buf[0] << 56) + ((i64)buf[1] << 48) + ((i64)buf[2] << 40) + ((i64)buf[3] << 32) + ((i64)buf[4] << 24) + ((i64)buf[5] << 16) + ((i64)buf[6] << 8) + (i64)buf[7];
        1:   72:    return ret;
        -:   73:}
        -:   74:
       10:   75:int rand_u64(u64* v)
        -:   76:{
        -:   77:    char buf[8];
       10:   78:    int ret = getentropy(buf, 8);
       10:   79:    *v = ((u64)buf[0] << 56) + ((u64)buf[1] << 48) + ((u64)buf[2] << 40) + ((u64)buf[3] << 32) + ((u64)buf[4] << 24) + ((u64)buf[5] << 16) + ((u64)buf[6] << 8) + (u64)buf[7];
       10:   80:    return ret;
        -:   81:}
        -:   82:
        1:   83:int rand_i128(i128* v)
        -:   84:{
        -:   85:    char buf[16];
        1:   86:    int ret = getentropy(buf, 16);
        1:   87:    *v = ((i128)buf[0] << 120) + ((i128)buf[1] << 112) + ((i128)buf[2] << 104) + ((i128)buf[3] << 96) + ((i128)buf[4] << 88) + ((i128)buf[5] << 80) + ((i128)buf[6] << 72) + ((i128)buf[7] << 64) + ((i128)buf[8] << 56) + ((i128)buf[9] << 48) + ((i128)buf[10] << 40) + ((i128)buf[11] << 32) + ((i128)buf[12] << 24) + ((i128)buf[13] << 16) + ((i128)buf[14] << 8) + (i128)buf[15];
        1:   88:    return ret;
        -:   89:}
        -:   90:
        3:   91:int rand_u128(u128* v)
        -:   92:{
        -:   93:    char buf[16];
        3:   94:    int ret = getentropy(buf, 16);
        3:   95:    *v = ((u128)buf[0] << 120) + ((u128)buf[1] << 112) + ((u128)buf[2] << 104) + ((u128)buf[3] << 96) + ((u128)buf[4] << 88) + ((u128)buf[5] << 80) + ((u128)buf[6] << 72) + ((u128)buf[7] << 64) + ((u128)buf[8] << 56) + ((u128)buf[9] << 48) + ((u128)buf[10] << 40) + ((u128)buf[11] << 32) + ((u128)buf[12] << 24) + ((u128)buf[13] << 16) + ((u128)buf[14] << 8) + (u128)buf[15];
        3:   96:    return ret;
        -:   97:}
        -:   98:
        2:   99:int rand_bytes(void* buf, size_t length)
        -:  100:{
        2:  101:    return getentropy(buf, length);
        -:  102:}
        -:    0:Source:ser.c
        -:    0:Graph:./ser.gcno
        -:    0:Data:./ser.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:#include <base/ser.h>
        -:   17:#include <string.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <stdio.h>
        -:   20:
       11:   21:int serialize(Serializable *s, Writer *writer) {
       11:   22:	return s->serialize(s->ptr, writer);
        -:   23:}
        -:   24:
       12:   25:int deserialize(Serializable *s, Reader *reader) {
       12:   26:	return s->deserialize(s->ptr, reader);
        -:   27:}
        -:   28:
        7:   29:Reader build_reader(int (*read_fixed_bytes)(struct Reader *reader, unsigned char *buffer, u64 len), void *ptr)
        -:   30:{
        -:   31:        Reader ret;
        7:   32:        ret.ptr = ptr;
        7:   33:        ret.read_fixed_bytes = read_fixed_bytes;
        7:   34:        return ret;
        -:   35:}
        -:   36:
       23:   37:Serializable build_serializable(
        -:   38:	void *ptr,
        -:   39:	int (*serialize)(void *obj, Writer *writer),
        -:   40:	int (*deserialize)(void *obj, Reader *reader)
        -:   41:) {
        -:   42:	Serializable ret;
       23:   43:	ret.ptr = ptr;
       23:   44:	ret.serialize = serialize;
       23:   45:	ret.deserialize = deserialize;
       23:   46:	return ret;
        -:   47:}
        -:   48:
        9:   49:Writer build_writer(int (*write_fixed_bytes)(struct Writer *writer, unsigned char *buffer, u64 len), void *ptr) {
        -:   50:	Writer ret;
        9:   51:	ret.ptr = ptr;
        9:   52:	ret.write_fixed_bytes = write_fixed_bytes;
        9:   53:	return ret;
        -:   54:}
        -:   55:
       15:   56:int bin_reader_read_fixed_bytes(Reader *reader, unsigned char *buffer, u64 len) {
       15:   57:	memcpy(buffer, reader->ptr, len);
       15:   58:	reader->ptr += len;
       15:   59:	return 0;
        -:   60:}
        -:   61:
       17:   62:int bin_writer_write_fixed_bytes(Writer *writer, unsigned char *buffer, u64 len) {
       17:   63:	memcpy(writer->ptr, buffer, len);
       17:   64:	writer->ptr += len;
       17:   65:	return 0;
        -:   66:}
        -:   67:
    #####:   68:int serialize_i128(void *obj, Writer *writer) {
    #####:   69:        return serialize_u128(obj, writer);
        -:   70:}
        -:   71:
    #####:   72:int deserialize_i128(void *obj, Reader *reader) {
    #####:   73:        return deserialize_u128(obj, reader);
        -:   74:}
        -:   75:
    #####:   76:int serialize_f64(void *obj, Writer *writer) {
    #####:   77:        return serialize_u64(obj, writer);
        -:   78:}
        -:   79:
    #####:   80:int deserialize_f64(void *obj, Reader *reader) {
    #####:   81:        return deserialize_u64(obj, reader);
        -:   82:}
        -:   83:
    #####:   84:int serialize_f32(void *obj, Writer *writer) {
    #####:   85:        return serialize_u32(obj, writer);
        -:   86:}
        -:   87:
    #####:   88:int deserialize_f32(void *obj, Reader *reader) {
    #####:   89:        return deserialize_u32(obj, reader);
        -:   90:}
        -:   91:
    #####:   92:int serialize_i64(void *obj, Writer *writer) {
    #####:   93:	return serialize_u64(obj, writer);
        -:   94:}
        -:   95:
        3:   96:int deserialize_i64(void *obj, Reader *reader) {
        3:   97:        return deserialize_u64(obj, reader);
        -:   98:}
        -:   99:
    #####:  100:int serialize_i32(void *obj, Writer *writer) {
    #####:  101:        return serialize_u32(obj, writer);
        -:  102:}
        -:  103:
    #####:  104:int deserialize_i32(void *obj, Reader *reader) {
    #####:  105:        return deserialize_u32(obj, reader);
        -:  106:}
        -:  107:
    #####:  108:int serialize_i16(void *obj, Writer *writer) {
    #####:  109:        return serialize_u16(obj, writer);
        -:  110:}
        -:  111:
    #####:  112:int deserialize_i16(void *obj, Reader *reader) {
    #####:  113:        return deserialize_u16(obj, reader);
        -:  114:}
        -:  115:
    #####:  116:int serialize_i8(void *obj, Writer *writer) {
    #####:  117:        return serialize_u8(obj, writer);
        -:  118:}
        -:  119:
    #####:  120:int deserialize_i8(void *obj, Reader *reader) {
    #####:  121:        return deserialize_u8(obj, reader);
        -:  122:}
        -:  123:
        2:  124:int deserialize_bool(void *obj, Reader *reader) {
        -:  125:	unsigned char buffer[1];
        2:  126:        int ret = reader->read_fixed_bytes(reader, buffer, 1);
        -:  127:
        2:  128:        if(ret == 0) {
        2:  129:                *((bool *)obj) = false;
        2:  130:		if(buffer[0])
        1:  131:			*((bool *)obj) = true;
        -:  132:        }
        -:  133:
        2:  134:        return ret;
        -:  135:}
        -:  136:
        2:  137:int serialize_bool(void *obj, Writer *writer) {
        -:  138:	unsigned char buffer[1];
        -:  139:
        2:  140:	if(*((bool *)obj)) {
        1:  141:		buffer[0] = 1;
        -:  142:	} else {
        1:  143:        	buffer[0] = 0;
        -:  144:	}
        -:  145:
        2:  146:        return writer->write_fixed_bytes(writer, buffer, 1);
        -:  147:}
        -:  148:
    #####:  149:int deserialize_u8(void *obj, Reader *reader) {
        -:  150:        unsigned char buffer[1];
    #####:  151:        int ret = reader->read_fixed_bytes(reader, buffer, 1);
        -:  152:
    #####:  153:        if(ret == 0) {
    #####:  154:                *((u8 *)obj) = 0;
    #####:  155:                *((u8 *)obj) += (u8)(buffer[0] & 0xFF);
        -:  156:        }
        -:  157:
    #####:  158:        return ret;
        -:  159:}
        -:  160:
    #####:  161:int serialize_u8(void *obj, Writer *writer) {
        -:  162:        unsigned char buffer[1];
        -:  163:
    #####:  164:        buffer[0] = *((u8 *)obj) & 0xFF;
        -:  165:
    #####:  166:        return writer->write_fixed_bytes(writer, buffer, 1);
        -:  167:}
        -:  168:
    #####:  169:int deserialize_u16(void *obj, Reader *reader) {
        -:  170:        unsigned char buffer[2];
    #####:  171:        int ret = reader->read_fixed_bytes(reader, buffer, 2);
        -:  172:
    #####:  173:        if(ret == 0) {
    #####:  174:                *((u16*)obj) = 0;
    #####:  175:                *((u16 *)obj) += (u16)(buffer[1] & 0xFF);
    #####:  176:                *((u16 *)obj) += (u16)(buffer[0] & 0xFF) << 8;
        -:  177:        }
        -:  178:
    #####:  179:        return ret;
        -:  180:}
        -:  181:
    #####:  182:int serialize_u16(void *obj, Writer *writer) {
        -:  183:        unsigned char buffer[2];
        -:  184:
    #####:  185:        u16  value = *((u16 *)obj);
    #####:  186:        buffer[1] = value & 0xFF;
    #####:  187:        value >>= 8;
    #####:  188:        buffer[0] = value & 0xFF;
        -:  189:
    #####:  190:        return writer->write_fixed_bytes(writer, buffer, 2);
        -:  191:}
        -:  192:
        3:  193:int deserialize_u32(void *obj, Reader *reader) {
        -:  194:        unsigned char buffer[4];
        3:  195:        int ret = reader->read_fixed_bytes(reader, buffer, 4);
        -:  196:
        3:  197:        if(ret == 0) {
        3:  198:                *((u32 *)obj) = 0;
        3:  199:		*((u32 *)obj) += (u32)(buffer[3] & 0xFF);
        3:  200:                *((u32 *)obj) += (u32)(buffer[2] & 0xFF) << 8;
        3:  201:                *((u32 *)obj) += (u32)(buffer[1] & 0xFF) << 16;
        3:  202:                *((u32 *)obj) += (u32)(buffer[0] & 0xFF) << 24;
        -:  203:        }
        -:  204:
        3:  205:        return ret;
        -:  206:}
        -:  207:
        3:  208:int serialize_u32(void *obj, Writer *writer) {
        -:  209:	unsigned char buffer[4];
        -:  210:
        3:  211:        u32 value = *((u32 *)obj);
        3:  212:        buffer[3] = value & 0xFF;
        3:  213:        value >>= 8;
        3:  214:        buffer[2] = value & 0xFF;
        3:  215:        value >>= 8;
        3:  216:        buffer[1] = value & 0xFF;
        3:  217:        value >>= 8;
        3:  218:        buffer[0] = value & 0xFF;
        -:  219:
        3:  220:        return writer->write_fixed_bytes(writer, buffer, 4);
        -:  221:}
        -:  222:
       11:  223:int deserialize_u64(void *obj, Reader *reader) {
        -:  224:        unsigned char buffer[8];
       11:  225:        int ret = reader->read_fixed_bytes(reader, buffer, 8);
        -:  226:
       11:  227:        if(ret == 0) {
       10:  228:                *((u64 *)obj) = 0;
       10:  229:                *((u64 *)obj) += (u64)(buffer[7] & 0xFF);
       10:  230:                *((u64 *)obj) += (u64)(buffer[6] & 0xFF) << 8;
       10:  231:                *((u64 *)obj) += (u64)(buffer[5] & 0xFF) << 16;
       10:  232:                *((u64 *)obj) += (u64)(buffer[4] & 0xFF) << 24;
       10:  233:                *((u64 *)obj) += (u64)(buffer[3] & 0xFF) << 32;
       10:  234:                *((u64 *)obj) += (u64)(buffer[2] & 0xFF) << 40;
       10:  235:                *((u64 *)obj) += (u64)(buffer[1] & 0xFF) << 48;
       10:  236:                *((u64 *)obj) += (u64)(buffer[0] & 0xFF) << 56;
        -:  237:        }
        -:  238:
       11:  239:        return ret;
        -:  240:}
        -:  241:
       12:  242:int serialize_u64(void *obj, Writer *writer) {
        -:  243:        unsigned char buffer[8];
        -:  244:
       12:  245:        u64 value = *((u64 *)obj);
       12:  246:        buffer[7] = value & 0xFF;
       12:  247:        value >>= 8;
       12:  248:        buffer[6] = value & 0xFF;
       12:  249:        value >>= 8;
       12:  250:        buffer[5] = value & 0xFF;
       12:  251:        value >>= 8;
       12:  252:        buffer[4] = value & 0xFF;
       12:  253:        value >>= 8;
       12:  254:        buffer[3] = value & 0xFF;
       12:  255:        value >>= 8;
       12:  256:        buffer[2] = value & 0xFF;
       12:  257:        value >>= 8;
       12:  258:        buffer[1] = value & 0xFF;
       12:  259:        value >>= 8;
       12:  260:        buffer[0] = value & 0xFF;
        -:  261:
       12:  262:        return writer->write_fixed_bytes(writer, buffer, 8);
        -:  263:}
        -:  264:
        2:  265:int deserialize_u128(void *obj, Reader *reader) {
        -:  266:        unsigned char buffer[16];
        2:  267:        int ret = reader->read_fixed_bytes(reader, buffer, 16);
        -:  268:
        2:  269:        if(ret == 0) {
        2:  270:                *((u128 *)obj) = 0;
        2:  271:                *((u128 *)obj) += (u128)(buffer[15] & 0xFF);
        2:  272:		*((u128 *)obj) += (u128)(buffer[14] & 0xFF) << 8;
        2:  273:		*((u128 *)obj) += (u128)(buffer[13] & 0xFF) << 16;
        2:  274:		*((u128 *)obj) += (u128)(buffer[12] & 0xFF) << 24;
        2:  275:		*((u128 *)obj) += (u128)(buffer[11] & 0xFF) << 32;
        2:  276:		*((u128 *)obj) += (u128)(buffer[10] & 0xFF) << 40;
        2:  277:		*((u128 *)obj) += (u128)(buffer[9] & 0xFF) << 48;
        2:  278:		*((u128 *)obj) += (u128)(buffer[8] & 0xFF) << 56;
        2:  279:		*((u128 *)obj) += (u128)(buffer[7] & 0xFF) << 64;
        2:  280:		*((u128 *)obj) += (u128)(buffer[6] & 0xFF) << 72;
        2:  281:		*((u128 *)obj) += (u128)(buffer[5] & 0xFF) << 80;
        2:  282:		*((u128 *)obj) += (u128)(buffer[4] & 0xFF) << 88;
        2:  283:		*((u128 *)obj) += (u128)(buffer[3] & 0xFF) << 96;
        2:  284:		*((u128 *)obj) += (u128)(buffer[2] & 0xFF) << 104;
        2:  285:		*((u128 *)obj) += (u128)(buffer[1] & 0xFF) << 112;
        2:  286:		*((u128 *)obj) += (u128)(buffer[0] & 0xFF) << 120;
        -:  287:        }
        -:  288:
        2:  289:        return ret;
        -:  290:}
        -:  291:
        2:  292:int serialize_u128(void *obj, Writer *writer) {
        -:  293:        unsigned char buffer[16];
        -:  294:
        2:  295:        u128 value = *((u128 *)obj);
        2:  296:	buffer[15] = value & 0xFF;
        2:  297:        value >>= 8;
        2:  298:        buffer[14] = value & 0xFF;
        2:  299:        value >>= 8;
        2:  300:        buffer[13] = value & 0xFF;
        2:  301:        value >>= 8;
        2:  302:        buffer[12] = value & 0xFF;
        2:  303:        value >>= 8;
        2:  304:        buffer[11] = value & 0xFF;
        2:  305:        value >>= 8;
        2:  306:        buffer[10] = value & 0xFF;
        2:  307:        value >>= 8;
        2:  308:        buffer[9] = value & 0xFF;
        2:  309:        value >>= 8;
        2:  310:        buffer[8] = value & 0xFF;
        2:  311:	value >>= 8;
        2:  312:        buffer[7] = value & 0xFF;
        2:  313:        value >>= 8;
        2:  314:        buffer[6] = value & 0xFF;
        2:  315:        value >>= 8;
        2:  316:        buffer[5] = value & 0xFF;
        2:  317:        value >>= 8;
        2:  318:        buffer[4] = value & 0xFF;
        2:  319:        value >>= 8;
        2:  320:        buffer[3] = value & 0xFF;
        2:  321:        value >>= 8;
        2:  322:        buffer[2] = value & 0xFF;
        2:  323:        value >>= 8;
        2:  324:        buffer[1] = value & 0xFF;
        2:  325:        value >>= 8;
        2:  326:        buffer[0] = value & 0xFF;
        -:  327:
        2:  328:        return writer->write_fixed_bytes(writer, buffer, 16);
        -:  329:}
        -:  330:
        3:  331:int serialize_string(void *obj, Writer *writer) {
        3:  332:	int ret = 0;
        3:  333:	u64 len = ((String *)obj)->len;
        3:  334:	serialize_u64(&len, writer);
        3:  335:	ret = writer->write_fixed_bytes(writer, (unsigned char *)((String *)obj)->ptr, len);
        -:  336:
        3:  337:	return ret;
        -:  338:}
        -:  339:
        3:  340:int deserialize_string(void *obj, Reader *reader) {
        3:  341:	int ret = 0;
        3:  342:	((String *)obj)->ptr = NULL;
        -:  343:
        -:  344:	u64 len;
        3:  345:	ret = deserialize_i64(&len, reader);
        -:  346:
        3:  347:	if(!ret) {
        3:  348:		unsigned char *ptr = malloc(sizeof(char) * (len+1));
        3:  349:		if(ptr == NULL)
    #####:  350:			ret = -1;
        -:  351:		else {
        3:  352:			ret = reader->read_fixed_bytes(reader, ptr, len);
        -:  353:		}
        -:  354:
        3:  355:		if(!ret) {
        3:  356:                	((String *)obj)->ptr = (char *)ptr;
        3:  357:                	((String *)obj)->len = len;
        -:  358:        	}
        -:  359:
        -:  360:	}
        -:  361:
        3:  362:	return ret;
        -:  363:}
        -:  364:
        -:    0:Source:types.c
        -:    0:Graph:./types.gcno
        -:    0:Data:./types.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdlib.h>
        -:   16:#include <string.h>
        -:   17:#include <stdio.h>
        -:   18:#include <base/types.h>
        -:   19:
        7:   20:void string_free(StringImpl *s) {
        7:   21:	if(s->ptr) {
        7:   22:		free(s->ptr);
        7:   23:		s->ptr = NULL;
        -:   24:	}
        7:   25:}
        -:   26:
        3:   27:int string_set(StringImpl *s, const char *ptr) {
        3:   28:	int ret = 0;
        3:   29:	s->len = strlen(ptr);
        -:   30:
        3:   31:	s->ptr = malloc(sizeof(char) * (s->len + 1));
        3:   32:	if(s->ptr == NULL)
    #####:   33:		ret = -1;
        -:   34:
        3:   35:	if(!ret)
        3:   36:		strcpy(s->ptr, ptr);
        -:   37:
        3:   38:	return ret;
        -:   39:}
        -:   40:
    #####:   41:i64 saddi64(i64 a, i64 b)
        -:   42:{
    #####:   43:    if (a > 0) {
    #####:   44:        if (b > INT64_MAX - a) {
    #####:   45:            return INT64_MAX;
        -:   46:        }
    #####:   47:    } else if (b < INT64_MIN - a) {
    #####:   48:            return INT64_MIN;
        -:   49:    }
        -:   50:
    #####:   51:    return a + b;
        -:   52:}
        -:   53:
       15:   54:u64 saddu64(u64 a, u64 b) {
      15*:   55:  return (a > 0xFFFFFFFFFFFFFFFF - b) ? 0xFFFFFFFFFFFFFFFF : a + b;
        -:   56:}
        -:    0:Source:main.c
        -:    0:Graph:./main.gcno
        -:    0:Data:./main.gcda
        -:    0:Runs:1
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdio.h>
        -:   16:#include <log/log.h>
        -:   17:#include <util/misc.h>
        -:   18:
        -:   19:#define LOG_LEVEL Info
        -:   20:
        1:   21:int real_main(int argc, char** argv)
        -:   22:{
        1:   23:    LogConfigOption opt1, opt2, opt3;
        1:   24:    log_config_option_show_colors(&opt1, true);
        1:   25:    log_config_option_show_stdout(&opt2, true);
        1:   26:    log_config_option_show_timestamp(&opt3, false);
        -:   27:
        1:   28:    init_global_logger(2, opt1, opt2);
        1:   29:    info("Main currently doesn't do %s.", "anything");
        1:   30:    global_log_config_option(opt3);
        1:   31:    info("Main currently doesn't do %s.", "anything");
        1:   32:    info("end");
        -:   33:
        1:   34:    return 0;
        -:   35:}
        -:   36:
        1:   37:int main(int argc, char **argv) {
        1:   38:    return real_main(argc, argv);
        -:   39:}
        -:   40:
        -:    0:Source:misc.c
        -:    0:Graph:./misc.gcno
        -:    0:Data:./misc.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:#include <util/misc.h>
        -:   17:#include <log/log.h>
        -:   18:
        -:   19:#define LOG_LEVEL Debug
        -:   20:
    #####:   21:bool is_white_space(char ch)
        -:   22:{
    #####:   23:    debug("is whitespace '%c'", ch);
    #####:   24:    if (ch == '\n' || ch == '\t' || ch == '\r' || ch == '\v' || ch == '\f' || ch == ' ')
    #####:   25:        return true;
        -:   26:    else
    #####:   27:        return false;
        -:   28:}
        -:   29:
    #####:   30:bool is_ident_start(char ch)
        -:   31:{
    #####:   32:    if ((ch <= 'Z' && ch >= 'A') || (ch <= 'z' && ch >= 'a') || ch == '_') {
    #####:   33:        return true;
        -:   34:    } else {
    #####:   35:        return false;
        -:   36:    }
        -:   37:}
        -:   38:
    #####:   39:bool is_ident_secondary(char ch)
        -:   40:{
    #####:   41:    if (is_ident_start(ch) || (ch <= '9' && ch >= '0')) {
    #####:   42:        return true;
        -:   43:    } else {
    #####:   44:        return false;
        -:   45:    }
        -:   46:}
        -:   47:
    #####:   48:bool is_joint_possible(char ch)
        -:   49:{
    #####:   50:    if (ch == '.' || ch == '=' || ch == '/' || ch == '+' || ch == '&' || ch == '<' || ch == '-' || ch == '%' || ch == '^' || ch == '*' || ch == '>' || ch == '|' || ch == '!' || ch == ':') {
    #####:   51:        return true;
        -:   52:    } else {
    #####:   53:        return false;
        -:   54:    }
        -:   55:}
        -:    0:Source:option.c
        -:    0:Graph:./option.gcno
        -:    0:Data:./option.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <util/option.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <base/rand.h>
        -:   19:#include <log/log.h>
        -:   20:#include <util/panic.h>
        -:   21:
        -:   22:#define LOG_LEVEL Debug
        -:   23:
        -:   24:Option None = { option_is_some_false, NULL };
        -:   25:
    #####:   26:bool option_is_some_false() {
    #####:   27:        return false;
        -:   28:}
        -:   29:
    #####:   30:bool option_is_some_true() {
    #####:   31:	return true;
        -:   32:}
        -:   33:
    #####:   34:void *option_unwrap(Option x) {
    #####:   35:	if(!x.is_some()) {
    #####:   36:		panic("attempt to unwrap on a None");
        -:   37:	} else {
    #####:   38:		return x.ref;
        -:   39:	}
        -:   40:}
        -:   41:
    #####:   42:Option option_build(OptionImpl *opt, void *x, size_t size) {
    #####:   43:	debug("size=%i", size);
        -:   44:
    #####:   45:	(*opt).is_some = option_is_some_true;
    #####:   46:	(*opt).ref = malloc(size);
    #####:   47:	debug("opt.ref=%i", (*opt).ref);
    #####:   48:	memcpy((*opt).ref, x, size);
    #####:   49:	return *opt;
        -:   50:}
        -:   51:
    #####:   52:void option_free(OptionImpl *ptr) {
    #####:   53:	debug("option free %i", ptr->ref);
    #####:   54:	if(ptr->ref) {
    #####:   55:		debug("ptr free %i", ptr->ref);
    #####:   56:		free(ptr->ref);
    #####:   57:		debug("free complete");
    #####:   58:		ptr->ref = NULL;
        -:   59:	}
    #####:   60:}
        -:    0:Source:panic.c
        -:    0:Graph:./panic.gcno
        -:    0:Data:./panic.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <util/panic.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:
    #####:   19:void panic(const char * str) {
    #####:   20:	printf("thread panicked: %s", str);
    #####:   21:	exit(-1);
        -:   22:}
        -:    0:Source:slabio.c
        -:    0:Graph:./slabio.gcno
        -:    0:Data:./slabio.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <util/slabio.h>
        -:   16:#include <string.h>
        -:   17:#include <log/log.h>
        -:   18:#include <limits.h>
        -:   19:
        -:   20:#define LOG_LEVEL Info
        -:   21:
        4:   22:int slab_reader_next_slab(SlabReader *reader, Slab *slab) {
        4:   23:	int ret = 0;
        4:   24:	u64 next = ULONG_MAX;
        -:   25:
        4:   26:	debug("next slab when cur = %llu", reader->cur_slab_id);
        -:   27:
        4:   28:	void *ptr = slab->data + (slab->len - SLABIO_NEXT_POINTER_SIZE);
        4:   29:        Reader bin_reader = READER(bin_reader_read_fixed_bytes, ptr);
        4:   30:        ret = deserialize_u64(&next, &bin_reader);
        4:   31:	debug("read next slab = %llu", next);
        4:   32:        reader->cur_slab_id = next;
        4:   33:        reader->cur_slab_offset = 0;
        -:   34:
        4:   35:	return ret;
        -:   36:}
        -:   37:
        6:   38:int slab_reader_read_fixed_bytes(Reader *reader, unsigned char *buffer, u64 len) {
        6:   39:	int ret = 0;
        6:   40:	SlabReader *sr = reader->ptr;
        -:   41:	Slab slab;
        6:   42:	u64 slab_len = ULONG_MAX;
        6:   43:	u64 len_sum = 0;
        -:   44:
        6:   45:	debug(
        -:   46:		"read cur_slab=%llu,offset=%llu,len=%llu",
        -:   47:		sr->cur_slab_id, sr->cur_slab_offset, len
        -:   48:	);
        -:   49:
        4:   50:	while(true) {
       10:   51:		if(sr->cur_slab_offset >= slab_len - SLABIO_NEXT_POINTER_SIZE) {
        4:   52:			if(slab_reader_next_slab(sr, &slab)) {
    #####:   53:				error("Could not read next slab");
    #####:   54:				ret = -1;
    #####:   55:				break;
        -:   56:			}
        -:   57:		}
       10:   58:		debug("cur_slab=%llu", sr->cur_slab_id);
       10:   59:		if(sr->cur_slab_id == ULONG_MAX) {
        1:   60:			error("tried to read past end of slabs");
        1:   61:			ret = -1;
        1:   62:			break;
        -:   63:		}
        -:   64:
        9:   65:		slab_read(sr->sa, sr->cur_slab_id, &slab);
        -:   66:
        9:   67:		slab_len = slab.len;
        9:   68:		u64 slab_rem = (slab_len - SLABIO_NEXT_POINTER_SIZE) - sr->cur_slab_offset;
        -:   69:		u64 wlen;
        -:   70:
        9:   71:		if(slab_len <= SLABIO_NEXT_POINTER_SIZE) {
    #####:   72:                        error(
        -:   73:                                "illegal slab size. slab_size must be greater than %llu",
        -:   74:                                SLABIO_NEXT_POINTER_SIZE
        -:   75:                        );
    #####:   76:                        ret = -1;
    #####:   77:                        break;
        -:   78:                }
        -:   79:
        9:   80:		if(slab_rem > len) {
        4:   81:                        wlen = len;
        -:   82:                } else {
        5:   83:                        wlen = slab_rem;
        -:   84:                }
        -:   85:
        9:   86:		if(wlen > 0) {
        8:   87:			memcpy(buffer + len_sum, slab.data + sr->cur_slab_offset, wlen);
        8:   88:			sr->cur_slab_offset += wlen;
        8:   89:                	len -= wlen;
        8:   90:			len_sum += wlen;
        -:   91:		}
        -:   92:
        9:   93:		if(len == 0)
        5:   94:			break;
        -:   95:	}
        -:   96:
        6:   97:	debug("read complete. Read %llu bytes.", len_sum);
        6:   98:	return ret;
        -:   99:}
        -:  100:
        3:  101:int slab_writer_allocate_slab(SlabWriter *writer, Slab *slab) {
        3:  102:	int ret = 0;
        -:  103:
        3:  104:	u64 next = slab_allocate(writer->sa, slab->len);
        3:  105:	if(next == ULONG_MAX)
    #####:  106:		ret = -1;
        -:  107:
        3:  108:	debug("allocate %llu", next);
        -:  109:
        3:  110:	if(!ret) {
        3:  111:		void *ptr = slab->data + (slab->len - SLABIO_NEXT_POINTER_SIZE);
        3:  112:		Writer bin_writer = WRITER(bin_writer_write_fixed_bytes, ptr);
        3:  113:		ret = serialize_u64(&next, &bin_writer);
        3:  114:		writer->cur_slab_id = next;
        3:  115:		writer->cur_slab_offset = 0;
        -:  116:	}
        -:  117:
        3:  118:	if(!ret) {
        3:  119:		u64 max = ULONG_MAX;
        -:  120:		Slab nslab;
        3:  121:		slab_read(writer->sa, next, &nslab);
        3:  122:		void *ptr = nslab.data + (slab->len - SLABIO_NEXT_POINTER_SIZE);
        3:  123:		Writer bin_writer = WRITER(bin_writer_write_fixed_bytes, ptr);
        3:  124:		ret = serialize_u64(&max, &bin_writer);
        -:  125:	}
        -:  126:
        -:  127:
        3:  128:	return ret;
        -:  129:}
        -:  130:
        5:  131:int slab_writer_write_fixed_bytes(Writer *writer, unsigned char *buffer, u64 len) {
        5:  132:	int ret = 0;
        5:  133:	SlabWriter *sw = writer->ptr;
        -:  134:	Slab slab;
        5:  135:	u64 len_sum = 0;
        5:  136:	u64 slab_len = ULONG_MAX;
        -:  137:
        5:  138:	debug("write cur_slab=%llu,len=%llu", sw->cur_slab_id, len);
        -:  139:
        3:  140:	while(true) {
        8:  141:		if(sw->cur_slab_offset >= slab_len - SLABIO_NEXT_POINTER_SIZE) {
        -:  142:			// allocate
        3:  143:			if(slab_writer_allocate_slab(sw, &slab)) {
    #####:  144:				error("Could not allocate another slab");
    #####:  145:				ret = -1;
    #####:  146:				break;
        -:  147:			}
        -:  148:		}
        8:  149:		slab_read(sw->sa, sw->cur_slab_id, &slab);
        -:  150:
        8:  151:		slab_len = slab.len;
        8:  152:		u64 slab_rem = (slab_len - SLABIO_NEXT_POINTER_SIZE) - sw->cur_slab_offset;
        -:  153:		u64 wlen;
        -:  154:
        8:  155:		if(slab_len <= SLABIO_NEXT_POINTER_SIZE) {
    #####:  156:			error(
        -:  157:				"illegal slab size. slab_size must be greater than %llu",
        -:  158:				SLABIO_NEXT_POINTER_SIZE
        -:  159:			);
    #####:  160:			ret = -1;
    #####:  161:			break;
        -:  162:		}
        -:  163:
        8:  164:		if(slab_rem > len) {
        4:  165:			wlen = len;
        -:  166:		} else {
        4:  167:			wlen = slab_rem;
        -:  168:		}
        -:  169:
        8:  170:		debug("slab_len=%llu,wlen=%llu", slab_len, wlen);
        -:  171:
        8:  172:		if(wlen > 0) {
        8:  173:			memcpy(slab.data + sw->cur_slab_offset, buffer + len_sum, wlen);
        8:  174:			sw->cur_slab_offset += wlen;
        8:  175:			len -= wlen;
        8:  176:			len_sum += wlen;
        -:  177:		}
        -:  178:
        8:  179:		if(len == 0)
        5:  180:			break;
        -:  181:	}
        -:  182:
        5:  183:	debug("slab write complete len = %llu", len_sum);
        -:  184:
        5:  185:	return ret;
        -:  186:}
        -:  187:
        2:  188:int slab_reader_init(SlabReader *sr, SlabAllocator *sa) {
        2:  189:	sr->sa = sa;
        2:  190:	sr->cur_slab_id = ULONG_MAX;
        2:  191:        sr->cur_slab_offset = 0;
        2:  192:	return 0;
        -:  193:}
        -:  194:
        2:  195:int slab_writer_init(SlabWriter *sw, SlabAllocator *sa) {
        2:  196:	sw->sa = sa;
        2:  197:	sw->cur_slab_id = ULONG_MAX;
        2:  198:	sw->cur_slab_offset = 0;
        -:  199:
        2:  200:	return 0;
        -:  201:}
        -:  202:
        2:  203:void slab_reader_seek(Reader *reader, u64 slab_id, u64 offset) {
        2:  204:	SlabReader *sr = reader->ptr;
        2:  205:	sr->cur_slab_id = slab_id;
        2:  206:	sr->cur_slab_offset = offset;
        2:  207:}
        -:  208:
        2:  209:void slab_writer_seek(Writer *writer, u64 slab_id, u64 offset) {
        2:  210:	SlabWriter *sw = writer->ptr;
        2:  211:	sw->cur_slab_id = slab_id;
        2:  212:        sw->cur_slab_offset = offset;
        2:  213:}
        -:  214:
    #####:  215:int slab_reader_skip(Reader *sr, u64 bytes) { return 0; }
    #####:  216:int slab_writer_skiip(Writer *sw, u64 bytes) { return 0; }
        -:  217:
    #####:  218:u64 slab_reader_cur_id(Reader *reader) { return 0; }
    #####:  219:u64 slab_writer_cur_id(Reader *writer) { return 0; }
        -:  220:
    #####:  221:u64 slab_reader_cur_offset(Reader *reader) { return 0; }
    #####:  222:u64 slab_writer_cur_offset(Writer *writer) { return 0; }
        -:  223:
        -:    0:Source:slabs.c
        -:    0:Graph:./slabs.gcno
        -:    0:Data:./slabs.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <string.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <util/slabs.h>
        -:   18:#include <base/types.h>
        -:   19:#include <limits.h>
        -:   20:#include <stdarg.h>
        -:   21:#include <log/log.h>
        -:   22:
        -:   23:#define LOG_LEVEL Info
        -:   24:
       15:   25:int slab_data_init(SlabData *sd, u64 slab_count, u64 slab_size, u64 max_slabs) {
       15:   26:	sd->data = NULL;
       15:   27:	sd->sdp.slab_size = slab_size;
       15:   28:	sd->sdp.slab_count = slab_count;
       15:   29:	sd->sdp.max_slabs = max_slabs;
       15:   30:	sd->sdp.free_list_head = 0;
        -:   31:
       15:   32:	sd->sdp.ptr_size = 0;
        -:   33:        // add 2 (1 termination pointer and one for free status)
       15:   34:        u64 x = saddu64(max_slabs, 2);
        -:   35:        while(true) {
       32:   36:        	if(x == 0) {
       15:   37:                	break;
        -:   38:                }
       17:   39:                x >>= 8;
       17:   40:                sd->sdp.ptr_size += 1;
        -:   41:        }
        -:   42:
       15:   43:	sd->sdp.null_ptr = 0;
       15:   44:	int shft = 0;
       32:   45:	for(int i=0; i<sd->sdp.ptr_size; i++) {
       17:   46:		sd->sdp.null_ptr |= 0xFF << shft;
       17:   47:		shft += 8;
        -:   48:	}
        -:   49:
       15:   50:	debug(
        -:   51:		"sd->sdp.ptr_size=%d,max_slabs=%llu,null_ptr=%llu",
        -:   52:		sd->sdp.ptr_size,
        -:   53:		max_slabs,
        -:   54:		sd->sdp.null_ptr
        -:   55:	);
        -:   56:
        -:   57:
       15:   58:	int ret = slab_data_resize(sd, slab_count);
        -:   59:
       15:   60:	return ret;
        -:   61:}
        -:   62:
    #####:   63:void *slab_data_read(SlabData *sd, u64 offset) {
    #####:   64:	if(offset > sd->sdp.slab_size * sd->sdp.slab_count)
    #####:   65:		return NULL;
    #####:   66:	return sd->data + offset;
        -:   67:}
        -:   68:
      332:   69:int slab_data_write(SlabData *sd, u64 dst_offset, void *value, u64 src_offset, u64 len) {
      332:   70:        int ret = 0;
      332:   71:	debug("=====sdw dst_offset=%llu,src_offset=%llu,len=%llu", dst_offset, src_offset, len);
      332:   72:	memcpy(sd->data + dst_offset, value + src_offset, len);
      332:   73:        return ret;
        -:   74:}
        -:   75:
       17:   76:int slab_data_resize(SlabData *sd, u64 slabs) {
       17:   77:	debug("slab_data_resize %llu", slabs);
       17:   78:	u64 len = slabs * (sd->sdp.slab_size + sd->sdp.ptr_size);
       17:   79:	int ret = 0;
        -:   80:
       17:   81:	if (sd->data == NULL) {
       15:   82:		debug("slab_data_resize malloc %llu", len);
       15:   83:		sd->data = malloc(len);
       15:   84:		if(sd->data == NULL) {
    #####:   85:			error("Could not allocate the required memory.");
    #####:   86:			ret = -1;
        -:   87:		}
        -:   88:	} else {
        2:   89:		void *tmp = realloc(sd->data, len);
        2:   90:		if(tmp == NULL) {
    #####:   91:			error("Could not allocate the required memory.");
    #####:   92:			ret = -1;
        -:   93:		} else {
        2:   94:			sd->data = tmp;
        -:   95:		}
        -:   96:	}
        -:   97:
       17:   98:	return ret;
        -:   99:}
        -:  100:
       15:  101:void slab_data_free(SlabData *sd) {
       15:  102:	if(sd->data) {
       15:  103:		free(sd->data);
       15:  104:		sd->data = NULL;
        -:  105:	}
       15:  106:}
        -:  107:
      320:  108:void slab_write_ptr(char *bytes, u64 n, u64 ptr_size) {
      840:  109:	for(int j=ptr_size-1; j>=0; j--) {
      520:  110:                bytes[j] = n & 0xFF;
      520:  111:        	n = n >> 8;
        -:  112:        }
      320:  113:}
        -:  114:
       17:  115:void slab_set_max(char *bytes, u64 ptr_size) {
       36:  116:	for(int j=0; j<ptr_size; j++)
       19:  117:		bytes[j] = 0xFF;
       17:  118:}
        -:  119:
       39:  120:u64 slab_read_ptr(unsigned char *bytes, u64 ptr_size) {
       39:  121:	u64 ret = 0;
       39:  122:	debug("slab_read_ptr with ptr_size = %llu", ptr_size);
        -:  123:
       39:  124:	int shft = 0;
       89:  125:	for(int j=ptr_size-1; j>=0; j--) {
       50:  126:		ret += bytes[j] << shft;
       50:  127:		shft += 8;
        -:  128:	}
        -:  129:
       39:  130:	debug("ret=%llu", ret);
        -:  131:
       39:  132:	return ret;
        -:  133:}
        -:  134:
       17:  135:int slab_init_free_list(SlabData *sd, u64 size, u64 offset) {
       17:  136:	debug("init free list %llu off=%llu, size=%llu", sd->sdp.slab_size, offset, size);
       17:  137:	int ret = 0;
       17:  138:	u64 ptr_size = sd->sdp.ptr_size;
       17:  139:	u64 slab_size = sd->sdp.slab_size;
        -:  140:
      348:  141:	for(u64 i=offset; i<offset + size; i++) {
      331:  142:		char next_bytes[ptr_size];
      331:  143:		if(i < (offset + size) - 1) {
      314:  144:			u64 n = i + 1;
      314:  145:			slab_write_ptr(next_bytes, n, ptr_size);
        -:  146:		} else {
       17:  147:			slab_set_max(next_bytes, ptr_size);
        -:  148:		}
      331:  149:		u64 offset_next = i * (ptr_size + slab_size);
      331:  150:		if(i < 1)
       15:  151:			debug(
        -:  152:				"writing first block at %llu,ptr_size=%llu, [0]=%d,[1]=%d",
        -:  153:				offset_next,
        -:  154:				ptr_size,
        -:  155:				next_bytes[0],
        -:  156:				next_bytes[1]
        -:  157:			);
      331:  158:		slab_data_write(sd, offset_next, next_bytes, 0, ptr_size);
        -:  159:	}
        -:  160:
        -:  161:
       17:  162:	return ret;
        -:  163:}
        -:  164:
        9:  165:int do_slabs(SlabAllocator *sa, int num, va_list valist) {
        -:  166:	va_list args_copy;
        9:  167:        va_copy(args_copy, valist);
        9:  168:	int ret = 0;
        9:  169:	int sd_count = 0;
        9:  170:	u64 slabs_per_resize = 100;
        9:  171:	bool zeroed = true;
        -:  172:
       28:  173:	for(int i=0; i<num; i++) {
       19:  174:		SlabAllocatorConfigImpl next = va_arg(valist, SlabAllocatorConfigImpl);
       19:  175:		if(next.type == SlabAllocatorConfigImplTypeSlabData)
       15:  176:			sd_count += 1;
        4:  177:		else if(next.type == SlabAllocatorConfigImplTypeSlabsPerResize) {
        2:  178:			slabs_per_resize = *((u64 *)next.value);
        2:  179:		} else if(next.type == SlabAllocatorConfigImplTypeZeroed) {
        2:  180:			zeroed = *((bool *)next.value);
        -:  181:		}
        -:  182:	}
        -:  183:
        9:  184:	if(sd_count > 254) {
    #####:  185:		error("slab_allocator may not have more than 254 slab sizes.");
    #####:  186:		return -1;
        -:  187:	}
        -:  188:
        9:  189:	u64 sizes[sd_count];
        9:  190:	u64 max_slabs[sd_count];
        9:  191:	int counter = 0;
       28:  192:	for(int i=0; i<num; i++) {
       19:  193:                SlabAllocatorConfigImpl next = va_arg(args_copy, SlabAllocatorConfigImpl);
       19:  194:                if(next.type == SlabAllocatorConfigImplTypeSlabData) {
       15:  195:			u64 slab_size = ((u64 *)next.value)[1];
       15:  196:			u64 max_slabs_value = ((u64 *)next.value)[0];
       15:  197:			sizes[counter] = slab_size;
       15:  198:			max_slabs[counter] = max_slabs_value;
       15:  199:			counter += 1;
        -:  200:		}
        -:  201:        }
        -:  202:
        -:  203:	// check that ordering is sorted and other configs are ok
        9:  204:        u64 last_size = 0;
       24:  205:        for(int i=0; i<counter; i++) {
       15:  206:                if(sizes[i] <= last_size) {
    #####:  207:                        error("slab_allocator sizes must be sorted in ascending order.");
    #####:  208:                        return -1;
        -:  209:                }
       15:  210:                last_size = sizes[i];
       15:  211:                if(max_slabs[i] == 0) {
    #####:  212:                        error("max_slabs must be greater than 0");
    #####:  213:                        return -1;
        -:  214:                }
        -:  215:        }
        -:  216:
        9:  217:        if(slabs_per_resize == 0) {
    #####:  218:                error("slabs_per_resize must be greater than 0");
    #####:  219:                return -1;
        -:  220:        }
        -:  221:
        9:  222:        sa->slab_data_array = NULL;
        9:  223:        sa->sizes = NULL;
        9:  224:        sa->max_slabs = NULL;
        9:  225:        sa->zeroed = zeroed;
        9:  226:        sa->slabs_per_resize = slabs_per_resize;
        9:  227:        sa->slab_data_array = malloc(sizeof(SlabData) * counter);
        9:  228:        if(sa->slab_data_array == NULL) {
    #####:  229:                ret = -1;
    #####:  230:                error("Could not allocate the required memory.");
        -:  231:        }
        -:  232:
        9:  233:	        if(ret == 0) {
        9:  234:                sa->sizes = malloc(sizeof(u64) * counter);
        -:  235:
        9:  236:                if(sa->sizes == NULL) {
    #####:  237:                        free(sa->slab_data_array);
    #####:  238:                        sa->slab_data_array = NULL;
    #####:  239:                        ret = -1;
    #####:  240:                        error("Could not allocate the required memory.");
        -:  241:                } else {
        9:  242:                        sa->slab_data_array_len = counter;
        9:  243:                        memcpy(sa->sizes, sizes, counter * sizeof(u64));
        -:  244:                }
        -:  245:
        -:  246:        }
        -:  247:
        9:  248:        if(ret == 0) {
        9:  249:                sa->max_slabs = malloc(sizeof(u64) * counter);
        9:  250:                if(sa->max_slabs == NULL) {
    #####:  251:                        free(sa->slab_data_array);
    #####:  252:                        sa->slab_data_array = NULL;
    #####:  253:                        free(sa->sizes);
    #####:  254:                        sa->sizes = NULL;
    #####:  255:                        error("Could not allocate required memory.");
    #####:  256:                        ret = -1;
        -:  257:                } else {
        9:  258:                        memcpy(sa->max_slabs, max_slabs, counter * sizeof(u64));
        -:  259:                }
        -:  260:        }
        -:  261:
        9:  262:	if(ret == 0) {
       24:  263: 		for(int i=0; i<counter; i++) {
       15:  264:			u64 initial_slabs = slabs_per_resize;
       15:  265:			if(slabs_per_resize > sa->max_slabs[i]) {
       12:  266:				initial_slabs = sa->max_slabs[i];
        -:  267:			}
       15:  268:			debug(
        -:  269:				"initial_slabs=%llu,max=%llu,spr=%llu",
        -:  270:				initial_slabs,
        -:  271:				sa->max_slabs[i],
        -:  272:				slabs_per_resize
        -:  273:			);
       15:  274:                	if(slab_data_init(
       15:  275:                        	&sa->slab_data_array[i],
        -:  276:                                initial_slabs,
       15:  277:                                sa->sizes[i],
       15:  278:                                sa->max_slabs[i]
        -:  279:                        )) {
    #####:  280:                        	ret = -1; 
    #####:  281:                                break;
        -:  282:                        }
        -:  283:                }
        -:  284:	}
        -:  285:
        9:  286:	if(ret == 0) {
       24:  287:		for(int i=0; i<sa->slab_data_array_len; i++) {
       15:  288:			u64 size = slabs_per_resize;
       15:  289:			if(sa->slab_data_array[i].sdp.max_slabs < slabs_per_resize)
       12:  290:				size = sa->slab_data_array[i].sdp.max_slabs;
       15:  291:                	slab_init_free_list(&sa->slab_data_array[i], size, 0);
        -:  292:                }
        -:  293:	}
        -:  294:
        9:  295:        return ret;	
        -:  296:}
        -:  297:
        9:  298:int slab_init(SlabAllocator *sa, int num, ...) {
        -:  299:    va_list valist;
        9:  300:    va_start(valist, num);
        9:  301:    int ret = do_slabs(sa, num, valist);
        9:  302:    va_end(valist);
        9:  303:    return ret;
        -:  304:}
        -:  305:
       65:  306:int slab_index_for_size(SlabAllocator *sa, u64 size) {
        -:  307:	// slab sizes are sorted so we can do binary search
       65:  308:	int slab_data_array_len = sa->slab_data_array_len;
       65:  309:	int mid = slab_data_array_len / 2;
       65:  310:	int min = 0;
       65:  311:	int max = slab_data_array_len - 1;
        -:  312:
        -:  313:	while(true) {
      140:  314:		if(sa->sizes[mid] == size)
       54:  315:			return mid;
       86:  316:		else if(sa->sizes[mid] > size) {
       49:  317:			if(max <= min)
        7:  318:				break;
       42:  319:			max = mid - 1;
        -:  320:		} else {
       37:  321:			if(max <= min)
        4:  322:				break;
       33:  323:			min = mid + 1;
        -:  324:		}
       75:  325:		mid = (min + (max - min) / 2);
        -:  326:	}
        -:  327:
       11:  328:	return -1;
        -:  329:}
        -:  330:
       44:  331:u64 slab_allocate(SlabAllocator *sa, u64 size) {
       44:  332:	int idx = slab_index_for_size(sa, size);
       44:  333:	if(idx < 0)
    #####:  334:		return ULONG_MAX;
        -:  335:
       44:  336:	u64 slab_size = sa->slab_data_array[idx].sdp.slab_size;
       44:  337:	u64 ptr_size = sa->slab_data_array[idx].sdp.ptr_size;
       44:  338:	u64 cur_slabs = sa->slab_data_array[idx].sdp.slab_count;
       44:  339:	u64 max_slabs = sa->slab_data_array[idx].sdp.max_slabs;
       44:  340:	u64 head = sa->slab_data_array[idx].sdp.free_list_head;
        -:  341:
       44:  342:	if(head == sa->slab_data_array[idx].sdp.null_ptr) {
        7:  343:		if(max_slabs > cur_slabs) {
        2:  344:			debug("resize possible for %d,max=%llu,cur=%llu", idx, max_slabs, cur_slabs);
        2:  345:			u64 nslabs = cur_slabs + sa->slabs_per_resize;
        2:  346:			if(nslabs > max_slabs) {
        1:  347:				nslabs = max_slabs;
        -:  348:			}
        2:  349:			slab_data_resize(&sa->slab_data_array[idx], nslabs);
        2:  350:			slab_init_free_list(&sa->slab_data_array[idx], nslabs - cur_slabs, cur_slabs);
        2:  351:			sa->slab_data_array[idx].sdp.free_list_head = cur_slabs;
        2:  352:			sa->slab_data_array[idx].sdp.slab_count = nslabs;
        2:  353:			head = cur_slabs;
        -:  354:		} else {
        5:  355:			return ULONG_MAX;
        -:  356:		}
        -:  357:	}
        -:  358:
       78:  359:	sa->slab_data_array[idx].sdp.free_list_head = slab_read_ptr(
       39:  360:		sa->slab_data_array[idx].data + head * (ptr_size + slab_size),
        -:  361:		ptr_size
        -:  362:	);
       39:  363:	debug("reading next free list at relative id = %llu", head);
        -:  364:
       39:  365:	if(sa->zeroed) {
    12737:  366:		for(int i=0; i<slab_size; i++) {
    12698:  367:			u64 offset = head * (ptr_size + slab_size) + ptr_size + i;
    12698:  368:			(((char*)sa->slab_data_array[idx].data)[offset]) = 0;
        -:  369:		}
        -:  370:	}
        -:  371:
       39:  372:	debug(
        -:  373:		"head=%llu,next=%llu, ULONG_MAX=%llu",
        -:  374:		head,
        -:  375:		sa->slab_data_array[idx].sdp.free_list_head,
        -:  376:		ULONG_MAX
        -:  377:	);
       39:  378:	u64 idx_u64 = idx;
       39:  379:	return head | (idx_u64 << 56);
        -:  380:}
        -:  381:
        6:  382:int slab_free(SlabAllocator *sa, u64 id) {
        6:  383:	int ret = 0;
        6:  384:	int idx = (id >> 56) & 0xFF;
        6:  385:	u64 id_relative = id & 0x00FFFFFFFFFFFFFF;
        -:  386:
        6:  387:	debug("id=%llu,idx=%d,id_relative=%llu", id, idx, id_relative);
        6:  388:	u64 head = sa->slab_data_array[idx].sdp.free_list_head;
        6:  389:	u64 slab_size = sa->slab_data_array[idx].sdp.slab_size;
        6:  390:	u64 ptr_size = sa->slab_data_array[idx].sdp.ptr_size;
        -:  391:
        6:  392:	sa->slab_data_array[idx].sdp.free_list_head = id_relative;
        6:  393:	u64 offset = id_relative * (ptr_size + slab_size);
        6:  394:	slab_write_ptr(sa->slab_data_array[idx].data + offset, head, ptr_size);
        -:  395:
        6:  396:	return ret;
        -:  397:}
        -:  398:
        1:  399:int slab_write(SlabAllocator *sa, u64 id, Slab *slab, u64 offset_slab) {
        1:  400:	int ret = 0;
        -:  401:
        1:  402: 	int idx = (id >> 56) & 0xFF;
        1:  403:        u64 id_relative = id & 0x00FFFFFFFFFFFFFF;
        -:  404:        
        1:  405:        u64 slab_size = sa->slab_data_array[idx].sdp.slab_size;
        1:  406:        u64 ptr_size = sa->slab_data_array[idx].sdp.ptr_size;
        -:  407:
        1:  408:	if(offset_slab >= slab_size) {
    #####:  409:		error(
        -:  410:			"offset (%llu) is greater than or equal to slab size (%llu)",
        -:  411:			offset_slab,
        -:  412:			slab_size
        -:  413:		);
    #####:  414:		return -1;
        -:  415:	}
        -:  416:
        1:  417:	if(slab->len != slab_size) {
    #####:  418:		error("slab->len (%llu) not equal to slab_size (%llu)", slab->len, slab_size);
    #####:  419:		return -1;
        -:  420:	}
        -:  421:                
        1:  422:        u64 offset = id_relative * (ptr_size + slab_size) + offset_slab + ptr_size;
        -:  423:
        1:  424:	debug("write offset = %llu", offset);
        1:  425:	u64 len = slab_size - offset_slab;
        -:  426:
        1:  427:	slab_data_write(&sa->slab_data_array[idx], offset, slab->data, 0, len);
        -:  428:
        -:  429:
        1:  430:	return ret;
        -:  431:}
        -:  432:
       23:  433:int slab_read(SlabAllocator *sa, u64 id, Slab *slab) {
       23:  434:	int ret = 0;
       23:  435:	int idx = (id >> 56) & 0xFF;
       23:  436:        u64 id_relative = id & 0x00FFFFFFFFFFFFFF;
        -:  437:
       23:  438:	u64 slab_size = sa->slab_data_array[idx].sdp.slab_size;
       23:  439:        u64 ptr_size = sa->slab_data_array[idx].sdp.ptr_size;
        -:  440:
       23:  441:	u64 offset = id_relative * (ptr_size + slab_size) + ptr_size;
       23:  442:	debug("read offset = %llu", offset);
       23:  443:	slab->data = sa->slab_data_array[idx].data + offset;
       23:  444:	slab->len = slab_size;
        -:  445:
       23:  446:	return ret;
        -:  447:}
        -:  448:
        9:  449:void slab_allocator_free(SlabAllocator *sa) {
       24:  450:	for(int i=0; i<sa->slab_data_array_len; i++) {
       15:  451:		slab_data_free(&sa->slab_data_array[i]);
        -:  452:	}
        9:  453:	sa->slab_data_array_len = 0;
        -:  454:
        9:  455:	if(sa->slab_data_array) {
        9:  456:		free(sa->slab_data_array);
        9:  457:		sa->slab_data_array = NULL;
        -:  458:	}
        -:  459:
        9:  460:	if(sa->sizes) {
        9:  461:		free(sa->sizes);
        9:  462:		sa->sizes = NULL;
        -:  463:	}
        -:  464:
        9:  465:	if(sa->max_slabs) {
        9:  466:		free(sa->max_slabs);
        9:  467:		sa->max_slabs = NULL;
        -:  468:	}
        9:  469:}
        -:  470:
        3:  471:int slab_allocator_config_zeroed(SlabAllocatorConfigImpl *sc, bool zeroed) {
        3:  472:	int ret = 0;
        3:  473:	sc->type = SlabAllocatorConfigImplTypeZeroed;
        3:  474:	sc->value = malloc(sizeof(bool));
        3:  475:        if(sc->value == NULL) {
    #####:  476:                ret = -1;
        -:  477:        } else {
        3:  478:                *((bool *)sc->value) = zeroed;
        -:  479:        }
        3:  480:	return ret;
        -:  481:}
        -:  482:
        3:  483:int slab_allocator_config_slabs_per_resize(SlabAllocatorConfigImpl *sc, u64 slabs_per_resize) {
        3:  484:	int ret = 0;
        3:  485:	sc->type = SlabAllocatorConfigImplTypeSlabsPerResize;
        3:  486:	sc->value = malloc(sizeof(u64));
        3:  487:	if(sc->value == NULL) {
    #####:  488:                ret = -1;
        -:  489:        } else {
        3:  490:		*((u64 *)sc->value) = slabs_per_resize;
        -:  491:	}
        3:  492:	return ret;
        -:  493:}
        -:  494:
       16:  495:int slab_allocator_config_slab_data(SlabAllocatorConfigImpl *sc, u64 max_slabs, u64 slab_size) {
       16:  496:	int ret = 0;
       16:  497:	sc->type = SlabAllocatorConfigImplTypeSlabData;
       16:  498:	sc->value = malloc(sizeof(u64) * 2);
       16:  499:	if(sc->value == NULL) {
    #####:  500:		ret = -1;
        -:  501:	} else {
       16:  502:		(((u64 *)sc->value)[0]) = max_slabs;
       16:  503:		(((u64 *)sc->value)[1]) = slab_size;
        -:  504:	}
       16:  505:	return ret;
        -:  506:}
        -:  507:
       22:  508:void slab_allocator_config_free(SlabAllocatorConfigImpl *sc) {
       22:  509:	if(sc->value != NULL) {
       22:  510:		free(sc->value);
       22:  511:		sc->value = NULL;
        -:  512:	}
       22:  513:}</textarea>
		</p>
	</body>
</html>

