<!DOCTYPE html>
<html>
	<head>
		<title>Code Coverage Report</title>
		<script src="chart.js"></script>
		<style>
			.chart {
				width: 900px;
			}
			.textarea {
				overflow:auto;
				resize:none;
			}
		</style>
	</head>
	<body>
		 <p align="center">
                        Code Coverage is currently 94.15%.
                </p>
		<center>
			<div class="chart">
				<canvas id="chart"></canvas>
			</div>
		</center>
		<script>
			function format_date(timestamp, time_frame) {
				var date = new Date(timestamp);
				var day_of_month = date.getDate();
				var full_year = date.getFullYear();
				var month = 1 + date.getMonth();
				var hours = date.getHours();
				var minutes = date.getMinutes();
				var seconds = date.getSeconds();
				var am_pm = 'AM';

				if(seconds < 10) {
					seconds = '0' + seconds;
				}
				if(minutes < 10) {
					minutes = '0' + minutes;
				}
				if(hours == 12) {
					am_pm = 'PM';
				} else if(hours > 12) {
					hours -= 12;
					am_pm = 'PM';
				}
				if(hours == 0) {
					hours = 12;
				}

				return month + '/' + day_of_month + '/' + full_year + ' ' +
					hours + ':' + minutes + ':' + seconds + ' ' + am_pm;
			}

			let raw_data = [86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
0.00,
0.00,
0.00,
85.57,
85.57,
86.81,
84.76,
94.15,];
			let labels = [format_date(1716876818 * 1000 ),
format_date(1716876822 * 1000 ),
format_date(1716904488 * 1000 ),
format_date(1716905952 * 1000 ),
format_date(1716905990 * 1000 ),
format_date(1716906171 * 1000 ),
format_date(1716906235 * 1000 ),
format_date(1716906333 * 1000 ),
format_date(1716906629 * 1000 ),
format_date(1716906787 * 1000 ),
format_date(1716907183 * 1000 ),
format_date(1716907441 * 1000 ),
format_date(1716907910 * 1000 ),
format_date(1716908379 * 1000 ),
format_date(1716909018 * 1000 ),
format_date(1716909696 * 1000 ),
format_date(1716920268 * 1000 ),
format_date(1717294283 * 1000 ),];

			const data = {
				labels: labels,
				datasets: [{
					label: 'Code Coverage',
					backgroundColor: 'rgb(31,176,245)',
					borderColor: 'rgb(31,176,245)',
					data: raw_data,
				}]
			};

			const config = {
				type: 'line',
				data: data,
				options: {}
			};

			const chart = new Chart(
				document.getElementById('chart'),
				config
			);

		</script>

		<p align="center">
			Raw gcov output:<br/>
			<textarea readonly class="textarea" rows="50" cols="100">        -:    0:Source:log.c
        -:    0:Graph:./log.gcno
        -:    0:Data:./log.gcda
        -:    0:Runs:18
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <execinfo.h>
        -:   17:#include <inttypes.h>
        -:   18:#include <limits.h>
        -:   19:#include <log/log.h>
        -:   20:#include <stdarg.h>
        -:   21:#include <stdio.h>
        -:   22:#include <pthread.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <string.h>
        -:   25:#include <sys/time.h>
        -:   26:#include <time.h>
        -:   27:#include <unistd.h>
        -:   28:
        -:   29:const char PathSeparator =
        -:   30:#ifdef _WIN32
        -:   31:    '\\';
        -:   32:#else
        -:   33:    '/';
        -:   34:#endif
        -:   35:
        -:   36:#define _FILE_OFFSET_BITS 64
        -:   37:
       65:   38:u64 log_now() {
        -:   39:    struct timeval tv;
       65:   40:    gettimeofday(&tv, NULL);
        -:   41:
       65:   42:    u64 ret = (u64)(tv.tv_sec) * 1000 + (u64)(tv.tv_usec) / 1000;
        -:   43:
       65:   44:    return ret;
        -:   45:}
        -:   46:
       79:   47:int set_option(Log* log, int type, void* value)
        -:   48:{
       79:   49:    if (value == NULL) {
        2:   50:	fputs("error: value pointer cannot be NULL\n", stderr);
        2:   51:	return -1;
        -:   52:    }
       77:   53:    if (type == ShowColors) {
       13:   54:        log->show_colors = *((bool*)value);
       64:   55:    } else if (type == ShowStdout) {
        9:   56:        log->show_stdout = *((bool*)value);
       55:   57:    } else if (type == ShowTimestamp) {
        2:   58:        log->show_timestamp = *((bool*)value);
       53:   59:    } else if (type == ShowMillis) {
        7:   60:        log->show_millis = *((bool*)value);
       46:   61:    } else if (type == ShowLogLevel) {
        1:   62:        log->show_log_level = *((bool*)value);
       45:   63:    } else if (type == AutoRotate) {
        2:   64:        log->auto_rotate = *((bool*)value);
       43:   65:    } else if (type == DeleteRotation) {
        1:   66:        log->delete_rotation = *((bool*)value);
       42:   67:    } else if (type == MaxSizeBytes) {
        7:   68:	if(*((u64*)value) < 1) {
        2:   69:		fputs("error: MaxSizeBytes cannot be less than 1\n", stderr);
        2:   70:		return -1;
        -:   71:	}
        5:   72:        log->max_size_bytes = *((u64*)value);
       35:   73:    } else if (type == MaxAgeMillis) {
        3:   74:	if(*((u64*)value) < 1000) {
        1:   75:		fputs("error: MaxAgeMillis cannot be less than 1,000\n", stderr);
        1:   76:                return -1;
        -:   77:        }
        2:   78:        log->max_age_millis = *((u64*)value);
       32:   79:    } else if (type == LogFilePath) {
       20:   80:        char* buf = ((char*)value);
       20:   81:        int len = strlen(buf);
       20:   82:	if(len < 1) {
        1:   83:		fputs("error: LogFilePath must be at least 1 bytes long\n", stderr);
        1:   84:                return -1;
        -:   85:	}
       19:   86:        log->path = malloc(sizeof(char) * (len + 1));
       19:   87:        if (log->path == NULL || log->debug_malloc) {
        1:   88:	    if(log->path) free(log->path); // if debug_malloc is set
        1:   89:	    log->path = NULL;
        1:   90:            fputs("error: Could not allocate the required memory\n", stderr);
        1:   91:            return -1;
        -:   92:        }
       18:   93:        strcpy(log->path, buf);
       12:   94:    } else if (type == FileHeader) {
       12:   95:        char* buf = ((char*)value);
       12:   96:        int len = strlen(buf);
       12:   97:	if(len < 1) {
        1:   98:                fputs("error: FileHeader must be at least 1 bytes long\n", stderr);
        1:   99:                return -1;
        -:  100:        }
       11:  101:        char* tmp = malloc(sizeof(char) * (len + 1));
       11:  102:        if (tmp == NULL || log->debug_malloc) {
        1:  103:	    if(tmp) free(tmp); // if debug_malloc is set
        1:  104:	    tmp = NULL;
        1:  105:	    fputs("error: Could not allocate the required memory\n", stderr);
        1:  106:            return -1;
        -:  107:        }
       10:  108:        strcpy(tmp, buf);
       10:  109:        if (log->file_header != NULL)
        1:  110:            free(log->file_header);
       10:  111:        log->file_header = tmp;
        -:  112:    }
        -:  113:
       70:  114:    return 0;
        -:  115:}
        -:  116:
       29:  117:int do_logger(Log *log, int num, va_list valist) {
       29:  118:    int ret = 0;
        -:  119:
        -:  120:    // set defaults
       29:  121:    log->fp = NULL;
       29:  122:    log->level = Info; 
       29:  123:    log->show_colors = true;
       29:  124:    log->show_stdout = true;
       29:  125:    log->show_timestamp = true;
       29:  126:    log->show_millis = true;
       29:  127:    log->show_log_level = true;
       29:  128:    log->auto_rotate = false;
       29:  129:    log->delete_rotation = false;
       29:  130:    log->max_size_bytes = ULONG_MAX;
       29:  131:    log->max_age_millis = ULONG_MAX;
       29:  132:    log->path = NULL;
       29:  133:    log->file_header = NULL;
       29:  134:    log->off = 0;
       29:  135:    log->last_rotation = log_now();
       29:  136:    log->is_init = false;
       29:  137:    log->debug_malloc = false;
        -:  138:            
        -:  139:    // iterate through arg list for overrides
       96:  140:    for (int i = 0; i < num; i++) {
       74:  141:        LogConfigOption next = va_arg(valist, LogConfigOption);
       74:  142:        if (set_option(log, next.type, next.value)) {
        7:  143:            if (log->file_header != NULL)
        1:  144:                free(log->file_header);
        7:  145:            if (log->path != NULL)
        1:  146:                free(log->path);
        7:  147:	    log->path = NULL;
        7:  148:	    log->file_header = NULL;
        7:  149:            ret = -1;
        7:  150:            break;
        -:  151:        }
        -:  152:    }
       29:  153:    return ret;
        -:  154:}
        -:  155:
       28:  156:int logger(Log* log, int num, ...)
        -:  157:{
        -:  158:    va_list valist;
       28:  159:    va_start(valist, num);
       28:  160:    int ret = do_logger(log, num, valist);
       28:  161:    va_end(valist);
       28:  162:    return ret;
        -:  163:}
        -:  164:
       20:  165:int get_format(Log* log, LogLevel level, char* buf)
        -:  166:{
        -:  167:    char milli_buf[14];
        -:  168:    char log_level_buf[20];
        -:  169:    char dt_buf[40];
        -:  170:    char spacing[2];
       20:  171:    time_t t = time(NULL);
       20:  172:    struct tm tm = *localtime(&t);
        -:  173:
       20:  174:    if (log->show_millis) {
        -:  175:        struct timeval time;
       17:  176:        gettimeofday(&time, NULL);
       17:  177:        int millis = time.tv_usec / 1000;
       17:  178:        sprintf(milli_buf, ".%03d", millis);
        -:  179:    } else {
        3:  180:        strcpy(milli_buf, "");
        -:  181:    }
        -:  182:
       20:  183:    if (log->show_timestamp) {
       18:  184:        strcpy(spacing, " ");
        -:  185:    } else {
        2:  186:        strcpy(spacing, "");
        -:  187:    }
        -:  188:
       20:  189:    if (log->show_log_level) {
       19:  190:        if (level == Trace) {
        2:  191:            if (log->show_colors) {
        1:  192:                sprintf(log_level_buf, "%s(" ANSI_COLOR_YELLOW "TRACE" ANSI_COLOR_RESET ")", spacing);
        -:  193:            } else {
        1:  194:                sprintf(log_level_buf, "%s(TRACE)", spacing);
        -:  195:            }
       17:  196:        } else if (level == Debug) {
        4:  197:            if (log->show_colors) {
        1:  198:                sprintf(log_level_buf, "%s(" ANSI_COLOR_CYAN "DEBUG" ANSI_COLOR_RESET ")", spacing);
        -:  199:            } else {
        3:  200:                sprintf(log_level_buf, "%s(DEBUG)", spacing);
        -:  201:            }
       13:  202:        } else if (level == Info) {
        7:  203:            if (log->show_colors) {
        1:  204:                sprintf(log_level_buf, "%s(" ANSI_COLOR_GREEN "INFO" ANSI_COLOR_RESET ")", spacing);
        -:  205:            } else {
        6:  206:                sprintf(log_level_buf, "%s(INFO)", spacing);
        -:  207:            }
        6:  208:        } else if (level == Warn) {
        2:  209:            if (log->show_colors) {
        1:  210:                sprintf(log_level_buf, "%s(" ANSI_COLOR_MAGENTA "WARN" ANSI_COLOR_RESET ")", spacing);
        -:  211:            } else {
        1:  212:                sprintf(log_level_buf, "%s(WARN)", spacing);
        -:  213:            }
        4:  214:        } else if (level == Error) {
        2:  215:            if (log->show_colors) {
        1:  216:                sprintf(log_level_buf, "%s(" ANSI_COLOR_RED "ERROR" ANSI_COLOR_RESET ")", spacing);
        -:  217:            } else {
        1:  218:                sprintf(log_level_buf, "%s(ERROR)", spacing);
        -:  219:            }
        2:  220:        } else if (level == Fatal) {
        2:  221:            if (log->show_colors) {
        1:  222:                sprintf(log_level_buf, "%s(" ANSI_COLOR_BRIGHT_RED "FATAL" ANSI_COLOR_RESET ")", spacing);
        -:  223:            } else {
        1:  224:                sprintf(log_level_buf, "%s(FATAL)", spacing);
        -:  225:            }
        -:  226:        }
        -:  227:    } else {
        1:  228:        strcpy(log_level_buf, "");
        -:  229:    }
        -:  230:
       20:  231:    if (log->show_timestamp) {
       18:  232:        if (log->show_colors) {
        6:  233:            sprintf(
        -:  234:                dt_buf,
        -:  235:                "[" ANSI_COLOR_DIMMED
        -:  236:                "%d-%02d-%02d %02d:%02d:%02d%s" ANSI_COLOR_RESET
        -:  237:                "]",
        6:  238:                tm.tm_year + 1900,
        6:  239:                tm.tm_mon + 1,
        -:  240:                tm.tm_mday,
        -:  241:                tm.tm_hour,
        -:  242:                tm.tm_min,
        -:  243:                tm.tm_sec,
        -:  244:                milli_buf);
        -:  245:        } else {
       12:  246:            sprintf(
        -:  247:                dt_buf,
        -:  248:                "["
        -:  249:                "%d-%02d-%02d %02d:%02d:%02d%s"
        -:  250:                "]",
       12:  251:                tm.tm_year + 1900,
       12:  252:                tm.tm_mon + 1,
        -:  253:                tm.tm_mday,
        -:  254:                tm.tm_hour,
        -:  255:                tm.tm_min,
        -:  256:                tm.tm_sec,
        -:  257:                milli_buf);
        -:  258:        }
        -:  259:    } else {
        2:  260:        strcpy(dt_buf, "");
        -:  261:    }
        -:  262:
       20:  263:    if ((level == Info || level == Warn) && log->show_log_level) {
        9:  264:        strcpy(spacing, ":");
        -:  265:    } else {
       11:  266:        strcpy(spacing, "");
        -:  267:    }
        -:  268:
       20:  269:    sprintf(
        -:  270:        buf,
        -:  271:        "%s%s%s: ",
        -:  272:        dt_buf,
        -:  273:        log_level_buf,
        -:  274:        spacing);
       20:  275:    return 0;
        -:  276:}
        -:  277:
       87:  278:int do_log(Log* log, LogLevel level, char* line, bool is_plain, bool is_all, va_list args)
        -:  279:{
       87:  280:    if (!log->is_init) {
        1:  281:       fputs("error: log has not been initialized\n", stderr);
        1:  282:       return -1;
        -:  283:    }
       86:  284:    if (level >= log->level) {
        -:  285:        va_list args_copy;
       81:  286:        va_copy(args_copy, args);
        -:  287:
       81:  288:        int len = strlen(line);
       81:  289:        char fline[len + 100];
        -:  290:
       81:  291:        if (is_plain) {
       61:  292:            strcpy(fline, "");
        -:  293:        } else {
       20:  294:            get_format(log, level, fline);
        -:  295:        }
       81:  296:        strcat(fline, line);
       81:  297:        strcat(fline, "\n");
        -:  298:
       81:  299:        if (log->show_stdout || is_all) {
       34:  300:            vprintf(fline, args);
        -:  301:        }
       81:  302:        if (log->fp) {
       81:  303:            vfprintf(log->fp, fline, args_copy);
       81:  304:            log->off = ftello(log->fp);
        -:  305:        }
       81:  306:	if(log->auto_rotate) {
       12:  307:		if(log_need_rotate(log)) {
        2:  308:			log_rotate(log);
        -:  309:		}
        -:  310:	}
        -:  311:    }
       86:  312:    return 0;
        -:  313:}
        -:  314:
        2:  315:int log_all(Log* log, LogLevel level, char* line, ...)
        -:  316:{
        -:  317:    va_list args;
        2:  318:    va_start(args, line);
        2:  319:    int ret = do_log(log, level, line, false, true, args);
        2:  320:    va_end(args);
        2:  321:    return ret;
        -:  322:}
        -:  323:
       60:  324:int log_plain(Log* log, LogLevel level, char* line, ...)
        -:  325:{
        -:  326:    va_list args;
       60:  327:    va_start(args, line);
       60:  328:    int ret = do_log(log, level, line, true, false, args);
       60:  329:    va_end(args);
       60:  330:    return ret;
        -:  331:}
        -:  332:
       21:  333:int log_line(Log* log, LogLevel level, char* line, ...)
        -:  334:{
        -:  335:    va_list args;
       21:  336:    va_start(args, line);
       21:  337:    int ret = do_log(log, level, line, false, false, args);
       21:  338:    va_end(args);
       21:  339:    return ret;
        -:  340:}
        -:  341:
        6:  342:void log_set_level(Log* log, LogLevel level)
        -:  343:{
        6:  344:    log->level = level;
        6:  345:}
        -:  346:
       21:  347:int log_init(Log* log)
        -:  348:{
       21:  349:    if(log->is_init) {
        1:  350:	fputs("error: log has already been initialized\n", stderr);
        1:  351:	return -1;
        -:  352:    }
       20:  353:    if (log->path) {
       17:  354:        bool write_header = false;
       17:  355:        if (log->file_header && access(log->path, F_OK) != 0) {
        6:  356:            write_header = true;
        -:  357:        }
       17:  358:        log->fp = fopen(log->path, "a");
       17:  359:        if (write_header) {
        6:  360:            fprintf(log->fp, "%s\n", log->file_header);
        -:  361:        }
       17:  362:        fseek(log->fp, 0, SEEK_END);
       17:  363:        log->off = ftello(log->fp);
        -:  364:    }
       20:  365:    log->is_init = true;
       20:  366:    return 0;
        -:  367:}
        -:  368:
        8:  369:int log_set_config_option(Log* log, LogConfigOption option)
        -:  370:{
        8:  371:	printf("log->debug_malloc=%d\n", log->debug_malloc);
        8:  372:    if(!log->is_init) {
        1:  373:	fputs("error: log has not been initialized\n", stderr);
        1:  374:	return -1;
        -:  375:    }
        7:  376:    if (option.type == LogFilePath && !log->debug_malloc) { // bypass this when we're debugging malloc
        2:  377:	fputs("error: cannot change log file path after initialization\n", stderr);
        2:  378:        return -1;
        -:  379:    }
        -:  380:
        5:  381:    return set_option(log, option.type, option.value);
        -:  382:}
        -:  383:
        9:  384:int log_rotate(Log* log)
        9:  385:{
        -:  386:    // format:
        -:  387:    // name.log -> name.r_<mon>_<day>_<year>_<time>_<rand>.log
        -:  388:
        9:  389:    int ret = 0;
        9:  390:    char rotation_name[strlen(log->path) + 100];
        9:  391:    time_t t = time(NULL);
        9:  392:    struct tm tm = *localtime(&t);
        -:  393:
        9:  394:    char* fname = strrchr(log->path, PathSeparator);
        9:  395:    if (fname == NULL) {
        1:  396:        fname = log->path;
        -:  397:    } else {
        8:  398:	ret = -1;
        8:  399:        if (strlen(fname) > 0) {
        8:  400:            ret = 0;
        8:  401:            fname = fname + 1;
        -:  402:	}
        -:  403:    }
        -:  404:
        9:  405:    if(!log->is_init) {
        1:  406:	fputs("error: log has not been initialized\n", stderr);
        1:  407:	ret = -1;
        -:  408:    }
        -:  409:
        -:  410:    char* ext;
        9:  411:    if (ret == 0) {
        8:  412:        strncpy(rotation_name, log->path, fname - log->path);
        8:  413:        rotation_name[fname - log->path] = 0;
        -:  414:
        8:  415:        ext = strrchr(fname, '.');
        8:  416:        if (ext == NULL) {
        1:  417:            ext = fname + strlen(fname);
        -:  418:        }
        -:  419:    }
        -:  420:
        9:  421:    if (ret == 0) {
        -:  422:        char date_format[100];
        8:  423:        strncpy(rotation_name + (fname - log->path), fname, ext - fname);
        8:  424:        rotation_name[ext - log->path] = 0;
        8:  425:        strcat(rotation_name, ".r_");
        -:  426:        u64 r;
        8:  427:        ret = rand_u64(&r);
        8:  428:        if (ret == 0) {
        8:  429:            sprintf(date_format,
        -:  430:                "%d_%02d_%02d_%02d_%02d_%02d_%" PRIu64,
        8:  431:                tm.tm_year + 1900,
        8:  432:                tm.tm_mon + 1,
        -:  433:                tm.tm_mday,
        -:  434:                tm.tm_hour,
        -:  435:                tm.tm_min,
        -:  436:                tm.tm_sec,
        -:  437:                r);
        8:  438:            strcat(rotation_name, date_format);
        8:  439:            strcat(rotation_name, ext);
        8:  440:	    fclose(log->fp);
        8:  441:	    if(log->delete_rotation) {
        1:  442:		remove(log->path);
        -:  443:	    } else {
        7:  444:	    	rename(log->path, rotation_name);
        -:  445:	    }
        -:  446:
        8:  447:            log->fp = fopen(log->path, "w");
        8:  448:	    if(log->file_header)
        7:  449:            	fprintf(log->fp, "%s\n", log->file_header);
        8:  450:	    fseek(log->fp, 0, SEEK_END);
        8:  451:            log->off = ftello(log->fp);
        -:  452:        }
        -:  453:    }
        -:  454:
        9:  455:    if (ret == 0) {
        8:  456:        log->off = 0;
        8:  457:        log->last_rotation = log_now();
        -:  458:    }
        9:  459:    return ret;
        -:  460:}
        -:  461:
       28:  462:bool log_need_rotate(Log* log)
        -:  463:{
       28:  464:    u64 now = log_now();
       28:  465:    u64 diff = now - log->last_rotation;
       28:  466:    return log->off > log->max_size_bytes || diff > log->max_age_millis;
        -:  467:}
        -:  468:
       16:  469:int log_close(Log* log)
        -:  470:{
       16:  471:    if (log->fp) {
       16:  472:        fclose(log->fp);
       16:  473:	log->fp = NULL;
        -:  474:    }
       16:  475:    return 0;
        -:  476:}
        -:  477:
       77:  478:int _log_allocate_config_option(LogConfigOption* option, size_t size, bool debug_malloc_err, void *value) {
       77:  479:    int ret = 0;
        -:  480:
       77:  481:    option->value = malloc(size);
       77:  482:    if(option->value == NULL || debug_malloc_err) {
        1:  483:        ret = -1;
        1:  484:        fputs("error: Could not allocate the required memory\n", stderr);
        -:  485:    }
        -:  486:
       77:  487:    return ret;
        -:  488:}
        -:  489:
       13:  490:int log_config_option_show_colors(LogConfigOption* option, bool value)
        -:  491:{
       13:  492:    option->type = ShowColors;
       13:  493:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
       13:  494:    if(!ret) *((bool*)option->value) = value;
       13:  495:    return ret;
        -:  496:}
        -:  497:
        9:  498:int log_config_option_show_stdout(LogConfigOption* option, bool value)
        -:  499:{
        9:  500:    option->type = ShowStdout;
        9:  501:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        9:  502:    if(!ret) *((bool*)option->value) = value;
        9:  503:    return ret;
        -:  504:}
        -:  505:
        2:  506:int log_config_option_show_timestamp(LogConfigOption* option, bool value)
        -:  507:{
        2:  508:    option->type = ShowTimestamp;
        2:  509:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        2:  510:    if(!ret) *((bool*)option->value) = value;
        2:  511:    return ret;
        -:  512:}
        -:  513:
        7:  514:int log_config_option_show_millis(LogConfigOption* option, bool value)
        -:  515:{
        7:  516:    option->type = ShowMillis;
        7:  517:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        7:  518:    if(!ret) *((bool*)option->value) = value;
        7:  519:    return ret;
        -:  520:}
        -:  521:
        1:  522:int log_config_option_show_log_level(LogConfigOption* option, bool value)
        -:  523:{
        1:  524:    option->type = ShowLogLevel;
        1:  525:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        1:  526:    if(!ret) *((bool*)option->value) = value;
        1:  527:    return ret;
        -:  528:}
        -:  529:
        2:  530:int log_config_option_auto_rotate(LogConfigOption* option, bool value)
        -:  531:{
        2:  532:    option->type = AutoRotate;
        2:  533:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        2:  534:    if(!ret) *((bool*)option->value) = value;
        2:  535:    return ret;
        -:  536:}
        -:  537:
        1:  538:int log_config_option_delete_rotation(LogConfigOption* option, bool value)
        -:  539:{
        1:  540:    option->type = DeleteRotation;
        1:  541:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        1:  542:    if(!ret) *((bool*)option->value) = value;
        1:  543:    return ret;
        -:  544:}
        -:  545:
        6:  546:int log_config_option_max_size_bytes(LogConfigOption* option, u64 value)
        -:  547:{
        6:  548:    option->type = MaxSizeBytes;
        6:  549:    int ret = _log_allocate_config_option(option, sizeof(u64), false, &value);
        6:  550:    if(!ret) *((u64*)option->value) = value;
        6:  551:    return ret;
        -:  552:}
        -:  553:
        3:  554:int log_config_option_max_age_millis(LogConfigOption* option, u64 value)
        -:  555:{
        3:  556:    option->type = MaxAgeMillis;
        3:  557:    int ret = _log_allocate_config_option(option, sizeof(u64), false, &value);
        3:  558:    if(!ret) *((u64*)option->value) = value;
        3:  559:    return ret;
        -:  560:}
        -:  561:
       21:  562:int log_config_option_log_file_path(LogConfigOption* option, char* value)
        -:  563:{
       21:  564:    option->type = LogFilePath;
       21:  565:    int ret = 0;
       21:  566:    if (value == NULL) {
        1:  567:        option->value = NULL;
        -:  568:    } else {
       20:  569:        int len = strlen(value);
       20:  570:        ret = _log_allocate_config_option(option, sizeof(char) * (len + 1), false, &value);
       20:  571:        if(!ret) strcpy(option->value, value);
        -:  572:    }
       21:  573:    return ret;
        -:  574:}
        -:  575:
       13:  576:int log_config_option_file_header(LogConfigOption* option, char* value)
        -:  577:{
       13:  578:    option->type = FileHeader;
       13:  579:    int ret = 0;
       13:  580:    if (value == NULL) {
        1:  581:        option->value = NULL;
        -:  582:    } else {
       12:  583:        int len = strlen(value);
       12:  584:    	ret = _log_allocate_config_option(option, sizeof(char) * (len + 1), false, &value);
       12:  585:    	if(!ret) strcpy(option->value, value);
        -:  586:    }
       13:  587:    return ret;
        -:  588:}
        -:  589:
       69:  590:void log_config_option_free(LogConfigOption* option)
        -:  591:{
       69:  592:    if (option->value != NULL)
       67:  593:        free(option->value);
       69:  594:}
        -:  595:
       21:  596:void log_free(Log* log)
        -:  597:{
       21:  598:    if (log->path)
       16:  599:        free(log->path);
       21:  600:    if (log->file_header)
        7:  601:        free(log->file_header);
       21:  602:}
        -:  603:
        -:  604:pthread_mutex_t _global_logger_mutex__ = PTHREAD_MUTEX_INITIALIZER;
        -:  605:Log _global_logger__;
        -:  606:bool _global_logger_is_init__ = false;
        -:  607:
        4:  608:int global_logger(bool is_plain, bool is_all, LogLevel level, LogLevel global, char *line, ...) {
        4:  609:    int ret = 0;
        4:  610:    pthread_mutex_lock(&_global_logger_mutex__);
        -:  611:
        4:  612:    if(!_global_logger_is_init__) {
        1:  613:	ret = logger(&_global_logger__, 0);
        1:  614:	if(ret == 0)
        1:  615:		ret = log_init(&_global_logger__);
        1:  616:	if(ret == 0)
        1:  617:        	_global_logger_is_init__ = true;
        -:  618:    }
        -:  619:
        4:  620:    if(ret == 0) {
        4:  621:    	log_set_level(&_global_logger__, global);
        -:  622:
        -:  623:    	va_list args;
        4:  624:    	va_start(args, line);
        4:  625:    	ret = do_log(&_global_logger__, level, line, is_plain, is_all, args);
        4:  626:    	va_end(args);
        -:  627:    }
        -:  628:
        4:  629:    pthread_mutex_unlock(&_global_logger_mutex__);
        4:  630:    return ret;
        -:  631:}
        -:  632:
        2:  633:int init_global_logger(int num, ...) {
        2:  634:	if(_global_logger_is_init__)
        1:  635:		return -1;
        1:  636:	int ret = 0;
        1:  637:	pthread_mutex_lock(&_global_logger_mutex__);
        -:  638:
        -:  639:	va_list valist;
        1:  640:        va_start(valist, num);
        1:  641:	ret = do_logger(&_global_logger__, num, valist);
        1:  642:	va_end(valist);
        -:  643:
        1:  644:	if(ret == 0)
        1:  645:		ret = log_init(&_global_logger__);
        1:  646:	if(ret == 0)
        1:  647:		_global_logger_is_init__ = true;
        -:  648:
        1:  649:	pthread_mutex_unlock(&_global_logger_mutex__);
        1:  650:	return ret;
        -:  651:}
        -:  652:
        1:  653:int global_log_rotate() {
        1:  654:	pthread_mutex_lock(&_global_logger_mutex__);
        1:  655:	int ret = log_rotate(&_global_logger__);
        1:  656:	pthread_mutex_unlock(&_global_logger_mutex__);
        1:  657:	return ret;
        -:  658:}
        -:  659:
        1:  660:bool global_log_need_rotate() {
        1:  661:	pthread_mutex_lock(&_global_logger_mutex__);
        1:  662:        bool ret = log_need_rotate(&_global_logger__);
        1:  663:        pthread_mutex_unlock(&_global_logger_mutex__);
        1:  664:        return ret;
        -:  665:}
        -:  666:
        1:  667:int global_log_config_option(LogConfigOption option) {
        1:  668:	pthread_mutex_lock(&_global_logger_mutex__);
        1:  669:	int ret = log_set_config_option(&_global_logger__, option);
        1:  670:	pthread_mutex_unlock(&_global_logger_mutex__);
        1:  671:	return ret;
        -:  672:}
        -:  673:
        1:  674:void _debug_global_logger_is_init__() {
        1:  675:        _global_logger_is_init__ = false;
        1:  676:}
        -:  677:
        -:    0:Source:config.c
        -:    0:Graph:./config.gcno
        -:    0:Data:./config.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/config.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        2:   20:void configure_u32(uint32_t* value, uint32_t* configured, uint32_t d)
        -:   21:{
        2:   22:    if (configured == NULL) {
        1:   23:        *value = d;
        -:   24:    } else {
        1:   25:        *value = *configured;
        -:   26:    }
        2:   27:}
        -:   28:
        2:   29:void configure_u64(uint64_t* value, uint64_t* configured, uint64_t d)
        -:   30:{
        2:   31:    if (configured == NULL) {
        1:   32:        *value = d;
        -:   33:    } else {
        1:   34:        *value = *configured;
        -:   35:    }
        2:   36:}
        -:   37:
        2:   38:void configure_u128(__uint128_t* value, __uint128_t* configured, __uint128_t d)
        -:   39:{
        2:   40:    if (configured == NULL) {
        1:   41:        *value = d;
        -:   42:    } else {
        1:   43:        *value = *configured;
        -:   44:    }
        2:   45:}
        -:   46:
        2:   47:void configure_bool(bool* value, bool* configured, bool d)
        -:   48:{
        2:   49:    if (configured == NULL) {
        1:   50:        *value = d;
        -:   51:    } else {
        1:   52:        *value = *configured;
        -:   53:    }
        2:   54:}
        -:   55:
        2:   56:void configure_u8(uint8_t* value, uint8_t* configured, uint8_t d)
        -:   57:{
        2:   58:    if (configured == NULL) {
        1:   59:        *value = d;
        -:   60:    } else {
        1:   61:        *value = *configured;
        -:   62:    }
        2:   63:}
        -:   64:
        2:   65:void configure_u16(uint16_t* value, uint16_t* configured, uint16_t d)
        -:   66:{
        2:   67:    if (configured == NULL) {
        1:   68:        *value = d;
        -:   69:    } else {
        1:   70:        *value = *configured;
        -:   71:    }
        2:   72:}
        -:   73:
        2:   74:void configure_string(char* value, char* configured, char* d, int max_len)
        -:   75:{
        2:   76:    if (configured == NULL) {
        1:   77:        int len = max_len - 1;
        1:   78:        int strlen_value = strlen(d);
        1:   79:        if (strlen_value < len) {
        1:   80:            len = strlen_value;
        -:   81:        }
        1:   82:        memcpy(value, d, len);
        1:   83:        value[len] = 0;
        -:   84:    } else {
        1:   85:        int len = max_len - 1;
        1:   86:        int strlen_value = strlen(configured);
        1:   87:        if (strlen_value < len) {
        1:   88:            len = strlen_value;
        -:   89:        }
        1:   90:        memcpy(value, configured, len);
        1:   91:        value[len] = 0;
        -:   92:    }
        2:   93:}
        -:    0:Source:rand.c
        -:    0:Graph:./rand.gcno
        -:    0:Data:./rand.gcda
        -:    0:Runs:21
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <sys/random.h>
        -:   17:
        4:   18:int rand_i8(i8* v)
        -:   19:{
        -:   20:    char buf[1];
        4:   21:    int ret = getentropy(buf, 1);
        4:   22:    *v = (i8)buf[0];
        4:   23:    return ret;
        -:   24:}
        -:   25:
        4:   26:int rand_u8(u8* v)
        -:   27:{
        -:   28:    char buf[1];
        4:   29:    int ret = getentropy(buf, 1);
        4:   30:    *v = (u8)buf[0];
        4:   31:    return ret;
        -:   32:}
        -:   33:
        4:   34:int rand_i16(i16* v)
        -:   35:{
        -:   36:    char buf[2];
        4:   37:    int ret = getentropy(buf, 2);
        4:   38:    *v = ((i16)buf[0] << 8) + (i16)buf[1];
        4:   39:    return ret;
        -:   40:}
        -:   41:
        4:   42:int rand_u16(u16* v)
        -:   43:{
        -:   44:    char buf[2];
        4:   45:    int ret = getentropy(buf, 2);
        4:   46:    *v = ((u16)buf[0] << 8) + (u16)buf[1];
        4:   47:    return ret;
        -:   48:}
        -:   49:
        1:   50:int rand_i32(int32_t* v)
        -:   51:{
        -:   52:    char buf[4];
        1:   53:    int ret = getentropy(buf, 4);
        1:   54:    *v = ((int32_t)buf[0] << 24) + ((int32_t)buf[1] << 16) + ((int32_t)buf[2] << 8) + (int32_t)buf[3];
        1:   55:    return ret;
        -:   56:}
        -:   57:
        2:   58:int rand_u32(uint32_t* v)
        -:   59:{
        -:   60:    char buf[4];
        2:   61:    int ret = getentropy(buf, 4);
        2:   62:    *v = ((uint32_t)buf[0] << 24) + ((uint32_t)buf[1] << 16) + ((uint32_t)buf[2] << 8) + (uint32_t)buf[3];
        2:   63:    return ret;
        -:   64:}
        -:   65:
        1:   66:int rand_i64(int64_t* v)
        -:   67:{
        -:   68:    char buf[8];
        1:   69:    int ret = getentropy(buf, 8);
        1:   70:    *v = ((int64_t)buf[0] << 56) + ((int64_t)buf[1] << 48) + ((int64_t)buf[2] << 40) + ((int64_t)buf[3] << 32) + ((int64_t)buf[4] << 24) + ((int64_t)buf[5] << 16) + ((int64_t)buf[6] << 8) + (int64_t)buf[7];
        1:   71:    return ret;
        -:   72:}
        -:   73:
       10:   74:int rand_u64(uint64_t* v)
        -:   75:{
        -:   76:    char buf[8];
       10:   77:    int ret = getentropy(buf, 8);
       10:   78:    *v = ((uint64_t)buf[0] << 56) + ((uint64_t)buf[1] << 48) + ((uint64_t)buf[2] << 40) + ((uint64_t)buf[3] << 32) + ((uint64_t)buf[4] << 24) + ((uint64_t)buf[5] << 16) + ((uint64_t)buf[6] << 8) + (uint64_t)buf[7];
       10:   79:    return ret;
        -:   80:}
        -:   81:
        1:   82:int rand_i128(i128* v)
        -:   83:{
        -:   84:    char buf[16];
        1:   85:    int ret = getentropy(buf, 16);
        1:   86:    *v = ((i128)buf[0] << 120) + ((i128)buf[1] << 112) + ((i128)buf[2] << 104) + ((i128)buf[3] << 96) + ((i128)buf[4] << 88) + ((i128)buf[5] << 80) + ((i128)buf[6] << 72) + ((i128)buf[7] << 64) + ((i128)buf[8] << 56) + ((i128)buf[9] << 48) + ((i128)buf[10] << 40) + ((i128)buf[11] << 32) + ((i128)buf[12] << 24) + ((i128)buf[13] << 16) + ((i128)buf[14] << 8) + (i128)buf[15];
        1:   87:    return ret;
        -:   88:}
        -:   89:
        1:   90:int rand_u128(u128* v)
        -:   91:{
        -:   92:    char buf[16];
        1:   93:    int ret = getentropy(buf, 16);
        1:   94:    *v = ((u128)buf[0] << 120) + ((u128)buf[1] << 112) + ((u128)buf[2] << 104) + ((u128)buf[3] << 96) + ((u128)buf[4] << 88) + ((u128)buf[5] << 80) + ((u128)buf[6] << 72) + ((u128)buf[7] << 64) + ((u128)buf[8] << 56) + ((u128)buf[9] << 48) + ((u128)buf[10] << 40) + ((u128)buf[11] << 32) + ((u128)buf[12] << 24) + ((u128)buf[13] << 16) + ((u128)buf[14] << 8) + (u128)buf[15];
        1:   95:    return ret;
        -:   96:}
        -:   97:
        2:   98:int rand_bytes(void* buf, size_t length)
        -:   99:{
        2:  100:    return getentropy(buf, length);
        -:  101:}
        -:    0:Source:main.c
        -:    0:Graph:./main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdio.h>
        -:   16:#include <log/log.h>
        -:   17:#include <util/misc.h>
        -:   18:
        -:   19:#define LOG_LEVEL Info
        -:   20:
    #####:   21:int main(int argc, char** argv)
        -:   22:{
        -:   23:    LogConfigOption opt1, opt2, opt3;
    #####:   24:    log_config_option_show_colors(&opt1, true);
    #####:   25:    log_config_option_show_stdout(&opt2, true);
    #####:   26:    log_config_option_show_timestamp(&opt3, false);
        -:   27:
    #####:   28:    init_global_logger(2, opt1, opt2);
    #####:   29:    log_config_option_free(&opt1);
    #####:   30:    log_config_option_free(&opt2);
    #####:   31:    info("Main currently doesn't do %s.", "anything");
    #####:   32:    global_log_config_option(opt3);
    #####:   33:    log_config_option_free(&opt3);
    #####:   34:    info("Main currently doesn't do %s.", "anything");
    #####:   35:    info("end");
        -:   36:
    #####:   37:    return 0;
        -:   38:}
        -:    0:Source:misc.c
        -:    0:Graph:./misc.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/constants.h>
        -:   16:#include <util/misc.h>
        -:   17:#include <log/log.h>
        -:   18:
        -:   19:#define LOG_LEVEL Debug
        -:   20:
    #####:   21:int is_white_space(char ch)
        -:   22:{
    #####:   23:    debug("is whitespace '%c'", ch);
    #####:   24:    if (ch == '\n' || ch == '\t' || ch == '\r' || ch == '\v' || ch == '\f' || ch == ' ')
    #####:   25:        return TRUE;
        -:   26:    else
    #####:   27:        return FALSE;
        -:   28:}
        -:   29:
    #####:   30:int is_ident_start(char ch)
        -:   31:{
    #####:   32:    if ((ch <= 'Z' && ch >= 'A') || (ch <= 'z' && ch >= 'a') || ch == '_') {
    #####:   33:        return TRUE;
        -:   34:    } else {
    #####:   35:        return FALSE;
        -:   36:    }
        -:   37:}
        -:   38:
    #####:   39:int is_ident_secondary(char ch)
        -:   40:{
    #####:   41:    if (is_ident_start(ch) || (ch <= '9' && ch >= '0')) {
    #####:   42:        return TRUE;
        -:   43:    } else {
    #####:   44:        return FALSE;
        -:   45:    }
        -:   46:}
        -:   47:
    #####:   48:int is_joint_possible(char ch)
        -:   49:{
    #####:   50:    if (ch == '.' || ch == '=' || ch == '/' || ch == '+' || ch == '&' || ch == '<' || ch == '-' || ch == '%' || ch == '^' || ch == '*' || ch == '>' || ch == '|' || ch == '!' || ch == ':') {
    #####:   51:        return TRUE;
        -:   52:    } else {
    #####:   53:        return FALSE;
        -:   54:    }
        -:   55:}</textarea>
		</p>
	</body>
</html>

