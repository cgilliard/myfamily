<!DOCTYPE html>
<html>
	<head>
		<title>Code Coverage Report</title>
		<script src="chart.js"></script>
		<style>
			.chart {
				width: 900px;
			}
			.textarea {
				overflow:auto;
				resize:none;
			}
		</style>
	</head>
	<body>
		 <p align="center">
                        Code Coverage is currently 17.11%.
                </p>
		<center>
			<div class="chart">
				<canvas id="chart"></canvas>
			</div>

			<div class="chart">
				<canvas id="chart2"></canvas>
			</div>
		</center>
		<script>
			function format_date(timestamp, time_frame) {
				var date = new Date(timestamp);
				var day_of_month = date.getDate();
				var full_year = date.getFullYear();
				var month = 1 + date.getMonth();
				var hours = date.getHours();
				var minutes = date.getMinutes();
				var seconds = date.getSeconds();
				var am_pm = 'AM';

				if(seconds < 10) {
					seconds = '0' + seconds;
				}
				if(minutes < 10) {
					minutes = '0' + minutes;
				}
				if(hours == 12) {
					am_pm = 'PM';
				} else if(hours > 12) {
					hours -= 12;
					am_pm = 'PM';
				}
				if(hours == 0) {
					hours = 12;
				}

				return month + '/' + day_of_month + '/' + full_year + ' ' +
					hours + ':' + minutes + ':' + seconds + ' ' + am_pm;
			}

			let raw_data = [16.67,
15.45,
15.45,
15.45,];
			let labels = [format_date(1724296044 * 1000 ),
format_date(1724297686 * 1000 ),
format_date(1724303299 * 1000 ),
format_date(1724310067 * 1000 ),];
			let raw_data2 = [1752,
1638,
1638,
1638,];
                        let raw_data3 = [292,
253,
253,
253,];

			const data = {
				labels: labels,
				datasets: [{
					label: 'Code Coverage',
					backgroundColor: 'rgb(31,176,245)',
					borderColor: 'rgb(31,176,245)',
					data: raw_data,
				}]
			};

			const data2 = {
                                labels: labels,
                                datasets: [{
                                        label: 'Lines of Code',
                                        backgroundColor: 'rgb(31,176,245)',
                                        borderColor: 'rgb(31,176,245)',
                                        data: raw_data2,
                                },
                                {
                                        label: 'Covered Lines',
                                        backgroundColor: 'rgb(240,128,128)',
                                        borderColor: 'rgb(240,128,128)',
                                        data: raw_data3,
                                }]
                        };

			const config = {
				type: 'line',
				data: data,
				options: {}
			};

			const config2 = {
				type: 'line',
				data: data2,
				options: {}
			};

			const chart = new Chart(
				document.getElementById('chart'),
				config
			);

			const chart2 = new Chart(
				document.getElementById('chart2'),
				config2
			);

		</script>

		<p align="center">
			Raw gcov output:<br/>
			<textarea readonly class="textarea" rows="50" cols="100">        -:    0:Source:heap.c
        -:    0:Graph:heap.gcno
        -:    0:Data:heap.gcda
        -:    0:Runs:12
        -:    0:Programs:1
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/heap.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:
        -:   19:// internal representation of the HeapDataParamsConfig with the required
        -:   20:// free_list_head value.
        -:   21:typedef struct HeapDataParams {
        -:   22:	HeapDataParamsConfig config;
        -:   23:	u32 free_list_head; // The next slab that is free
        -:   24:} HeapDataParams;
        -:   25:
        -:   26:// The data associated with each slab_size.
        -:   27:typedef struct HeapData {
        -:   28:	void **data;	    // pointers to each chunk of data
        -:   29:	u32 *free_list;	    // the pointers for free slabs.
        -:   30:	u32 count;	    // the number of chunks currently allocated
        -:   31:	u32 cur_slabs;	    // the number of slabs currently allocated
        -:   32:	HeapDataParams hdp; // The heap data params for this HeapData
        -:   33:} HeapData;
        -:   34:
        -:   35:// The opaque pointer type which is stored in the HeapAllocator data structure
        -:   36:// which is used to access a HeapAllocator.
        -:   37:typedef struct HeapAllocatorImpl {
        -:   38:	u32 hd_size;		    // number of sizes available
        -:   39:	HeapAllocatorConfig config; // the configuration
        -:   40:	HeapData *hd_arr;	    // The array of heap data.
        -:   41:} HeapAllocatorImpl;
        -:   42:
        -:   43:// debugging options/counters
        -:   44:u64 __malloc_count = 0;
        -:   45:u64 __free_count = 0;
        -:   46:bool __debug_build_allocator_malloc_fail1 = false;
        -:   47:bool __debug_build_allocator_malloc_fail2 = false;
        -:   48:bool __debug_build_allocator_malloc_fail3 = false;
        -:   49:bool __debug_build_allocator_malloc_fail4 = false;
        -:   50:bool __debug_build_allocator_malloc_fail5 = false;
        -:   51:bool __debug_build_allocator_malloc_fail6 = false;
        -:   52:bool __debug_build_allocator_malloc_fail7 = false;
        -:   53:bool __debug_build_allocator_malloc_fail8 = false;
        -:   54:
      121:   55:void *do_malloc(size_t size) {
      121:   56:	__malloc_count += 1;
      121:   57:	void *ret = malloc(size);
        -:   58:	// printf("malloc %zu [%p (%llu)]\n", size, ret, __malloc_count);
      121:   59:	return ret;
        -:   60:}
        -:   61:
      121:   62:void do_free(void *ptr) {
      121:   63:	__free_count += 1;
        -:   64:	// printf("free %p (%llu)\n", ptr, __free_count);
      121:   65:	free(ptr);
      121:   66:}
        -:   67:
       21:   68:void *do_realloc(void *ptr, size_t size) {
       21:   69:	void *ret = realloc(ptr, size);
        -:   70:	// printf("realloc %zu [old=%p,new=%p]\n", size, ptr, ret);
       21:   71:	return ret;
        -:   72:}
        -:   73:
        5:   74:void *fat_ptr_data(FatPtr *ptr) { return ptr->data; }
        -:   75:
        1:   76:u64 fat_ptr_len(FatPtr *ptr) { return ptr->len; }
        -:   77:
        5:   78:u64 fat_ptr_id(FatPtr *ptr) { return ptr->id; }
        -:   79:
       32:   80:int heap_allocator_init_free_list(HeapData *hd, u64 index, u32 slabs,
        -:   81:				  bool last_is_uint_max) {
       32:   82:	hd->data[index] = NULL; // set to NULL for cleanup consistency
        -:   83:
        -:   84:	// allocate memory for slabs
       32:   85:	if (!__debug_build_allocator_malloc_fail4)
       30:   86:		hd->data[index] = do_malloc(hd->hdp.config.slab_size * slabs);
       32:   87:	if (hd->data[index] == NULL)
        2:   88:		return -1;
        -:   89:
       30:   90:	void *tmp = NULL;
        -:   91:
        -:   92:	// allocate / or reallocate the freelist
       30:   93:	if (!__debug_build_allocator_malloc_fail5) {
       28:   94:		if (index == 0)
       18:   95:			tmp = do_malloc(sizeof(u32) * slabs);
        -:   96:		else {
       20:   97:			tmp = do_realloc(hd->free_list,
       10:   98:					 sizeof(u32) * (hd->cur_slabs + slabs));
        -:   99:		}
       28:  100:	}
        -:  101:
       30:  102:	if (!tmp) {
        2:  103:		do_free(hd->data[index]);
        2:  104:		return -1;
        -:  105:	}
        -:  106:
       28:  107:	hd->free_list = tmp;
        -:  108:
        -:  109:	// initialize the values of the free list.
       28:  110:	u32 offset = index * hd->hdp.config.slabs_per_resize;
      436:  111:	for (u64 i = 0; i < slabs; i++) {
      408:  112:		if ((i == (slabs - 1)) && last_is_uint_max)
       27:  113:			hd->free_list[i + offset] = UINT32_MAX;
        -:  114:		else
      381:  115:			hd->free_list[i + offset] = offset + i + 1;
      408:  116:	}
        -:  117:
       28:  118:	return 0;
       32:  119:}
        -:  120:
        -:  121:// compare function used for sorting.
        4:  122:int heap_data_compare(const void *p1, const void *p2) {
        4:  123:	int ret = 0;
        -:  124:
        4:  125:	HeapData d1 = *(HeapData *)p1;
        4:  126:	HeapData d2 = *(HeapData *)p2;
        -:  127:
        4:  128:	if (d1.hdp.config.slab_size > d2.hdp.config.slab_size)
        1:  129:		ret = 1;
        3:  130:	else if (d1.hdp.config.slab_size < d2.hdp.config.slab_size)
        2:  131:		ret = -1;
        -:  132:
        4:  133:	return ret;
        -:  134:}
        -:  135:
        -:  136:// initialize the heap data params
       23:  137:int heap_allocator_init_hdp(HeapAllocator *ptr, HeapDataParamsConfig *hdp,
        -:  138:			    u64 index) {
        -:  139:
        -:  140:	// set some value in case of a failure below such that cleanup can
        -:  141:	// succeed
       23:  142:	int ret = 0;
       23:  143:	ptr->impl->hd_arr[index].hdp.config = *hdp;
       23:  144:	ptr->impl->hd_arr[index].hdp.free_list_head = 0;
       23:  145:	ptr->impl->hd_arr[index].cur_slabs = 0;
       23:  146:	ptr->impl->hd_arr[index].count =
       23:  147:	    ptr->impl->hd_arr[index].hdp.config.initial_chunks;
        -:  148:
        -:  149:	// if we have initial chunks, initialize them
       23:  150:	if (ptr->impl->hd_arr[index].hdp.config.initial_chunks) {
       20:  151:		ptr->impl->hd_arr[index].data = NULL;
        -:  152:
        -:  153:		// try to allocate space for the data for this size
       20:  154:		if (!__debug_build_allocator_malloc_fail8)
       19:  155:			ptr->impl->hd_arr[index].data = do_malloc(
       19:  156:			    ptr->impl->hd_arr[index].hdp.config.initial_chunks *
        -:  157:			    sizeof(void *));
        -:  158:
        -:  159:		// if NULL return error
       20:  160:		if (ptr->impl->hd_arr[index].data == NULL)
        1:  161:			return -1;
        -:  162:
        -:  163:		// set cur_slabs value
       19:  164:		ptr->impl->hd_arr[index].cur_slabs =
       38:  165:		    ptr->impl->hd_arr[index].hdp.config.initial_chunks *
       19:  166:		    ptr->impl->hd_arr[index].hdp.config.slabs_per_resize;
        -:  167:
        -:  168:		// initialize the initial_chunks of the free list
       19:  169:		bool last_is_uint_max = false;
       19:  170:		ptr->impl->hd_arr[index].free_list = NULL;
       39:  171:		for (u64 i = 0;
       39:  172:		     i < ptr->impl->hd_arr[index].hdp.config.initial_chunks;
       20:  173:		     i++) {
        -:  174:
       40:  175:			if (i ==
       20:  176:			    ptr->impl->hd_arr[index].hdp.config.initial_chunks -
        -:  177:				1)
       19:  178:				last_is_uint_max = true;
       20:  179:			if (heap_allocator_init_free_list(
       20:  180:				&ptr->impl->hd_arr[index], i,
       20:  181:				ptr->impl->hd_arr[index]
       20:  182:				    .hdp.config.slabs_per_resize,
       20:  183:				last_is_uint_max))
        2:  184:				ret = -1;
       20:  185:		}
       19:  186:	} else
        3:  187:		ptr->impl->hd_arr[index].data = NULL;
       22:  188:	return ret;
       23:  189:}
        -:  190:
       24:  191:int heap_allocator_build(HeapAllocator *ptr, HeapAllocatorConfig *config,
        -:  192:			 int heap_data_params_count, ...) {
        -:  193:
        -:  194:	// check inputs
       24:  195:	if (ptr == NULL || config == NULL || heap_data_params_count >= 256) {
        1:  196:		errno = EINVAL;
        1:  197:		return -1;
        -:  198:	}
        -:  199:
        -:  200:	// allocate the HeapAllocatorImpl
       23:  201:	if (!__debug_build_allocator_malloc_fail1)
       22:  202:		ptr->impl = do_malloc(sizeof(HeapAllocatorImpl));
       23:  203:	if (ptr->impl == NULL || __debug_build_allocator_malloc_fail1)
        1:  204:		return -1;
        -:  205:
       22:  206:	ptr->impl->hd_size = 0;
        -:  207:
        -:  208:	// copy the config
       22:  209:	ptr->impl->config = *config;
        -:  210:
        -:  211:	// allocate heap data array
       22:  212:	ptr->impl->hd_arr = NULL;
       22:  213:	if (!__debug_build_allocator_malloc_fail2)
       21:  214:		ptr->impl->hd_arr =
       21:  215:		    do_malloc(sizeof(HeapData) * heap_data_params_count);
       22:  216:	if (ptr->impl->hd_arr == NULL || __debug_build_allocator_malloc_fail2) {
        1:  217:		heap_allocator_cleanup(ptr);
        1:  218:		return -1;
        -:  219:	}
       21:  220:	ptr->impl->hd_size = heap_data_params_count;
        -:  221:
        -:  222:	// iterate through specified heap data params
        -:  223:	va_list hdps;
       21:  224:	va_start(hdps, heap_data_params_count);
       41:  225:	for (u64 i = 0; i < heap_data_params_count; i++) {
       24:  226:		HeapDataParamsConfig hdp = va_arg(hdps, HeapDataParamsConfig);
       24:  227:		ptr->impl->hd_arr[i].count = 0; // init to 0 for safe cleanup
       24:  228:		ptr->impl->hd_arr[i].data = NULL;
       24:  229:		if ((__debug_build_allocator_malloc_fail3 && i > 0) ||
       24:  230:		    heap_allocator_init_hdp(ptr, &hdp, i)) {
        4:  231:			ptr->impl->hd_size = i; // update for cleanup, others
        -:  232:						// did not get allocated
        4:  233:			if (ptr->impl->hd_arr[i].data) {
        2:  234:				do_free(ptr->impl->hd_arr[i].data);
        2:  235:			}
        4:  236:			heap_allocator_cleanup(ptr);
        4:  237:			return -1;
        -:  238:		}
       20:  239:	}
        -:  240:
       17:  241:	if (heap_data_params_count) {
       15:  242:		qsort(ptr->impl->hd_arr, heap_data_params_count,
        -:  243:		      sizeof(HeapData), heap_data_compare);
       15:  244:	}
        -:  245:
        -:  246:	// check invalid configurations
       17:  247:	u64 last_size = 0;
       34:  248:	for (u64 i = 0; i < heap_data_params_count; i++) {
       19:  249:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == 0) {
        -:  250:			// no 0 sized slabs allowed
        1:  251:			errno = EINVAL;
        1:  252:			heap_allocator_cleanup(ptr);
        1:  253:			return -1;
        -:  254:		}
        -:  255:		// note: logic correct because array is sorted.
       18:  256:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == last_size) {
        -:  257:			// Duplicate slab_size
        1:  258:			errno = EEXIST;
        1:  259:			heap_allocator_cleanup(ptr);
        1:  260:			return -1;
        -:  261:		}
       17:  262:		last_size = ptr->impl->hd_arr[i].hdp.config.slab_size;
       17:  263:	}
        -:  264:
       15:  265:	va_end(hdps);
        -:  266:
       15:  267:	return 0;
       24:  268:}
        -:  269:
        -:  270:// binary search for the correct slab size
      390:  271:int heap_allocator_index(HeapAllocator *ptr, u64 size) {
      390:  272:	int ret = -1;
      390:  273:	if (ptr->impl->hd_size == 0)
        2:  274:		return ret;
        -:  275:
      388:  276:	int left = 0;
      388:  277:	int right = ptr->impl->hd_size - 1;
        -:  278:
      484:  279:	while (left <= right) {
      447:  280:		int mid = left + (right - left) / 2;
      447:  281:		u64 slab_size = ptr->impl->hd_arr[mid].hdp.config.slab_size;
      447:  282:		if (slab_size == size) {
      351:  283:			ret = mid;
      351:  284:			break;
       96:  285:		} else if (slab_size > size)
       40:  286:			right = mid - 1;
        -:  287:		else
       56:  288:			left = mid + 1;
        -:  289:	}
        -:  290:
      388:  291:	if (ret == -1 && right + 1 <= ptr->impl->hd_size - 1) {
       29:  292:		return right + 1;
        -:  293:	}
        -:  294:
      359:  295:	return ret;
      390:  296:}
        -:  297:
       20:  298:int heap_data_resize(u64 index, HeapData *hd) {
        -:  299:	// check that we can resize this hdp
       20:  300:	if (hd->cur_slabs < hd->hdp.config.max_slabs) {
        -:  301:		// calculate the new slabs
       13:  302:		u32 nslabs_count =
       13:  303:		    hd->hdp.config.slabs_per_resize + hd->cur_slabs;
       13:  304:		if (nslabs_count > hd->hdp.config.max_slabs)
        2:  305:			nslabs_count = hd->hdp.config.max_slabs;
        -:  306:
        -:  307:		// determine slabs to allocate
       13:  308:		u32 slabs_to_alloc = nslabs_count - hd->cur_slabs;
        -:  309:
        -:  310:		// attempt to allocate
       13:  311:		void *tmp = NULL;
       13:  312:		if (!__debug_build_allocator_malloc_fail7) {
       12:  313:			if (hd->data)
       11:  314:				tmp = do_realloc(hd->data, (hd->count + 1) *
        -:  315:							       sizeof(void *));
        -:  316:			else
        1:  317:				tmp = do_malloc((hd->count + 1) *
        -:  318:						sizeof(void **));
       12:  319:		}
        -:  320:
       13:  321:		if (tmp == NULL)
        1:  322:			return -1;
       12:  323:		hd->data = tmp;
        -:  324:
        -:  325:		// initialize the new part of the free list
       12:  326:		if (heap_allocator_init_free_list(hd, hd->count, slabs_to_alloc,
        -:  327:						  true))
        2:  328:			return -1;
       10:  329:		hd->hdp.free_list_head = hd->cur_slabs;
       10:  330:		hd->cur_slabs = nslabs_count;
       10:  331:		hd->count += 1;
       10:  332:		return 0;
        -:  333:	}
        7:  334:	return -1;
       20:  335:}
        -:  336:
      389:  337:int heap_data_allocate(u64 index, HeapData *hd, FatPtr *fptr) {
      389:  338:	if (hd->cur_slabs == 0) {
        -:  339:		// this hd initially had 0 slabs
        -:  340:		// resize it
        2:  341:		if (heap_data_resize(index, hd))
        1:  342:			return -1;
        1:  343:	}
        -:  344:
        -:  345:	// no more slabs, return error
      388:  346:	if (hd->hdp.free_list_head == UINT32_MAX)
       17:  347:		return -1;
        -:  348:
        -:  349:	// get next free slab
      371:  350:	u64 id = hd->hdp.free_list_head;
        -:  351:
        -:  352:	// update free list head
      371:  353:	hd->hdp.free_list_head = hd->free_list[id];
        -:  354:
        -:  355:	// update with the specific index (differing slab sizes)
      371:  356:	fptr->id = id | (index << 56);
      371:  357:	fptr->len = hd->hdp.config.slab_size;
        -:  358:
      371:  359:	u64 heap_data_index = id / hd->hdp.config.slabs_per_resize;
      371:  360:	u64 offset_mod = id % hd->hdp.config.slabs_per_resize;
        -:  361:
        -:  362:	// set the data of the fptr
      371:  363:	fptr->data =
      371:  364:	    hd->data[heap_data_index] + offset_mod * hd->hdp.config.slab_size;
        -:  365:
      371:  366:	return 0;
      389:  367:}
        -:  368:
        -:  369:// free data in this HeapData
      121:  370:int heap_data_free(u64 index, HeapData *hd, FatPtr *fptr) {
      121:  371:	u64 rel = fptr->id & 0x00FFFFFFFFFFFFFF; // Extract the relative ID
        -:  372:
        -:  373:	// if this is invalid return an error
      121:  374:	if (rel >= hd->cur_slabs)
        1:  375:		return -1;
        -:  376:
        -:  377:	// update head and rest of the list
      120:  378:	u64 head = hd->hdp.free_list_head;
      120:  379:	hd->hdp.free_list_head = rel;
      120:  380:	hd->free_list[rel] = head;
        -:  381:
      120:  382:	return 0;
      121:  383:}
        -:  384:
        -:  385:// main allocation function
      390:  386:int heap_allocator_allocate(HeapAllocator *ptr, u64 size, FatPtr *fptr) {
      390:  387:	int ret = -1;
        -:  388:	// determine the index via binary search
      390:  389:	int index = heap_allocator_index(ptr, size);
        -:  390:
        -:  391:	// if this index is not found (too big) fall back to malloc
      390:  392:	if (index < 0) {
       10:  393:		if (!ptr->impl->config.no_malloc) {
        8:  394:			fptr->data = NULL;
        8:  395:			if (!__debug_build_allocator_malloc_fail6)
        7:  396:				fptr->data = do_malloc(size);
        8:  397:			if (fptr->data == NULL) {
        1:  398:				fptr->len = 0;
        1:  399:				ret = -1;
        1:  400:			} else {
        7:  401:				fptr->len = size;
        7:  402:				fptr->id = UINT64_MAX;
        7:  403:				ret = 0;
        -:  404:			}
        8:  405:		}
       10:  406:	} else {
      380:  407:		HeapData *hd = &ptr->impl->hd_arr[index];
      380:  408:		ret = heap_data_allocate(index, hd, fptr);
      380:  409:		if (ret) {
        -:  410:			// there are no more slabs. Try to resize
       18:  411:			if (!heap_data_resize(index, hd)) {
        -:  412:				// successful resize, allocate should always
        -:  413:				// succeed here
        9:  414:				ret = heap_data_allocate(index, hd, fptr);
       18:  415:			} else if (!ptr->impl->config.no_malloc) {
        -:  416:				// could not allocate, so we fall back to malloc
        -:  417:				// if configured
        4:  418:				fptr->data = NULL;
        4:  419:				if (!__debug_build_allocator_malloc_fail6)
        3:  420:					fptr->data = do_malloc(size);
        4:  421:				if (fptr->data == NULL) {
        1:  422:					fptr->len = 0;
        1:  423:					ret = -1;
        1:  424:				} else {
        3:  425:					fptr->len = size;
        3:  426:					fptr->id = UINT64_MAX;
        3:  427:					ret = 0;
        -:  428:				}
        4:  429:			}
       18:  430:		}
        -:  431:	}
        -:  432:
      390:  433:	if (!ret && ptr->impl->config.zeroed) {
      924:  434:		for (u64 i = 0; i < fptr->len; i++) {
      880:  435:			((char *)fptr->data)[i] = 0;
      880:  436:		}
       44:  437:	}
        -:  438:
      390:  439:	return ret;
        -:  440:}
        -:  441:
      132:  442:int heap_allocator_free(HeapAllocator *ptr, FatPtr *fptr) {
      132:  443:	int ret = 0;
      132:  444:	if (fptr->id == UINT64_MAX) {
        -:  445:		// malloc allocated
        -:  446:
       10:  447:		if (fptr->data) {
       10:  448:			do_free(fptr->data);
       10:  449:			fptr->data = NULL;
       10:  450:		}
        -:  451:
       10:  452:		ret = 0;
       10:  453:	} else {
        -:  454:
      122:  455:		u64 index = (fptr->id >> 56) & 0xFF; // Extract the index
        -:  456:
      122:  457:		if (index >= ptr->impl->hd_size) {
        1:  458:			errno = EINVAL;
        1:  459:			ret = -1; // invalid index
        1:  460:		} else {
      121:  461:			HeapData *hd = &ptr->impl->hd_arr[index];
      121:  462:			ret = heap_data_free(index, hd, fptr);
        -:  463:		}
        -:  464:	}
        -:  465:
      132:  466:	if (!ret && ptr->impl->config.zeroed) {
       17:  467:		for (u64 i = 0; i < fptr->len; i++) {
       16:  468:			((char *)fptr->data)[i] = 0;
       16:  469:		}
        1:  470:	}
        -:  471:
      132:  472:	return ret;
        -:  473:}
        -:  474:
       25:  475:int heap_allocator_cleanup(HeapAllocator *ptr) {
        -:  476:	// check for impl and deallocate
       25:  477:	if (ptr->impl) {
       42:  478:		for (u32 i = 0; i < ptr->impl->hd_size; i++) {
       20:  479:			if (ptr->impl->hd_arr[i].count) {
        -:  480:				// check that it's not an unallocated heap data
       18:  481:				if (ptr->impl->hd_arr[i].free_list) {
       18:  482:					do_free(ptr->impl->hd_arr[i].free_list);
       18:  483:					ptr->impl->hd_arr[i].free_list = NULL;
       18:  484:				}
       46:  485:				for (u64 j = 0; j < ptr->impl->hd_arr[i].count;
       28:  486:				     j++) {
       28:  487:					do_free(ptr->impl->hd_arr[i].data[j]);
       28:  488:				}
       18:  489:				if (ptr->impl->hd_arr[i].data) {
       18:  490:					do_free(ptr->impl->hd_arr[i].data);
       18:  491:					ptr->impl->hd_arr[i].data = NULL;
       18:  492:				}
       18:  493:			}
       20:  494:		}
        -:  495:
       22:  496:		if (ptr->impl->hd_arr) {
       21:  497:			do_free(ptr->impl->hd_arr);
       21:  498:			ptr->impl->hd_arr = NULL;
       21:  499:		}
       22:  500:		do_free(ptr->impl);
       22:  501:		ptr->impl = NULL;
       22:  502:	}
       25:  503:	return 0;
        -:  504:}
        -:    0:Source:panic.c
        -:    0:Graph:panic.gcno
        -:    0:Data:panic.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/panic.h>
        -:   16:#include <stdarg.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:
        -:   20:bool __debug_no_exit = false;
        -:   21:
        1:   22:void panic(const char *fmt, ...) {
        -:   23:	va_list args;
        -:   24:
        1:   25:	fprintf(stderr, "thread panicked: ");
        1:   26:	va_start(args, fmt);
        1:   27:	vfprintf(stderr, fmt, args);
        1:   28:	va_end(args);
        1:   29:	fprintf(stderr, "\n");
        -:   30:
        -:   31:	// clang-format off
        1:   32:	if (!__debug_no_exit) { exit(-1); } else { printf("simulated panic!\n"); }
        -:   33:	// clang-format on
        1:   34:}</textarea>
		</p>
	</body>
</html>

