<!DOCTYPE html>
<html>
	<head>
		<title>Code Coverage Report</title>
		<script src="chart.js"></script>
		<style>
			.chart {
				width: 900px;
			}
			.textarea {
				overflow:auto;
				resize:none;
			}
		</style>
	</head>
	<body>
		 <p align="center">
                        Code Coverage is currently 90.32%.
                </p>
		<center>
			<div class="chart">
				<canvas id="chart"></canvas>
			</div>
		</center>
		<script>
			function format_date(timestamp, time_frame) {
				var date = new Date(timestamp);
				var day_of_month = date.getDate();
				var full_year = date.getFullYear();
				var month = 1 + date.getMonth();
				var hours = date.getHours();
				var minutes = date.getMinutes();
				var seconds = date.getSeconds();
				var am_pm = 'AM';

				if(seconds < 10) {
					seconds = '0' + seconds;
				}
				if(minutes < 10) {
					minutes = '0' + minutes;
				}
				if(hours == 12) {
					am_pm = 'PM';
				} else if(hours > 12) {
					hours -= 12;
					am_pm = 'PM';
				}
				if(hours == 0) {
					hours = 12;
				}

				return month + '/' + day_of_month + '/' + full_year + ' ' +
					hours + ':' + minutes + ':' + seconds + ' ' + am_pm;
			}

			let raw_data = [86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
86.54,
0.00,
0.00,
0.00,
85.57,
85.57,
86.81,
84.76,
94.15,
94.15,
94.39,
96.83,
96.83,
85.76,
90.32,];
			let labels = [format_date(1716876818 * 1000 ),
format_date(1716876822 * 1000 ),
format_date(1716904488 * 1000 ),
format_date(1716905952 * 1000 ),
format_date(1716905990 * 1000 ),
format_date(1716906171 * 1000 ),
format_date(1716906235 * 1000 ),
format_date(1716906333 * 1000 ),
format_date(1716906629 * 1000 ),
format_date(1716906787 * 1000 ),
format_date(1716907183 * 1000 ),
format_date(1716907441 * 1000 ),
format_date(1716907910 * 1000 ),
format_date(1716908379 * 1000 ),
format_date(1716909018 * 1000 ),
format_date(1716909696 * 1000 ),
format_date(1716920268 * 1000 ),
format_date(1717294283 * 1000 ),
format_date(1717311812 * 1000 ),
format_date(1717380318 * 1000 ),
format_date(1717381641 * 1000 ),
format_date(1717398065 * 1000 ),
format_date(1717484462 * 1000 ),
format_date(1717570913 * 1000 ),];

			const data = {
				labels: labels,
				datasets: [{
					label: 'Code Coverage',
					backgroundColor: 'rgb(31,176,245)',
					borderColor: 'rgb(31,176,245)',
					data: raw_data,
				}]
			};

			const config = {
				type: 'line',
				data: data,
				options: {}
			};

			const chart = new Chart(
				document.getElementById('chart'),
				config
			);

		</script>

		<p align="center">
			Raw gcov output:<br/>
			<textarea readonly class="textarea" rows="50" cols="100">        -:    0:Source:log.c
        -:    0:Graph:./log.gcno
        -:    0:Data:./log.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <execinfo.h>
        -:   17:#include <inttypes.h>
        -:   18:#include <limits.h>
        -:   19:#include <log/log.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdarg.h>
        -:   22:#include <stdio.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <string.h>
        -:   25:#include <sys/time.h>
        -:   26:#include <time.h>
        -:   27:#include <unistd.h>
        -:   28:
        -:   29:const char PathSeparator =
        -:   30:#ifdef _WIN32
        -:   31:    '\\';
        -:   32:#else
        -:   33:    '/';
        -:   34:#endif
        -:   35:
        -:   36:#define _FILE_OFFSET_BITS 64
        -:   37:
       70:   38:u64 log_now()
        -:   39:{
        -:   40:    struct timeval tv;
       70:   41:    gettimeofday(&tv, NULL);
        -:   42:
       70:   43:    u64 ret = (u64)(tv.tv_sec) * 1000 + (u64)(tv.tv_usec) / 1000;
        -:   44:
       70:   45:    return ret;
        -:   46:}
        -:   47:
     2480:   48:int sprintf_err(char* str, const char* string, ...)
        -:   49:{
        -:   50:    va_list args;
     2480:   51:    va_start(args, string);
     2480:   52:    int ret = vsprintf(str, string, args);
     2480:   53:    va_end(args);
     2480:   54:    return (ret > 0) ? 0 : ret;
        -:   55:}
        -:   56:
       82:   57:int set_option(Log* log, int type, void* value)
        -:   58:{
       82:   59:    if (value == NULL) {
        2:   60:        fputs("error: value pointer cannot be NULL\n", stderr);
        2:   61:        return -1;
        -:   62:    }
       80:   63:    if (type == ShowColors) {
       14:   64:        log->show_colors = *((bool*)value);
       66:   65:    } else if (type == ShowStdout) {
       10:   66:        log->show_stdout = *((bool*)value);
       56:   67:    } else if (type == ShowTimestamp) {
        3:   68:        log->show_timestamp = *((bool*)value);
       53:   69:    } else if (type == ShowMillis) {
        7:   70:        log->show_millis = *((bool*)value);
       46:   71:    } else if (type == ShowLogLevel) {
        1:   72:        log->show_log_level = *((bool*)value);
       45:   73:    } else if (type == AutoRotate) {
        2:   74:        log->auto_rotate = *((bool*)value);
       43:   75:    } else if (type == DeleteRotation) {
        1:   76:        log->delete_rotation = *((bool*)value);
       42:   77:    } else if (type == MaxSizeBytes) {
        7:   78:        if (*((u64*)value) < 1) {
        2:   79:            fputs("error: MaxSizeBytes cannot be less than 1\n", stderr);
        2:   80:            return -1;
        -:   81:        }
        5:   82:        log->max_size_bytes = *((u64*)value);
       35:   83:    } else if (type == MaxAgeMillis) {
        3:   84:        if (*((u64*)value) < 1000) {
        1:   85:            fputs("error: MaxAgeMillis cannot be less than 1,000\n", stderr);
        1:   86:            return -1;
        -:   87:        }
        2:   88:        log->max_age_millis = *((u64*)value);
       32:   89:    } else if (type == LogFilePath) {
       20:   90:        char* buf = ((char*)value);
       20:   91:        int len = strlen(buf);
       20:   92:        if (len < 1) {
        1:   93:            fputs("error: LogFilePath must be at least 1 bytes long\n", stderr);
        1:   94:            return -1;
        -:   95:        }
       19:   96:        log->path = malloc(sizeof(char) * (len + 1));
       19:   97:        if (log->path == NULL || log->debug_malloc) {
        1:   98:            if (log->path)
        1:   99:                free(log->path); // if debug_malloc is set
        1:  100:            log->path = NULL;
        1:  101:            fputs("error: Could not allocate the required memory\n", stderr);
        1:  102:            return -1;
        -:  103:        }
       18:  104:        strcpy(log->path, buf);
       12:  105:    } else if (type == FileHeader) {
       12:  106:        char* buf = ((char*)value);
       12:  107:        int len = strlen(buf);
       12:  108:        if (len < 1) {
        1:  109:            fputs("error: FileHeader must be at least 1 bytes long\n", stderr);
        1:  110:            return -1;
        -:  111:        }
       11:  112:        char* tmp = malloc(sizeof(char) * (len + 1));
       11:  113:        if (tmp == NULL || log->debug_malloc) {
        1:  114:            if (tmp)
        1:  115:                free(tmp); // if debug_malloc is set
        1:  116:            tmp = NULL;
        1:  117:            fputs("error: Could not allocate the required memory\n", stderr);
        1:  118:            return -1;
        -:  119:        }
       10:  120:        strcpy(tmp, buf);
       10:  121:        if (log->file_header != NULL)
        1:  122:            free(log->file_header);
       10:  123:        log->file_header = tmp;
        -:  124:    }
        -:  125:
       73:  126:    return 0;
        -:  127:}
        -:  128:
       34:  129:int do_logger(Log* log, int num, va_list valist)
        -:  130:{
       34:  131:    int ret = 0;
        -:  132:
        -:  133:    // set defaults
       34:  134:    log->fp = NULL;
       34:  135:    log->level = Info;
       34:  136:    log->show_colors = true;
       34:  137:    log->show_stdout = true;
       34:  138:    log->show_timestamp = true;
       34:  139:    log->show_millis = true;
       34:  140:    log->show_log_level = true;
       34:  141:    log->auto_rotate = false;
       34:  142:    log->delete_rotation = false;
       34:  143:    log->max_size_bytes = ULONG_MAX;
       34:  144:    log->max_age_millis = ULONG_MAX;
       34:  145:    log->path = NULL;
       34:  146:    log->file_header = NULL;
       34:  147:    log->off = 0;
       34:  148:    log->last_rotation = log_now();
       34:  149:    log->is_init = false;
       34:  150:    log->debug_malloc = false;
        -:  151:
        -:  152:    // iterate through arg list for overrides
      103:  153:    for (int i = 0; i < num; i++) {
       76:  154:        LogConfigOptionImpl next = va_arg(valist, LogConfigOptionImpl);
       76:  155:        if (set_option(log, next.type, next.value)) {
        7:  156:            if (log->file_header != NULL)
        1:  157:                free(log->file_header);
        7:  158:            if (log->path != NULL)
        1:  159:                free(log->path);
        7:  160:            log->path = NULL;
        7:  161:            log->file_header = NULL;
        7:  162:            ret = -1;
        7:  163:            break;
        -:  164:        }
        -:  165:    }
       34:  166:    return ret;
        -:  167:}
        -:  168:
       32:  169:int logger(Log* log, int num, ...)
        -:  170:{
        -:  171:    va_list valist;
       32:  172:    va_start(valist, num);
       32:  173:    int ret = do_logger(log, num, valist);
       32:  174:    va_end(valist);
       32:  175:    return ret;
        -:  176:}
        -:  177:
      620:  178:int get_format(Log* log, LogLevel level, char* buf)
        -:  179:{
      620:  180:    int ret = 0;
        -:  181:    char milli_buf[14];
        -:  182:    char log_level_buf[20];
        -:  183:    char dt_buf[40];
        -:  184:    char spacing[2];
      620:  185:    time_t t = time(NULL);
      620:  186:    struct tm tm = *localtime(&t);
        -:  187:
      620:  188:    if (log->show_millis) {
        -:  189:        struct timeval time;
      617:  190:        gettimeofday(&time, NULL);
      617:  191:        int millis = time.tv_usec / 1000;
      617:  192:        ret = sprintf_err(milli_buf, ".%03d", millis);
        -:  193:    } else {
        3:  194:        strcpy(milli_buf, "");
        -:  195:    }
        -:  196:
      620:  197:    if (log->show_timestamp) {
      616:  198:        strcpy(spacing, " ");
        -:  199:    } else {
        4:  200:        strcpy(spacing, "");
        -:  201:    }
        -:  202:
      620:  203:    if (log->show_log_level && ret == 0) {
      619:  204:        if (level == Trace) {
        2:  205:            if (log->show_colors) {
        1:  206:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_YELLOW "TRACE" ANSI_COLOR_RESET ")", spacing);
        -:  207:            } else {
        1:  208:                ret = sprintf_err(log_level_buf, "%s(TRACE)", spacing);
        -:  209:            }
      617:  210:        } else if (level == Debug) {
      601:  211:            if (log->show_colors) {
      598:  212:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_CYAN "DEBUG" ANSI_COLOR_RESET ")", spacing);
        -:  213:            } else {
        3:  214:                ret = sprintf_err(log_level_buf, "%s(DEBUG)", spacing);
        -:  215:            }
       16:  216:        } else if (level == Info) {
       10:  217:            if (log->show_colors) {
        4:  218:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_GREEN "INFO" ANSI_COLOR_RESET ")", spacing);
        -:  219:            } else {
        6:  220:                ret = sprintf_err(log_level_buf, "%s(INFO)", spacing);
        -:  221:            }
        6:  222:        } else if (level == Warn) {
        2:  223:            if (log->show_colors) {
        1:  224:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_MAGENTA "WARN" ANSI_COLOR_RESET ")", spacing);
        -:  225:            } else {
        1:  226:                ret = sprintf_err(log_level_buf, "%s(WARN)", spacing);
        -:  227:            }
        4:  228:        } else if (level == Error) {
        2:  229:            if (log->show_colors) {
        1:  230:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_RED "ERROR" ANSI_COLOR_RESET ")", spacing);
        -:  231:            } else {
        1:  232:                ret = sprintf_err(log_level_buf, "%s(ERROR)", spacing);
        -:  233:            }
        2:  234:        } else if (level == Fatal) {
        2:  235:            if (log->show_colors) {
        1:  236:                ret = sprintf_err(log_level_buf, "%s(" ANSI_COLOR_BRIGHT_RED "FATAL" ANSI_COLOR_RESET ")", spacing);
        -:  237:            } else {
        1:  238:                ret = sprintf_err(log_level_buf, "%s(FATAL)", spacing);
        -:  239:            }
        -:  240:        }
        -:  241:    } else {
        1:  242:        strcpy(log_level_buf, "");
        -:  243:    }
        -:  244:
      620:  245:    if (log->show_timestamp && ret == 0) {
      616:  246:        if (log->show_colors) {
      604:  247:            ret = sprintf_err(
        -:  248:                dt_buf,
        -:  249:                "[" ANSI_COLOR_DIMMED
        -:  250:                "%d-%02d-%02d %02d:%02d:%02d%s" ANSI_COLOR_RESET
        -:  251:                "]",
      604:  252:                tm.tm_year + 1900,
      604:  253:                tm.tm_mon + 1,
        -:  254:                tm.tm_mday,
        -:  255:                tm.tm_hour,
        -:  256:                tm.tm_min,
        -:  257:                tm.tm_sec,
        -:  258:                milli_buf);
        -:  259:        } else {
       12:  260:            ret = sprintf_err(
        -:  261:                dt_buf,
        -:  262:                "["
        -:  263:                "%d-%02d-%02d %02d:%02d:%02d%s"
        -:  264:                "]",
       12:  265:                tm.tm_year + 1900,
       12:  266:                tm.tm_mon + 1,
        -:  267:                tm.tm_mday,
        -:  268:                tm.tm_hour,
        -:  269:                tm.tm_min,
        -:  270:                tm.tm_sec,
        -:  271:                milli_buf);
        -:  272:        }
        -:  273:    } else {
        4:  274:        strcpy(dt_buf, "");
        -:  275:    }
        -:  276:
      620:  277:    if ((level == Info || level == Warn) && log->show_log_level) {
       12:  278:        strcpy(spacing, ":");
        -:  279:    } else {
      608:  280:        strcpy(spacing, "");
        -:  281:    }
        -:  282:
      620:  283:    if (ret == 0) {
      620:  284:        ret = sprintf_err(
        -:  285:            buf,
        -:  286:            "%s%s%s: ",
        -:  287:            dt_buf,
        -:  288:            log_level_buf,
        -:  289:            spacing);
        -:  290:    }
      620:  291:    return ret;
        -:  292:}
        -:  293:
      687:  294:int do_log(Log* log, LogLevel level, char* line, bool is_plain, bool is_all, va_list args)
        -:  295:{
      687:  296:    int ret = 0;
      687:  297:    if (!log->is_init) {
        1:  298:        fputs("error: log has not been initialized\n", stderr);
        1:  299:        return -1;
        -:  300:    }
        -:  301:
      686:  302:    if (level >= log->level) {
        -:  303:        va_list args_copy;
      681:  304:        va_copy(args_copy, args);
        -:  305:
      681:  306:        int len = strlen(line);
      681:  307:        char fline[len + 100];
        -:  308:
      681:  309:        if (is_plain) {
       61:  310:            strcpy(fline, "");
        -:  311:        } else {
      620:  312:            ret = get_format(log, level, fline);
        -:  313:        }
      681:  314:        strcat(fline, line);
      681:  315:        strcat(fline, "\n");
        -:  316:
      681:  317:        if ((log->show_stdout || is_all) && ret == 0) {
      634:  318:            int v = vprintf(fline, args);
      634:  319:	    ret = (v > 0) ? 0 : v;
        -:  320:        }
        -:  321:
      681:  322:        if (log->fp && ret == 0) {
       81:  323:            int v = vfprintf(log->fp, fline, args_copy);
       81:  324:	    ret = (v > 0) ? 0 : v;
       81:  325:            log->off = ftello(log->fp);
        -:  326:        }
      681:  327:        if (log->auto_rotate && ret == 0) {
       12:  328:            if (log_need_rotate(log)) {
        2:  329:                ret = log_rotate(log);
        -:  330:            }
        -:  331:        }
        -:  332:    }
      686:  333:    return ret;
        -:  334:}
        -:  335:
        2:  336:int log_all(Log* log, LogLevel level, char* line, ...)
        -:  337:{
        -:  338:    va_list args;
        2:  339:    va_start(args, line);
        2:  340:    int ret = do_log(log, level, line, false, true, args);
        2:  341:    va_end(args);
        2:  342:    return ret;
        -:  343:}
        -:  344:
       60:  345:int log_plain(Log* log, LogLevel level, char* line, ...)
        -:  346:{
        -:  347:    va_list args;
       60:  348:    va_start(args, line);
       60:  349:    int ret = do_log(log, level, line, true, false, args);
       60:  350:    va_end(args);
       60:  351:    return ret;
        -:  352:}
        -:  353:
       21:  354:int log_line(Log* log, LogLevel level, char* line, ...)
        -:  355:{
        -:  356:    va_list args;
       21:  357:    va_start(args, line);
       21:  358:    int ret = do_log(log, level, line, false, false, args);
       21:  359:    va_end(args);
       21:  360:    return ret;
        -:  361:}
        -:  362:
      606:  363:void log_set_level(Log* log, LogLevel level)
        -:  364:{
      606:  365:    log->level = level;
      606:  366:}
        -:  367:
       26:  368:int log_init(Log* log)
        -:  369:{
       26:  370:    if (log->is_init) {
        1:  371:        fputs("error: log has already been initialized\n", stderr);
        1:  372:        return -1;
        -:  373:    }
       25:  374:    if (log->path) {
       17:  375:        bool write_header = false;
       17:  376:        if (log->file_header && access(log->path, F_OK) != 0) {
        6:  377:            write_header = true;
        -:  378:        }
       17:  379:        log->fp = fopen(log->path, "a");
       17:  380:        if (write_header) {
        6:  381:            fprintf(log->fp, "%s\n", log->file_header);
        -:  382:        }
       17:  383:        fseek(log->fp, 0, SEEK_END);
       17:  384:        log->off = ftello(log->fp);
        -:  385:    }
       25:  386:    log->is_init = true;
       25:  387:    return 0;
        -:  388:}
        -:  389:
        9:  390:int log_set_config_option(Log* log, LogConfigOptionImpl option)
        -:  391:{
        9:  392:    if (!log->is_init) {
        1:  393:        fputs("error: log has not been initialized\n", stderr);
        1:  394:        return -1;
        -:  395:    }
        8:  396:    if (option.type == LogFilePath && !log->debug_malloc) { // bypass this when we're debugging malloc
        2:  397:        fputs("error: cannot change log file path after initialization\n", stderr);
        2:  398:        return -1;
        -:  399:    }
        -:  400:
        6:  401:    return set_option(log, option.type, option.value);
        -:  402:}
        -:  403:
        9:  404:int log_rotate(Log* log)
        9:  405:{
        -:  406:    // format:
        -:  407:    // name.log -> name.r_<mon>_<day>_<year>_<time>_<rand>.log
        -:  408:
        9:  409:    int ret = 0;
        9:  410:    char rotation_name[strlen(log->path) + 100];
        9:  411:    time_t t = time(NULL);
        9:  412:    struct tm tm = *localtime(&t);
        -:  413:
        9:  414:    char* fname = strrchr(log->path, PathSeparator);
        9:  415:    if (fname == NULL) {
        1:  416:        fname = log->path;
        -:  417:    } else {
        8:  418:        ret = -1;
        8:  419:        if (strlen(fname) > 0) {
        8:  420:            ret = 0;
        8:  421:            fname = fname + 1;
        -:  422:        }
        -:  423:    }
        -:  424:
        9:  425:    if (!log->is_init) {
        1:  426:        fputs("error: log has not been initialized\n", stderr);
        1:  427:        ret = -1;
        -:  428:    }
        -:  429:
        -:  430:    char* ext;
        9:  431:    if (ret == 0) {
        8:  432:        strncpy(rotation_name, log->path, fname - log->path);
        8:  433:        rotation_name[fname - log->path] = 0;
        -:  434:
        8:  435:        ext = strrchr(fname, '.');
        8:  436:        if (ext == NULL) {
        1:  437:            ext = fname + strlen(fname);
        -:  438:        }
        -:  439:    }
        -:  440:
        9:  441:    if (ret == 0) {
        -:  442:        char date_format[100];
        8:  443:        strncpy(rotation_name + (fname - log->path), fname, ext - fname);
        8:  444:        rotation_name[ext - log->path] = 0;
        8:  445:        strcat(rotation_name, ".r_");
        -:  446:        u64 r;
        8:  447:        ret = rand_u64(&r);
        8:  448:        if (ret == 0) {
        8:  449:            sprintf_err(date_format,
        -:  450:                "%d_%02d_%02d_%02d_%02d_%02d_%" PRIu64,
        8:  451:                tm.tm_year + 1900,
        8:  452:                tm.tm_mon + 1,
        -:  453:                tm.tm_mday,
        -:  454:                tm.tm_hour,
        -:  455:                tm.tm_min,
        -:  456:                tm.tm_sec,
        -:  457:                r);
        8:  458:            strcat(rotation_name, date_format);
        8:  459:            strcat(rotation_name, ext);
        8:  460:            fclose(log->fp);
        8:  461:            if (log->delete_rotation) {
        1:  462:                remove(log->path);
        -:  463:            } else {
        7:  464:                rename(log->path, rotation_name);
        -:  465:            }
        -:  466:
        8:  467:            log->fp = fopen(log->path, "w");
        8:  468:            if (log->file_header)
        7:  469:                fprintf(log->fp, "%s\n", log->file_header);
        8:  470:            fseek(log->fp, 0, SEEK_END);
        8:  471:            log->off = ftello(log->fp);
        -:  472:        }
        -:  473:    }
        -:  474:
        9:  475:    if (ret == 0) {
        8:  476:        log->off = 0;
        8:  477:        log->last_rotation = log_now();
        -:  478:    }
        9:  479:    return ret;
        -:  480:}
        -:  481:
       28:  482:bool log_need_rotate(Log* log)
        -:  483:{
       28:  484:    u64 now = log_now();
       28:  485:    u64 diff = now - log->last_rotation;
       28:  486:    return log->off > log->max_size_bytes || diff > log->max_age_millis;
        -:  487:}
        -:  488:
       16:  489:int log_close(Log* log)
        -:  490:{
       16:  491:    if (log->fp) {
       16:  492:        fclose(log->fp);
       16:  493:        log->fp = NULL;
        -:  494:    }
       16:  495:    return 0;
        -:  496:}
        -:  497:
       80:  498:int _log_allocate_config_option(LogConfigOptionImpl* option, size_t size, bool debug_malloc_err, void* value)
        -:  499:{
       80:  500:    int ret = 0;
        -:  501:
       80:  502:    option->value = malloc(size);
       80:  503:    if (option->value == NULL || debug_malloc_err) {
        1:  504:        ret = -1;
        1:  505:        fputs("error: Could not allocate the required memory\n", stderr);
        -:  506:    }
        -:  507:
       80:  508:    return ret;
        -:  509:}
        -:  510:
       14:  511:int log_config_option_show_colors(LogConfigOptionImpl* option, bool value)
        -:  512:{
       14:  513:    option->type = ShowColors;
       14:  514:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
       14:  515:    if (!ret)
       14:  516:        *((bool*)option->value) = value;
       14:  517:    return ret;
        -:  518:}
        -:  519:
       10:  520:int log_config_option_show_stdout(LogConfigOptionImpl* option, bool value)
        -:  521:{
       10:  522:    option->type = ShowStdout;
       10:  523:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
       10:  524:    if (!ret)
       10:  525:        *((bool*)option->value) = value;
       10:  526:    return ret;
        -:  527:}
        -:  528:
        3:  529:int log_config_option_show_timestamp(LogConfigOptionImpl* option, bool value)
        -:  530:{
        3:  531:    option->type = ShowTimestamp;
        3:  532:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        3:  533:    if (!ret)
        3:  534:        *((bool*)option->value) = value;
        3:  535:    return ret;
        -:  536:}
        -:  537:
        7:  538:int log_config_option_show_millis(LogConfigOptionImpl* option, bool value)
        -:  539:{
        7:  540:    option->type = ShowMillis;
        7:  541:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        7:  542:    if (!ret)
        7:  543:        *((bool*)option->value) = value;
        7:  544:    return ret;
        -:  545:}
        -:  546:
        1:  547:int log_config_option_show_log_level(LogConfigOptionImpl* option, bool value)
        -:  548:{
        1:  549:    option->type = ShowLogLevel;
        1:  550:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        1:  551:    if (!ret)
        1:  552:        *((bool*)option->value) = value;
        1:  553:    return ret;
        -:  554:}
        -:  555:
        2:  556:int log_config_option_auto_rotate(LogConfigOptionImpl* option, bool value)
        -:  557:{
        2:  558:    option->type = AutoRotate;
        2:  559:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        2:  560:    if (!ret)
        2:  561:        *((bool*)option->value) = value;
        2:  562:    return ret;
        -:  563:}
        -:  564:
        1:  565:int log_config_option_delete_rotation(LogConfigOptionImpl* option, bool value)
        -:  566:{
        1:  567:    option->type = DeleteRotation;
        1:  568:    int ret = _log_allocate_config_option(option, sizeof(bool), false, &value);
        1:  569:    if (!ret)
        1:  570:        *((bool*)option->value) = value;
        1:  571:    return ret;
        -:  572:}
        -:  573:
        6:  574:int log_config_option_max_size_bytes(LogConfigOptionImpl* option, u64 value)
        -:  575:{
        6:  576:    option->type = MaxSizeBytes;
        6:  577:    int ret = _log_allocate_config_option(option, sizeof(u64), false, &value);
        6:  578:    if (!ret)
        6:  579:        *((u64*)option->value) = value;
        6:  580:    return ret;
        -:  581:}
        -:  582:
        3:  583:int log_config_option_max_age_millis(LogConfigOptionImpl* option, u64 value)
        -:  584:{
        3:  585:    option->type = MaxAgeMillis;
        3:  586:    int ret = _log_allocate_config_option(option, sizeof(u64), false, &value);
        3:  587:    if (!ret)
        3:  588:        *((u64*)option->value) = value;
        3:  589:    return ret;
        -:  590:}
        -:  591:
       21:  592:int log_config_option_log_file_path(LogConfigOptionImpl* option, char* value)
        -:  593:{
       21:  594:    option->type = LogFilePath;
       21:  595:    int ret = 0;
       21:  596:    if (value == NULL) {
        1:  597:        option->value = NULL;
        -:  598:    } else {
       20:  599:        int len = strlen(value);
       20:  600:        ret = _log_allocate_config_option(option, sizeof(char) * (len + 1), false, &value);
       20:  601:        if (!ret)
       20:  602:            strcpy(option->value, value);
        -:  603:    }
       21:  604:    return ret;
        -:  605:}
        -:  606:
       13:  607:int log_config_option_file_header(LogConfigOptionImpl* option, char* value)
        -:  608:{
       13:  609:    option->type = FileHeader;
       13:  610:    int ret = 0;
       13:  611:    if (value == NULL) {
        1:  612:        option->value = NULL;
        -:  613:    } else {
       12:  614:        int len = strlen(value);
       12:  615:        ret = _log_allocate_config_option(option, sizeof(char) * (len + 1), false, &value);
       12:  616:        if (!ret)
       12:  617:            strcpy(option->value, value);
        -:  618:    }
       13:  619:    return ret;
        -:  620:}
        -:  621:
       72:  622:void log_config_option_free(LogConfigOptionImpl* option)
        -:  623:{
       72:  624:    if (option->value != NULL) {
       70:  625:        free(option->value);
       70:  626:	option->value = NULL;
        -:  627:    }
       72:  628:}
        -:  629:
       21:  630:void log_free(Log* log)
        -:  631:{
       21:  632:    if (log->path) {
       16:  633:        free(log->path);
       16:  634:	log->path = NULL;
        -:  635:    }
       21:  636:    if (log->file_header) {
        7:  637:        free(log->file_header);
        7:  638:	log->file_header = NULL;
        -:  639:    }
       21:  640:}
        -:  641:
        -:  642:pthread_mutex_t _global_logger_mutex__ = PTHREAD_MUTEX_INITIALIZER;
        -:  643:Log _global_logger__;
        -:  644:bool _global_logger_is_init__ = false;
        -:  645:
      604:  646:int _global_logger(bool is_plain, bool is_all, LogLevel level, LogLevel global, char* line, ...)
        -:  647:{
      604:  648:    int ret = 0;
      604:  649:    pthread_mutex_lock(&_global_logger_mutex__);
        -:  650:
      604:  651:    if (!_global_logger_is_init__) {
        5:  652:        ret = logger(&_global_logger__, 0);
        5:  653:        if (ret == 0)
        5:  654:            ret = log_init(&_global_logger__);
        5:  655:        if (ret == 0)
        5:  656:            _global_logger_is_init__ = true;
        -:  657:    }
        -:  658:
      604:  659:    if (ret == 0) {
      604:  660:        log_set_level(&_global_logger__, global);
        -:  661:
        -:  662:        va_list args;
      604:  663:        va_start(args, line);
      604:  664:        ret = do_log(&_global_logger__, level, line, is_plain, is_all, args);
      604:  665:        va_end(args);
        -:  666:    }
        -:  667:
      604:  668:    pthread_mutex_unlock(&_global_logger_mutex__);
      604:  669:    return ret;
        -:  670:}
        -:  671:
        3:  672:int init_global_logger(int num, ...)
        -:  673:{
        3:  674:    if (_global_logger_is_init__)
        1:  675:        return -1;
        2:  676:    int ret = 0;
        2:  677:    pthread_mutex_lock(&_global_logger_mutex__);
        -:  678:
        -:  679:    va_list valist;
        2:  680:    va_start(valist, num);
        2:  681:    ret = do_logger(&_global_logger__, num, valist);
        2:  682:    va_end(valist);
        -:  683:
        2:  684:    if (ret == 0)
        2:  685:        ret = log_init(&_global_logger__);
        2:  686:    if (ret == 0)
        2:  687:        _global_logger_is_init__ = true;
        -:  688:
        2:  689:    pthread_mutex_unlock(&_global_logger_mutex__);
        2:  690:    return ret;
        -:  691:}
        -:  692:
        1:  693:int global_log_rotate()
        -:  694:{
        1:  695:    pthread_mutex_lock(&_global_logger_mutex__);
        1:  696:    int ret = log_rotate(&_global_logger__);
        1:  697:    pthread_mutex_unlock(&_global_logger_mutex__);
        1:  698:    return ret;
        -:  699:}
        -:  700:
        1:  701:bool global_log_need_rotate()
        -:  702:{
        1:  703:    pthread_mutex_lock(&_global_logger_mutex__);
        1:  704:    bool ret = log_need_rotate(&_global_logger__);
        1:  705:    pthread_mutex_unlock(&_global_logger_mutex__);
        1:  706:    return ret;
        -:  707:}
        -:  708:
        2:  709:int global_log_config_option(LogConfigOptionImpl option)
        -:  710:{
        2:  711:    pthread_mutex_lock(&_global_logger_mutex__);
        2:  712:    int ret = log_set_config_option(&_global_logger__, option);
        2:  713:    pthread_mutex_unlock(&_global_logger_mutex__);
        2:  714:    return ret;
        -:  715:}
        -:  716:
        1:  717:void _debug_global_logger_is_init__()
        -:  718:{
        1:  719:    _global_logger_is_init__ = false;
        1:  720:}
        -:    0:Source:config.c
        -:    0:Graph:./config.gcno
        -:    0:Data:./config.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/config.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        2:   20:void configure_u32(uint32_t* value, uint32_t* configured, uint32_t d)
        -:   21:{
        2:   22:    if (configured == NULL) {
        1:   23:        *value = d;
        -:   24:    } else {
        1:   25:        *value = *configured;
        -:   26:    }
        2:   27:}
        -:   28:
        2:   29:void configure_u64(uint64_t* value, uint64_t* configured, uint64_t d)
        -:   30:{
        2:   31:    if (configured == NULL) {
        1:   32:        *value = d;
        -:   33:    } else {
        1:   34:        *value = *configured;
        -:   35:    }
        2:   36:}
        -:   37:
        2:   38:void configure_u128(__uint128_t* value, __uint128_t* configured, __uint128_t d)
        -:   39:{
        2:   40:    if (configured == NULL) {
        1:   41:        *value = d;
        -:   42:    } else {
        1:   43:        *value = *configured;
        -:   44:    }
        2:   45:}
        -:   46:
        2:   47:void configure_bool(bool* value, bool* configured, bool d)
        -:   48:{
        2:   49:    if (configured == NULL) {
        1:   50:        *value = d;
        -:   51:    } else {
        1:   52:        *value = *configured;
        -:   53:    }
        2:   54:}
        -:   55:
        2:   56:void configure_u8(uint8_t* value, uint8_t* configured, uint8_t d)
        -:   57:{
        2:   58:    if (configured == NULL) {
        1:   59:        *value = d;
        -:   60:    } else {
        1:   61:        *value = *configured;
        -:   62:    }
        2:   63:}
        -:   64:
        2:   65:void configure_u16(uint16_t* value, uint16_t* configured, uint16_t d)
        -:   66:{
        2:   67:    if (configured == NULL) {
        1:   68:        *value = d;
        -:   69:    } else {
        1:   70:        *value = *configured;
        -:   71:    }
        2:   72:}
        -:   73:
        2:   74:void configure_string(char* value, char* configured, char* d, int max_len)
        -:   75:{
        2:   76:    if (configured == NULL) {
        1:   77:        int len = max_len - 1;
        1:   78:        int strlen_value = strlen(d);
        1:   79:        if (strlen_value < len) {
        1:   80:            len = strlen_value;
        -:   81:        }
        1:   82:        memcpy(value, d, len);
        1:   83:        value[len] = 0;
        -:   84:    } else {
        1:   85:        int len = max_len - 1;
        1:   86:        int strlen_value = strlen(configured);
        1:   87:        if (strlen_value < len) {
        1:   88:            len = strlen_value;
        -:   89:        }
        1:   90:        memcpy(value, configured, len);
        1:   91:        value[len] = 0;
        -:   92:    }
        2:   93:}
        -:    0:Source:rand.c
        -:    0:Graph:./rand.gcno
        -:    0:Data:./rand.gcda
        -:    0:Runs:28
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <sys/random.h>
        -:   17:
        4:   18:int rand_i8(i8* v)
        -:   19:{
        -:   20:    char buf[1];
        4:   21:    int ret = getentropy(buf, 1);
        4:   22:    *v = (i8)buf[0];
        4:   23:    return ret;
        -:   24:}
        -:   25:
        4:   26:int rand_u8(u8* v)
        -:   27:{
        -:   28:    char buf[1];
        4:   29:    int ret = getentropy(buf, 1);
        4:   30:    *v = (u8)buf[0];
        4:   31:    return ret;
        -:   32:}
        -:   33:
        4:   34:int rand_i16(i16* v)
        -:   35:{
        -:   36:    char buf[2];
        4:   37:    int ret = getentropy(buf, 2);
        4:   38:    *v = ((i16)buf[0] << 8) + (i16)buf[1];
        4:   39:    return ret;
        -:   40:}
        -:   41:
        4:   42:int rand_u16(u16* v)
        -:   43:{
        -:   44:    char buf[2];
        4:   45:    int ret = getentropy(buf, 2);
        4:   46:    *v = ((u16)buf[0] << 8) + (u16)buf[1];
        4:   47:    return ret;
        -:   48:}
        -:   49:
        1:   50:int rand_i32(int32_t* v)
        -:   51:{
        -:   52:    char buf[4];
        1:   53:    int ret = getentropy(buf, 4);
        1:   54:    *v = ((int32_t)buf[0] << 24) + ((int32_t)buf[1] << 16) + ((int32_t)buf[2] << 8) + (int32_t)buf[3];
        1:   55:    return ret;
        -:   56:}
        -:   57:
        2:   58:int rand_u32(uint32_t* v)
        -:   59:{
        -:   60:    char buf[4];
        2:   61:    int ret = getentropy(buf, 4);
        2:   62:    *v = ((uint32_t)buf[0] << 24) + ((uint32_t)buf[1] << 16) + ((uint32_t)buf[2] << 8) + (uint32_t)buf[3];
        2:   63:    return ret;
        -:   64:}
        -:   65:
        1:   66:int rand_i64(int64_t* v)
        -:   67:{
        -:   68:    char buf[8];
        1:   69:    int ret = getentropy(buf, 8);
        1:   70:    *v = ((int64_t)buf[0] << 56) + ((int64_t)buf[1] << 48) + ((int64_t)buf[2] << 40) + ((int64_t)buf[3] << 32) + ((int64_t)buf[4] << 24) + ((int64_t)buf[5] << 16) + ((int64_t)buf[6] << 8) + (int64_t)buf[7];
        1:   71:    return ret;
        -:   72:}
        -:   73:
       10:   74:int rand_u64(uint64_t* v)
        -:   75:{
        -:   76:    char buf[8];
       10:   77:    int ret = getentropy(buf, 8);
       10:   78:    *v = ((uint64_t)buf[0] << 56) + ((uint64_t)buf[1] << 48) + ((uint64_t)buf[2] << 40) + ((uint64_t)buf[3] << 32) + ((uint64_t)buf[4] << 24) + ((uint64_t)buf[5] << 16) + ((uint64_t)buf[6] << 8) + (uint64_t)buf[7];
       10:   79:    return ret;
        -:   80:}
        -:   81:
        1:   82:int rand_i128(i128* v)
        -:   83:{
        -:   84:    char buf[16];
        1:   85:    int ret = getentropy(buf, 16);
        1:   86:    *v = ((i128)buf[0] << 120) + ((i128)buf[1] << 112) + ((i128)buf[2] << 104) + ((i128)buf[3] << 96) + ((i128)buf[4] << 88) + ((i128)buf[5] << 80) + ((i128)buf[6] << 72) + ((i128)buf[7] << 64) + ((i128)buf[8] << 56) + ((i128)buf[9] << 48) + ((i128)buf[10] << 40) + ((i128)buf[11] << 32) + ((i128)buf[12] << 24) + ((i128)buf[13] << 16) + ((i128)buf[14] << 8) + (i128)buf[15];
        1:   87:    return ret;
        -:   88:}
        -:   89:
        1:   90:int rand_u128(u128* v)
        -:   91:{
        -:   92:    char buf[16];
        1:   93:    int ret = getentropy(buf, 16);
        1:   94:    *v = ((u128)buf[0] << 120) + ((u128)buf[1] << 112) + ((u128)buf[2] << 104) + ((u128)buf[3] << 96) + ((u128)buf[4] << 88) + ((u128)buf[5] << 80) + ((u128)buf[6] << 72) + ((u128)buf[7] << 64) + ((u128)buf[8] << 56) + ((u128)buf[9] << 48) + ((u128)buf[10] << 40) + ((u128)buf[11] << 32) + ((u128)buf[12] << 24) + ((u128)buf[13] << 16) + ((u128)buf[14] << 8) + (u128)buf[15];
        1:   95:    return ret;
        -:   96:}
        -:   97:
        2:   98:int rand_bytes(void* buf, size_t length)
        -:   99:{
        2:  100:    return getentropy(buf, length);
        -:  101:}
        -:    0:Source:types.c
        -:    0:Graph:./types.gcno
        -:    0:Data:./types.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:
    #####:   17:i64 saddi64(i64 a, i64 b)
        -:   18:{
    #####:   19:    if (a > 0) {
    #####:   20:        if (b > INT64_MAX - a) {
    #####:   21:            return INT64_MAX;
        -:   22:        }
    #####:   23:    } else if (b < INT64_MIN - a) {
    #####:   24:            return INT64_MIN;
        -:   25:    }
        -:   26:
    #####:   27:    return a + b;
        -:   28:}
        -:   29:
       13:   30:u64 saddu64(u64 a, u64 b) {
      13*:   31:  return (a > 0xFFFFFFFFFFFFFFFF - b) ? 0xFFFFFFFFFFFFFFFF : a + b;
        -:   32:}
        -:    0:Source:main.c
        -:    0:Graph:./main.gcno
        -:    0:Data:./main.gcda
        -:    0:Runs:1
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdio.h>
        -:   16:#include <log/log.h>
        -:   17:#include <util/misc.h>
        -:   18:
        -:   19:#define LOG_LEVEL Info
        -:   20:
        1:   21:int real_main(int argc, char** argv)
        -:   22:{
        1:   23:    LogConfigOption opt1, opt2, opt3;
        1:   24:    log_config_option_show_colors(&opt1, true);
        1:   25:    log_config_option_show_stdout(&opt2, true);
        1:   26:    log_config_option_show_timestamp(&opt3, false);
        -:   27:
        1:   28:    init_global_logger(2, opt1, opt2);
        1:   29:    info("Main currently doesn't do %s.", "anything");
        1:   30:    global_log_config_option(opt3);
        1:   31:    info("Main currently doesn't do %s.", "anything");
        1:   32:    info("end");
        -:   33:
        1:   34:    return 0;
        -:   35:}
        -:   36:
        1:   37:int main(int argc, char **argv) {
        1:   38:    return real_main(argc, argv);
        -:   39:}
        -:   40:
        -:    0:Source:misc.c
        -:    0:Graph:./misc.gcno
        -:    0:Data:./misc.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:#include <util/misc.h>
        -:   17:#include <log/log.h>
        -:   18:
        -:   19:#define LOG_LEVEL Debug
        -:   20:
    #####:   21:bool is_white_space(char ch)
        -:   22:{
    #####:   23:    debug("is whitespace '%c'", ch);
    #####:   24:    if (ch == '\n' || ch == '\t' || ch == '\r' || ch == '\v' || ch == '\f' || ch == ' ')
    #####:   25:        return true;
        -:   26:    else
    #####:   27:        return false;
        -:   28:}
        -:   29:
    #####:   30:bool is_ident_start(char ch)
        -:   31:{
    #####:   32:    if ((ch <= 'Z' && ch >= 'A') || (ch <= 'z' && ch >= 'a') || ch == '_') {
    #####:   33:        return true;
        -:   34:    } else {
    #####:   35:        return false;
        -:   36:    }
        -:   37:}
        -:   38:
    #####:   39:bool is_ident_secondary(char ch)
        -:   40:{
    #####:   41:    if (is_ident_start(ch) || (ch <= '9' && ch >= '0')) {
    #####:   42:        return true;
        -:   43:    } else {
    #####:   44:        return false;
        -:   45:    }
        -:   46:}
        -:   47:
    #####:   48:bool is_joint_possible(char ch)
        -:   49:{
    #####:   50:    if (ch == '.' || ch == '=' || ch == '/' || ch == '+' || ch == '&' || ch == '<' || ch == '-' || ch == '%' || ch == '^' || ch == '*' || ch == '>' || ch == '|' || ch == '!' || ch == ':') {
    #####:   51:        return true;
        -:   52:    } else {
    #####:   53:        return false;
        -:   54:    }
        -:   55:}
        -:    0:Source:slabs.c
        -:    0:Graph:./slabs.gcno
        -:    0:Data:./slabs.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <string.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <util/slabs.h>
        -:   18:#include <base/types.h>
        -:   19:#include <limits.h>
        -:   20:#include <stdarg.h>
        -:   21:#include <log/log.h>
        -:   22:
        -:   23:#define LOG_LEVEL Debug
        -:   24:
       13:   25:int slab_data_init(SlabData *sd, u64 slab_count, u64 slab_size, u64 max_slabs) {
       13:   26:	sd->data = NULL;
       13:   27:	sd->sdp.slab_size = slab_size;
       13:   28:	sd->sdp.slab_count = slab_count;
       13:   29:	sd->sdp.max_slabs = max_slabs;
       13:   30:	sd->sdp.free_list_head = 0;
        -:   31:
       13:   32:	sd->sdp.ptr_size = 0;
        -:   33:        // add 2 (1 termination pointer and one for free status)
       13:   34:        u64 x = saddu64(max_slabs, 2);
        -:   35:        while(true) {
       28:   36:        	if(x == 0) {
       13:   37:                	break;
        -:   38:                }
       15:   39:                x >>= 8;
       15:   40:                sd->sdp.ptr_size += 1;
        -:   41:        }
        -:   42:
       13:   43:	sd->sdp.null_ptr = 0;
       13:   44:	int shft = 0;
       28:   45:	for(int i=0; i<sd->sdp.ptr_size; i++) {
       15:   46:		sd->sdp.null_ptr |= 0xFF << shft;
       15:   47:		shft += 8;
        -:   48:	}
        -:   49:
       13:   50:	debug(
        -:   51:		"sd->sdp.ptr_size=%d,max_slabs=%llu,null_ptr=%llu",
        -:   52:		sd->sdp.ptr_size,
        -:   53:		max_slabs,
        -:   54:		sd->sdp.null_ptr
        -:   55:	);
        -:   56:
        -:   57:
       13:   58:	int ret = slab_data_resize(sd, slab_count);
        -:   59:
       13:   60:	return ret;
        -:   61:}
        -:   62:
    #####:   63:void *slab_data_read(SlabData *sd, u64 offset) {
    #####:   64:	if(offset > sd->sdp.slab_size * sd->sdp.slab_count)
    #####:   65:		return NULL;
    #####:   66:	return sd->data + offset;
        -:   67:}
        -:   68:
      312:   69:int slab_data_write(SlabData *sd, u64 dst_offset, void *value, u64 src_offset, u64 len) {
      312:   70:        int ret = 0;
      312:   71:	debug("=====sdw dst_offset=%llu,src_offset=%llu,len=%llu", dst_offset, src_offset, len);
      312:   72:	memcpy(sd->data + dst_offset, value + src_offset, len);
      312:   73:        return ret;
        -:   74:}
        -:   75:
       15:   76:int slab_data_resize(SlabData *sd, u64 slabs) {
       15:   77:	debug("slab_data_resize %llu", slabs);
       15:   78:	u64 len = slabs * sd->sdp.slab_size;
       15:   79:	int ret = 0;
        -:   80:
       15:   81:	if (sd->data == NULL) {
       13:   82:		debug("slab_data_resize malloc %llu", len);
       13:   83:		sd->data = malloc(len);
       13:   84:		if(sd->data == NULL) {
    #####:   85:			error("Could not allocate the required memory.");
    #####:   86:			ret = -1;
        -:   87:		}
        -:   88:	} else {
        2:   89:		void *tmp = realloc(sd->data, len);
        2:   90:		if(tmp == NULL) {
    #####:   91:			error("Could not allocate the required memory.");
    #####:   92:			ret = -1;
        -:   93:		} else {
        2:   94:			sd->data = tmp;
        -:   95:		}
        -:   96:	}
        -:   97:
       15:   98:	return ret;
        -:   99:}
        -:  100:
    #####:  101:void slab_data_free(SlabData *sd) {
    #####:  102:	if(sd->data) {
    #####:  103:		free(sd->data);
    #####:  104:		sd->data = NULL;
        -:  105:	}
    #####:  106:}
        -:  107:
      302:  108:void slab_write_ptr(char *bytes, u64 n, u64 ptr_size) {
      804:  109:	for(int j=ptr_size-1; j>=0; j--) {
      502:  110:                bytes[j] = n & 0xFF;
      502:  111:        	n = n >> 8;
        -:  112:        }
      302:  113:}
        -:  114:
       15:  115:void slab_set_max(char *bytes, u64 ptr_size) {
       32:  116:	for(int j=0; j<ptr_size; j++)
       17:  117:		bytes[j] = 0xFF;
       15:  118:}
        -:  119:
       34:  120:u64 slab_read_ptr(unsigned char *bytes, u64 ptr_size) {
       34:  121:	u64 ret = 0;
       34:  122:	debug("slab_read_ptr with ptr_size = %llu", ptr_size);
        -:  123:
       34:  124:	int shft = 0;
       79:  125:	for(int j=ptr_size-1; j>=0; j--) {
       45:  126:		ret += bytes[j] << shft;
       45:  127:		shft += 8;
        -:  128:	}
        -:  129:
       34:  130:	debug("ret=%llu", ret);
        -:  131:
       34:  132:	return ret;
        -:  133:}
        -:  134:
       15:  135:int slab_init_free_list(SlabData *sd, u64 size, u64 offset) {
       15:  136:	debug("init free list %llu off=%llu, size=%llu", sd->sdp.slab_size, offset, size);
       15:  137:	int ret = 0;
       15:  138:	u64 ptr_size = sd->sdp.ptr_size;
       15:  139:	u64 slab_size = sd->sdp.slab_size;
        -:  140:
      326:  141:	for(u64 i=offset; i<offset + size; i++) {
      311:  142:		char next_bytes[ptr_size];
      311:  143:		if(i < (offset + size) - 1) {
      296:  144:			u64 n = i + 1;
      296:  145:			slab_write_ptr(next_bytes, n, ptr_size);
        -:  146:		} else {
       15:  147:			slab_set_max(next_bytes, ptr_size);
        -:  148:		}
      311:  149:		u64 offset_next = i * (ptr_size + slab_size);
      311:  150:		if(i < 1)
       13:  151:			debug(
        -:  152:				"writing first block at %llu,ptr_size=%llu, [0]=%d,[1]=%d",
        -:  153:				offset_next,
        -:  154:				ptr_size,
        -:  155:				next_bytes[0],
        -:  156:				next_bytes[1]
        -:  157:			);
      311:  158:		slab_data_write(sd, offset_next, next_bytes, 0, ptr_size);
        -:  159:	}
        -:  160:
        -:  161:
       15:  162:	return ret;
        -:  163:}
        -:  164:
        7:  165:int do_slabs(SlabAllocator *sa, int num, va_list valist) {
        -:  166:	va_list args_copy;
        7:  167:        va_copy(args_copy, valist);
        7:  168:	int ret = 0;
        7:  169:	int sd_count = 0;
        7:  170:	u64 slabs_per_resize = 100;
        7:  171:	bool zeroed = true;
        -:  172:
       24:  173:	for(int i=0; i<num; i++) {
       17:  174:		SlabAllocatorConfigImpl next = va_arg(valist, SlabAllocatorConfigImpl);
       17:  175:		if(next.type == SlabAllocatorConfigImplTypeSlabData)
       13:  176:			sd_count += 1;
        4:  177:		else if(next.type == SlabAllocatorConfigImplTypeSlabsPerResize) {
        2:  178:			slabs_per_resize = *((u64 *)next.value);
        2:  179:		} else if(next.type == SlabAllocatorConfigImplTypeZeroed) {
        2:  180:			zeroed = *((bool *)next.value);
        -:  181:		}
        -:  182:	}
        -:  183:
        7:  184:	if(sd_count > 254) {
    #####:  185:		error("slab_allocator may not have more than 254 slab sizes.");
    #####:  186:		return -1;
        -:  187:	}
        -:  188:
        7:  189:	u64 sizes[sd_count];
        7:  190:	u64 max_slabs[sd_count];
        7:  191:	int counter = 0;
       24:  192:	for(int i=0; i<num; i++) {
       17:  193:                SlabAllocatorConfigImpl next = va_arg(args_copy, SlabAllocatorConfigImpl);
       17:  194:                if(next.type == SlabAllocatorConfigImplTypeSlabData) {
       13:  195:			u64 slab_size = ((u64 *)next.value)[1];
       13:  196:			u64 max_slabs_value = ((u64 *)next.value)[0];
       13:  197:			printf("ss=%llu,max=%llu\n", slab_size, max_slabs_value);
       13:  198:			sizes[counter] = slab_size;
       13:  199:			max_slabs[counter] = max_slabs_value;
       13:  200:			counter += 1;
        -:  201:		}
        -:  202:        }
        7:  203:	printf("counter=%d\n", counter);
        -:  204:
        -:  205:	// check that ordering is sorted and other configs are ok
        7:  206:        u64 last_size = 0;
       20:  207:        for(int i=0; i<counter; i++) {
       13:  208:                if(sizes[i] <= last_size) {
    #####:  209:                        error("slab_allocator sizes must be sorted in ascending order.");
    #####:  210:                        return -1;
        -:  211:                }
       13:  212:                last_size = sizes[i];
       13:  213:                if(max_slabs[i] == 0) {
    #####:  214:                        error("max_slabs must be greater than 0");
    #####:  215:                        return -1;
        -:  216:                }
        -:  217:        }
        -:  218:
        7:  219:        if(slabs_per_resize == 0) {
    #####:  220:                error("slabs_per_resize must be greater than 0");
    #####:  221:                return -1;
        -:  222:        }
        -:  223:
        7:  224:        sa->slab_data_array = NULL;
        7:  225:        sa->sizes = NULL;
        7:  226:        sa->max_slabs = NULL;
        7:  227:        sa->zeroed = zeroed;
        7:  228:        sa->slabs_per_resize = slabs_per_resize;
        7:  229:        sa->slab_data_array = malloc(sizeof(SlabData) * counter);
        7:  230:        if(sa->slab_data_array == NULL) {
    #####:  231:                ret = -1;
    #####:  232:                error("Could not allocate the required memory.");
        -:  233:        }
        -:  234:
        7:  235:	        if(ret == 0) {
        7:  236:                sa->sizes = malloc(sizeof(u64) * counter);
        -:  237:
        7:  238:                if(sa->sizes == NULL) {
    #####:  239:                        free(sa->slab_data_array);
    #####:  240:                        sa->slab_data_array = NULL;
    #####:  241:                        ret = -1;
    #####:  242:                        error("Could not allocate the required memory.");
        -:  243:                } else {
        7:  244:                        sa->slab_data_array_len = counter;
        7:  245:                        memcpy(sa->sizes, sizes, counter * sizeof(u64));
        -:  246:                }
        -:  247:
        -:  248:        }
        -:  249:
        7:  250:        if(ret == 0) {
        7:  251:                sa->max_slabs = malloc(sizeof(u64) * counter);
        7:  252:                if(sa->max_slabs == NULL) {
    #####:  253:                        free(sa->slab_data_array);
    #####:  254:                        sa->slab_data_array = NULL;
    #####:  255:                        free(sa->sizes);
    #####:  256:                        sa->sizes = NULL;
    #####:  257:                        error("Could not allocate required memory.");
    #####:  258:                        ret = -1;
        -:  259:                } else {
        7:  260:                        memcpy(sa->max_slabs, max_slabs, counter * sizeof(u64));
        -:  261:                }
        -:  262:        }
        -:  263:
        7:  264:	if(ret == 0) {
       20:  265: 		for(int i=0; i<counter; i++) {
       13:  266:			u64 initial_slabs = slabs_per_resize;
       13:  267:			if(slabs_per_resize > sa->max_slabs[i]) {
       10:  268:				initial_slabs = sa->max_slabs[i];
        -:  269:			}
       13:  270:			debug(
        -:  271:				"initial_slabs=%llu,max=%llu,spr=%llu",
        -:  272:				initial_slabs,
        -:  273:				sa->max_slabs[i],
        -:  274:				slabs_per_resize
        -:  275:			);
       13:  276:                	if(slab_data_init(
       13:  277:                        	&sa->slab_data_array[i],
        -:  278:                                initial_slabs,
       13:  279:                                sa->sizes[i],
       13:  280:                                sa->max_slabs[i]
        -:  281:                        )) {
    #####:  282:                        	ret = -1; 
    #####:  283:                                break;
        -:  284:                        }
        -:  285:                }
        -:  286:	}
        -:  287:
        7:  288:	if(ret == 0) {
       20:  289:		for(int i=0; i<sa->slab_data_array_len; i++) {
       13:  290:			u64 size = slabs_per_resize;
       13:  291:			if(sa->slab_data_array[i].sdp.max_slabs < slabs_per_resize)
       10:  292:				size = sa->slab_data_array[i].sdp.max_slabs;
       13:  293:                	slab_init_free_list(&sa->slab_data_array[i], size, 0);
        -:  294:                }
        -:  295:	}
        -:  296:
        7:  297:        return ret;	
        -:  298:}
        -:  299:
        7:  300:int slab_init(SlabAllocator *sa, int num, ...) {
        -:  301:    va_list valist;
        7:  302:    va_start(valist, num);
        7:  303:    int ret = do_slabs(sa, num, valist);
        7:  304:    va_end(valist);
        7:  305:    return ret;
        -:  306:}
        -:  307:
       60:  308:int slab_index_for_size(SlabAllocator *sa, u64 size) {
        -:  309:	// slab sizes are sorted so we can do binary search
       60:  310:	int slab_data_array_len = sa->slab_data_array_len;
       60:  311:	int mid = slab_data_array_len / 2;
       60:  312:	int min = 0;
       60:  313:	int max = slab_data_array_len - 1;
        -:  314:
        -:  315:	while(true) {
      135:  316:		if(sa->sizes[mid] == size)
       49:  317:			return mid;
       86:  318:		else if(sa->sizes[mid] > size) {
       49:  319:			if(max <= min)
        7:  320:				break;
       42:  321:			max = mid - 1;
        -:  322:		} else {
       37:  323:			if(max <= min)
        4:  324:				break;
       33:  325:			min = mid + 1;
        -:  326:		}
       75:  327:		mid = (min + (max - min) / 2);
        -:  328:	}
        -:  329:
       11:  330:	return -1;
        -:  331:}
        -:  332:
       39:  333:u64 slab_allocate(SlabAllocator *sa, u64 size) {
       39:  334:	int idx = slab_index_for_size(sa, size);
       39:  335:	if(idx < 0)
    #####:  336:		return ULONG_MAX;
        -:  337:
       39:  338:	u64 slab_size = sa->slab_data_array[idx].sdp.slab_size;
       39:  339:	u64 ptr_size = sa->slab_data_array[idx].sdp.ptr_size;
       39:  340:	u64 cur_slabs = sa->slab_data_array[idx].sdp.slab_count;
       39:  341:	u64 max_slabs = sa->slab_data_array[idx].sdp.max_slabs;
       39:  342:	u64 head = sa->slab_data_array[idx].sdp.free_list_head;
        -:  343:
       39:  344:	if(head == sa->slab_data_array[idx].sdp.null_ptr) {
        7:  345:		if(max_slabs > cur_slabs) {
        2:  346:			debug("resize possible for %d,max=%llu,cur=%llu", idx, max_slabs, cur_slabs);
        2:  347:			u64 nslabs = cur_slabs + sa->slabs_per_resize;
        2:  348:			if(nslabs > max_slabs) {
        1:  349:				nslabs = max_slabs;
        -:  350:			}
        2:  351:			slab_data_resize(&sa->slab_data_array[idx], nslabs);
        2:  352:			slab_init_free_list(&sa->slab_data_array[idx], nslabs - cur_slabs, cur_slabs);
        2:  353:			sa->slab_data_array[idx].sdp.free_list_head = cur_slabs;
        2:  354:			sa->slab_data_array[idx].sdp.slab_count = nslabs;
        2:  355:			head = cur_slabs;
        -:  356:		} else {
        5:  357:			return ULONG_MAX;
        -:  358:		}
        -:  359:	}
        -:  360:
       68:  361:	sa->slab_data_array[idx].sdp.free_list_head = slab_read_ptr(
       34:  362:		sa->slab_data_array[idx].data + head * (ptr_size + slab_size),
        -:  363:		ptr_size
        -:  364:	);
       34:  365:	debug("reading next free list at relative id = %llu", head);
        -:  366:
       34:  367:	if(sa->zeroed) {
    12472:  368:		for(int i=0; i<slab_size; i++) {
    12438:  369:			u64 offset = head * (ptr_size + slab_size) + ptr_size + i;
    12438:  370:			(((char*)sa->slab_data_array[idx].data)[offset]) = 0;
        -:  371:		}
        -:  372:	}
        -:  373:
       34:  374:	debug(
        -:  375:		"head=%llu,next=%llu, ULONG_MAX=%llu",
        -:  376:		head,
        -:  377:		sa->slab_data_array[idx].sdp.free_list_head,
        -:  378:		ULONG_MAX
        -:  379:	);
       34:  380:	u64 idx_u64 = idx;
       34:  381:	return head | (idx_u64 << 56);
        -:  382:}
        -:  383:
        6:  384:int slab_free(SlabAllocator *sa, u64 id) {
        6:  385:	int ret = 0;
        6:  386:	int idx = (id >> 56) & 0xFF;
        6:  387:	u64 id_relative = id & 0x00FFFFFFFFFFFFFF;
        -:  388:
        6:  389:	debug("id=%llu,idx=%d,id_relative=%llu", id, idx, id_relative);
        6:  390:	u64 head = sa->slab_data_array[idx].sdp.free_list_head;
        6:  391:	u64 slab_size = sa->slab_data_array[idx].sdp.slab_size;
        6:  392:	u64 ptr_size = sa->slab_data_array[idx].sdp.ptr_size;
        -:  393:
        6:  394:	sa->slab_data_array[idx].sdp.free_list_head = id_relative;
        6:  395:	u64 offset = id_relative * (ptr_size + slab_size);
        6:  396:	slab_write_ptr(sa->slab_data_array[idx].data + offset, head, ptr_size);
        -:  397:
        6:  398:	return ret;
        -:  399:}
        -:  400:
        1:  401:int slab_write(SlabAllocator *sa, u64 id, Slab *slab, u64 offset_slab) {
        1:  402:	int ret = 0;
        -:  403:
        1:  404: 	int idx = (id >> 56) & 0xFF;
        1:  405:        u64 id_relative = id & 0x00FFFFFFFFFFFFFF;
        -:  406:        
        1:  407:        u64 slab_size = sa->slab_data_array[idx].sdp.slab_size;
        1:  408:        u64 ptr_size = sa->slab_data_array[idx].sdp.ptr_size;
        -:  409:
        1:  410:	if(offset_slab >= slab_size) {
    #####:  411:		error(
        -:  412:			"offset (%llu) is greater than or equal to slab size (%llu)",
        -:  413:			offset_slab,
        -:  414:			slab_size
        -:  415:		);
    #####:  416:		return -1;
        -:  417:	}
        -:  418:
        1:  419:	if(slab->len != slab_size) {
    #####:  420:		error("slab->len (%llu) not equal to slab_size (%llu)", slab->len, slab_size);
    #####:  421:		return -1;
        -:  422:	}
        -:  423:                
        1:  424:        u64 offset = id_relative * (ptr_size + slab_size) + offset_slab + ptr_size;
        -:  425:
        1:  426:	debug("write offset = %llu", offset);
        1:  427:	u64 len = slab_size - offset_slab;
        -:  428:
        1:  429:	slab_data_write(&sa->slab_data_array[idx], offset, slab->data, 0, len);
        -:  430:
        -:  431:
        1:  432:	return ret;
        -:  433:}
        -:  434:
        3:  435:int slab_read(SlabAllocator *sa, u64 id, Slab *slab) {
        3:  436:	int ret = 0;
        3:  437:	int idx = (id >> 56) & 0xFF;
        3:  438:        u64 id_relative = id & 0x00FFFFFFFFFFFFFF;
        -:  439:
        3:  440:	u64 slab_size = sa->slab_data_array[idx].sdp.slab_size;
        3:  441:        u64 ptr_size = sa->slab_data_array[idx].sdp.ptr_size;
        -:  442:
        3:  443:	u64 offset = id_relative * (ptr_size + slab_size) + ptr_size;
        3:  444:	debug("read offset = %llu", offset);
        3:  445:	slab->data = sa->slab_data_array[idx].data + offset;
        3:  446:	slab->len = slab_size;
        -:  447:
        3:  448:	return ret;
        -:  449:}
        -:  450:
    #####:  451:void slab_allocator_free(SlabAllocator *sa) {
    #####:  452:	for(int i=0; i<sa->slab_data_array_len; i++) {
    #####:  453:		slab_data_free(&sa->slab_data_array[i]);
        -:  454:	}
    #####:  455:	sa->slab_data_array_len = 0;
        -:  456:
    #####:  457:	if(sa->slab_data_array) {
    #####:  458:		free(sa->slab_data_array);
    #####:  459:		sa->slab_data_array = NULL;
        -:  460:	}
        -:  461:
    #####:  462:	if(sa->sizes) {
    #####:  463:		free(sa->sizes);
    #####:  464:		sa->sizes = NULL;
        -:  465:	}
        -:  466:
    #####:  467:	if(sa->max_slabs) {
    #####:  468:		free(sa->max_slabs);
    #####:  469:		sa->max_slabs = NULL;
        -:  470:	}
    #####:  471:}
        -:  472:
        3:  473:int slab_allocator_config_zeroed(SlabAllocatorConfigImpl *sc, bool zeroed) {
        3:  474:	int ret = 0;
        3:  475:	sc->type = SlabAllocatorConfigImplTypeZeroed;
        3:  476:	sc->value = malloc(sizeof(bool));
        3:  477:        if(sc->value == NULL) {
    #####:  478:                ret = -1;
        -:  479:        } else {
        3:  480:                *((bool *)sc->value) = zeroed;
        -:  481:        }
        3:  482:	return ret;
        -:  483:}
        -:  484:
        3:  485:int slab_allocator_config_slabs_per_resize(SlabAllocatorConfigImpl *sc, u64 slabs_per_resize) {
        3:  486:	int ret = 0;
        3:  487:	sc->type = SlabAllocatorConfigImplTypeSlabsPerResize;
        3:  488:	sc->value = malloc(sizeof(u64));
        3:  489:	if(sc->value == NULL) {
    #####:  490:                ret = -1;
        -:  491:        } else {
        3:  492:		*((u64 *)sc->value) = slabs_per_resize;
        -:  493:	}
        3:  494:	return ret;
        -:  495:}
        -:  496:
       14:  497:int slab_allocator_config_slab_data(SlabAllocatorConfigImpl *sc, u64 max_slabs, u64 slab_size) {
       14:  498:	int ret = 0;
       14:  499:	sc->type = SlabAllocatorConfigImplTypeSlabData;
       14:  500:	printf("config slab data\n");
       14:  501:	sc->value = malloc(sizeof(u64) * 2);
       14:  502:	if(sc->value == NULL) {
    #####:  503:		ret = -1;
        -:  504:	} else {
       14:  505:		(((u64 *)sc->value)[0]) = max_slabs;
       14:  506:		(((u64 *)sc->value)[1]) = slab_size;
        -:  507:	}
       14:  508:	return ret;
        -:  509:}
        -:  510:
       20:  511:void slab_allocator_config_free(SlabAllocatorConfigImpl *sc) {
       20:  512:	if(sc->value != NULL) {
       20:  513:		free(sc->value);
       20:  514:		sc->value = NULL;
        -:  515:	}
       20:  516:}</textarea>
		</p>
	</body>
</html>

