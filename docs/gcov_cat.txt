        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/util.h>
        -:   17:
        -:   18:extern char **environ;
        -:   19:static bool checked = false;
        -:   20:static bool no_color_value = false;
        -:   21:
       16:   22:bool no_color() {
       16:   23:	if (checked) return no_color_value;
      516:   24:	for (int i = 0; environ[i] != NULL; i++) {
      512:   25:		char *env_var = environ[i];
      512:   26:		if (!cstring_compare_n("NO_COLOR=", env_var, 9)) {
    #####:   27:			no_color_value = true;
    #####:   28:			checked = true;
    #####:   29:			return true;
        -:   30:		}
        -:   31:	}
        4:   32:	checked = true;
        4:   33:	return false;
        -:   34:}
        -:   35:
    #####:   36:byte *get_dimmed() {
    #####:   37:	if (no_color()) {
    #####:   38:		return "";
        -:   39:	} else {
    #####:   40:		return "\x1b[2m";
        -:   41:	}
        -:   42:}
        -:   43:
    #####:   44:byte *get_red() {
    #####:   45:	if (no_color()) {
    #####:   46:		return "";
        -:   47:	} else {
    #####:   48:		return "\x1b[31m";
        -:   49:	}
        -:   50:}
        -:   51:
    #####:   52:byte *get_bright_red() {
    #####:   53:	if (no_color()) {
    #####:   54:		return "";
        -:   55:	} else {
    #####:   56:		return "\x1b[91m";
        -:   57:	}
        -:   58:}
        -:   59:
        4:   60:byte *get_green() {
        4:   61:	if (no_color()) {
    #####:   62:		return "";
        -:   63:	} else {
        4:   64:		return "\x1b[32m";
        -:   65:	}
        -:   66:}
        -:   67:
    #####:   68:byte *get_yellow() {
    #####:   69:	if (no_color()) {
    #####:   70:		return "";
        -:   71:	} else {
    #####:   72:		return "\x1b[33m";
        -:   73:	}
        -:   74:}
        -:   75:
    #####:   76:byte *get_cyan() {
    #####:   77:	if (no_color()) {
    #####:   78:		return "";
        -:   79:	} else {
    #####:   80:		return "\x1b[36m";
        -:   81:	}
        -:   82:}
        -:   83:
    #####:   84:byte *get_magenta() {
    #####:   85:	if (no_color()) {
    #####:   86:		return "";
        -:   87:	} else {
    #####:   88:		return "\x1b[35m";
        -:   89:	}
        -:   90:}
        -:   91:
        4:   92:byte *get_blue() {
        4:   93:	if (no_color()) {
    #####:   94:		return "";
        -:   95:	} else {
        4:   96:		return "\x1b[34m";
        -:   97:	}
        -:   98:}
        -:   99:
        8:  100:byte *get_reset() {
        8:  101:	if (no_color()) {
    #####:  102:		return "";
        -:  103:	} else {
        8:  104:		return "\x1b[0m";
        -:  105:	}
        -:  106:}
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:// #include <base/macro_util.h>
        -:   17:// #include <base/os.h>
        -:   18://  #include <base/print_util.h>
        -:   19://  #include <base/string.h>
        -:   20:
        -:   21:_Thread_local byte fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local int64 fam_err = NoErrors;
        -:   24://_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const byte *get_err() {
        -:   27:	// return strncpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
    #####:   28:	return NULL;
        -:   29:}
        -:   30:
    #####:   31:void print_err(const byte *text) {
        -:   32:	// println("{}: {}", FamErrText[fam_err], text);
        -:   33:	// backtrace_print(&thread_local_bt__);
    #####:   34:}
        -:   35:
        -:   36:// void do_backtrace_generate(Backtrace *bt) {
        -:   37:// if (env("CBACKTRACE") != NULL) {
        -:   38://  backtrace_generate(bt);
        -:   39://	}
        -:   40://}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/lock.h>
        -:   16:#include <base/macros.h>
        -:   17:#include <base/print_util.h>
        -:   18:
        -:   19:_Thread_local bool _lock_is_write__ = false;
        -:   20:
    #####:   21:Lock lock_create() {
    #####:   22:	return 0;
        -:   23:}
   501510:   24:void lock_read(Lock *lock) {
   501510:   25:	_lock_is_write__ = false;
        -:   26:	unsigned long long state;
        -:   27:	unsigned long long state_update;
        -:   28:	do {
        -:   29:		// get current state set the write_pending bit to false
   501510:   30:		state = ALOAD(lock) & ~0x80000000ULL;
        -:   31:		// increment the read counter and add 1 to the sequence number (upper 32
        -:   32:		// bits)
   501510:   33:		state_update = (state + 0x100000000ULL) + 1ULL;
        -:   34:		// while our target state (no change including sequence number and
        -:   35:		// write_pending != false, we spin)
   501510:   36:	} while (!CAS_ACQUIRE(lock, &state, state_update));
   501510:   37:}
     4011:   38:void lock_write(Lock *lock) {
     4011:   39:	_lock_is_write__ = true;
        -:   40:	unsigned long long state;
        -:   41:	unsigned long long state_update;
        -:   42:
        -:   43:	// first step, set write bit true indicating a writer is waiting
        -:   44:	// this lock should be obtained soon after the previous writer
        -:   45:	// is complete indicating to readers our desire to write
        -:   46:	// this avoids write starvation
        -:   47:	do {
     4011:   48:		state = ALOAD(lock) & ~0x80000000ULL;
     4011:   49:		state_update = (state + 0x100000000ULL) | 0x80000000ULL;
     4011:   50:	} while (!CAS(lock, &state, state_update));
        -:   51:
        -:   52:	// second step, obtain total lock before proceeding
        -:   53:	do {
        -:   54:		// get current state. We will wait for the read count to go to 0.
     4011:   55:		state = ALOAD(lock) & 0xFFFFFFFF80000000ULL;
        -:   56:		// set the updated value to set the write bit true and read count to 0,
        -:   57:		// increment the sequence number
     4011:   58:		state_update = (state + 0x100000000ULL) & 0xFFFFFFFF80000000ULL;
     4011:   59:	} while (!CAS_ACQUIRE(lock, &state, state_update));
     4011:   60:}
        -:   61:
   505521:   62:void lock_unlock(Lock *lock) {
        -:   63:	unsigned long long state;
        -:   64:	unsigned long long state_update;
        -:   65:	// check thread local write variable
   505521:   66:	if (_lock_is_write__) {
        -:   67:		// writer
        -:   68:		do {
        -:   69:			// get current state
     4011:   70:			state = ALOAD(lock);
        -:   71:			// unset the write bit and increment the sequence number
     4011:   72:			state_update = (state + 0x100000000ULL) & ~0x80000000ULL;
     4011:   73:		} while (!CAS_RELEASE(lock, &state, state_update));
        -:   74:	} else {
        -:   75:		// reader
        -:   76:		do {
        -:   77:			// get current state
   501510:   78:			state = ALOAD(lock);
  501510*:   79:			if ((state & 0x7FFFFFFF) == 0) panic("underflow!");
        -:   80:			// subtract 1 from the read count and increment the sequence number
   501510:   81:			state_update = (state + 0x100000000ULL) - 1ULL;
   501510:   82:		} while (!CAS_RELEASE(lock, &state, state_update));
        -:   83:	}
   505521:   84:}
        -:   85:
        2:   86:void lock_guard_cleanup(LockGuard *l) {
        2:   87:	lock_unlock(l);
        2:   88:}
        -:   89:
        1:   90:LockGuard lock_guard_read(Lock l) {
        1:   91:	lock_read(&l);
        1:   92:	return l;
        -:   93:}
        1:   94:LockGuard lock_guard_write(Lock l) {
        1:   95:	lock_write(&l);
        1:   96:	return l;
        -:   97:}
        -:    0:Source:memmap.c
        -:    0:Graph:memmap.gcno
        -:    0:Data:memmap.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/memmap.h>
        -:   17:#include <base/mmap.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <base/util.h>
        -:   20:
        -:   21:#define MEMMAP_ENTRY_PER_LEVEL 256
        -:   22:#define BITMAP_SIZE 32
        -:   23:#define MEMMAP_SHIFT 8
        -:   24:
        -:   25:_Thread_local int last_i = 0, last_j = 0, last_k = 0, last_l = 0;
        -:   26:
        -:   27:typedef struct MemMapImpl {
        -:   28:	byte ****data;
        -:   29:	unsigned int size;
        -:   30:} MemMapImpl;
        -:   31:
       25:   32:void __attribute__((constructor)) __memmap_check_sizes() {
        -:   33:	if (sizeof(MemMapImpl) != sizeof(MemMap))
        -:   34:		panic("sizeof(MemMapImpl) (%i) != sizeof(MemMap) (%i)",
        -:   35:			  sizeof(MemMapImpl), sizeof(MemMap));
       25:   36:}
        -:   37:
 12055940:   38:unsigned long long *memmap_itt_for(MemMapImpl *impl, int i, int j, int k,
        -:   39:								   int l) {
 12055940:   40:	bool mmapped = false;
 12055940:   41:	byte ****nullvalue1 = NULL;
 12055940:   42:	byte ****data1 = NULL;
        -:   43:	// load data
        -:   44:	do {
 12055940:   45:		if (mmapped) {
    #####:   46:			mmap_free(data1, MEMMAP_ENTRY_PER_LEVEL * sizeof(byte ***));
        -:   47:		}
 12055940:   48:		data1 = ALOAD(&impl->data);
 12055940:   49:		if (data1 == NULL) {
       16:   50:			data1 = mmap_allocate(MEMMAP_ENTRY_PER_LEVEL * sizeof(byte ***));
       16:   51:			if (data1 == NULL) {
    #####:   52:				SetErr(AllocErr);
    #####:   53:				return NULL;
        -:   54:			}
       16:   55:			mmapped = true;
       16:   56:			set_bytes((byte *)data1, '\0',
        -:   57:					  MEMMAP_ENTRY_PER_LEVEL * sizeof(byte ***));
        -:   58:		} else
 12055924:   59:			break;
       16:   60:	} while (!CAS(&impl->data, &nullvalue1, data1));
        -:   61:
        -:   62:	// load second level
 12055940:   63:	byte ***nullvalue2 = NULL;
        -:   64:	byte ***data2;
 12055940:   65:	mmapped = false;
        -:   66:	do {
 12055940:   67:		if (mmapped) {
    #####:   68:			mmap_free(data2, MEMMAP_ENTRY_PER_LEVEL * sizeof(byte **));
        -:   69:		}
 12055940:   70:		data2 = ALOAD(&impl->data[i]);
 12055940:   71:		if (data2 == NULL) {
       16:   72:			data2 = mmap_allocate(MEMMAP_ENTRY_PER_LEVEL * sizeof(byte **));
       16:   73:			if (data2 == NULL) {
    #####:   74:				SetErr(AllocErr);
    #####:   75:				return NULL;
        -:   76:			}
       16:   77:			mmapped = true;
       16:   78:			set_bytes((byte *)data2, '\0',
        -:   79:					  MEMMAP_ENTRY_PER_LEVEL * sizeof(byte **));
        -:   80:		} else
 12055924:   81:			break;
       16:   82:	} while (!CAS(&impl->data[i], &nullvalue2, data2));
        -:   83:
        -:   84:	// load third level
 12055940:   85:	byte **nullvalue3 = NULL;
        -:   86:	byte **data3;
 12055940:   87:	mmapped = false;
        -:   88:	do {
 12055940:   89:		if (mmapped) {
    #####:   90:			mmap_free(data3, MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:   91:		}
 12055940:   92:		data3 = ALOAD(&impl->data[i][j]);
 12055940:   93:		if (data3 == NULL) {
       16:   94:			data3 = mmap_allocate(MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
       16:   95:			if (data3 == NULL) {
    #####:   96:				SetErr(AllocErr);
    #####:   97:				return NULL;
        -:   98:			}
       16:   99:			mmapped = true;
       16:  100:			set_bytes((byte *)data3, '\0',
        -:  101:					  MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:  102:		} else
 12055924:  103:			break;
       16:  104:	} while (!CAS(&impl->data[i][j], &nullvalue3, data3));
        -:  105:
        -:  106:	// load fourth and final level
 12055940:  107:	byte *nullvalue4 = NULL;
        -:  108:	byte *data4;
 12055940:  109:	mmapped = false;
        -:  110:	// add 32 bytes for the bitmap
        -:  111:	do {
 12055940:  112:		if (mmapped) {
    #####:  113:			mmap_free(data4,
    #####:  114:					  MEMMAP_ENTRY_PER_LEVEL * impl->size * sizeof(byte) +
        -:  115:						  BITMAP_SIZE);
        -:  116:		}
 12055940:  117:		data4 = ALOAD(&impl->data[i][j][k]);
 12055940:  118:		if (data4 == NULL) {
      228:  119:			data4 = mmap_allocate(MEMMAP_ENTRY_PER_LEVEL * impl->size *
        -:  120:									  sizeof(byte) +
        -:  121:								  BITMAP_SIZE);
      228:  122:			if (data4 == NULL) {
    #####:  123:				SetErr(AllocErr);
    #####:  124:				return NULL;
        -:  125:			}
      228:  126:			mmapped = true;
      228:  127:			set_bytes((byte *)data4, '\0',
      228:  128:					  MEMMAP_ENTRY_PER_LEVEL * impl->size * sizeof(byte) +
        -:  129:						  BITMAP_SIZE);
        -:  130:			// set Ptr=0 to allocated so we never return null / also reserve the
        -:  131:			// first value for other purposes
      228:  132:			if (i == 0 && j == 0 && k == 0) data4[0] = 0x3;
        -:  133:		} else
 12055712:  134:			break;
      228:  135:	} while (!CAS(&impl->data[i][j][k], &nullvalue4, data4));
        -:  136:
        -:  137:	// return the lth item at the begining of the data array (32 bytes reserved)
        -:  138:	// l is between 0-3.
 12055940:  139:	unsigned long long *ret = ((unsigned long long *)impl->data[i][j][k]) + l;
 12055940:  140:	return ret;
        -:  141:}
        -:  142:
 67497331:  143:void *memmap_data(const MemMap *mm, Ptr ptr) {
 67497331:  144:	const MemMapImpl *impl = (const MemMapImpl *)mm;
 67497331:  145:	byte *block = impl->data[ptr >> (MEMMAP_SHIFT * 3)]
 67497331:  146:							[(ptr >> (MEMMAP_SHIFT * 2)) & 0xFF]
 67497331:  147:							[(ptr >> (MEMMAP_SHIFT)) & 0xFF];
 67497331:  148:	return (byte *)(block + ((ptr & 0xFF) * impl->size + 32));
        -:  149:}
       16:  150:int memmap_init(MemMap *mm, unsigned int size) {
       16:  151:	MemMapImpl *impl = (MemMapImpl *)mm;
       16:  152:	impl->size = size;
       16:  153:	impl->data = NULL;
       16:  154:	return 0;
        -:  155:}
        -:  156:
 12055037:  157:Ptr memmap_allocate(MemMap *mm) {
 12055037:  158:	Ptr ret = null;
 12055037:  159:	MemMapImpl *impl = (MemMapImpl *)mm;
 12055037:  160:	int i = last_i, j = last_j, k = last_k, l = last_l;
        -:  161:	unsigned long long *current, desired, v;
        -:  162:
        -:  163:	do {
        -:  164:		loop {
        -:  165:			// load section of bitmap
 12055940:  166:			current = memmap_itt_for(impl, i, j, k, l);
12055940*:  167:			if (current == NULL) return null;
 12055940:  168:			v = ALOAD(current);
 12055940:  169:			if (v != ((unsigned long long)0) - 1) break;
        -:  170:			// l is 4 because 64 bits are used in the atomic load
        -:  171:			// the other 4 combinations cover all 256 entries
      903:  172:			if (++l >= 4) {
      223:  173:				l = 0;
      223:  174:				if (++k >= MEMMAP_ENTRY_PER_LEVEL) {
    #####:  175:					k = 0;
    #####:  176:					if (++j >= MEMMAP_ENTRY_PER_LEVEL) {
    #####:  177:						j = 0;
    #####:  178:						i++;
    #####:  179:						if (i == last_i) {
    #####:  180:							SetErr(CapacityExceeded);
    #####:  181:							return null;
        -:  182:						}
        -:  183:					}
        -:  184:				}
        -:  185:			}
        -:  186:		}
        -:  187:
        -:  188:		// find open bit
        -:  189:		int x;
 55786670:  190:		for (x = 0; (v & (0x1ULL << x)) != 0; x++);
 12055037:  191:		ret = (i << (MEMMAP_SHIFT * 3)) | (j << (2 * MEMMAP_SHIFT)) |
 12055037:  192:			  (k << MEMMAP_SHIFT) | (l << 6) | x;
        -:  193:		// set bit
 12055037:  194:		desired = v | (0x1ULL << x);
 12055037:  195:	} while (!CAS(current, &v, desired));
        -:  196:
 12055037:  197:	last_i = i;
 12055037:  198:	last_j = j;
 12055037:  199:	last_k = k;
 12055037:  200:	last_l = l;
        -:  201:
 12055037:  202:	return ret;
        -:  203:}
        -:  204:
 12052024:  205:void memmap_free(MemMap *mm, Ptr ptr) {
12052024*:  206:	if (ptr == null) panic("attempt to free null!");
12052024*:  207:	if (ptr == ptr_reserved) panic("attempt to free a reserved ptr = 1");
12052024*:  208:	if (mm == NULL) panic("invalid (null) memmap");
 12052024:  209:	MemMapImpl *impl = (MemMapImpl *)mm;
        -:  210:	unsigned long long nv, *v, vo;
        -:  211:	int i, j, k, l;
        -:  212:
 12052024:  213:	i = (ptr >> (MEMMAP_SHIFT * 3)) & 0xFF;
 12052024:  214:	j = (ptr >> (MEMMAP_SHIFT * 2)) & 0xFF;
 12052024:  215:	k = (ptr >> (MEMMAP_SHIFT)) & 0xFF;
 12052024:  216:	l = (ptr >> 6) & 0x3;
        -:  217:
        -:  218:	do {
 12052024:  219:		v = (unsigned long long *)impl->data[i][j][k] + l;
 12052024:  220:		vo = ALOAD((unsigned long long *)(v));
12052024*:  221:		if ((vo & (0x1ULL << (ptr & 0x3F))) == 0) panic("double free attempt!");
 12052024:  222:		nv = vo & ~(0x1ULL << (ptr & 0x3F));
 12052024:  223:	} while (!CAS(&*v, &vo, nv));
        -:  224:
 12052024:  225:	last_i = i;
 12052024:  226:	last_j = j;
 12052024:  227:	last_k = k;
 12052024:  228:	last_l = 0;
 12052024:  229:}
        -:  230:
        8:  231:void memmap_cleanup(MemMap *mm) {
        8:  232:	MemMapImpl *impl = (MemMapImpl *)mm;
       8*:  233:	if (impl->data == NULL) return;
       16:  234:	for (int i = 0; impl->data[i] && i < MEMMAP_ENTRY_PER_LEVEL; i++) {
       16:  235:		for (int j = 0; impl->data[i][j] && j < MEMMAP_ENTRY_PER_LEVEL; j++) {
      228:  236:			for (int k = 0; impl->data[i][j][k] && k < MEMMAP_ENTRY_PER_LEVEL;
      220:  237:				 k++) {
      220:  238:				mmap_free(impl->data[i][j][k],
      220:  239:						  MEMMAP_ENTRY_PER_LEVEL * impl->size * sizeof(byte) +
        -:  240:							  BITMAP_SIZE);
      220:  241:				impl->data[i][j][k] = NULL;
        -:  242:			}
        8:  243:			mmap_free(impl->data[i][j],
        -:  244:					  MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:  245:		}
        8:  246:		mmap_free(impl->data[i], MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:  247:	}
        8:  248:	mmap_free(impl->data, MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:  249:}
        -:    0:Source:mmap.c
        -:    0:Graph:mmap.gcno
        -:    0:Data:mmap.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/mmap.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <base/types.h>
        -:   18:#include <sys/mman.h>
        -:   19:
        -:   20:size_t getpagesize();
        -:   21:
      279:   22:void *mmap_allocate(unsigned int size) {
      279:   23:	return mmap(NULL, mmap_aligned_size(size), PROT_READ | PROT_WRITE,
        -:   24:				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        -:   25:}
        -:   26:
      247:   27:void mmap_free(void *ptr, unsigned int size) {
     247*:   28:	if (munmap(ptr, mmap_aligned_size(size))) panic("unexpected mmap error!");
      247:   29:}
        -:   30:
      530:   31:unsigned int mmap_aligned_size(unsigned int size) {
      530:   32:	unsigned int page_size = getpagesize();
      530:   33:	return (size + (page_size - 1)) & ~(page_size - 1);
        -:   34:}
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/print_util.h>
        -:   16:
        -:   17:// currently using stdio, will move to write
        -:   18:#include <stdio.h>
        -:   19:
        -:   20:void exit(int);
        -:   21:
    #####:   22:void __attribute__((no_return)) panic(const char *fmt, ...) {
        -:   23:	char buf[1024];
        -:   24:	__builtin_va_list args;
    #####:   25:	print("Panic: ");
    #####:   26:	__builtin_va_start(args, fmt);
    #####:   27:	vfprintf(stderr, fmt, args);
    #####:   28:	__builtin_va_end(args);
    #####:   29:	fprintf(stderr, "\n");
        -:   30:
    #####:   31:	exit(-1);
        -:   32:}
        -:   33:
        4:   34:int println(const char *fmt, ...) {
        -:   35:	__builtin_va_list args;
        4:   36:	__builtin_va_start(args, fmt);
        4:   37:	vfprintf(stderr, fmt, args);
        4:   38:	__builtin_va_end(args);
        4:   39:	fprintf(stderr, "\n");
        4:   40:	return 0;
        -:   41:}
        -:   42:
    #####:   43:int print(const char *fmt, ...) {
        -:   44:	__builtin_va_list args;
    #####:   45:	__builtin_va_start(args, fmt);
    #####:   46:	vfprintf(stderr, fmt, args);
    #####:   47:	__builtin_va_end(args);
    #####:   48:	return 0;
        -:   49:}
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/lock.h>
        -:   17:#include <base/macros.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <base/slabs.h>
        -:   20:
        -:   21:static Ptr RESERVED_PTR = 1;
        -:   22:
        -:   23:typedef struct SlabList {
        -:   24:	Ptr next;
        -:   25:	byte data[];
        -:   26:} SlabList;
        -:   27:
        -:   28:typedef struct SlabAllocatorImpl {
        -:   29:	MemMap mm;
        -:   30:	unsigned int slab_size;
        -:   31:	unsigned int max_free_slabs;
        -:   32:	unsigned int max_total_slabs;
        -:   33:	unsigned int free_size;
        -:   34:	unsigned int total_slabs;
        -:   35:	Ptr head;
        -:   36:	Ptr tail;
        -:   37:} SlabAllocatorImpl;
        -:   38:
       25:   39:void __attribute__((constructor)) __slabs_check_sizes() {
        -:   40:	if (sizeof(SlabAllocatorImpl) != sizeof(SlabAllocator))
        -:   41:		panic("sizeof(SlabAllocatorImpl) (%i) != sizeof(SlabAllocator) (%i)",
        -:   42:			  sizeof(SlabAllocatorImpl), sizeof(SlabAllocator));
       25:   43:}
        -:   44:
 46252838:   45:byte *slab_get(const SlabAllocator *sa, Ptr ptr) {
 46252838:   46:	if (sa == NULL || nil(ptr)) {
     9152:   47:		SetErr(IllegalArgument);
     9152:   48:		return NULL;
        -:   49:	}
 46243686:   50:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
 46243686:   51:	SlabList *sl = memmap_data(&impl->mm, ptr);
 46243686:   52:	if (sl == NULL) {
    #####:   53:		SetErr(IllegalState);
    #####:   54:		return NULL;
        -:   55:	}
 46243686:   56:	return sl->data;
        -:   57:}
        -:   58:
    52033:   59:Ptr slab_allocator_grow(SlabAllocatorImpl *impl) {
    52033:   60:	if (AADD(&impl->total_slabs, 1) > impl->max_total_slabs) {
    #####:   61:		ASUB(&impl->total_slabs, 1);
    #####:   62:		SetErr(CapacityExceeded);
    #####:   63:		return null;
        -:   64:	}
    52033:   65:	Ptr ret = memmap_allocate(&impl->mm);
   52033*:   66:	if (nil(ret)) return null;
    52033:   67:	SlabList *sl = memmap_data(&impl->mm, ret);
   52033*:   68:	if (sl == NULL) return null;
    52033:   69:	sl->next = ptr_reserved;
        -:   70:
    52033:   71:	return ret;
        -:   72:}
        -:   73:
       14:   74:int slab_allocator_init(SlabAllocator *sa, unsigned int slab_size,
        -:   75:						unsigned long long max_free_slabs,
        -:   76:						unsigned long long max_total_slabs) {
       14:   77:	if (sa == NULL || slab_size == 0 || max_free_slabs < 5 ||
        -:   78:		max_total_slabs < 5) {
    #####:   79:		SetErr(IllegalArgument);
    #####:   80:		return -1;
        -:   81:	}
       14:   82:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        -:   83:
      14*:   84:	if (memmap_init(&impl->mm, slab_size + sizeof(SlabList))) return -1;
       14:   85:	ASTORE(&impl->free_size, 1);
       14:   86:	ASTORE(&impl->total_slabs, 0);
       14:   87:	impl->slab_size = slab_size;
       14:   88:	impl->max_free_slabs = max_free_slabs;
       14:   89:	impl->max_total_slabs = max_total_slabs;
        -:   90:
       14:   91:	Ptr ptr = slab_allocator_grow(impl);
       14:   92:	if (ptr == null) {
    #####:   93:		return -1;
        -:   94:	}
        -:   95:
       14:   96:	SlabList *sl = memmap_data(&impl->mm, ptr);
       14:   97:	if (sl == NULL) {
    #####:   98:		SetErr(IllegalState);
    #####:   99:		return -1;
        -:  100:	}
       14:  101:	sl->next = null;
       14:  102:	impl->head = impl->tail = ptr;
        -:  103:
       14:  104:	return 0;
        -:  105:}
        -:  106:
        6:  107:void slab_allocator_cleanup(SlabAllocator *sa) {
       6*:  108:	if (sa == NULL) panic("slab_allocator_cleanup with sa = NULL!");
        -:  109:
        6:  110:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        6:  111:	Ptr itt = impl->head;
    52027:  112:	while (itt) {
    52021:  113:		Ptr to_delete = itt;
    52021:  114:		SlabList *sl = memmap_data(&impl->mm, itt);
   52021*:  115:		if (sl == NULL) panic("slab_allocator_cleanup: memmap_data ret NULL!");
    52021:  116:		itt = sl->next;
    52021:  117:		memmap_free(&impl->mm, to_delete);
        -:  118:	}
        -:  119:
        6:  120:	memmap_cleanup(&impl->mm);
        6:  121:}
        -:  122:
  5298899:  123:Ptr slab_allocator_allocate(SlabAllocator *sa) {
  5298899:  124:	if (sa == NULL) {
    #####:  125:		SetErr(IllegalArgument);
    #####:  126:		return null;
        -:  127:	}
  5298899:  128:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        -:  129:	Ptr head, tail, next, ret;
    #####:  130:	loop {
  5298899:  131:		head = impl->head;
  5298899:  132:		tail = impl->tail;
  5298899:  133:		SlabList *sl = memmap_data(&impl->mm, head);
  5298899:  134:		if (sl == NULL) {
    #####:  135:			SetErr(IllegalState);
    #####:  136:			return null;
        -:  137:		}
  5298899:  138:		next = sl->next;
  5298899:  139:		if (head == impl->head) {
  5298899:  140:			if (head == tail) {
    52019:  141:				if (next == null) {
    52019:  142:					return slab_allocator_grow(impl);
        -:  143:				}
    #####:  144:				CAS_SEQ(&impl->tail, &tail, next);
        -:  145:			} else {
  5246880:  146:				ret = head;
  5246880:  147:				if (CAS_SEQ(&impl->head, &head, next)) break;
        -:  148:			}
        -:  149:		}
        -:  150:	}
        -:  151:
  5246880:  152:	ASUB(&impl->free_size, 1);
  5246880:  153:	SlabList *sl = memmap_data(&impl->mm, ret);
  5246880:  154:	if (sl == NULL) {
    #####:  155:		SetErr(IllegalState);
    #####:  156:		return null;
        -:  157:	}
  5246880:  158:	sl->next = ptr_reserved;
  5246880:  159:	return ret;
        -:  160:}
  5298899:  161:void slab_allocator_free(SlabAllocator *sa, Ptr ptr) {
 5298899*:  162:	if (sa == NULL) panic("slab_allocator_free with sa = NULL!");
  5298899:  163:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        -:  164:
  5298899:  165:	SlabList *slptr = memmap_data(&impl->mm, ptr);
 5298899*:  166:	if (slptr == NULL) panic("cannot retrieve data for a freed ptr!");
        -:  167:
  5298899:  168:	if (!CAS(&slptr->next, &RESERVED_PTR, null))
    #####:  169:		panic("Double free attempt! ptr=%u", ptr);
  5298899:  170:	if (AADD(&impl->free_size, 1) > impl->max_free_slabs) {
    #####:  171:		memmap_free(&impl->mm, ptr);
    #####:  172:		ASUB(&impl->total_slabs, 1);
    #####:  173:		return;
        -:  174:	}
        -:  175:
        -:  176:	Ptr tail, next;
        -:  177:
    #####:  178:	loop {
  5298899:  179:		tail = impl->tail;
  5298899:  180:		SlabList *sltail = memmap_data(&impl->mm, tail);
 5298899*:  181:		if (sltail == NULL) panic("cannot retrieve data for tail!");
  5298899:  182:		next = sltail->next;
  5298899:  183:		if (tail == impl->tail) {
  5298899:  184:			if (next == null) {
  5298899:  185:				if (CAS_SEQ(&sltail->next, &next, ptr)) {
  5298899:  186:					CAS_SEQ(&impl->tail, &tail, ptr);
  5298899:  187:					break;
        -:  188:				}
        -:  189:			} else {
    #####:  190:				CAS_SEQ(&impl->tail, &tail, next);
        -:  191:			}
        -:  192:		}
        -:  193:	}
        -:  194:}
        -:  195:
        -:  196:#ifdef TEST
        2:  197:unsigned long long slab_allocator_free_size(SlabAllocator *sa) {
        2:  198:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        2:  199:	return ALOAD(&impl->free_size);
        -:  200:}
        -:  201:
        2:  202:unsigned long long slab_allocator_total_slabs(SlabAllocator *sa) {
        2:  203:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        2:  204:	return ALOAD(&impl->total_slabs);
        -:  205:}
        -:  206:#endif	// TEST
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/print_util.h>
        -:   16:#include <base/types.h>
        -:   17:
       25:   18:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   19:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   20:	panic("Supported architectures: __x86_64__, _M_X64, and __aarch64__");
        -:   21:#endif	// arch
        -:   22:
        -:   23:	// check size_t
        -:   24:	if (__SIZEOF_SIZE_T__ != 8) panic("size_t must be 8 bytes. Invalid arch!");
        -:   25:	// check primitive types
        -:   26:	if (sizeof(byte) != 1) panic("byte must be 1 byte. Invalid arch!");
        -:   27:
        -:   28:	if (sizeof(int64) != 8) panic("must be 8 bytes. Invalid arch!");
        -:   29:
        -:   30:	if (sizeof(int) != 4) panic("int must be 4 bytes. Invalid arch!");
        -:   31:
        -:   32:	if (sizeof(float64) != 8) panic("float64 must be 8 bytes. Invalid arch!");
        -:   33:
        -:   34:	if (sizeof(bool) != 1) panic("bool must be 1 byte. Invalid arch!");
        -:   35:
        -:   36:	// little endian check
       25:   37:	int test = 0x1;
       25:   38:	if (*(byte *)&test != 0x1) {
    #####:   39:		panic("Big endian is not supported!");
        -:   40:	}
       25:   41:}
        -:    0:Source:util.c
        -:    0:Graph:util.gcno
        -:    0:Data:util.gcda
        -:    0:Runs:25
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/print_util.h>
        -:   16:#include <base/types.h>
        -:   17:#include <base/util.h>
        -:   18:
        -:   19:// note: assume non-null strings passed in
     1018:   20:void copy_bytes(byte *dst, const byte *src, unsigned long long n) {
    21349:   21:	for (unsigned long long i = 0; i < n; i++) {
    20331:   22:		dst[i] = src[i];
        -:   23:	}
     1018:   24:}
        -:   25:
        -:   26:// note: assume non-null strings passed in
      277:   27:void set_bytes(byte *ptr, byte x, unsigned long long n) {
  7355802:   28:	for (unsigned long long i = 0; i < n; i++) ptr[i] = x;
      277:   29:}
        -:   30:
        -:   31:// note: assume non-null strings passed in and null terminated
        3:   32:unsigned long long cstring_len(const char *S) {
        3:   33:	const char *s = S;
       14:   34:	while (*S) S++;
        3:   35:	return S - s;
        -:   36:}
        -:   37:
        -:   38:// note: assume non-null strings passed in and null terminated
    #####:   39:int cstring_compare(const char *X, const char *Y) {
    #####:   40:	while (*X && *X == *Y) {
    #####:   41:		X++;
    #####:   42:		Y++;
        -:   43:	}
    #####:   44:	if (*X > *Y) return 1;
    #####:   45:	if (*Y > *X) return -1;
    #####:   46:	return 0;
        -:   47:}
        -:   48:
        -:   49:// we compare byte by byte for length n, even if null
      513:   50:int cstring_compare_n(const byte *X, const byte *Y, unsigned long long n) {
      521:   51:	while (n && *X == *Y) {
        8:   52:		n--;
        8:   53:		X++;
        8:   54:		Y++;
        -:   55:	}
      513:   56:	if (n == 0) return 0;
      512:   57:	if (*X > *Y) return 1;
      156:   58:	if (*Y > *X) return -1;
    #####:   59:	return 0;
        -:   60:}
        -:    0:Source:aes.c
        -:    0:Graph:aes.gcno
        -:    0:Data:aes.gcda
        -:    0:Runs:11
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:
        -:   17:/*
        -:   18:
        -:   19:This is an implementation of the AES algorithm, specifically ECB, CTR and CBC
        -:   20:mode. Block size can be chosen in aes.h - available choices are AES128, AES192,
        -:   21:AES256.
        -:   22:
        -:   23:The implementation is verified against the test vectors in:
        -:   24:  National Institute of Standards and Technology Special Publication 800-38A
        -:   25:2001 ED
        -:   26:
        -:   27:ECB-AES128
        -:   28:----------
        -:   29:
        -:   30:  plain-text:
        -:   31:	6bc1bee22e409f96e93d7e117393172a
        -:   32:	ae2d8a571e03ac9c9eb76fac45af8e51
        -:   33:	30c81c46a35ce411e5fbc1191a0a52ef
        -:   34:	f69f2445df4f9b17ad2b417be66c3710
        -:   35:
        -:   36:  key:
        -:   37:	2b7e151628aed2a6abf7158809cf4f3c
        -:   38:
        -:   39:  resulting cipher
        -:   40:	3ad77bb40d7a3660a89ecaf32466ef97
        -:   41:	f5d3d58503b9699de785895a96fdbaaf
        -:   42:	43b1cd7f598ece23881b00e3ed030688
        -:   43:	7b0c785e27e8ad3f8223207104725dd4
        -:   44:
        -:   45:
        -:   46:NOTE:   String length must be evenly divisible by 16byte (str_len % 16 == 0)
        -:   47:		You should pad the end of the string with zeros if this is not the case.
        -:   48:		For AES192/256 the key size is proportionally larger.
        -:   49:
        -:   50:*/
        -:   51:
        -:   52:/*****************************************************************************/
        -:   53:/* Includes:                                                                 */
        -:   54:/*****************************************************************************/
        -:   55:#include <base/util.h>
        -:   56:#include <crypto/aes.h>
        -:   57:
        -:   58:/*****************************************************************************/
        -:   59:/* Defines:                                                                  */
        -:   60:/*****************************************************************************/
        -:   61:// The number of columns comprising a state in AES. This is a constant in AES.
        -:   62:// Value=4
        -:   63:#define Nb 4
        -:   64:
        -:   65:#if defined(AES256) && (AES256 == 1)
        -:   66:#define Nk 8
        -:   67:#define Nr 14
        -:   68:#elif defined(AES192) && (AES192 == 1)
        -:   69:#define Nk 6
        -:   70:#define Nr 12
        -:   71:#else
        -:   72:#define Nk 4   // The number of 32 bit words in a key.
        -:   73:#define Nr 10  // The number of rounds in AES Cipher.
        -:   74:#endif
        -:   75:
        -:   76:// jcallan@github points out that declaring Multiply as a function
        -:   77:// reduces code size considerably with the Keil ARM compiler.
        -:   78:// See this link for more information:
        -:   79:// https://github.com/kokke/tiny-AES-C/pull/3
        -:   80:#ifndef MULTIPLY_AS_A_FUNCTION
        -:   81:#define MULTIPLY_AS_A_FUNCTION 0
        -:   82:#endif
        -:   83:
        -:   84:/*****************************************************************************/
        -:   85:/* Private variables:                                                        */
        -:   86:/*****************************************************************************/
        -:   87:// state - array holding the intermediate results during decryption.
        -:   88:typedef byte state_t[4][4];
        -:   89:
        -:   90:// The lookup-tables are marked const so they can be placed in read-only storage
        -:   91:// instead of RAM The numbers below can be computed dynamically trading ROM for
        -:   92:// RAM - This can be useful in (embedded) bootloader applications, where ROM is
        -:   93:// often limited.
        -:   94:static const byte sbox[256] = {
        -:   95:	// 0     1    2      3     4    5     6     7      8    9     A      B    C
        -:   96:	// D     E     F
        -:   97:	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
        -:   98:	0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
        -:   99:	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,
        -:  100:	0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
        -:  101:	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
        -:  102:	0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
        -:  103:	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,
        -:  104:	0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
        -:  105:	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
        -:  106:	0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
        -:  107:	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
        -:  108:	0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
        -:  109:	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
        -:  110:	0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
        -:  111:	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
        -:  112:	0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
        -:  113:	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
        -:  114:	0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
        -:  115:	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,
        -:  116:	0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        -:  117:	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
        -:  118:	0xb0, 0x54, 0xbb, 0x16};
        -:  119:
        -:  120:#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
        -:  121:static const byte rsbox[256] = {
        -:  122:	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e,
        -:  123:	0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
        -:  124:	0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32,
        -:  125:	0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        -:  126:	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49,
        -:  127:	0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
        -:  128:	0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50,
        -:  129:	0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        -:  130:	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05,
        -:  131:	0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
        -:  132:	0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41,
        -:  133:	0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        -:  134:	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8,
        -:  135:	0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
        -:  136:	0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b,
        -:  137:	0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        -:  138:	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59,
        -:  139:	0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
        -:  140:	0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d,
        -:  141:	0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        -:  142:	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63,
        -:  143:	0x55, 0x21, 0x0c, 0x7d};
        -:  144:#endif
        -:  145:
        -:  146:// The round constant word array, Rcon[i], contains the values given by
        -:  147:// x to the power (i-1) being powers of x (x is denoted as {02}) in the field
        -:  148:// GF(2^8)
        -:  149:static const byte Rcon[11] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10,
        -:  150:							  0x20, 0x40, 0x80, 0x1b, 0x36};
        -:  151:
        -:  152:/*
        -:  153: * Jordan Goulder points out in PR #12
        -:  154: * (https://github.com/kokke/tiny-AES-C/pull/12), that you can remove most of
        -:  155: * the elements in the Rcon array, because they are unused.
        -:  156: *
        -:  157: * From Wikipedia's article on the Rijndael key schedule @
        -:  158: * https://en.wikipedia.org/wiki/Rijndael_key_schedule#Rcon
        -:  159: *
        -:  160: * "Only the first some of these constants are actually used â€“ up to rcon[10]
        -:  161: * for AES-128 (as 11 round keys are needed), up to rcon[8] for AES-192, up to
        -:  162: * rcon[7] for AES-256. rcon[0] is not used in AES algorithm."
        -:  163: */
        -:  164:
        -:  165:/*****************************************************************************/
        -:  166:/* Private functions:                                                        */
        -:  167:/*****************************************************************************/
        -:  168:/*
        -:  169:static byte getSBoxValue(byte num)
        -:  170:{
        -:  171:  return sbox[num];
        -:  172:}
        -:  173:*/
        -:  174:#define getSBoxValue(num) (sbox[(num)])
        -:  175:
        -:  176:// This function produces Nb(Nr+1) round keys. The round keys are used in each
        -:  177:// round to decrypt the states.
       12:  178:static void KeyExpansion(byte *RoundKey, const byte *Key) {
        -:  179:	unsigned i, j, k;
        -:  180:	byte tempa[4];	// Used for the column/row operations
        -:  181:
        -:  182:	// The first round key is the key itself.
      108:  183:	for (i = 0; i < Nk; ++i) {
       96:  184:		RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
       96:  185:		RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
       96:  186:		RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
       96:  187:		RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
        -:  188:	}
        -:  189:
        -:  190:	// All other round keys are found from the previous round keys.
      636:  191:	for (i = Nk; i < Nb * (Nr + 1); ++i) {
        -:  192:		{
      624:  193:			k = (i - 1) * 4;
      624:  194:			tempa[0] = RoundKey[k + 0];
      624:  195:			tempa[1] = RoundKey[k + 1];
      624:  196:			tempa[2] = RoundKey[k + 2];
      624:  197:			tempa[3] = RoundKey[k + 3];
        -:  198:		}
        -:  199:
      624:  200:		if (i % Nk == 0) {
        -:  201:			// This function shifts the 4 bytes in a word to the left once.
        -:  202:			// [a0,a1,a2,a3] becomes [a1,a2,a3,a0]
        -:  203:
        -:  204:			// Function RotWord()
        -:  205:			{
       84:  206:				const byte bytetmp = tempa[0];
       84:  207:				tempa[0] = tempa[1];
       84:  208:				tempa[1] = tempa[2];
       84:  209:				tempa[2] = tempa[3];
       84:  210:				tempa[3] = bytetmp;
        -:  211:			}
        -:  212:
        -:  213:			// SubWord() is a function that takes a four-byte input word and
        -:  214:			// applies the S-box to each of the four bytes to produce an output
        -:  215:			// word.
        -:  216:
        -:  217:			// Function Subword()
        -:  218:			{
       84:  219:				tempa[0] = getSBoxValue(tempa[0]);
       84:  220:				tempa[1] = getSBoxValue(tempa[1]);
       84:  221:				tempa[2] = getSBoxValue(tempa[2]);
       84:  222:				tempa[3] = getSBoxValue(tempa[3]);
        -:  223:			}
        -:  224:
       84:  225:			tempa[0] = tempa[0] ^ Rcon[i / Nk];
        -:  226:		}
        -:  227:#if defined(AES256) && (AES256 == 1)
      624:  228:		if (i % Nk == 4) {
        -:  229:			// Function Subword()
        -:  230:			{
       72:  231:				tempa[0] = getSBoxValue(tempa[0]);
       72:  232:				tempa[1] = getSBoxValue(tempa[1]);
       72:  233:				tempa[2] = getSBoxValue(tempa[2]);
       72:  234:				tempa[3] = getSBoxValue(tempa[3]);
        -:  235:			}
        -:  236:		}
        -:  237:#endif
      624:  238:		j = i * 4;
      624:  239:		k = (i - Nk) * 4;
      624:  240:		RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
      624:  241:		RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
      624:  242:		RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
      624:  243:		RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
        -:  244:	}
       12:  245:}
        -:  246:
    #####:  247:void AES_init_ctx(struct AES_ctx *ctx, const byte *key) {
    #####:  248:	KeyExpansion(ctx->RoundKey, key);
    #####:  249:}
        -:  250:#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
       12:  251:void AES_init_ctx_iv(struct AES_ctx *ctx, const byte *key, const byte *iv) {
       12:  252:	KeyExpansion(ctx->RoundKey, key);
       12:  253:	copy_bytes(ctx->Iv, iv, AES_BLOCKLEN);
       12:  254:}
    #####:  255:void AES_ctx_set_iv(struct AES_ctx *ctx, const byte *iv) {
    #####:  256:	copy_bytes(ctx->Iv, iv, AES_BLOCKLEN);
    #####:  257:}
        -:  258:#endif
        -:  259:
        -:  260:// This function adds the round key to state.
        -:  261:// The round key is added to the state by an XOR function.
    15015:  262:static void AddRoundKey(byte round, state_t *state, const byte *RoundKey) {
        -:  263:	byte i, j;
    75075:  264:	for (i = 0; i < 4; ++i) {
   300300:  265:		for (j = 0; j < 4; ++j) {
   240240:  266:			(*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
        -:  267:		}
        -:  268:	}
    15015:  269:}
        -:  270:
        -:  271:// The SubBytes Function Substitutes the values in the
        -:  272:// state matrix with values in an S-box.
    14014:  273:static void SubBytes(state_t *state) {
        -:  274:	byte i, j;
    70070:  275:	for (i = 0; i < 4; ++i) {
   280280:  276:		for (j = 0; j < 4; ++j) {
   224224:  277:			(*state)[j][i] = getSBoxValue((*state)[j][i]);
        -:  278:		}
        -:  279:	}
    14014:  280:}
        -:  281:
        -:  282:// The ShiftRows() function shifts the rows in the state to the left.
        -:  283:// Each row is shifted with different offset.
        -:  284:// Offset = Row number. So the first row is not shifted.
    14014:  285:static void ShiftRows(state_t *state) {
        -:  286:	byte temp;
        -:  287:
        -:  288:	// Rotate first row 1 columns to left
    14014:  289:	temp = (*state)[0][1];
    14014:  290:	(*state)[0][1] = (*state)[1][1];
    14014:  291:	(*state)[1][1] = (*state)[2][1];
    14014:  292:	(*state)[2][1] = (*state)[3][1];
    14014:  293:	(*state)[3][1] = temp;
        -:  294:
        -:  295:	// Rotate second row 2 columns to left
    14014:  296:	temp = (*state)[0][2];
    14014:  297:	(*state)[0][2] = (*state)[2][2];
    14014:  298:	(*state)[2][2] = temp;
        -:  299:
    14014:  300:	temp = (*state)[1][2];
    14014:  301:	(*state)[1][2] = (*state)[3][2];
    14014:  302:	(*state)[3][2] = temp;
        -:  303:
        -:  304:	// Rotate third row 3 columns to left
    14014:  305:	temp = (*state)[0][3];
    14014:  306:	(*state)[0][3] = (*state)[3][3];
    14014:  307:	(*state)[3][3] = (*state)[2][3];
    14014:  308:	(*state)[2][3] = (*state)[1][3];
    14014:  309:	(*state)[1][3] = temp;
    14014:  310:}
        -:  311:
   208208:  312:static byte xtime(byte x) {
   208208:  313:	return ((x << 1) ^ (((x >> 7) & 1) * 0x1b));
        -:  314:}
        -:  315:
        -:  316:// MixColumns function mixes the columns of the state matrix
    13013:  317:static void MixColumns(state_t *state) {
        -:  318:	byte i;
        -:  319:	byte Tmp, Tm, t;
    65065:  320:	for (i = 0; i < 4; ++i) {
    52052:  321:		t = (*state)[i][0];
    52052:  322:		Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3];
    52052:  323:		Tm = (*state)[i][0] ^ (*state)[i][1];
    52052:  324:		Tm = xtime(Tm);
    52052:  325:		(*state)[i][0] ^= Tm ^ Tmp;
    52052:  326:		Tm = (*state)[i][1] ^ (*state)[i][2];
    52052:  327:		Tm = xtime(Tm);
    52052:  328:		(*state)[i][1] ^= Tm ^ Tmp;
    52052:  329:		Tm = (*state)[i][2] ^ (*state)[i][3];
    52052:  330:		Tm = xtime(Tm);
    52052:  331:		(*state)[i][2] ^= Tm ^ Tmp;
    52052:  332:		Tm = (*state)[i][3] ^ t;
    52052:  333:		Tm = xtime(Tm);
    52052:  334:		(*state)[i][3] ^= Tm ^ Tmp;
        -:  335:	}
    13013:  336:}
        -:  337:
        -:  338:// Multiply is used to multiply numbers in the field GF(2^8)
        -:  339:// Note: The last call to xtime() is unneeded, but often ends up generating a
        -:  340:// smaller binary
        -:  341://       The compiler seems to be able to vectorize the operation better this
        -:  342://       way. See https://github.com/kokke/tiny-AES-c/pull/34
        -:  343:#if MULTIPLY_AS_A_FUNCTION
        -:  344:static byte Multiply(byte x, byte y) {
        -:  345:	return (((y & 1) * x) ^ ((y >> 1 & 1) * xtime(x)) ^
        -:  346:			((y >> 2 & 1) * xtime(xtime(x))) ^
        -:  347:			((y >> 3 & 1) * xtime(xtime(xtime(x)))) ^
        -:  348:			((y >> 4 & 1) *
        -:  349:			 xtime(xtime(xtime(
        -:  350:				 xtime(x)))))); /* this last call to xtime() can be omitted */
        -:  351:}
        -:  352:#else
        -:  353:#define Multiply(x, y)                           \
        -:  354:	(((y & 1) * x) ^ ((y >> 1 & 1) * xtime(x)) ^ \
        -:  355:	 ((y >> 2 & 1) * xtime(xtime(x))) ^          \
        -:  356:	 ((y >> 3 & 1) * xtime(xtime(xtime(x)))) ^   \
        -:  357:	 ((y >> 4 & 1) * xtime(xtime(xtime(xtime(x))))))
        -:  358:
        -:  359:#endif
        -:  360:
        -:  361:#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
        -:  362:/*
        -:  363:static byte getSBoxInvert(byte num)
        -:  364:{
        -:  365:  return rsbox[num];
        -:  366:}
        -:  367:*/
        -:  368:#define getSBoxInvert(num) (rsbox[(num)])
        -:  369:
        -:  370:// MixColumns function mixes the columns of the state matrix.
        -:  371:// The method used to multiply may be difficult to understand for the
        -:  372:// inexperienced. Please use the references to gain more information.
    #####:  373:static void InvMixColumns(state_t *state) {
        -:  374:	int i;
        -:  375:	byte a, b, c, d;
    #####:  376:	for (i = 0; i < 4; ++i) {
    #####:  377:		a = (*state)[i][0];
    #####:  378:		b = (*state)[i][1];
    #####:  379:		c = (*state)[i][2];
    #####:  380:		d = (*state)[i][3];
        -:  381:
    #####:  382:		(*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^
    #####:  383:						 Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    #####:  384:		(*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^
    #####:  385:						 Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    #####:  386:		(*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^
    #####:  387:						 Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    #####:  388:		(*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^
    #####:  389:						 Multiply(c, 0x09) ^ Multiply(d, 0x0e);
        -:  390:	}
    #####:  391:}
        -:  392:
        -:  393:// The SubBytes Function Substitutes the values in the
        -:  394:// state matrix with values in an S-box.
    #####:  395:static void InvSubBytes(state_t *state) {
        -:  396:	byte i, j;
    #####:  397:	for (i = 0; i < 4; ++i) {
    #####:  398:		for (j = 0; j < 4; ++j) {
    #####:  399:			(*state)[j][i] = getSBoxInvert((*state)[j][i]);
        -:  400:		}
        -:  401:	}
    #####:  402:}
        -:  403:
    #####:  404:static void InvShiftRows(state_t *state) {
        -:  405:	byte temp;
        -:  406:
        -:  407:	// Rotate first row 1 columns to right
    #####:  408:	temp = (*state)[3][1];
    #####:  409:	(*state)[3][1] = (*state)[2][1];
    #####:  410:	(*state)[2][1] = (*state)[1][1];
    #####:  411:	(*state)[1][1] = (*state)[0][1];
    #####:  412:	(*state)[0][1] = temp;
        -:  413:
        -:  414:	// Rotate second row 2 columns to right
    #####:  415:	temp = (*state)[0][2];
    #####:  416:	(*state)[0][2] = (*state)[2][2];
    #####:  417:	(*state)[2][2] = temp;
        -:  418:
    #####:  419:	temp = (*state)[1][2];
    #####:  420:	(*state)[1][2] = (*state)[3][2];
    #####:  421:	(*state)[3][2] = temp;
        -:  422:
        -:  423:	// Rotate third row 3 columns to right
    #####:  424:	temp = (*state)[0][3];
    #####:  425:	(*state)[0][3] = (*state)[1][3];
    #####:  426:	(*state)[1][3] = (*state)[2][3];
    #####:  427:	(*state)[2][3] = (*state)[3][3];
    #####:  428:	(*state)[3][3] = temp;
    #####:  429:}
        -:  430:#endif	// #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
        -:  431:
        -:  432:// Cipher is the main function that encrypts the PlainText.
     1001:  433:static void Cipher(state_t *state, const byte *RoundKey) {
     1001:  434:	byte round = 0;
        -:  435:
        -:  436:	// Add the First round key to the state before starting the rounds.
     1001:  437:	AddRoundKey(0, state, RoundKey);
        -:  438:
        -:  439:	// There will be Nr rounds.
        -:  440:	// The first Nr-1 rounds are identical.
        -:  441:	// These Nr rounds are executed in the loop below.
        -:  442:	// Last one without MixColumns()
    14014:  443:	for (round = 1;; ++round) {
    14014:  444:		SubBytes(state);
    14014:  445:		ShiftRows(state);
    14014:  446:		if (round == Nr) {
     1001:  447:			break;
        -:  448:		}
    13013:  449:		MixColumns(state);
    13013:  450:		AddRoundKey(round, state, RoundKey);
        -:  451:	}
        -:  452:	// Add round key to last round
     1001:  453:	AddRoundKey(Nr, state, RoundKey);
     1001:  454:}
        -:  455:
        -:  456:#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
    #####:  457:static void InvCipher(state_t *state, const byte *RoundKey) {
    #####:  458:	byte round = 0;
        -:  459:
        -:  460:	// Add the First round key to the state before starting the rounds.
    #####:  461:	AddRoundKey(Nr, state, RoundKey);
        -:  462:
        -:  463:	// There will be Nr rounds.
        -:  464:	// The first Nr-1 rounds are identical.
        -:  465:	// These Nr rounds are executed in the loop below.
        -:  466:	// Last one without InvMixColumn()
    #####:  467:	for (round = (Nr - 1);; --round) {
    #####:  468:		InvShiftRows(state);
    #####:  469:		InvSubBytes(state);
    #####:  470:		AddRoundKey(round, state, RoundKey);
    #####:  471:		if (round == 0) {
    #####:  472:			break;
        -:  473:		}
    #####:  474:		InvMixColumns(state);
        -:  475:	}
    #####:  476:}
        -:  477:#endif	// #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
        -:  478:
        -:  479:/*****************************************************************************/
        -:  480:/* Public functions:                                                         */
        -:  481:/*****************************************************************************/
        -:  482:#if defined(ECB) && (ECB == 1)
        -:  483:
    #####:  484:void AES_ECB_encrypt(const struct AES_ctx *ctx, byte *buf) {
        -:  485:	// The next function call encrypts the PlainText with the Key using AES
        -:  486:	// algorithm.
    #####:  487:	Cipher((state_t *)buf, ctx->RoundKey);
    #####:  488:}
        -:  489:
    #####:  490:void AES_ECB_decrypt(const struct AES_ctx *ctx, byte *buf) {
        -:  491:	// The next function call decrypts the PlainText with the Key using AES
        -:  492:	// algorithm.
    #####:  493:	InvCipher((state_t *)buf, ctx->RoundKey);
    #####:  494:}
        -:  495:
        -:  496:#endif	// #if defined(ECB) && (ECB == 1)
        -:  497:
        -:  498:#if defined(CBC) && (CBC == 1)
        -:  499:
    #####:  500:static void XorWithIv(byte *buf, const byte *Iv) {
        -:  501:	byte i;
    #####:  502:	for (i = 0; i < AES_BLOCKLEN;
    #####:  503:		 ++i)  // The block in AES is always 128bit no matter the key size
        -:  504:	{
    #####:  505:		buf[i] ^= Iv[i];
        -:  506:	}
    #####:  507:}
        -:  508:
    #####:  509:void AES_CBC_encrypt_buffer(struct AES_ctx *ctx, byte *buf,
        -:  510:							unsigned long long length) {
        -:  511:	unsigned long long i;
    #####:  512:	byte *Iv = ctx->Iv;
    #####:  513:	for (i = 0; i < length; i += AES_BLOCKLEN) {
    #####:  514:		XorWithIv(buf, Iv);
    #####:  515:		Cipher((state_t *)buf, ctx->RoundKey);
    #####:  516:		Iv = buf;
    #####:  517:		buf += AES_BLOCKLEN;
        -:  518:	}
        -:  519:	/* store Iv in ctx for next call */
    #####:  520:	copy_bytes(ctx->Iv, Iv, AES_BLOCKLEN);
    #####:  521:}
        -:  522:
    #####:  523:void AES_CBC_decrypt_buffer(struct AES_ctx *ctx, byte *buf,
        -:  524:							unsigned long long length) {
        -:  525:	unsigned long long i;
        -:  526:	byte storeNextIv[AES_BLOCKLEN];
    #####:  527:	for (i = 0; i < length; i += AES_BLOCKLEN) {
    #####:  528:		copy_bytes(storeNextIv, buf, AES_BLOCKLEN);
    #####:  529:		InvCipher((state_t *)buf, ctx->RoundKey);
    #####:  530:		XorWithIv(buf, ctx->Iv);
    #####:  531:		copy_bytes(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    #####:  532:		buf += AES_BLOCKLEN;
        -:  533:	}
    #####:  534:}
        -:  535:
        -:  536:#endif	// #if defined(CBC) && (CBC == 1)
        -:  537:
        -:  538:#if defined(CTR) && (CTR == 1)
        -:  539:
        -:  540:/* Symmetrical operation: same function for encrypting as for decrypting. Note
        -:  541: * any IV/nonce should never be reused with the same key */
     1001:  542:void AES_CTR_xcrypt_buffer(struct AES_ctx *ctx, byte *buf,
        -:  543:						   unsigned long long length) {
        -:  544:	byte buffer[AES_BLOCKLEN];
        -:  545:
        -:  546:	unsigned long long i;
        -:  547:	int bi;
     5009:  548:	for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi) {
     4008:  549:		if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
        -:  550:		{
     1001:  551:			copy_bytes(buffer, ctx->Iv, AES_BLOCKLEN);
     1001:  552:			Cipher((state_t *)buffer, ctx->RoundKey);
        -:  553:
        -:  554:			/* Increment Iv and handle overflow */
     1004:  555:			for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi) {
        -:  556:				/* inc will overflow */
     1004:  557:				if (ctx->Iv[bi] == 255) {
        3:  558:					ctx->Iv[bi] = 0;
        3:  559:					continue;
        -:  560:				}
     1001:  561:				ctx->Iv[bi] += 1;
     1001:  562:				break;
        -:  563:			}
     1001:  564:			bi = 0;
        -:  565:		}
        -:  566:
     4008:  567:		buf[i] = (buf[i] ^ buffer[bi]);
        -:  568:	}
     1001:  569:}
        -:  570:
        -:  571:#endif	// #if defined(CTR) && (CTR == 1)
        -:    0:Source:cpsrng.c
        -:    0:Graph:cpsrng.gcno
        -:    0:Data:cpsrng.gcda
        -:    0:Runs:11
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/print_util.h>
        -:   16:#include <crypto/aes.h>
        -:   17:#include <crypto/cpsrng.h>
        -:   18:#include <crypto/rand.h>
        -:   19:
        -:   20:static struct AES_ctx aes_ctx;
        -:   21:
       11:   22:void cpsrng_reseed() {
        -:   23:	byte iv[16];
        -:   24:	byte key[32];
       11:   25:	if (rand_bytes(key, 32)) {
    #####:   26:		panic("Could not generate entropy for AES key generation");
        -:   27:	}
       11:   28:	if (rand_bytes(iv, 16)) {
    #####:   29:		panic("Could not generate entropy for AES iv generation");
        -:   30:	}
        -:   31:
       11:   32:	AES_init_ctx_iv(&aes_ctx, key, iv);
       11:   33:}
        -:   34:
        -:   35:// __attribute__ ((constructor)) guaranteed to be called before main.
        -:   36:// This will either succeed or exit before main is called.
       11:   37:void __attribute__((constructor)) __init_cpsrng() {
       11:   38:	cpsrng_reseed();
       11:   39:}
        -:   40:
        -:   41:// note: not thread safe as user must ensure thread safety. This allows for
        -:   42:// flexible usage in a single thread, no locking is needed. In multi-threaded
        -:   43:// environments, locking may be used.
    #####:   44:void cpsrng_rand_byte(byte *v) {
    #####:   45:	AES_CTR_xcrypt_buffer(&aes_ctx, v, sizeof(byte));
    #####:   46:}
        -:   47:
        -:   48:// note: not thread safe as user must ensure thread safety. This allows for
        -:   49:// flexible usage in a single thread, no locking is needed. In multi-threaded
        -:   50:// environments, locking may be used.
        1:   51:void cpsrng_rand_int64(int64 *v) {
        1:   52:	AES_CTR_xcrypt_buffer(&aes_ctx, (byte *)v, sizeof(int64));
        1:   53:}
        -:   54:
        -:   55:// note: not thread safe as user must ensure thread safety. This allows for
        -:   56:// flexible usage in a single thread, no locking is needed. In multi-threaded
        -:   57:// environments, locking may be used.
     1000:   58:void cpsrng_rand_int(int *v) {
     1000:   59:	AES_CTR_xcrypt_buffer(&aes_ctx, (byte *)v, sizeof(int));
     1000:   60:}
        -:   61:
        -:   62:// note: not thread safe as user must ensure thread safety. This allows for
        -:   63:// flexible usage in a single thread, no locking is needed. In multi-threaded
        -:   64:// environments, locking may be used.
    #####:   65:void cpsrng_rand_bytes(void *v, unsigned long long size) {
    #####:   66:	AES_CTR_xcrypt_buffer(&aes_ctx, (byte *)v, size);
    #####:   67:}
        -:   68:
        -:   69:// only available in test mode for tests. Not used in production environments.
        -:   70:#ifdef TEST
        1:   71:void cpsrng_test_seed(byte iv[16], byte key[32]) {
        1:   72:	AES_init_ctx_iv(&aes_ctx, key, iv);
        1:   73:	int64 v0 = 0;
        1:   74:	cpsrng_rand_int64(&v0);
        1:   75:}
        -:   76:#endif	// TEST
        -:    0:Source:murmurhash.c
        -:    0:Graph:murmurhash.gcno
        -:    0:Data:murmurhash.gcda
        -:    0:Runs:11
        -:    1:/**
        -:    2: * `murmurhash.h' - murmurhash
        -:    3: *
        -:    4: * copyright (c) 2014-2022 joseph werle <joseph.werle@gmail.com>
        -:    5: */
        -:    6:
        -:    7:#include <crypto/murmurhash.h>
        -:    8:
    #####:    9:unsigned int murmurhash(const byte *key, unsigned int len, unsigned int seed) {
    #####:   10:	unsigned int c1 = 0xcc9e2d51;
    #####:   11:	unsigned int c2 = 0x1b873593;
    #####:   12:	unsigned int r1 = 15;
    #####:   13:	unsigned int r2 = 13;
    #####:   14:	unsigned int m = 5;
    #####:   15:	unsigned int n = 0xe6546b64;
    #####:   16:	unsigned int h = 0;
    #####:   17:	unsigned int k = 0;
    #####:   18:	byte *d = (byte *)key;	// 32 bit extract from `key'
    #####:   19:	const unsigned int *chunks = NULL;
    #####:   20:	const byte *tail = NULL;  // tail - last 8 bytes
    #####:   21:	int i = 0;
    #####:   22:	int l = len / 4;  // chunk length
        -:   23:
    #####:   24:	h = seed;
        -:   25:
    #####:   26:	chunks = (const unsigned int *)(d + l * 4);	 // body
    #####:   27:	tail = (const byte *)(d + l * 4);			 // last 8 byte chunk of `key'
        -:   28:
        -:   29:	// for each 4 byte chunk of `key'
    #####:   30:	for (i = -l; i != 0; ++i) {
        -:   31:		// next 4 byte chunk of `key'
    #####:   32:		k = chunks[i];
        -:   33:
        -:   34:		// encode next 4 byte chunk of `key'
    #####:   35:		k *= c1;
    #####:   36:		k = (k << r1) | (k >> (32 - r1));
    #####:   37:		k *= c2;
        -:   38:
        -:   39:		// append to hash
    #####:   40:		h ^= k;
    #####:   41:		h = (h << r2) | (h >> (32 - r2));
    #####:   42:		h = h * m + n;
        -:   43:	}
        -:   44:
    #####:   45:	k = 0;
        -:   46:
        -:   47:	// remainder
    #####:   48:	switch (len & 3) {	// `len % 4'
    #####:   49:		case 3:
    #####:   50:			k ^= (tail[2] << 16);
    #####:   51:		case 2:
    #####:   52:			k ^= (tail[1] << 8);
        -:   53:
    #####:   54:		case 1:
    #####:   55:			k ^= tail[0];
    #####:   56:			k *= c1;
    #####:   57:			k = (k << r1) | (k >> (32 - r1));
    #####:   58:			k *= c2;
    #####:   59:			h ^= k;
        -:   60:	}
        -:   61:
    #####:   62:	h ^= len;
        -:   63:
    #####:   64:	h ^= (h >> 16);
    #####:   65:	h *= 0x85ebca6b;
    #####:   66:	h ^= (h >> 13);
    #####:   67:	h *= 0xc2b2ae35;
    #####:   68:	h ^= (h >> 16);
        -:   69:
    #####:   70:	return h;
        -:   71:}
        -:    0:Source:rand.c
        -:    0:Graph:rand.gcno
        -:    0:Data:rand.gcda
        -:    0:Runs:11
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:#include <crypto/rand.h>
        -:   17:#include <sys/random.h>
        -:   18:
    #####:   19:int rand_byte(byte *v) {
    #####:   20:	return getentropy(v, sizeof(byte));
        -:   21:}
        -:   22:
    #####:   23:int rand_int(int *v) {
    #####:   24:	return getentropy(v, sizeof(int));
        -:   25:}
        -:   26:
    #####:   27:int rand_int64(int64 *v) {
    #####:   28:	return getentropy(v, sizeof(int64));
        -:   29:}
        -:   30:
       22:   31:int rand_bytes(void *buf, int64 length) {
       22:   32:	return getentropy(buf, length);
        -:   33:}
        -:    0:Source:sha3.c
        -:    0:Graph:sha3.gcno
        -:    0:Data:sha3.gcda
        -:    0:Runs:11
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:/* -------------------------------------------------------------------------
        -:   16: * Works when compiled for either 32-bit or 64-bit targets, optimized for
        -:   17: * 64 bit.
        -:   18: *
        -:   19: * Canonical implementation of Init/Update/Finalize for SHA-3 byte input.
        -:   20: *
        -:   21: * SHA3-256, SHA3-384, SHA-512 are implemented. SHA-224 can easily be added.
        -:   22: *
        -:   23: * Based on code from http://keccak.noekeon.org/ .
        -:   24: *
        -:   25: * I place the code that I wrote into public domain, free to use.
        -:   26: *
        -:   27: * I would appreciate if you give credits to this work if you used it to
        -:   28: * write or test * your code.
        -:   29: *
        -:   30: * Aug 2015. Andrey Jivsov. crypto@brainhub.org
        -:   31: * ---------------------------------------------------------------------- */
        -:   32:
        -:   33:#include <base/util.h>
        -:   34:#include <crypto/sha3.h>
        -:   35:
        -:   36:#define SHA3_ASSERT(x)
        -:   37:#define SHA3_TRACE(format, ...)
        -:   38:#define SHA3_TRACE_BUF(format, buf, l)
        -:   39:
        -:   40:/*
        -:   41: * This flag is used to configure "pure" Keccak, as opposed to NIST SHA3.
        -:   42: */
        -:   43:#define SHA3_USE_KECCAK_FLAG 0x80000000
        -:   44:#define SHA3_CW(x) ((x) & (~SHA3_USE_KECCAK_FLAG))
        -:   45:
        -:   46:#if defined(_MSC_VER)
        -:   47:#define SHA3_CONST(x) x
        -:   48:#else
        -:   49:#define SHA3_CONST(x) x##L
        -:   50:#endif
        -:   51:
        -:   52:#ifndef SHA3_ROTL64
        -:   53:#define SHA3_ROTL64(x, y) \
        -:   54:	(((x) << (y)) | ((x) >> ((sizeof(unsigned long long) * 8) - (y))))
        -:   55:#endif
        -:   56:
        -:   57:static const unsigned long long keccakf_rndc[24] = {
        -:   58:	SHA3_CONST(0x0000000000000001UL), SHA3_CONST(0x0000000000008082UL),
        -:   59:	SHA3_CONST(0x800000000000808aUL), SHA3_CONST(0x8000000080008000UL),
        -:   60:	SHA3_CONST(0x000000000000808bUL), SHA3_CONST(0x0000000080000001UL),
        -:   61:	SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008009UL),
        -:   62:	SHA3_CONST(0x000000000000008aUL), SHA3_CONST(0x0000000000000088UL),
        -:   63:	SHA3_CONST(0x0000000080008009UL), SHA3_CONST(0x000000008000000aUL),
        -:   64:	SHA3_CONST(0x000000008000808bUL), SHA3_CONST(0x800000000000008bUL),
        -:   65:	SHA3_CONST(0x8000000000008089UL), SHA3_CONST(0x8000000000008003UL),
        -:   66:	SHA3_CONST(0x8000000000008002UL), SHA3_CONST(0x8000000000000080UL),
        -:   67:	SHA3_CONST(0x000000000000800aUL), SHA3_CONST(0x800000008000000aUL),
        -:   68:	SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008080UL),
        -:   69:	SHA3_CONST(0x0000000080000001UL), SHA3_CONST(0x8000000080008008UL)};
        -:   70:
        -:   71:static const unsigned keccakf_rotc[24] = {1,  3,  6,  10, 15, 21, 28, 36,
        -:   72:										  45, 55, 2,  14, 27, 41, 56, 8,
        -:   73:										  25, 43, 62, 18, 39, 61, 20, 44};
        -:   74:
        -:   75:static const unsigned keccakf_piln[24] = {10, 7,  11, 17, 18, 3,  5,  16,
        -:   76:										  8,  21, 24, 4,  15, 23, 19, 13,
        -:   77:										  12, 2,  20, 14, 22, 9,  6,  1};
        -:   78:
        -:   79:/* generally called after SHA3_KECCAK_SPONGE_WORDS-ctx->capacityWords words
        -:   80: * are XORed into the state s
        -:   81: */
    #####:   82:static void keccakf(unsigned long long s[25]) {
        -:   83:	int i, j, round;
        -:   84:	unsigned long long t, bc[5];
        -:   85:#define KECCAK_ROUNDS 24
        -:   86:
    #####:   87:	for (round = 0; round < KECCAK_ROUNDS; round++) {
        -:   88:		/* Theta */
    #####:   89:		for (i = 0; i < 5; i++)
    #####:   90:			bc[i] = s[i] ^ s[i + 5] ^ s[i + 10] ^ s[i + 15] ^ s[i + 20];
        -:   91:
    #####:   92:		for (i = 0; i < 5; i++) {
    #####:   93:			t = bc[(i + 4) % 5] ^ SHA3_ROTL64(bc[(i + 1) % 5], 1);
    #####:   94:			for (j = 0; j < 25; j += 5) s[j + i] ^= t;
        -:   95:		}
        -:   96:
        -:   97:		/* Rho Pi */
    #####:   98:		t = s[1];
    #####:   99:		for (i = 0; i < 24; i++) {
    #####:  100:			j = keccakf_piln[i];
    #####:  101:			bc[0] = s[j];
    #####:  102:			s[j] = SHA3_ROTL64(t, keccakf_rotc[i]);
    #####:  103:			t = bc[0];
        -:  104:		}
        -:  105:
        -:  106:		/* Chi */
    #####:  107:		for (j = 0; j < 25; j += 5) {
    #####:  108:			for (i = 0; i < 5; i++) bc[i] = s[j + i];
    #####:  109:			for (i = 0; i < 5; i++)
    #####:  110:				s[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
        -:  111:		}
        -:  112:
        -:  113:		/* Iota */
    #####:  114:		s[0] ^= keccakf_rndc[round];
        -:  115:	}
    #####:  116:}
        -:  117:
        -:  118:/* *************************** Public Inteface ************************ */
        -:  119:
        -:  120:/* For Init or Reset call these: */
    #####:  121:sha3_return_t sha3_Init(void *priv, unsigned bitSize) {
    #####:  122:	sha3_context *ctx = (sha3_context *)priv;
    #####:  123:	if (bitSize != 256 && bitSize != 384 && bitSize != 512)
    #####:  124:		return SHA3_RETURN_BAD_PARAMS;
    #####:  125:	set_bytes((byte *)ctx, 0, sizeof(*ctx));
    #####:  126:	ctx->capacityWords = 2 * bitSize / (8 * sizeof(unsigned long long));
    #####:  127:	return SHA3_RETURN_OK;
        -:  128:}
        -:  129:
    #####:  130:void sha3_Init256(void *priv) {
    #####:  131:	sha3_Init(priv, 256);
    #####:  132:}
        -:  133:
    #####:  134:void sha3_Init384(void *priv) {
    #####:  135:	sha3_Init(priv, 384);
    #####:  136:}
        -:  137:
    #####:  138:void sha3_Init512(void *priv) {
    #####:  139:	sha3_Init(priv, 512);
    #####:  140:}
        -:  141:
    #####:  142:enum SHA3_FLAGS sha3_SetFlags(void *priv, enum SHA3_FLAGS flags) {
    #####:  143:	sha3_context *ctx = (sha3_context *)priv;
    #####:  144:	flags &= SHA3_FLAGS_KECCAK;
    #####:  145:	ctx->capacityWords |=
    #####:  146:		(flags == SHA3_FLAGS_KECCAK ? SHA3_USE_KECCAK_FLAG : 0);
    #####:  147:	return flags;
        -:  148:}
        -:  149:
    #####:  150:void sha3_Update(void *priv, void const *bufIn, unsigned long long len) {
    #####:  151:	sha3_context *ctx = (sha3_context *)priv;
        -:  152:
        -:  153:	/* 0...7 -- how much is needed to have a word */
    #####:  154:	unsigned old_tail = (8 - ctx->byteIndex) & 7;
        -:  155:
        -:  156:	unsigned long long words;
        -:  157:	unsigned tail;
        -:  158:	unsigned long long i;
        -:  159:
    #####:  160:	const byte *buf = bufIn;
        -:  161:
        -:  162:	SHA3_TRACE_BUF("called to update with:", buf, len);
        -:  163:
        -:  164:	SHA3_ASSERT(ctx->byteIndex < 8);
        -:  165:	SHA3_ASSERT(ctx->wordIndex < sizeof(ctx->u.s) / sizeof(ctx->u.s[0]));
        -:  166:
    #####:  167:	if (len < old_tail) { /* have no complete word or haven't started
        -:  168:						   * the word yet */
        -:  169:		SHA3_TRACE("because %d<%d, store it and return", (unsigned)len,
        -:  170:				   (unsigned)old_tail);
        -:  171:		/* endian-independent code follows: */
    #####:  172:		while (len--)
    #####:  173:			ctx->saved |= (unsigned long long)(*(buf++))
    #####:  174:						  << ((ctx->byteIndex++) * 8);
        -:  175:		SHA3_ASSERT(ctx->byteIndex < 8);
    #####:  176:		return;
        -:  177:	}
        -:  178:
    #####:  179:	if (old_tail) { /* will have one word to process */
        -:  180:		SHA3_TRACE("completing one word with %d bytes", (unsigned)old_tail);
        -:  181:		/* endian-independent code follows: */
    #####:  182:		len -= old_tail;
    #####:  183:		while (old_tail--)
    #####:  184:			ctx->saved |= (unsigned long long)(*(buf++))
    #####:  185:						  << ((ctx->byteIndex++) * 8);
        -:  186:
        -:  187:		/* now ready to add saved to the sponge */
    #####:  188:		ctx->u.s[ctx->wordIndex] ^= ctx->saved;
        -:  189:		SHA3_ASSERT(ctx->byteIndex == 8);
    #####:  190:		ctx->byteIndex = 0;
    #####:  191:		ctx->saved = 0;
    #####:  192:		if (++ctx->wordIndex ==
    #####:  193:			(SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords))) {
    #####:  194:			keccakf(ctx->u.s);
    #####:  195:			ctx->wordIndex = 0;
        -:  196:		}
        -:  197:	}
        -:  198:
        -:  199:	/* now work in full words directly from input */
        -:  200:
        -:  201:	SHA3_ASSERT(ctx->byteIndex == 0);
        -:  202:
    #####:  203:	words = len / sizeof(unsigned long long);
    #####:  204:	tail = len - words * sizeof(unsigned long long);
        -:  205:
        -:  206:	SHA3_TRACE("have %d full words to process", (unsigned)words);
        -:  207:
    #####:  208:	for (i = 0; i < words; i++, buf += sizeof(unsigned long long)) {
    #####:  209:		const unsigned long long t = (unsigned long long)(buf[0]) |
    #####:  210:									 ((unsigned long long)(buf[1]) << 8 * 1) |
    #####:  211:									 ((unsigned long long)(buf[2]) << 8 * 2) |
    #####:  212:									 ((unsigned long long)(buf[3]) << 8 * 3) |
    #####:  213:									 ((unsigned long long)(buf[4]) << 8 * 4) |
    #####:  214:									 ((unsigned long long)(buf[5]) << 8 * 5) |
    #####:  215:									 ((unsigned long long)(buf[6]) << 8 * 6) |
    #####:  216:									 ((unsigned long long)(buf[7]) << 8 * 7);
        -:  217:#if defined(__x86_64__) || defined(__i386__)
        -:  218:		SHA3_ASSERT(memcmp(&t, buf, 8) == 0);
        -:  219:#endif
    #####:  220:		ctx->u.s[ctx->wordIndex] ^= t;
    #####:  221:		if (++ctx->wordIndex ==
    #####:  222:			(SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords))) {
    #####:  223:			keccakf(ctx->u.s);
    #####:  224:			ctx->wordIndex = 0;
        -:  225:		}
        -:  226:	}
        -:  227:
        -:  228:	SHA3_TRACE("have %d bytes left to process, save them", (unsigned)tail);
        -:  229:
        -:  230:	/* finally, save the partial word */
        -:  231:	SHA3_ASSERT(ctx->byteIndex == 0 && tail < 8);
    #####:  232:	while (tail--) {
        -:  233:		SHA3_TRACE("Store byte %02x '%c'", *buf, *buf);
    #####:  234:		ctx->saved |= (unsigned long long)(*(buf++))
    #####:  235:					  << ((ctx->byteIndex++) * 8);
        -:  236:	}
        -:  237:	SHA3_ASSERT(ctx->byteIndex < 8);
        -:  238:	SHA3_TRACE("Have saved=0x%016" PRIx64 " at the end", ctx->saved);
        -:  239:}
        -:  240:
        -:  241:/* This is simply the 'update' with the padding block.
        -:  242: * The padding block is 0x01 || 0x00* || 0x80. First 0x01 and last 0x80
        -:  243: * bytes are always present, but they can be the same byte.
        -:  244: */
    #####:  245:void const *sha3_Finalize(void *priv) {
    #####:  246:	sha3_context *ctx = (sha3_context *)priv;
        -:  247:
        -:  248:	SHA3_TRACE("called with %d bytes in the buffer", ctx->byteIndex);
        -:  249:
        -:  250:	/* Append 2-bit suffix 01, per SHA-3 spec. Instead of 1 for padding we
        -:  251:	 * use 1<<2 below. The 0x02 below corresponds to the suffix 01.
        -:  252:	 * Overall, we feed 0, then 1, and finally 1 to start padding. Without
        -:  253:	 * M || 01, we would simply use 1 to start padding. */
        -:  254:
        -:  255:	unsigned long long t;
        -:  256:
    #####:  257:	if (ctx->capacityWords & SHA3_USE_KECCAK_FLAG) {
        -:  258:		/* Keccak version */
    #####:  259:		t = (unsigned long long)(((unsigned long long)1)
    #####:  260:								 << (ctx->byteIndex * 8));
        -:  261:	} else {
        -:  262:		/* SHA3 version */
    #####:  263:		t = (unsigned long long)(((unsigned long long)(0x02 | (1 << 2)))
    #####:  264:								 << ((ctx->byteIndex) * 8));
        -:  265:	}
        -:  266:
    #####:  267:	ctx->u.s[ctx->wordIndex] ^= ctx->saved ^ t;
        -:  268:
    #####:  269:	ctx->u.s[SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords) - 1] ^=
        -:  270:		SHA3_CONST(0x8000000000000000UL);
    #####:  271:	keccakf(ctx->u.s);
        -:  272:
        -:  273:	/* Return first bytes of the ctx->s. This conversion is not needed for
        -:  274:	 * little-endian platforms e.g. wrap with #if !defined(__BYTE_ORDER__)
        -:  275:	 * || !defined(__ORDER_LITTLE_ENDIAN__) ||
        -:  276:	 * __BYTE_ORDER__!=__ORDER_LITTLE_ENDIAN__
        -:  277:	 *    ... the conversion below ...
        -:  278:	 * #endif */
        -:  279:	{
        -:  280:		unsigned i;
    #####:  281:		for (i = 0; i < SHA3_KECCAK_SPONGE_WORDS; i++) {
    #####:  282:			const unsigned t1 = (unsigned int)ctx->u.s[i];
    #####:  283:			const unsigned t2 = (unsigned int)((ctx->u.s[i] >> 16) >> 16);
    #####:  284:			ctx->u.sb[i * 8 + 0] = (byte)(t1);
    #####:  285:			ctx->u.sb[i * 8 + 1] = (byte)(t1 >> 8);
    #####:  286:			ctx->u.sb[i * 8 + 2] = (byte)(t1 >> 16);
    #####:  287:			ctx->u.sb[i * 8 + 3] = (byte)(t1 >> 24);
    #####:  288:			ctx->u.sb[i * 8 + 4] = (byte)(t2);
    #####:  289:			ctx->u.sb[i * 8 + 5] = (byte)(t2 >> 8);
    #####:  290:			ctx->u.sb[i * 8 + 6] = (byte)(t2 >> 16);
    #####:  291:			ctx->u.sb[i * 8 + 7] = (byte)(t2 >> 24);
        -:  292:		}
        -:  293:	}
        -:  294:
        -:  295:	SHA3_TRACE_BUF("Hash: (first 32 bytes)", ctx->u.sb, 256 / 8);
        -:  296:
    #####:  297:	return (ctx->u.sb);
        -:  298:}
        -:  299:
    #####:  300:sha3_return_t sha3_HashBuffer(unsigned bitSize, enum SHA3_FLAGS flags,
        -:  301:							  const void *in, unsigned inBytes, void *out,
        -:  302:							  unsigned outBytes) {
        -:  303:	sha3_return_t err;
        -:  304:	sha3_context c;
        -:  305:
    #####:  306:	err = sha3_Init(&c, bitSize);
    #####:  307:	if (err != SHA3_RETURN_OK) return err;
    #####:  308:	if (sha3_SetFlags(&c, flags) != flags) {
    #####:  309:		return SHA3_RETURN_BAD_PARAMS;
        -:  310:	}
    #####:  311:	sha3_Update(&c, in, inBytes);
    #####:  312:	const void *h = sha3_Finalize(&c);
        -:  313:
    #####:  314:	if (outBytes > bitSize / 8) outBytes = bitSize / 8;
    #####:  315:	copy_bytes(out, h, outBytes);
    #####:  316:	return SHA3_RETURN_OK;
        -:  317:}
        -:    0:Source:object.c
        -:    0:Graph:object.gcno
        -:    0:Data:object.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/lock.h>
        -:   16:#include <base/macros.h>
        -:   17:#include <base/mmap.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <base/slabs.h>
        -:   20:#include <base/util.h>
        -:   21:#include <core/err.h>
        -:   22:#include <core/macros.h>
        -:   23:#include <core/object.h>
        -:   24:#include <core/orbtree.h>
        -:   25:#include <stddef.h>
        -:   26:
        -:   27:// #define offsetof(type, member) ((unsigned long long)&(((type *)0)->member))
        -:   28:
        -:   29:#define OBJECT_MAX_FREE_LIST_SIZE 1024
        -:   30:#define OBJECT_PROPERTY_KV_SSO_LEN \
        -:   31:	OBJECT_SSO_DATA_BUFFER_SIZE -  \
        -:   32:		(sizeof(unsigned int) + sizeof(OrbTreeNode) * 2)
        -:   33:
        -:   34:static OrbTree seqtree;
        -:   35:static OrbTree ordtree;
        -:   36:static SlabAllocator sa;
        -:   37:static unsigned long long next_namespace = 0;
        -:   38:
        -:   39:typedef struct ObjectImpl {
        -:   40:	union {
        -:   41:		int int_value;
        -:   42:		float float_value;
        -:   43:		byte byte_value;
        -:   44:		bool bool_value;
        -:   45:		Ptr ptr_value;
        -:   46:		void *function_value;
        -:   47:	} data;
        -:   48:	unsigned int type : 6;
        -:   49:	unsigned int consumed : 1;
        -:   50:	unsigned int no_cleanup : 1;
        -:   51:} ObjectImpl;
        -:   52:
        -:   53:typedef struct __attribute__((packed)) ObjectBox {
        -:   54:	unsigned int size;
        -:   55:	unsigned long long namespace;
        -:   56:	byte sso_data[OBJECT_SSO_DATA_BUFFER_SIZE];
        -:   57:	unsigned int resize_seqno;
        -:   58:	Lock lock;
        -:   59:	void *extended;
        -:   60:	unsigned int strong_count;
        -:   61:	unsigned int weak_count;
        -:   62:} ObjectBox;
        -:   63:
        -:   64:typedef struct __attribute__((packed)) ObjectPropertyBoxData {
        -:   65:	OrbTreeNode ord;
        -:   66:	OrbTreeNode seq;
        -:   67:	unsigned int seqno;
        -:   68:	byte key_value_sso[OBJECT_PROPERTY_KV_SSO_LEN];
        -:   69:} ObjectPropertyBoxData;
        -:   70:
        -:   71:// Extended data has spill over from the key_value_sso data:
        -:   72:// 5.) [n bytes of key data]
        -:   73:// 6.) [16 bytes value data]
        -:   74:
        4:   75:static ObjectBox *object_get_box_data(ObjectImpl *impl) {
        4:   76:	Ptr ptr = impl->data.ptr_value;
       4*:   77:	if (ptr == null) return NULL;
        4:   78:	return (ObjectBox *)slab_get(&sa, ptr);
        -:   79:}
        -:   80:
        1:   81:static int ordtree_search(const OrbTreeNode *root, const OrbTreeNode *value,
        -:   82:						  OrbTreeNodePair *retval) {
        1:   83:	retval->parent = null;
        1:   84:	retval->is_right = true;
        1:   85:	const OrbTreeNode *cur = root;
        1:   86:	unsigned int offsetof = offsetof(ObjectBox, sso_data);
        -:   87:
        1:   88:	while (cur) {
        1:   89:		ObjectBox *v1 = (ObjectBox *)((byte *)cur - offsetof);
        1:   90:		ObjectBox *v2 = (ObjectBox *)((byte *)value - offsetof);
        1:   91:		retval->self = orbtree_node_ptr(cur, retval->is_right);
        -:   92:
        1:   93:		if (v1->namespace == v2->namespace) {
        1:   94:			ObjectPropertyBoxData *v1prop =
        -:   95:				(ObjectPropertyBoxData *)v1->sso_data;
        1:   96:			ObjectPropertyBoxData *v2prop =
        -:   97:				(ObjectPropertyBoxData *)v2->sso_data;
        1:   98:			byte *key1 = v1prop->key_value_sso;
        1:   99:			byte *key2 = v2prop->key_value_sso;
        -:  100:			unsigned int len;
        1:  101:			if (v2->size < v1->size)
    #####:  102:				len = v2->size;
        -:  103:			else
        1:  104:				len = v1->size;
        1:  105:			unsigned int overhead =
        -:  106:				sizeof(OrbTreeNode) * 2 + sizeof(unsigned int) + sizeof(Object);
       1*:  107:			if (len < overhead) break;
        1:  108:			len -= overhead;
        1:  109:			int v = cstring_compare_n(key1, key2, len);
        1:  110:			if (v == 0 && v1->size == v2->size)
        -:  111:				break;
    #####:  112:			else if ((v == 0 && v1->size > v2->size) || v > 0) {
    #####:  113:				ObjectBox *right = orbtree_node_right(cur);
    #####:  114:				if (right == NULL) {
    #####:  115:					retval->parent = retval->self;
    #####:  116:					retval->self = null;
    #####:  117:					retval->is_right = true;
    #####:  118:					break;
        -:  119:				}
    #####:  120:				ObjectPropertyBoxData *opbd =
        -:  121:					(ObjectPropertyBoxData *)right->sso_data;
    #####:  122:				Ptr rptr = orbtree_node_ptr(&opbd->ord, true);
    #####:  123:				retval->parent = orbtree_node_ptr(cur, retval->is_right);
    #####:  124:				retval->is_right = true;
    #####:  125:				cur = (const OrbTreeNode *)(slab_get(&sa, rptr) + offsetof);
        -:  126:			} else {
    #####:  127:				ObjectBox *left = orbtree_node_left(cur);
    #####:  128:				if (left == NULL) {
    #####:  129:					retval->parent = retval->self;
    #####:  130:					retval->self = null;
    #####:  131:					retval->is_right = false;
    #####:  132:					break;
        -:  133:				}
    #####:  134:				ObjectPropertyBoxData *opbd =
        -:  135:					(ObjectPropertyBoxData *)left->sso_data;
    #####:  136:				Ptr lptr = orbtree_node_ptr(&opbd->ord, false);
    #####:  137:				retval->parent = orbtree_node_ptr(cur, retval->is_right);
    #####:  138:				retval->is_right = false;
    #####:  139:				cur = (const OrbTreeNode *)(slab_get(&sa, lptr) + offsetof);
        -:  140:			}
        -:  141:
    #####:  142:		} else if (v1->namespace > v2->namespace) {
    #####:  143:			ObjectBox *right = orbtree_node_right(cur);
    #####:  144:			if (right == NULL) {
    #####:  145:				retval->parent = retval->self;
    #####:  146:				retval->self = null;
    #####:  147:				retval->is_right = true;
    #####:  148:				break;
        -:  149:			}
    #####:  150:			ObjectPropertyBoxData *opbd =
        -:  151:				(ObjectPropertyBoxData *)right->sso_data;
    #####:  152:			Ptr rptr = orbtree_node_ptr(&opbd->ord, true);
    #####:  153:			retval->parent = orbtree_node_ptr(cur, retval->is_right);
    #####:  154:			retval->is_right = true;
    #####:  155:			cur = (const OrbTreeNode *)(slab_get(&sa, rptr) + offsetof);
        -:  156:		} else {
    #####:  157:			ObjectBox *left = orbtree_node_left(cur);
    #####:  158:			if (left == NULL) {
    #####:  159:				retval->parent = retval->self;
    #####:  160:				retval->self = null;
    #####:  161:				retval->is_right = false;
    #####:  162:				break;
        -:  163:			}
    #####:  164:			ObjectPropertyBoxData *opbd =
        -:  165:				(ObjectPropertyBoxData *)left->sso_data;
    #####:  166:			Ptr lptr = orbtree_node_ptr(&opbd->ord, false);
    #####:  167:			retval->parent = orbtree_node_ptr(cur, retval->is_right);
    #####:  168:			retval->is_right = false;
    #####:  169:			cur = (const OrbTreeNode *)(slab_get(&sa, lptr) + offsetof);
        -:  170:		}
        -:  171:	}
        -:  172:
        1:  173:	return 0;
        -:  174:}
        -:  175:
        8:  176:static __attribute__((constructor)) void object_init() {
        -:  177:	if (sizeof(Object) != sizeof(ObjectImpl))
        -:  178:		panic("sizeof(ObjectImpl) (%i) != sizeof(Object) (%i)",
        -:  179:			  sizeof(ObjectImpl), sizeof(Object));
        -:  180:	if (sizeof(Object) != 16)
        -:  181:		panic("sizeof(Object) (%i) != 16", sizeof(Object));
        -:  182:	if (sizeof(ObjectBox) != 124)
        -:  183:		panic("sizeof(ObjectBox) (%i) != 124", sizeof(ObjectBox));
        -:  184:	if (sizeof(ObjectPropertyBoxData) != OBJECT_SSO_DATA_BUFFER_SIZE)
        -:  185:		panic("sizeof(ObjectPropertyBoxData) (%i) != %i",
        -:  186:			  sizeof(ObjectPropertyBoxData), OBJECT_SSO_DATA_BUFFER_SIZE);
        -:  187:
        8:  188:	ASTORE(&next_namespace, 0);
        8:  189:	slab_allocator_init(&sa, sizeof(ObjectBox), OBJECT_MAX_FREE_LIST_SIZE,
        -:  190:						UINT32_MAX);
        8:  191:	orbtree_init(&seqtree, &sa);
        8:  192:	orbtree_init(&ordtree, &sa);
        8:  193:}
        -:  194:
       17:  195:void object_cleanup(const Object *obj) {
       17:  196:	ObjectImpl *impl = (ObjectImpl *)obj;
      17*:  197:	if (impl->no_cleanup) return;
       17:  198:	if (impl->type == ObjectTypeBox) {
        5:  199:		if (impl->data.ptr_value != null) {
        5:  200:			ObjectBox *box = (ObjectBox *)slab_get(&sa, impl->data.ptr_value);
        -:  201:
        5:  202:			if (box->extended) {
        1:  203:				mmap_free(box->extended,
        1:  204:						  box->size - OBJECT_SSO_DATA_BUFFER_SIZE);
        1:  205:				box->extended = NULL;
        -:  206:			}
        -:  207:
        5:  208:			slab_allocator_free(&sa, impl->data.ptr_value);
        5:  209:			impl->data.ptr_value = null;
        -:  210:		}
        -:  211:	}
        -:  212:}
        -:  213:
        2:  214:ObjectType object_type(const Object *obj) {
        2:  215:	return ((ObjectImpl *)obj)->type;
        -:  216:}
        -:  217:
        4:  218:Object object_create_int(int value) {
        4:  219:	ObjectImpl ret = {.data.int_value = value, .type = ObjectTypeInt};
        4:  220:	return *((Object *)&ret);
        -:  221:}
        -:  222:
        1:  223:Object object_create_byte(byte b) {
        1:  224:	ObjectImpl ret = {.data.byte_value = b, .type = ObjectTypeByte};
        1:  225:	return *((Object *)&ret);
        -:  226:}
        -:  227:
        4:  228:Object object_create_unit() {
        4:  229:	ObjectImpl ret = {.data.int_value = 0, .type = ObjectTypeUnit};
        4:  230:	return *((Object *)&ret);
        -:  231:}
        -:  232:
    #####:  233:Object object_create_err(int code) {
    #####:  234:	ObjectImpl ret = {.data.int_value = code, .type = ObjectTypeErr};
    #####:  235:	return *((Object *)&ret);
        -:  236:}
        -:  237:
        2:  238:Object object_create_function(void *fn) {
        2:  239:	ObjectImpl ret = {.data.function_value = fn, .type = ObjectTypeFunction};
        2:  240:	return *((Object *)&ret);
        -:  241:}
        -:  242:
        1:  243:Object object_set_property(Object *obj, const char *key, const Object *value) {
        1:  244:	ObjectBox *impl = object_get_box_data((ObjectImpl *)obj);
        1:  245:	unsigned long long key_len = cstring_len(key);
        1:  246:	unsigned int box_size = sizeof(OrbTreeNode) * 2 + sizeof(unsigned int) +
        1:  247:							sizeof(Object) + key_len;
        2:  248:	Object property = object_create_box(box_size);
        1:  249:	Ptr property_ptr = ((ObjectImpl *)&property)->data.ptr_value;
        1:  250:	ObjectBox *property_impl = object_get_box_data((ObjectImpl *)&property);
        -:  251:
        1:  252:	property_impl->namespace = impl->namespace;
        1:  253:	ObjectPropertyBoxData *property_data = object_box_sso(&property);
        1:  254:	property_data->seqno = 0;
        1:  255:	unsigned int sso_copy_len = OBJECT_PROPERTY_KV_SSO_LEN;
        1:  256:	if (key_len < OBJECT_PROPERTY_KV_SSO_LEN) sso_copy_len = key_len;
        1:  257:	copy_bytes(property_data->key_value_sso, key, sso_copy_len);
        1:  258:	unsigned int rem = sso_copy_len - OBJECT_PROPERTY_KV_SSO_LEN;
        1:  259:	if (rem) {
        1:  260:		if (rem > sizeof(Object)) rem = sizeof(Object);
        1:  261:		copy_bytes(property_data->key_value_sso + sso_copy_len, (byte *)value,
        -:  262:				   rem);
        -:  263:
        1:  264:		ObjectImpl *tmp =
        1:  265:			(ObjectImpl *)(property_data->key_value_sso + sso_copy_len);
        -:  266:	}
        -:  267:
        -:  268:	if (rem != sizeof(Object)) {
        -:  269:		// we have to write more data to the extended buffer
        -:  270:	}
        -:  271:
        1:  272:	unsigned long long offsetof = offsetof(ObjectBox, sso_data);
        1:  273:	OrbTreeNodeWrapper wrap = {.ptr = property_ptr, .offsetof = offsetof};
        1:  274:	orbtree_put(&ordtree, &wrap, &ordtree_search);
        -:  275:
        1:  276:	return Unit;
        -:  277:}
        -:  278:
    #####:  279:Object object_delete_property(Object *obj, const char *key) {
    #####:  280:	return Err(NotYetImplemented);
        -:  281:}
        -:  282:
        1:  283:Object object_get_property(const Object *obj, const char *key) {
        1:  284:	ObjectBox *impl = object_get_box_data((ObjectImpl *)obj);
        1:  285:	unsigned int key_len = cstring_len(key);
        1:  286:	unsigned int box_size = sizeof(OrbTreeNode) * 2 + sizeof(unsigned int) +
        -:  287:							key_len + sizeof(Object);
        1:  288:	unsigned long long namespace = impl->namespace;
        -:  289:
        2:  290:	Object property = object_create_box(box_size);
        1:  291:	Ptr property_ptr = ((ObjectImpl *)&property)->data.ptr_value;
        1:  292:	ObjectBox *box = object_get_box_data((ObjectImpl *)&property);
        -:  293:
        -:  294:	/*
        -:  295:		Ptr ptr = slab_allocator_allocate(&sa);
        -:  296:		ObjectBox *box = (ObjectBox *)slab_get(&sa, ptr);
        -:  297:	*/
        1:  298:	box->namespace = namespace;
        1:  299:	box->size = box_size;
        -:  300:
        1:  301:	ObjectPropertyBoxData *property_data = object_box_sso(&property);
        -:  302:
        1:  303:	unsigned int sso_copy_len = OBJECT_PROPERTY_KV_SSO_LEN;
        1:  304:	if (key_len < OBJECT_PROPERTY_KV_SSO_LEN) sso_copy_len = key_len;
        1:  305:	copy_bytes(property_data->key_value_sso, key, sso_copy_len);
        -:  306:
        1:  307:	unsigned long long offsetof = offsetof(ObjectBox, sso_data);
        1:  308:	OrbTreeNodeWrapper wrap = {.ptr = property_ptr, .offsetof = offsetof};
        1:  309:	Ptr ret = orbtree_get(&ordtree, &wrap, &ordtree_search, 0);
        -:  310:
        -:  311:	// for now we return an error, eventually we'll implement Option
       1*:  312:	if (ret == null) return Err(FileNotFound);
        -:  313:
        1:  314:	ObjectBox *ret_box = (ObjectBox *)slab_get(&sa, ret);
        1:  315:	ObjectPropertyBoxData *property_data_out =
        -:  316:		(ObjectPropertyBoxData *)ret_box->sso_data;
        1:  317:	unsigned int overhead =
        -:  318:		sizeof(OrbTreeNode) * 2 + sizeof(unsigned int) + sizeof(Object);
       1*:  319:	if (overhead > ret_box->size) return Err(FileNotFound);
        1:  320:	unsigned int offset = ret_box->size - overhead;
        -:  321:	ObjectNc ret_obj;
        1:  322:	*(&ret_obj) = *(Object *)(property_data_out->key_value_sso + offset);
        -:  323:
        1:  324:	return ret_obj;
        -:  325:}
        -:  326:
        5:  327:Object object_create_box(unsigned int size) {
        5:  328:	Ptr ptr = slab_allocator_allocate(&sa);
       5*:  329:	if (ptr == null) return Err(fam_err);
        5:  330:	ObjectBox *box = (ObjectBox *)slab_get(&sa, ptr);
        5:  331:	box->namespace = AADD(&next_namespace, 1);
        5:  332:	box->size = size;
        5:  333:	box->lock = INIT_LOCK;
        5:  334:	box->resize_seqno = 0;
        -:  335:
        5:  336:	if (size > OBJECT_SSO_DATA_BUFFER_SIZE) {
        1:  337:		box->extended = mmap_allocate(size - OBJECT_SSO_DATA_BUFFER_SIZE);
        1:  338:		if (box->extended == NULL) {
    #####:  339:			slab_allocator_free(&sa, ptr);
    #####:  340:			return Err(AllocErr);
        -:  341:		}
        -:  342:	} else
        4:  343:		box->extended = NULL;
        -:  344:
        5:  345:	ObjectImpl ret = {.data = ptr, .type = ObjectTypeBox};
        5:  346:	return *((Object *)&ret);
        -:  347:}
        -:  348:
        4:  349:void *object_box_sso(const Object *obj) {
        4:  350:	Ptr ptr = ((ObjectImpl *)obj)->data.ptr_value;
       4*:  351:	if (ptr == null) return NULL;
        4:  352:	ObjectBox *box = (ObjectBox *)slab_get(&sa, ptr);
       4*:  353:	if (box == NULL) return NULL;
        4:  354:	return box->sso_data;
        -:  355:}
        -:  356:
        4:  357:void *object_box_extended(const Object *obj) {
        4:  358:	Ptr ptr = ((ObjectImpl *)obj)->data.ptr_value;
       4*:  359:	if (ptr == null) return NULL;
        4:  360:	ObjectBox *box = (ObjectBox *)slab_get(&sa, ptr);
       4*:  361:	if (box == NULL) return NULL;
        4:  362:	return box->extended;
        -:  363:}
        -:  364:
    #####:  365:unsigned int object_box_size(const Object *obj) {
    #####:  366:	Ptr ptr = ((ObjectImpl *)obj)->data.ptr_value;
    #####:  367:	if (ptr == null) return 0;
    #####:  368:	ObjectBox *box = (ObjectBox *)slab_get(&sa, ptr);
    #####:  369:	if (box == NULL) return 0;
    #####:  370:	return box->size;
        -:  371:}
        -:  372:
        4:  373:int object_value_of(const Object *obj) {
        4:  374:	ObjectImpl *impl = (ObjectImpl *)obj;
        4:  375:	return impl->data.int_value;
        -:  376:}
        -:  377:
        2:  378:void *object_value_function(const Object *obj) {
        2:  379:	ObjectImpl *impl = (ObjectImpl *)obj;
        2:  380:	return impl->data.function_value;
        -:  381:}
        -:  382:
        -:  383:#pragma clang diagnostic ignored "-Waddress-of-packed-member"
        -:  384:#pragma GCC diagnostic ignored "-Waddress-of-packed-member"
        3:  385:Object object_resize_box(Object *obj, unsigned int size) {
        3:  386:	Ptr ptr = ((ObjectImpl *)obj)->data.ptr_value;
       3*:  387:	if (ptr == null) return Err(IllegalState);
        3:  388:	ObjectBox *box = (ObjectBox *)slab_get(&sa, ptr);
       3*:  389:	if (box == NULL) return Err(IllegalState);
        3:  390:	int count = 0;
        -:  391:
    #####:  392:	loop {
        3:  393:		if (++count >= 10000) {
    #####:  394:			return Err(Busy);
        -:  395:		}
        3:  396:		unsigned int resize_seqno = box->resize_seqno;
        3:  397:		size_t aligned_size = 0;
        3:  398:		if (size > OBJECT_SSO_DATA_BUFFER_SIZE)
        2:  399:			aligned_size =
        2:  400:				mmap_aligned_size(size - OBJECT_SSO_DATA_BUFFER_SIZE);
        3:  401:		size_t cur_aligned_size = 0;
        3:  402:		if (box->size > OBJECT_SSO_DATA_BUFFER_SIZE)
        2:  403:			cur_aligned_size =
        2:  404:				mmap_aligned_size(box->size - OBJECT_SSO_DATA_BUFFER_SIZE);
        -:  405:
        3:  406:		if (aligned_size == cur_aligned_size) {
        -:  407:			// no resize needed
        -:  408:
    #####:  409:			lockw(&box->lock);
    #####:  410:			if (box->resize_seqno != resize_seqno) {
    #####:  411:				unlock(&box->lock);
    #####:  412:				continue;
        -:  413:			}
    #####:  414:			box->size = size;
    #####:  415:			unlock(&box->lock);
    #####:  416:			return Unit;
        3:  417:		} else if (aligned_size < cur_aligned_size) {
        -:  418:			// shrink memeory map
        1:  419:			unsigned int diff = cur_aligned_size - aligned_size;
        1:  420:			void *extended = box->extended;
       1*:  421:			if (extended == NULL) panic("extended must not be NULL!");
        -:  422:
        1:  423:			lockw(&box->lock);
        -:  424:
       1*:  425:			if (box->resize_seqno != resize_seqno) {
    #####:  426:				unlock(&box->lock);
    #####:  427:				continue;
        -:  428:			}
        -:  429:
        1:  430:			box->size = size;
        1:  431:			if (aligned_size == 0) box->extended = NULL;
        -:  432:
        1:  433:			unlock(&box->lock);
        -:  434:
        1:  435:			mmap_free((byte *)extended + aligned_size, diff);
        -:  436:
        1:  437:			return Unit;
        -:  438:		} else {
        2:  439:			void *extended = box->extended;
        -:  440:			// we need more memory so call mmap
        2:  441:			void *tmp = mmap_allocate(size - OBJECT_SSO_DATA_BUFFER_SIZE);
       2*:  442:			if (tmp == NULL) return Err(AllocErr);
        -:  443:
        2:  444:			lockw(&box->lock);
        -:  445:
       2*:  446:			if (box->resize_seqno != resize_seqno) {
    #####:  447:				unlock(&box->lock);
    #####:  448:				continue;
        -:  449:			}
        -:  450:
        2:  451:			if (cur_aligned_size) {
       1*:  452:				if (extended == NULL) panic("extended must not be NULL!");
        1:  453:				copy_bytes(tmp, extended, cur_aligned_size);
        -:  454:			}
        -:  455:
        2:  456:			box->size = size;
        2:  457:			box->extended = tmp;
        -:  458:
        2:  459:			unlock(&box->lock);
        -:  460:
        2:  461:			if (cur_aligned_size) {
       1*:  462:				if (extended == NULL) panic("extended must not be NULL!");
        1:  463:				mmap_free(extended, cur_aligned_size);
        -:  464:			}
        2:  465:			return Unit;
        -:  466:		}
        -:  467:	}
        -:  468:}
        -:    0:Source:orbtree.c
        -:    0:Graph:orbtree.gcno
        -:    0:Data:orbtree.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/lock.h>
        -:   16:#include <base/macro_util.h>
        -:   17:#include <base/print_util.h>
        -:   18:#include <base/slabs.h>
        -:   19:#include <core/orbtree.h>
        -:   20:
        -:   21:typedef struct OrbTreeNodeImpl {
        -:   22:	Ptr parent;
        -:   23:	Ptr right;
        -:   24:	Ptr left;
        -:   25:	unsigned int right_subtree_height_color;
        -:   26:	unsigned int left_subtree_height;
        -:   27:} OrbTreeNodeImpl;
        -:   28:
        -:   29:typedef struct OrbTreeImpl {
        -:   30:	const SlabAllocator *sa;
        -:   31:	Ptr root;
        -:   32:	Lock lock;
        -:   33:} OrbTreeImpl;
        -:   34:
        -:   35:typedef struct OrbTreeCtx {
        -:   36:	const SlabAllocator *sa;
        -:   37:	OrbTreeImpl *tree;
        -:   38:	unsigned int offset;
        -:   39:} OrbTreeCtx;
        -:   40:
        -:   41:_Thread_local OrbTreeCtx orbtree_tl_ctx = {};
        -:   42:
        8:   43:void __attribute__((constructor)) __orbtree_check_sizes() {
        -:   44:	if (sizeof(OrbTreeNodeImpl) != sizeof(OrbTreeNode))
        -:   45:		panic("sizeof(OrbTreeNodeImpl) (%i) != sizeof(OrbTreeNode) (%i)",
        -:   46:			  sizeof(OrbTreeNodeImpl), sizeof(OrbTreeNode));
        -:   47:	if (sizeof(OrbTreeImpl) != sizeof(OrbTree))
        -:   48:		panic("sizeof(OrbTreeImpl) (%i) != sizeof(OrbTree) (%i)",
        -:   49:			  sizeof(OrbTreeImpl), sizeof(OrbTree));
        8:   50:}
        -:   51:
 10362719:   52:void *orbtree_value(Ptr ptr) {
 10362719:   53:	return slab_get(orbtree_tl_ctx.sa, ptr);
        -:   54:}
        -:   55:
 29362913:   56:OrbTreeNodeImpl *orbtree_node(Ptr ptr) {
 29362913:   57:	byte *slab = slab_get(orbtree_tl_ctx.sa, ptr);
 29362913:   58:	if (slab == NULL) return NULL;
 29353761:   59:	return (OrbTreeNodeImpl *)(slab + orbtree_tl_ctx.offset);
        -:   60:}
        -:   61:
        -:   62:#define RED_NODE 0x80000000
        -:   63:#define IS_RED(k)                                                    \
        -:   64:	({                                                               \
        -:   65:		OrbTreeNodeImpl *_impl__ = orbtree_node(k);                  \
        -:   66:		int _ret__;                                                  \
        -:   67:		if (_impl__ == NULL)                                         \
        -:   68:			_ret__ = 0;                                              \
        -:   69:		else                                                         \
        -:   70:			_ret__ = _impl__->right_subtree_height_color & RED_NODE; \
        -:   71:		_ret__;                                                      \
        -:   72:	})
        -:   73:#define IS_BLACK(k) !IS_RED(k)
        -:   74:#define SET_BLACK(k)                                      \
        -:   75:	({                                                    \
        -:   76:		OrbTreeNodeImpl *_impl__ = orbtree_node(k);       \
        -:   77:		_impl__->right_subtree_height_color &= ~RED_NODE; \
        -:   78:	})
        -:   79:#define SET_RED(k)                                       \
        -:   80:	({                                                   \
        -:   81:		OrbTreeNodeImpl *_impl__ = orbtree_node(k);      \
        -:   82:		_impl__->right_subtree_height_color |= RED_NODE; \
        -:   83:	})
        -:   84:#define RIGHT_HEIGHT(n) (n->right_subtree_height_color & ~RED_NODE)
        -:   85:#define LEFT_HEIGHT(n) (n->left_subtree_height)
        -:   86:#define SET_RIGHT_HEIGHT(n, v)                                \
        -:   87:	({                                                        \
        -:   88:		(n->right_subtree_height_color =                      \
        -:   89:			 v | (n->right_subtree_height_color & RED_NODE)); \
        -:   90:	})
        -:   91:#define SET_LEFT_HEIGHT(n, v) ({ (n->left_subtree_height = v); })
        -:   92:
     4872:   93:void orbtree_update_heights(Ptr node, bool is_right, bool insert) {
     4872:   94:	OrbTreeNodeImpl *last = orbtree_node(node);
     4872:   95:	if (last == NULL) return;
     4854:   96:	if (insert) {
     2000:   97:		if (is_right)
     1498:   98:			last->right_subtree_height_color++;
        -:   99:
        -:  100:		else
      502:  101:			last->left_subtree_height++;
        -:  102:	}
        -:  103:	OrbTreeNodeImpl *parent;
    42268:  104:	while (last->parent != null) {
    37414:  105:		parent = orbtree_node(last->parent);
    37414:  106:		if (orbtree_node(parent->right) == last) {
    22790:  107:			unsigned int h = 1 + RIGHT_HEIGHT(last) + LEFT_HEIGHT(last);
    22790:  108:			SET_RIGHT_HEIGHT(parent, h);
        -:  109:		} else {
    14624:  110:			unsigned int h = 1 + RIGHT_HEIGHT(last) + LEFT_HEIGHT(last);
    14624:  111:			SET_LEFT_HEIGHT(parent, h);
        -:  112:		}
    37414:  113:		last = parent;
        -:  114:	}
        -:  115:}
        -:  116:
      500:  117:void orbtree_rotate_right(Ptr x_ptr) {
      500:  118:	OrbTreeNodeImpl *x = orbtree_node(x_ptr);
      500:  119:	Ptr y_ptr = x->left;
      500:  120:	OrbTreeNodeImpl *y = orbtree_node(y_ptr);
        -:  121:
      500:  122:	unsigned int y_right_height = RIGHT_HEIGHT(y);
        -:  123:
        -:  124:	// Move subtree
      500:  125:	x->left = y->right;
      500:  126:	SET_LEFT_HEIGHT(x, y_right_height);
        -:  127:
      500:  128:	if (y->right != null) {
      167:  129:		OrbTreeNodeImpl *yright = orbtree_node(y->right);
      167:  130:		yright->parent = x_ptr;
        -:  131:	}
        -:  132:
        -:  133:	// Update y's parent to x's parent
      500:  134:	y->parent = x->parent;
        -:  135:
        -:  136:	// If x was the root, now y becomes the root
      500:  137:	OrbTreeNodeImpl *xparent = orbtree_node(x->parent);
      500:  138:	if (x->parent == null) {
        1:  139:		orbtree_tl_ctx.tree->root = y_ptr;
      499:  140:	} else if (x_ptr == xparent->right) {
      312:  141:		xparent->right = y_ptr;
        -:  142:	} else {
      187:  143:		xparent->left = y_ptr;
        -:  144:	}
        -:  145:
        -:  146:	// Place x as y's left child
      500:  147:	y->right = x_ptr;
      500:  148:	unsigned int h = 1 + RIGHT_HEIGHT(x) + LEFT_HEIGHT(x);
      500:  149:	SET_RIGHT_HEIGHT(y, h);
      500:  150:	x->parent = y_ptr;
      500:  151:}
        -:  152:
     1986:  153:void orbtree_rotate_left(Ptr x_ptr) {
     1986:  154:	OrbTreeNodeImpl *x = orbtree_node(x_ptr);
     1986:  155:	Ptr y_ptr = x->right;
     1986:  156:	OrbTreeNodeImpl *y = orbtree_node(y_ptr);
        -:  157:
     1986:  158:	unsigned int y_left_height = LEFT_HEIGHT(y);
        -:  159:
        -:  160:	// Move subtree
     1986:  161:	x->right = y->left;
     1986:  162:	SET_RIGHT_HEIGHT(x, y_left_height);
        -:  163:
     1986:  164:	if (y->left != null) {
     1145:  165:		OrbTreeNodeImpl *yleft = orbtree_node(y->left);
     1145:  166:		yleft->parent = x_ptr;
        -:  167:	}
        -:  168:
        -:  169:	// Update y's parent to x's parent
     1986:  170:	y->parent = x->parent;
        -:  171:
        -:  172:	// If x was the root, now y becomes the root
     1986:  173:	OrbTreeNodeImpl *xparent = orbtree_node(x->parent);
     1986:  174:	if (x->parent == null) {
       23:  175:		orbtree_tl_ctx.tree->root = y_ptr;
     1963:  176:	} else if (x_ptr == xparent->left) {
      814:  177:		xparent->left = y_ptr;
        -:  178:	} else {
     1149:  179:		xparent->right = y_ptr;
        -:  180:	}
        -:  181:
        -:  182:	// Place x as y's left child
     1986:  183:	y->left = x_ptr;
     1986:  184:	unsigned int h = 1 + RIGHT_HEIGHT(x) + LEFT_HEIGHT(x);
     1986:  185:	SET_LEFT_HEIGHT(y, h);
     1986:  186:	x->parent = y_ptr;
     1986:  187:}
        -:  188:
     2004:  189:int orbtree_put_fixup(Ptr k_ptr) {
     2004:  190:	OrbTreeNodeImpl *k = orbtree_node(k_ptr);
    4859*:  191:	while (k_ptr != orbtree_tl_ctx.tree->root && IS_RED(k->parent)) {
     2855:  192:		k = orbtree_node(k_ptr);
     2855:  193:		OrbTreeNodeImpl *parent = orbtree_node(k->parent);
     2855:  194:		OrbTreeNodeImpl *gparent = orbtree_node(parent->parent);
        -:  195:
     2855:  196:		if (k->parent == gparent->left) {
        -:  197:			// Case 1: Uncle is on the right
      453:  198:			OrbTreeNodeImpl *u = orbtree_node(gparent->right);
      453:  199:			Ptr u_ptr = gparent->right;
      453:  200:			if (IS_RED(u_ptr)) {
        -:  201:				// Case 1a: Uncle is red
        -:  202:				// Recolor the parent and uncle to black
      259:  203:				SET_BLACK(k->parent);
      259:  204:				SET_BLACK(u_ptr);
        -:  205:				// Recolor the grandparent to red
      259:  206:				SET_RED(parent->parent);
        -:  207:
        -:  208:				// Move up the tree
      259:  209:				k_ptr = parent->parent;
      259:  210:				k = orbtree_node(k_ptr);
        -:  211:			} else {
        -:  212:				// Case 1b: Uncle is black
      194:  213:				if (k_ptr == parent->right) {
        -:  214:					// Case 1b1: Node is a right child
        -:  215:					// Rotate left to make the node the left child
       94:  216:					k_ptr = k->parent;
       94:  217:					k = orbtree_node(k_ptr);
       94:  218:					orbtree_rotate_left(k_ptr);
        -:  219:				}
        -:  220:				// Recolor and rotate
      194:  221:				OrbTreeNodeImpl *kparent = orbtree_node(k->parent);
      194:  222:				SET_BLACK(k->parent);
      194:  223:				SET_RED(kparent->parent);
        -:  224:
      194:  225:				orbtree_rotate_right(kparent->parent);
        -:  226:			}
        -:  227:		} else {
        -:  228:			// Case 2: Uncle is on the left
     2402:  229:			OrbTreeNodeImpl *u = orbtree_node(gparent->left);
     2402:  230:			Ptr u_ptr = gparent->left;
     2402:  231:			if (IS_RED(u_ptr)) {
        -:  232:				// Case 2a: Uncle is red
        -:  233:				// Recolor the parent and uncle to black
     1228:  234:				SET_BLACK(k->parent);
     1228:  235:				SET_BLACK(u_ptr);
        -:  236:				// Recolor the grandparent to red
     1228:  237:				SET_RED(parent->parent);
        -:  238:
        -:  239:				// Move up the tree
     1228:  240:				k_ptr = parent->parent;
     1228:  241:				k = orbtree_node(k_ptr);
        -:  242:			} else {
        -:  243:				// Case 2b: Uncle is black
     1174:  244:				if (k_ptr == parent->left) {
        -:  245:					// Case 2b1: Node is a left child
        -:  246:					// Rotate right to make the node the right child
       92:  247:					k_ptr = k->parent;
       92:  248:					k = orbtree_node(k_ptr);
       92:  249:					orbtree_rotate_right(k_ptr);
        -:  250:				}
        -:  251:				// Recolor and rotate
     1174:  252:				SET_BLACK(k->parent);
     1174:  253:				OrbTreeNodeImpl *kparent = orbtree_node(k->parent);
     1174:  254:				SET_RED(kparent->parent);
     1174:  255:				orbtree_rotate_left(kparent->parent);
        -:  256:			}
        -:  257:		}
        -:  258:	}
        -:  259:	// Ensure the root is always black
     2004:  260:	SET_BLACK(orbtree_tl_ctx.tree->root);
     2004:  261:	return 0;
        -:  262:}
        -:  263:
     2004:  264:void orbtree_init_node(OrbTreeNodeImpl *node, bool red, Ptr parent) {
     2004:  265:	node->right = null;
     2004:  266:	node->left = null;
     2004:  267:	node->parent = parent;
     2004:  268:	if (red)
     2000:  269:		node->right_subtree_height_color = RED_NODE;
        -:  270:	else
        4:  271:		node->right_subtree_height_color = 0;
     2004:  272:	node->left_subtree_height = 0;
     2004:  273:}
        -:  274:
        2:  275:void orbtree_insert_transplant(OrbTreeImpl *impl, const OrbTreeNodeImpl *prev,
        -:  276:							   OrbTreeNodeImpl *next, Ptr ptr, bool is_right) {
        2:  277:	next->parent = prev->parent;
        2:  278:	next->right = prev->right;
        2:  279:	next->left = prev->left;
        2:  280:	next->right_subtree_height_color = prev->right_subtree_height_color;
        2:  281:	next->left_subtree_height = prev->left_subtree_height;
        -:  282:
        2:  283:	if (next->parent != null) {
        2:  284:		OrbTreeNodeImpl *parent = orbtree_node(next->parent);
        2:  285:		if (is_right) {
    #####:  286:			parent->right = ptr;
        -:  287:		} else
        2:  288:			parent->left = ptr;
        -:  289:	}
        2:  290:	if (next->left != null) {
        2:  291:		OrbTreeNodeImpl *left = orbtree_node(next->left);
        2:  292:		left->parent = ptr;
        -:  293:	}
        2:  294:	if (next->right != null) {
        2:  295:		OrbTreeNodeImpl *right = orbtree_node(next->right);
        2:  296:		right->parent = ptr;
        -:  297:	}
        2:  298:}
        -:  299:
     2006:  300:Ptr orbtree_insert(OrbTreeImpl *impl, OrbTreeNodePair *pair, Ptr ptr) {
     2006:  301:	if (pair->parent == null) {
        4:  302:		impl->root = pair->self;
        4:  303:		OrbTreeNodeImpl *self = (OrbTreeNodeImpl *)orbtree_node(pair->self);
        4:  304:		orbtree_init_node(self, false, null);
        -:  305:	} else {
     2002:  306:		OrbTreeNodeImpl *self = (OrbTreeNodeImpl *)orbtree_node(pair->self);
     2002:  307:		if (self == NULL) {
        -:  308:			OrbTreeNodeImpl *parent =
     2000:  309:				(OrbTreeNodeImpl *)orbtree_node(pair->parent);
     2000:  310:			if (pair->is_right)
     1498:  311:				parent->right = ptr;
        -:  312:			else
      502:  313:				parent->left = ptr;
     2000:  314:			self = (OrbTreeNodeImpl *)orbtree_node(ptr);
     2000:  315:			orbtree_init_node(self, true, pair->parent);
        -:  316:		} else {
        2:  317:			OrbTreeNodeImpl *next = orbtree_value(ptr) + orbtree_tl_ctx.offset;
        -:  318:			Ptr ret =
        2:  319:				orbtree_node_ptr((const OrbTreeNode *)self, pair->is_right);
        2:  320:			orbtree_insert_transplant(impl, self, next, ptr, pair->is_right);
        2:  321:			return ret;
        -:  322:		}
        -:  323:	}
     2004:  324:	return null;
        -:  325:}
        -:  326:
     2352:  327:void orbtree_remove_transplant(Ptr dst, Ptr src) {
     2352:  328:	OrbTreeNodeImpl *dst_node = orbtree_node(dst);
     2352:  329:	OrbTreeNodeImpl *dst_parent = orbtree_node(dst_node->parent);
        -:  330:
     2352:  331:	if (dst_node->parent == null)
       14:  332:		orbtree_tl_ctx.tree->root = src;
     2338:  333:	else if (dst == dst_parent->left) {
     1825:  334:		dst_parent->left = src;
     1825:  335:		if (src == null) SET_LEFT_HEIGHT(dst_parent, 0);
        -:  336:
        -:  337:	} else {
      513:  338:		dst_parent->right = src;
      513:  339:		if (src == null) SET_RIGHT_HEIGHT(dst_parent, 0);
        -:  340:	}
     2352:  341:	if (src != null) {
     1205:  342:		OrbTreeNodeImpl *src_node = orbtree_node(src);
     1205:  343:		src_node->parent = dst_node->parent;
        -:  344:
     1205:  345:		OrbTreeNodeImpl *src_node_p = orbtree_node(src_node->parent);
     1205:  346:		if (src_node_p) {
     1193:  347:			unsigned int h = 1 + RIGHT_HEIGHT(src_node) + LEFT_HEIGHT(src_node);
     1193:  348:			if (src_node_p->right == src)
      317:  349:				SET_RIGHT_HEIGHT(src_node_p, h);
        -:  350:			else
      876:  351:				SET_LEFT_HEIGHT(src_node_p, h);
        -:  352:		}
        -:  353:	}
        -:  354:
     2352:  355:	orbtree_update_heights(dst_node->parent, false, false);
     2352:  356:}
        -:  357:
      516:  358:Ptr orbtree_find_successor(Ptr x_ptr) {
      516:  359:	OrbTreeNodeImpl *x = orbtree_node(x_ptr);
      516:  360:	Ptr successor_ptr = x->right;
      516:  361:	OrbTreeNodeImpl *successor = orbtree_node(x->right);
     1261:  362:	while (successor && successor->left != null) {
      745:  363:		successor_ptr = successor->left;
      745:  364:		successor = orbtree_node(successor->left);
        -:  365:	}
      516:  366:	return successor_ptr;
        -:  367:}
        -:  368:
        -:  369:// set child's color to parent's
      770:  370:void orbtree_set_color_based_on_parent(Ptr child, Ptr parent) {
      770:  371:	if (child != null) {
     770*:  372:		if (IS_RED(parent)) {
      271:  373:			SET_RED(child);
        -:  374:		} else {
      499:  375:			SET_BLACK(child);
        -:  376:		}
        -:  377:	}
      770:  378:}
        -:  379:
     1741:  380:void orbtree_remove_fixup(Ptr p_ptr, Ptr w_ptr, Ptr x_ptr) {
     3482:  381:	while (x_ptr != orbtree_tl_ctx.tree->root && IS_BLACK(x_ptr)) {
     1741:  382:		OrbTreeNodeImpl *parent_node = orbtree_node(p_ptr);
     1741:  383:		OrbTreeNodeImpl *w_node = orbtree_node(w_ptr);
     1741:  384:		OrbTreeNodeImpl *x_node = orbtree_node(x_ptr);
     1741:  385:		if (w_ptr == parent_node->right) {
        -:  386:			// Case 1: Sibling is
        -:  387:			// red
    1379*:  388:			if (IS_RED(w_ptr)) {
      513:  389:				SET_BLACK(w_ptr);
      513:  390:				SET_RED(p_ptr);
      513:  391:				orbtree_rotate_left(p_ptr);
      513:  392:				w_ptr = parent_node->right;
      513:  393:				w_node = orbtree_node(w_ptr);
        -:  394:			}
        -:  395:
        -:  396:			// Case 2: Sibling's
        -:  397:			// children are both
        -:  398:			// black
     2622:  399:			if (IS_BLACK(w_node->left) && IS_BLACK(w_node->right)) {
     1243:  400:				SET_RED(w_ptr);
     1243:  401:				x_ptr = p_ptr;
     1243:  402:				x_node = orbtree_node(x_ptr);
     1243:  403:				p_ptr = parent_node->parent;
     1243:  404:				parent_node = orbtree_node(p_ptr);
     1243:  405:				OrbTreeNodeImpl *x_parent = orbtree_node(x_node->parent);
     1243:  406:				if (x_parent == NULL) {
        9:  407:					w_ptr = null;
        9:  408:					w_node = NULL;
     1234:  409:				} else if (x_ptr == x_parent->left) {
     1106:  410:					w_ptr = x_parent->right;
     1106:  411:					w_node = orbtree_node(w_ptr);
        -:  412:				} else {
      128:  413:					w_ptr = x_parent->left;
      128:  414:					w_node = orbtree_node(w_ptr);
        -:  415:				}
        -:  416:			} else {
        -:  417:				// Case 3: Sibling's
        -:  418:				// right child is
        -:  419:				// black, left child
        -:  420:				// is red
      136:  421:				if (IS_BLACK(w_node->right)) {
       57:  422:					SET_BLACK(w_node->left);
       57:  423:					SET_RED(w_ptr);
       57:  424:					orbtree_rotate_right(w_ptr);
       57:  425:					w_ptr = parent_node->right;
       57:  426:					w_node = orbtree_node(w_ptr);
        -:  427:				}
        -:  428:
        -:  429:				// Case 4: Sibling's
        -:  430:				// right child is
        -:  431:				// red
      136:  432:				orbtree_set_color_based_on_parent(w_ptr, p_ptr);
      136:  433:				SET_BLACK(p_ptr);
      136:  434:				SET_BLACK(w_node->right);
      136:  435:				orbtree_rotate_left(p_ptr);
      136:  436:				x_ptr = orbtree_tl_ctx.tree->root;
      136:  437:				x_node = orbtree_node(x_ptr);
        -:  438:			}
        -:  439:		} else {
        -:  440:			// Case 1: Sibling is
        -:  441:			// red
     362*:  442:			if (IS_RED(w_ptr)) {
       39:  443:				SET_BLACK(w_ptr);
       39:  444:				SET_RED(p_ptr);
       39:  445:				orbtree_rotate_right(p_ptr);
       39:  446:				w_ptr = parent_node->left;
       39:  447:				w_node = orbtree_node(w_ptr);
        -:  448:			}
        -:  449:
        -:  450:			// Case 2: Sibling's
        -:  451:			// children are both
        -:  452:			// black
      606:  453:			if (IS_BLACK(w_node->right) && IS_BLACK(w_node->left)) {
      244:  454:				SET_RED(w_ptr);
      244:  455:				x_ptr = p_ptr;
      244:  456:				x_node = orbtree_node(x_ptr);
      244:  457:				p_ptr = parent_node->parent;
      244:  458:				parent_node = orbtree_node(p_ptr);
      244:  459:				OrbTreeNodeImpl *x_parent = orbtree_node(x_node->parent);
      244:  460:				if (x_parent == NULL) {
        4:  461:					w_ptr = null;
        4:  462:					w_node = NULL;
      240:  463:				} else if (x_ptr == x_parent->left) {
      109:  464:					w_ptr = x_parent->right;
      109:  465:					w_node = orbtree_node(w_ptr);
        -:  466:				} else {
      131:  467:					w_ptr = x_parent->left;
      131:  468:					w_node = orbtree_node(w_ptr);
        -:  469:				}
        -:  470:			} else {
        -:  471:				// Case 3: Sibling's
        -:  472:				// right child is
        -:  473:				// black, left child
        -:  474:				// is red
      118:  475:				if (IS_BLACK(w_node->left)) {
       69:  476:					SET_BLACK(w_node->right);
       69:  477:					SET_RED(w_ptr);
       69:  478:					orbtree_rotate_left(w_ptr);
       69:  479:					w_ptr = parent_node->left;
       69:  480:					w_node = orbtree_node(w_ptr);
        -:  481:				}
        -:  482:
        -:  483:				// Case 4: Sibling's
        -:  484:				// right child is
        -:  485:				// red
      118:  486:				orbtree_set_color_based_on_parent(w_ptr, p_ptr);
      118:  487:				SET_BLACK(p_ptr);
      118:  488:				SET_BLACK(w_node->left);
      118:  489:				orbtree_rotate_right(p_ptr);
      118:  490:				x_ptr = orbtree_tl_ctx.tree->root;
      118:  491:				x_node = orbtree_node(x_ptr);
        -:  492:			}
        -:  493:		}
        -:  494:	}
        -:  495:
        -:  496:	// Ensure x is black at the end
        -:  497:	// of fixup
     1741:  498:	SET_BLACK(x_ptr);
     1741:  499:}
        -:  500:
     2000:  501:void orbtree_remove_impl(Ptr ptr, bool is_right) {
    2000*:  502:	bool do_fixup = IS_BLACK(ptr);
     2000:  503:	OrbTreeNodeImpl *node_to_delete = orbtree_node(ptr);
        -:  504:
     2000:  505:	Ptr x_ptr = null, w_ptr = null, p_ptr = null;
     2000:  506:	OrbTreeNodeImpl *x = NULL, *w = NULL, *p = NULL;
        -:  507:
     2000:  508:	if (node_to_delete->left == null) {
     1424:  509:		x_ptr = node_to_delete->right;
     1424:  510:		x = orbtree_node(x_ptr);
     1424:  511:		orbtree_remove_transplant(ptr, node_to_delete->right);
        -:  512:		OrbTreeNodeImpl *node_to_delete_parent =
     1424:  513:			orbtree_node(node_to_delete->parent);
     1424:  514:		if (node_to_delete->parent != null) {
     1421:  515:			if (node_to_delete_parent->left == null) {
      725:  516:				w_ptr = node_to_delete_parent->right;
      725:  517:				w = orbtree_node(w_ptr);
      696:  518:			} else if (node_to_delete_parent) {
      696:  519:				w_ptr = node_to_delete_parent->left;
      696:  520:				w = orbtree_node(w_ptr);
        -:  521:			}
        -:  522:		}
     1424:  523:		if (x_ptr != null) {
      572:  524:			x = orbtree_node(x_ptr);
      572:  525:			p_ptr = x->parent;
      572:  526:			p = orbtree_node(p_ptr);
      852:  527:		} else if (w_ptr != null) {
      745:  528:			p_ptr = w->parent;
      745:  529:			p = orbtree_node(p_ptr);
        -:  530:		}
      576:  531:	} else if (node_to_delete->right == null) {
       60:  532:		x_ptr = node_to_delete->left;
       60:  533:		x = orbtree_node(x_ptr);
       60:  534:		orbtree_remove_transplant(ptr, node_to_delete->left);
        -:  535:		OrbTreeNodeImpl *node_to_delete_parent =
       60:  536:			orbtree_node(node_to_delete->parent);
       60:  537:		if (node_to_delete_parent) {
       59:  538:			w_ptr = node_to_delete_parent->left;
       59:  539:			w = orbtree_node(w_ptr);
        -:  540:		}
       60:  541:		p_ptr = x->parent;
       60:  542:		p = orbtree_node(p_ptr);
        -:  543:	} else {
      516:  544:		Ptr successor_ptr = orbtree_find_successor(ptr);
      516:  545:		OrbTreeNodeImpl *successor = orbtree_node(successor_ptr);
     516*:  546:		do_fixup = IS_BLACK(successor_ptr);
        -:  547:
      516:  548:		x_ptr = successor->right;
      516:  549:		OrbTreeNodeImpl *successor_parent = orbtree_node(successor->parent);
      516:  550:		w_ptr = successor_parent->right;
      516:  551:		x = orbtree_node(x_ptr);
      516:  552:		w = orbtree_node(w_ptr);
        -:  553:
      516:  554:		if (w == NULL) {
       82:  555:			p_ptr = null;
       82:  556:			p = NULL;
      434:  557:		} else if (w->parent == ptr) {
      164:  558:			w_ptr = node_to_delete->left;
      164:  559:			w = orbtree_node(w_ptr);
      164:  560:			p_ptr = successor_ptr;
      164:  561:			p = successor;
        -:  562:		} else {
      270:  563:			p_ptr = w->parent;
      270:  564:			p = orbtree_node(p_ptr);
        -:  565:		}
        -:  566:
      516:  567:		if (successor->parent != ptr) {
      352:  568:			orbtree_remove_transplant(successor_ptr, successor->right);
      352:  569:			successor->right = node_to_delete->right;
      352:  570:			SET_RIGHT_HEIGHT(successor, 0);
      352:  571:			OrbTreeNodeImpl *successor_right = orbtree_node(successor->right);
      352:  572:			if (successor_right) {
      352:  573:				unsigned int h = 1 + RIGHT_HEIGHT(successor_right) +
      352:  574:								 LEFT_HEIGHT(successor_right);
      352:  575:				SET_RIGHT_HEIGHT(successor, h);
      352:  576:				successor_right->parent = successor_ptr;
        -:  577:			}
        -:  578:		}
        -:  579:
      516:  580:		orbtree_remove_transplant(ptr, successor_ptr);
      516:  581:		successor->left = node_to_delete->left;
        -:  582:
      516:  583:		OrbTreeNodeImpl *successor_left = orbtree_node(successor->left);
      516:  584:		SET_LEFT_HEIGHT(successor, 0);
      516:  585:		if (node_to_delete->left != null) {
      516:  586:			OrbTreeNodeImpl *ntdl = orbtree_node(node_to_delete->left);
      516:  587:			unsigned int h = 1 + LEFT_HEIGHT(ntdl) + RIGHT_HEIGHT(ntdl);
      516:  588:			SET_LEFT_HEIGHT(successor, h);
        -:  589:		}
      516:  590:		successor_left->parent = successor_ptr;
      516:  591:		orbtree_set_color_based_on_parent(successor_ptr, ptr);
        -:  592:
      516:  593:		orbtree_update_heights(successor_ptr, false, false);
        -:  594:	}
        -:  595:
     2000:  596:	if (do_fixup) {
     1745:  597:		if (w_ptr != null && p_ptr != null) {
     1741:  598:			orbtree_remove_fixup(p_ptr, w_ptr, x_ptr);
        -:  599:		} else {
        4:  600:			if (orbtree_tl_ctx.tree->root) SET_BLACK(orbtree_tl_ctx.tree->root);
        -:  601:		}
        -:  602:	}
     2000:  603:}
        -:  604:
  6944629:  605:void *orbtree_node_right(const OrbTreeNode *node) {
  6944629:  606:	const OrbTreeNodeImpl *impl = (const OrbTreeNodeImpl *)node;
  6944629:  607:	if (impl->right == null) return NULL;
  4948801:  608:	return orbtree_value(impl->right);
        -:  609:}
        -:  610:
  6989031:  611:void *orbtree_node_left(const OrbTreeNode *node) {
  6989031:  612:	const OrbTreeNodeImpl *impl = (const OrbTreeNodeImpl *)node;
  6989031:  613:	if (impl->left == null) return NULL;
  4964844:  614:	return orbtree_value(impl->left);
        -:  615:}
        -:  616:
   449072:  617:void *orbtree_node_parent(const OrbTreeNode *node) {
   449072:  618:	const OrbTreeNodeImpl *impl = (const OrbTreeNodeImpl *)node;
  449072*:  619:	if (impl->parent == null) return NULL;
   449072:  620:	return orbtree_value(impl->parent);
        -:  621:}
        -:  622:
  6011005:  623:unsigned int orbtree_node_right_subtree_height(const OrbTreeNode *node) {
 6011005*:  624:	if (node == NULL) return 0;
  6011005:  625:	return RIGHT_HEIGHT(((OrbTreeNodeImpl *)node));
        -:  626:}
        -:  627:
  6011005:  628:unsigned int orbtree_node_left_subtree_height(const OrbTreeNode *node) {
 6011005*:  629:	if (node == NULL) return 0;
  6011005:  630:	return LEFT_HEIGHT(((OrbTreeNodeImpl *)node));
        -:  631:}
        -:  632:
  2907151:  633:bool orbtree_node_is_red(const OrbTreeNode *node) {
  2907151:  634:	const OrbTreeNodeImpl *impl = (const OrbTreeNodeImpl *)node;
  2907151:  635:	return (impl->right_subtree_height_color & RED_NODE) != 0;
        -:  636:}
        -:  637:
     4006:  638:Ptr orbtree_root(const OrbTree *tree) {
     4006:  639:	OrbTreeImpl *impl = (OrbTreeImpl *)tree;
     4006:  640:	return impl->root;
        -:  641:}
        -:  642:
 14687527:  643:Ptr orbtree_node_ptr(const OrbTreeNode *node, bool is_right) {
14687527*:  644:	if (node == NULL) return null;
 14687527:  645:	const OrbTreeNodeImpl *impl = (const OrbTreeNodeImpl *)node;
 14687527:  646:	if (impl->parent == null) {
  1013739:  647:		return orbtree_tl_ctx.tree->root;
        -:  648:	} else {
 13673788:  649:		OrbTreeNodeImpl *node = (OrbTreeNodeImpl *)orbtree_node(impl->parent);
 13673788:  650:		if (is_right)
  6768809:  651:			return node->right;
        -:  652:		else
  6904979:  653:			return node->left;
        -:  654:	}
        -:  655:}
        -:  656:
   505514:  657:void orbtree_set_tl_context(OrbTreeImpl *impl,
        -:  658:							const OrbTreeNodeWrapper *value) {
   505514:  659:	orbtree_tl_ctx.sa = impl->sa;
   505514:  660:	orbtree_tl_ctx.tree = impl;
   505514:  661:	orbtree_tl_ctx.offset = value->offsetof;
   505514:  662:}
        -:  663:
        -:  664:// use subtree heights to navigate to correct offset
   501508:  665:Ptr orbtree_adjust_offset(Ptr ret, unsigned int offset) {
  4767610:  666:	while (offset && ret) {
  4266102:  667:		OrbTreeNodeImpl *cur = orbtree_node(ret);
  4266102:  668:		unsigned int rh = RIGHT_HEIGHT(cur);
  4266102:  669:		if (rh < offset) {
  1839853:  670:			offset -= rh + 1;
  3185083:  671:			while (ret) {
  3185083:  672:				OrbTreeNodeImpl *n = orbtree_node(ret);
  3185083:  673:				if (n->parent) {
  3185083:  674:					OrbTreeNodeImpl *parent = orbtree_node(n->parent);
  3185083:  675:					if (parent->left == ret) {
  1839853:  676:						ret = n->parent;
  1839853:  677:						break;
        -:  678:					}
        -:  679:				}
  1345230:  680:				ret = n->parent;
        -:  681:			}
        -:  682:		} else {
  2426249:  683:			offset -= 1;
  2426249:  684:			ret = cur->right;
  2426249:  685:			cur = orbtree_node(ret);
  3863041:  686:			while (cur->left) {
  3611544:  687:				unsigned int lh = LEFT_HEIGHT(cur);
  3611544:  688:				if (lh <= offset) {
  2174752:  689:					offset -= lh;
  2174752:  690:					break;
        -:  691:				}
  1436792:  692:				ret = cur->left;
  1436792:  693:				cur = orbtree_node(cur->left);
        -:  694:			}
        -:  695:		}
        -:  696:	}
   501508:  697:	return ret;
        -:  698:}
        -:  699:
       19:  700:int orbtree_init(OrbTree *tree, const SlabAllocator *sa) {
       19:  701:	OrbTreeImpl *impl = (OrbTreeImpl *)tree;
       19:  702:	impl->sa = sa;
       19:  703:	impl->root = null;
       19:  704:	impl->lock = INIT_LOCK;
       19:  705:	return 0;
        -:  706:}
        -:  707:
   501508:  708:Ptr orbtree_get(const OrbTree *tree, const OrbTreeNodeWrapper *value,
        -:  709:				OrbTreeSearch search, unsigned int offset) {
   501508:  710:	OrbTreeImpl *impl = (OrbTreeImpl *)tree;
   501508:  711:	OrbTreeNode *target = (OrbTreeNode *)orbtree_node(value->ptr);
   501508:  712:	OrbTreeNodePair retval = {};
   501508:  713:	orbtree_set_tl_context(impl, value);
   501508:  714:	Ptr ret = null;
        -:  715:
   501508:  716:	lockr(&impl->lock);
   501508:  717:	if (impl->root != null) {
   501508:  718:		OrbTreeNode *root = (OrbTreeNode *)orbtree_node(impl->root);
   501508:  719:		search(root, target, &retval);
   501508:  720:		ret = orbtree_adjust_offset(retval.self, offset);
        -:  721:	}
   501508:  722:	unlock(&impl->lock);
        -:  723:
   501508:  724:	return ret;
        -:  725:}
        -:  726:
     2006:  727:Ptr orbtree_put(OrbTree *tree, const OrbTreeNodeWrapper *value,
        -:  728:				OrbTreeSearch search) {
     2006:  729:	OrbTreeImpl *impl = (OrbTreeImpl *)tree;
     2006:  730:	orbtree_set_tl_context(impl, value);
     2006:  731:	OrbTreeNode *target = (OrbTreeNode *)orbtree_node(value->ptr);
     2006:  732:	OrbTreeNodePair pair = {.parent = null, .self = value->ptr};
        -:  733:
     2006:  734:	lockw(&impl->lock);
     2006:  735:	if (impl->root != null) {
     2002:  736:		OrbTreeNode *root = (OrbTreeNode *)orbtree_node(impl->root);
     2002:  737:		search(root, target, &pair);
        -:  738:	}
        -:  739:
     2006:  740:	Ptr ret = orbtree_insert(impl, &pair, value->ptr);
     2006:  741:	if (ret == null) {
     2004:  742:		orbtree_update_heights(pair.parent, pair.is_right, true);
     2004:  743:		orbtree_put_fixup(value->ptr);
        -:  744:	}
     2006:  745:	unlock(&impl->lock);
        -:  746:
     2006:  747:	return ret;
        -:  748:}
        -:  749:
     2000:  750:Ptr orbtree_remove(OrbTree *tree, const OrbTreeNodeWrapper *value,
        -:  751:				   OrbTreeSearch search) {
     2000:  752:	OrbTreeImpl *impl = (OrbTreeImpl *)tree;
     2000:  753:	orbtree_set_tl_context(impl, value);
     2000:  754:	OrbTreeNode *target = (OrbTreeNode *)orbtree_node(value->ptr);
     2000:  755:	OrbTreeNodePair pair = {.parent = null, .self = value->ptr};
        -:  756:
     2000:  757:	lockw(&impl->lock);
     2000:  758:	if (impl->root != null) {
     2000:  759:		OrbTreeNode *root = (OrbTreeNode *)orbtree_node(impl->root);
     2000:  760:		search(root, target, &pair);
        -:  761:	}
     2000:  762:	if (pair.self != null) orbtree_remove_impl(pair.self, pair.is_right);
     2000:  763:	unlock(&impl->lock);
        -:  764:
     2000:  765:	return pair.self;
        -:  766:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
