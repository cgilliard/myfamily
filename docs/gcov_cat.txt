        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/os.h>
        -:   17:
    #####:   18:byte *get_dimmed() {
    #####:   19:	if (env("NO_COLOR") != NULL) {
    #####:   20:		return "";
        -:   21:	} else {
    #####:   22:		return "\x1b[2m";
        -:   23:	}
        -:   24:}
        -:   25:
    #####:   26:byte *get_red() {
    #####:   27:	if (env("NO_COLOR") != NULL) {
    #####:   28:		return "";
        -:   29:	} else {
    #####:   30:		return "\x1b[31m";
        -:   31:	}
        -:   32:}
        -:   33:
    #####:   34:byte *get_bright_red() {
    #####:   35:	if (env("NO_COLOR") != NULL) {
    #####:   36:		return "";
        -:   37:	} else {
    #####:   38:		return "\x1b[91m";
        -:   39:	}
        -:   40:}
        -:   41:
    #####:   42:byte *get_green() {
    #####:   43:	if (env("NO_COLOR") != NULL) {
    #####:   44:		return "";
        -:   45:	} else {
    #####:   46:		return "\x1b[32m";
        -:   47:	}
        -:   48:}
        -:   49:
    #####:   50:byte *get_yellow() {
    #####:   51:	if (env("NO_COLOR") != NULL) {
    #####:   52:		return "";
        -:   53:	} else {
    #####:   54:		return "\x1b[33m";
        -:   55:	}
        -:   56:}
        -:   57:
    #####:   58:byte *get_cyan() {
    #####:   59:	if (env("NO_COLOR") != NULL) {
    #####:   60:		return "";
        -:   61:	} else {
    #####:   62:		return "\x1b[36m";
        -:   63:	}
        -:   64:}
        -:   65:
    #####:   66:byte *get_magenta() {
    #####:   67:	if (env("NO_COLOR") != NULL) {
    #####:   68:		return "";
        -:   69:	} else {
    #####:   70:		return "\x1b[35m";
        -:   71:	}
        -:   72:}
        -:   73:
    #####:   74:byte *get_blue() {
    #####:   75:	if (env("NO_COLOR") != NULL) {
    #####:   76:		return "";
        -:   77:	} else {
    #####:   78:		return "\x1b[34m";
        -:   79:	}
        -:   80:}
        -:   81:
    #####:   82:byte *get_reset() {
    #####:   83:	if (env("NO_COLOR") != NULL) {
    #####:   84:		return "";
        -:   85:	} else {
    #####:   86:		return "\x1b[0m";
        -:   87:	}
        -:   88:}
        -:    0:Source:fam_alloc.c
        -:    0:Graph:fam_alloc.gcno
        -:    0:Data:fam_alloc.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/osdef.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <base/string.h>
        -:   20:#include <pthread.h>
        -:   21:
        -:   22:#define PTR_FLAGS_SEND 0
        -:   23:#define PTR_FLAGS_DIRECT 1
        -:   24:
        -:   25:_Thread_local SlabAllocator tl_slab_allocator = NULL;
        -:   26:SlabAllocator global_slab_allocator = NULL;
        -:   27:pthread_mutex_t global_allocator_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   28:
        -:   29:// use highest byte in aux for flags
       32:   30:void ptr_flag_set(Ptr ptr, byte flag, bool value) {
       32:   31:	int64 *aux = ptr_aux(ptr);
       32:   32:	if (value)
    #####:   33:		*aux |= (0x1ULL << (unsigned long long)flag) << 56;
        -:   34:	else
       32:   35:		*aux &= ~((0x1ULL << (unsigned long long)flag) << 56);
       32:   36:}
        -:   37:
       32:   38:bool ptr_flag_check(Ptr ptr, byte flag) {
       32:   39:	int64 *aux = ptr_aux(ptr);
       32:   40:	return (*aux) & ((0x1ULL << (unsigned long long)flag) << 56);
        -:   41:}
        -:   42:
       16:   43:int check_initialize_default_slab_allocator() {
       16:   44:	if (tl_slab_allocator == NULL)
        3:   45:		tl_slab_allocator = slab_allocator_create();
       16:   46:	if (global_slab_allocator == NULL) {
        3:   47:		pthread_mutex_lock(&global_allocator_lock);
        3:   48:		if (global_slab_allocator == NULL)
        3:   49:			global_slab_allocator = slab_allocator_create();
        3:   50:		pthread_mutex_unlock(&global_allocator_lock);
        -:   51:	}
      16*:   52:	return tl_slab_allocator && global_slab_allocator;
        -:   53:}
        -:   54:
       16:   55:Ptr fam_alloc(unsigned int size, bool send) {
       16:   56:	if (!check_initialize_default_slab_allocator())
    #####:   57:		return NULL;
        -:   58:	Ptr ret;
       16:   59:	if (size > MAX_SLAB_SIZE)
    #####:   60:		ret = ptr_direct_alloc(size);
       16:   61:	else if (send) {
    #####:   62:		pthread_mutex_lock(&global_allocator_lock);
    #####:   63:		ret = slab_allocator_allocate(global_slab_allocator, size);
    #####:   64:		pthread_mutex_unlock(&global_allocator_lock);
        -:   65:	} else
       16:   66:		ret = slab_allocator_allocate(tl_slab_allocator, size);
        -:   67:
       16:   68:	if (ret) {
       16:   69:		int64 *aux = ptr_aux(ret);
       16:   70:		*aux = 0;
       16:   71:		ptr_flag_set(ret, PTR_FLAGS_SEND, send);
       16:   72:		ptr_flag_set(ret, PTR_FLAGS_DIRECT, size > MAX_SLAB_SIZE);
        -:   73:	}
        -:   74:
       16:   75:	return ret;
        -:   76:}
    #####:   77:Ptr fam_resize(Ptr ptr, unsigned int size) {
    #####:   78:	if (!check_initialize_default_slab_allocator())
    #####:   79:		return NULL;
        -:   80:
    #####:   81:	if (ptr == NULL) {
    #####:   82:		SetErr(IllegalArgument);
    #####:   83:		return NULL;
        -:   84:	}
        -:   85:
    #####:   86:	bool send = ptr_flag_check(ptr, PTR_FLAGS_SEND);
    #####:   87:	Ptr ret = fam_alloc(size, send);
    #####:   88:	if (ret) {
    #####:   89:		unsigned int len = $len(ptr);
    #####:   90:		if (len > size)
    #####:   91:			len = size;
    #####:   92:		memcpy($(ret), $(ptr), len);
        -:   93:	}
        -:   94:
    #####:   95:	return ret;
        -:   96:}
        -:   97:
       16:   98:void fam_release(Ptr *ptr) {
       16:   99:	if (nil(*ptr)) {
    #####:  100:		panic("fam_free on nil ptr!");
       16:  101:	} else if (ptr_flag_check(*ptr, PTR_FLAGS_DIRECT)) {
    #####:  102:		ptr_direct_release(*ptr);
       16:  103:	} else if (ptr_flag_check(*ptr, PTR_FLAGS_SEND)) {
    #####:  104:		pthread_mutex_lock(&global_allocator_lock);
    #####:  105:		slab_allocator_free(global_slab_allocator, *ptr);
    #####:  106:		pthread_mutex_unlock(&global_allocator_lock);
        -:  107:	} else
       16:  108:		slab_allocator_free(tl_slab_allocator, *ptr);
       16:  109:}
        -:  110:
        7:  111:void fam_alloc_thread_local_cleanup() {
        7:  112:	slab_allocator_cleanup(&tl_slab_allocator);
        7:  113:}
        -:  114:
        -:  115:#ifdef TEST
        7:  116:void fam_alloc_global_cleanup() {
        7:  117:	slab_allocator_cleanup(&global_slab_allocator);
        7:  118:}
        -:  119:
        7:  120:int64 fam_alloc_count_tl_slab_allocator() {
        7:  121:	if (tl_slab_allocator == NULL)
        4:  122:		return 0;
        3:  123:	return slab_allocator_cur_slabs_allocated(tl_slab_allocator);
        -:  124:}
        7:  125:int64 fam_alloc_count_global_allocator() {
        7:  126:	if (global_slab_allocator == NULL)
        4:  127:		return 0;
        3:  128:	return slab_allocator_cur_slabs_allocated(global_slab_allocator);
        -:  129:}
        -:  130:#endif // TEST
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/macro_util.h>
        -:   17:#include <base/os.h>
        -:   18:// #include <base/print_util.h>
        -:   19:#include <base/string.h>
        -:   20:
        -:   21:_Thread_local byte fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local int64 fam_err = NoErrors;
        -:   24://_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const byte *get_err() {
        -:   27:	// return strncpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
    #####:   28:	return NULL;
        -:   29:}
        -:   30:
    #####:   31:void print_err(const byte *text) {
        -:   32:	// println("{}: {}", FamErrText[fam_err], text);
        -:   33:	// backtrace_print(&thread_local_bt__);
    #####:   34:}
        -:   35:
        -:   36:// void do_backtrace_generate(Backtrace *bt) {
        -:   37:// if (env("CBACKTRACE") != NULL) {
        -:   38://  backtrace_generate(bt);
        -:   39://	}
        -:   40://}
        -:    0:Source:object.c
        -:    0:Graph:object.gcno
        -:    0:Data:object.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/object.h>
        -:   18:
        -:   19:#include <stdio.h>
        -:   20:
        -:   21:// types:
        -:   22:// int64: 64 bit signed
        -:   23:// int: 32 bit signed
        -:   24:// string: string (binary string)
        -:   25:// byte: unsigned 8 bit byte
        -:   26:// object: contains other primitives and objects as properties
        -:   27:
        -:   28:#define OBJECT_FLAG_FAM_ALLOC_RESERVED1 0
        -:   29:#define OBJECT_FLAG_FAM_ALLOC_RESERVED2 1
        -:   30:#define OBJECT_FLAG_TYPE0 2
        -:   31:#define OBJECT_FLAG_TYPE1 3
        -:   32:#define OBJECT_FLAG_TYPE2 4
        -:   33:#define OBJECT_FLAG_HAS_CLEANUP 5
        -:   34:#define OBJECT_FLAG_RC 6
        -:   35:
        4:   36:Object object_create_int64(int64 v) {
        4:   37:	Ptr ret = fam_alloc(sizeof(int64), false);
        4:   38:	if (nil(ret))
    #####:   39:		return NULL;
        -:   40:
        4:   41:	int64 *value = $(ret);
        4:   42:	*value = v;
        -:   43:
        -:   44:	// set type flags for int64
        4:   45:	int64 *aux = ptr_aux(ret);
        4:   46:	*aux |= (0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE0) << 56;
        4:   47:	*aux |= (0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE1) << 56;
        4:   48:	*aux |= (0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE2) << 56;
        -:   49:
        4:   50:	return ret;
        -:   51:}
        -:   52:
        4:   53:Object object_create_int(int v) {
        4:   54:	Ptr ret = fam_alloc(sizeof(int), false);
        4:   55:	if (nil(ret))
    #####:   56:		return NULL;
        -:   57:
        4:   58:	int *value = $(ret);
        4:   59:	*value = v;
        -:   60:
        -:   61:	// set type flags for int
        4:   62:	int64 *aux = ptr_aux(ret);
        4:   63:	*aux |= (0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE0) << 56;
        4:   64:	*aux |= (0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE1) << 56;
        4:   65:	*aux &= ~((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE2) << 56);
        -:   66:
        4:   67:	return ret;
        -:   68:}
        -:   69:
        1:   70:Object object_create_byte(byte v) {
        1:   71:	Ptr ret = fam_alloc(sizeof(byte), false);
        1:   72:	if (nil(ret))
    #####:   73:		return NULL;
        -:   74:
        1:   75:	byte *value = $(ret);
        1:   76:	*value = v;
        -:   77:
        -:   78:	// set type flags for byte
        1:   79:	int64 *aux = ptr_aux(ret);
        1:   80:	*aux |= (0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE0) << 56;
        1:   81:	*aux &= ~((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE1) << 56);
        1:   82:	*aux |= (0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE2) << 56;
        -:   83:
        1:   84:	return ret;
        -:   85:}
        -:   86:
        5:   87:int64 object_as_int64(const Object obj) {
        5:   88:	if (nil(obj)) {
    #####:   89:		SetErr(ObjectConsumed);
    #####:   90:		return -1;
        -:   91:	}
        -:   92:	// check flags
        5:   93:	int64 *aux = ptr_aux(obj);
        5:   94:	bool type0 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE0) << 56) & *aux;
        5:   95:	bool type1 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE1) << 56) & *aux;
        5:   96:	bool type2 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE2) << 56) & *aux;
        5:   97:	if (!type0 || !type1 || !type2) {
        2:   98:		SetErr(TypeMismatch);
        2:   99:		return -1;
        -:  100:	}
        -:  101:
        3:  102:	int64 *value = $(obj);
        3:  103:	return *value;
        -:  104:}
        -:  105:
        7:  106:int object_as_int(const Object obj) {
        7:  107:	if (nil(obj)) {
        1:  108:		SetErr(ObjectConsumed);
        1:  109:		return -1;
        -:  110:	}
        -:  111:	// check flags
        6:  112:	int64 *aux = ptr_aux(obj);
        6:  113:	bool type0 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE0) << 56) & *aux;
        6:  114:	bool type1 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE1) << 56) & *aux;
        6:  115:	bool type2 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE2) << 56) & *aux;
        6:  116:	if (!type0 || !type1 || type2) {
        1:  117:		SetErr(TypeMismatch);
        1:  118:		return -1;
        -:  119:	}
        -:  120:
        5:  121:	int *value = $(obj);
        5:  122:	return *value;
        -:  123:}
        -:  124:
        1:  125:byte object_as_byte(const Object obj) {
        1:  126:	if (nil(obj)) {
    #####:  127:		SetErr(ObjectConsumed);
    #####:  128:		return -1;
        -:  129:	}
        -:  130:	// check flags
        1:  131:	int64 *aux = ptr_aux(obj);
        1:  132:	bool type0 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE0) << 56) & *aux;
        1:  133:	bool type1 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE1) << 56) & *aux;
        1:  134:	bool type2 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE2) << 56) & *aux;
        1:  135:	if (!type0 || type1 || !type2) {
    #####:  136:		SetErr(TypeMismatch);
    #####:  137:		return BYTE_MAX;
        -:  138:	}
        -:  139:
        1:  140:	int *value = $(obj);
        1:  141:	return *value;
        -:  142:}
        -:  143:
        -:  144:// Functions that require override of const
        -:  145:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  146:#pragma clang diagnostic ignored "-Wunknown-warning-option"
        -:  147:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  148:
        2:  149:Object object_move(Object obj) {
        2:  150:	if (nil(obj)) {
    #####:  151:		SetErr(ObjectConsumed);
    #####:  152:		return NULL;
        -:  153:	}
        -:  154:	// check flags
        2:  155:	int64 *aux = ptr_aux(obj);
        2:  156:	bool type0 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE0) << 56) & *aux;
        2:  157:	bool type1 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE1) << 56) & *aux;
        2:  158:	bool type2 = ((0x1ULL << (unsigned long long)OBJECT_FLAG_TYPE2) << 56) & *aux;
        -:  159:
        2:  160:	if (type0 && type1 && type2) {
        -:  161:		// int64 type
        1:  162:		int *value = $(obj);
        1:  163:		ObjectNc ret = object_create_int64(*value);
        1:  164:		Object_cleanup(&obj);
        1:  165:		return ret;
        1:  166:	} else if (type0 && type1 && !type2) {
        -:  167:		// int type
        1:  168:		int *value = $(obj);
        1:  169:		ObjectNc ret = object_create_int(*value);
        1:  170:		Object_cleanup(&obj);
        1:  171:		return ret;
    #####:  172:	} else if (type0 && !type1 && type2) {
        -:  173:		// byte type
    #####:  174:		byte *value = $(obj);
    #####:  175:		ObjectNc ret = object_create_byte(*value);
    #####:  176:		Object_cleanup(&obj);
    #####:  177:		return ret;
        -:  178:	}
        -:  179:
    #####:  180:	return null;
        -:  181:}
        -:  182:
        2:  183:Object object_ref(Object obj) {
        2:  184:	if (nil(obj)) {
    #####:  185:		SetErr(ObjectConsumed);
    #####:  186:		return NULL;
        -:  187:	}
        -:  188:
        2:  189:	int64 *aux = ptr_aux(obj);
        2:  190:	(*aux)++;
        2:  191:	ObjectNc ret = obj;
        -:  192:
        2:  193:	return ret;
        -:  194:}
        -:  195:
       14:  196:void Object_cleanup(const Object *ptr) {
       14:  197:	if (!nil(*ptr)) {
       11:  198:		int64 *aux = ptr_aux(*ptr);
       11:  199:		int64 count = *aux & 0x00FFFFFFFFFFFFFFLL;
       11:  200:		int64 flags = *aux & 0xFF00000000000000LL;
       11:  201:		if (count == 0) {
        9:  202:			fam_release(ptr);
        -:  203:		} else {
        2:  204:			count--;
        2:  205:			*aux = count | flags;
        -:  206:		}
        -:  207:	}
       14:  208:}
        -:    0:Source:os.c
        -:    0:Graph:os.gcno
        -:    0:Data:os.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/osdef.h>
        -:   18:
        -:   19:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   20:
       64:   21:void *alloc(int64 size, int64 zeroed) {
       64:   22:	if (!size) {
    #####:   23:		SetErr(IllegalArgument);
    #####:   24:		return NULL;
        -:   25:	}
        -:   26:	void *ret;
       64:   27:	ret = malloc(size);
        -:   28:
       64:   29:	if (ret) {
       64:   30:		THREAD_LOCAL_RESOURCE_STATS.alloc_sum += 1;
       64:   31:		if (zeroed)
    #####:   32:			memset(ret, 0, size);
        -:   33:	} else {
    #####:   34:		SetErr(AllocErr);
        -:   35:	}
        -:   36:
       64:   37:	return ret;
        -:   38:}
       64:   39:void *resize(void *ptr, int64 size) {
       64:   40:	if (!ptr || !size) {
    #####:   41:		SetErr(IllegalArgument);
    #####:   42:		return NULL;
        -:   43:	}
        -:   44:	void *ret;
       64:   45:	ret = realloc(ptr, size);
        -:   46:
       64:   47:	if (ret) {
       64:   48:		THREAD_LOCAL_RESOURCE_STATS.resize_sum += 1;
        -:   49:	} else {
    #####:   50:		SetErr(AllocErr);
        -:   51:	}
       64:   52:	return ret;
        -:   53:}
        -:   54:
       64:   55:void release(void *ptr) {
       64:   56:	if (!ptr) {
    #####:   57:		SetErr(IllegalArgument);
    #####:   58:		return;
        -:   59:	}
       64:   60:	THREAD_LOCAL_RESOURCE_STATS.release_sum += 1;
       64:   61:	free(ptr);
        -:   62:}
        -:   63:
       14:   64:int64 alloc_sum() {
       14:   65:	return THREAD_LOCAL_RESOURCE_STATS.alloc_sum;
        -:   66:}
    #####:   67:int64 resize_sum() {
    #####:   68:	return THREAD_LOCAL_RESOURCE_STATS.resize_sum;
        -:   69:}
       14:   70:int64 release_sum() {
       14:   71:	return THREAD_LOCAL_RESOURCE_STATS.release_sum;
        -:   72:}
        -:   73:
        -:   74:char *getenv(const char *name);
        -:   75:
    #####:   76:byte *env(const byte *name) {
    #####:   77:	return getenv(name);
        -:   78:}
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdarg.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
    #####:   18:void __attribute__((no_return)) panic(const char *fmt, ...) {
        -:   19:	char buf[1024];
        -:   20:	va_list args;
    #####:   21:	fprintf(stderr, "Panic: ");
    #####:   22:	va_start(args, fmt);
    #####:   23:	vfprintf(stderr, fmt, args);
    #####:   24:	vsnprintf(buf, 1024, fmt, args);
    #####:   25:	va_end(args);
    #####:   26:	fprintf(stderr, "\n");
        -:   27:
    #####:   28:	exit(-1);
        -:   29:}
        -:   30:
        -:   31:/*
        -:   32:#include <base/fam_err.h>
        -:   33:#include <base/macro_util.h>
        -:   34:#include <base/os.h>
        -:   35:#include <base/print_util.h>
        -:   36:#include <base/string.h>
        -:   37:
        -:   38:#define BUF_LEN 64
        -:   39:
        -:   40:// get the va functionality (with GCC/Clang use the builtin version, otherwise use stdarg)
        -:   41:#if defined(__GNUC__) || defined(__clang__)
        -:   42:typedef __builtin_va_list va_list;
        -:   43:#define va_start(ap, param) __builtin_va_start(ap, param)
        -:   44:#define va_end(ap) __builtin_va_end(ap)
        -:   45:#define va_arg(ap, type) __builtin_va_arg(ap, type)
        -:   46:#else // __GNUC__ or __clang__
        -:   47:#include <stdarg.h>
        -:   48:#endif // __GNUC__ or __clang__
        -:   49:
        -:   50:i32 write_loop(const Stream *strm, u8 *s, i32 *cur, i32 limit, const u8 *buf, u64 len) {
        -:   51:	if (s) {
        -:   52:		if (strm->handle == -1) {
        -:   53:			// length only
        -:   54:			*cur += len;
        -:   55:		} else if (*cur < limit) {
        -:   56:			u8 *res;
        -:   57:			if (*cur == 0) {
        -:   58:				res = strncpy(s, buf, len);
        -:   59:				if (res == NULL)
        -:   60:					return -1;
        -:   61:			} else {
        -:   62:				res = strncat(s, buf, len);
        -:   63:				if (res == NULL)
        -:   64:					return -1;
        -:   65:			}
        -:   66:
        -:   67:			i32 l = strlen(buf);
        -:   68:			*cur = l;
        -:   69:		}
        -:   70:	} else {
        -:   71:		while (len > 0) {
        -:   72:			i64 w = strm_write(strm, buf, len);
        -:   73:			if (w < 0) {
        -:   74:				SetErr(IO);
        -:   75:				return w;
        -:   76:			}
        -:   77:
        -:   78:			len -= w;
        -:   79:		}
        -:   80:	}
        -:   81:	return 0;
        -:   82:}
        -:   83:
        -:   84:i32 print_impl(const Stream *strm, u8 *s, i32 capacity, bool nl, bool do_exit, i32 code,
        -:   85:			   const u8 *prefix, const u8 *fmt, ...) {
        -:   86:	int ret = 0;
        -:   87:	if (capacity < 0 && s) {
        -:   88:		SetErr(IllegalArgument);
        -:   89:		ret = -1;
        -:   90:	}
        -:   91:	if (s) {
        -:   92:		memset(s, '\0', capacity);
        -:   93:	}
        -:   94:	va_list args;
        -:   95:	va_start(args, fmt);
        -:   96:	i32 max = capacity;
        -:   97:	capacity = 0;
        -:   98:
        -:   99:	if (prefix && ret != -1) {
        -:  100:		if (write_loop(strm, s, &capacity, max, prefix, strlen(prefix)))
        -:  101:			ret = -1;
        -:  102:	}
        -:  103:
        -:  104:	while (ret != -1) {
        -:  105:		bool is_hex = false;
        -:  106:		const u8 *next = strstr(fmt, "{}");
        -:  107:		const u8 *next_hex = strstr(fmt, "{hex}");
        -:  108:		if ((next_hex && !next) || (next_hex && next_hex < next)) {
        -:  109:			next = next_hex;
        -:  110:			is_hex = true;
        -:  111:		}
        -:  112:
        -:  113:		if (next == NULL) {
        -:  114:			if (write_loop(strm, s, &capacity, max, fmt, strlen(fmt))) {
        -:  115:				ret = -1;
        -:  116:				break;
        -:  117:			}
        -:  118:			if (nl)
        -:  119:				if (write_loop(strm, s, &capacity, max, "\n", 1)) {
        -:  120:					ret = -1;
        -:  121:					break;
        -:  122:				}
        -:  123:			break;
        -:  124:		} else {
        -:  125:			u64 diff = next - fmt;
        -:  126:			u8 buf[1 + diff];
        -:  127:			memset(buf, '\0', 1 + diff);
        -:  128:			strncpy(buf, fmt, diff);
        -:  129:			if (write_loop(strm, s, &capacity, max, buf, diff)) {
        -:  130:				ret = -1;
        -:  131:				break;
        -:  132:			}
        -:  133:		}
        -:  134:
        -:  135:		PrintPair arg = va_arg(args, PrintPair);
        -:  136:
        -:  137:		if (arg.type == PrintTypeTerm) {
        -:  138:			if (next) {
        -:  139:				if (write_loop(strm, s, &capacity, max, next, strlen(next))) {
        -:  140:					ret = -1;
        -:  141:					break;
        -:  142:				}
        -:  143:				if (nl)
        -:  144:					if (write_loop(strm, s, &capacity, max, "\n", 1)) {
        -:  145:						ret = -1;
        -:  146:						break;
        -:  147:					}
        -:  148:			}
        -:  149:			break;
        -:  150:		} else if (arg.type == PrintTypeBool) {
        -:  151:			bool value;
        -:  152:			memcpy(&value, arg.buf, sizeof(bool));
        -:  153:			u8 buf[BUF_LEN];
        -:  154:			if (value)
        -:  155:				strncpy(buf, "true", 5);
        -:  156:			else
        -:  157:				strncpy(buf, "false", 6);
        -:  158:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  159:				ret = -1;
        -:  160:				break;
        -:  161:			}
        -:  162:		} else if (arg.type == PrintTypeF64) {
        -:  163:			f64 value;
        -:  164:			memcpy(&value, arg.buf, sizeof(f64));
        -:  165:			u8 buf[BUF_LEN];
        -:  166:			strcpy(buf, "");
        -:  167:			snprintf(buf, BUF_LEN - 1, "%lf", value);
        -:  168:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  169:				ret = -1;
        -:  170:				break;
        -:  171:			}
        -:  172:		} else if (arg.type == PrintTypeF32) {
        -:  173:			f32 value;
        -:  174:			memcpy(&value, arg.buf, sizeof(f32));
        -:  175:			u8 buf[BUF_LEN];
        -:  176:			strcpy(buf, "");
        -:  177:			snprintf(buf, BUF_LEN - 1, "%f", value);
        -:  178:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  179:				ret = -1;
        -:  180:				break;
        -:  181:			}
        -:  182:		} else if (arg.type == PrintTypeI64) {
        -:  183:			i64 value;
        -:  184:			memcpy(&value, arg.buf, sizeof(i64));
        -:  185:			u8 buf[BUF_LEN];
        -:  186:			strcpy(buf, "");
        -:  187:			if (is_hex)
        -:  188:				snprintf(buf, BUF_LEN - 1, "%llX", value);
        -:  189:			else
        -:  190:				snprintf(buf, BUF_LEN - 1, "%lli", value);
        -:  191:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  192:				ret = -1;
        -:  193:				break;
        -:  194:			}
        -:  195:		} else if (arg.type == PrintTypeU64) {
        -:  196:			u64 value;
        -:  197:			memcpy(&value, arg.buf, sizeof(u64));
        -:  198:			u8 buf[BUF_LEN];
        -:  199:			strcpy(buf, "");
        -:  200:			if (is_hex)
        -:  201:				snprintf(buf, BUF_LEN - 1, "%llx", value);
        -:  202:			else
        -:  203:				snprintf(buf, BUF_LEN - 1, "%llu", value);
        -:  204:
        -:  205:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  206:				ret = -1;
        -:  207:				break;
        -:  208:			}
        -:  209:		} else if (arg.type == PrintTypeI32) {
        -:  210:			i32 value;
        -:  211:			memcpy(&value, arg.buf, sizeof(i32));
        -:  212:			u8 buf[BUF_LEN];
        -:  213:			strcpy(buf, "");
        -:  214:			snprintf(buf, BUF_LEN - 1, "%i", value);
        -:  215:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  216:				ret = -1;
        -:  217:				break;
        -:  218:			}
        -:  219:		} else if (arg.type == PrintTypeU32) {
        -:  220:			u32 value;
        -:  221:			memcpy(&value, arg.buf, sizeof(u32));
        -:  222:			u8 buf[BUF_LEN];
        -:  223:			strcpy(buf, "");
        -:  224:			snprintf(buf, BUF_LEN - 1, "%u", value);
        -:  225:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  226:				ret = -1;
        -:  227:				break;
        -:  228:			}
        -:  229:		} else if (arg.type == PrintTypeI16) {
        -:  230:			i16 value;
        -:  231:			memcpy(&value, arg.buf, sizeof(i16));
        -:  232:			u8 buf[BUF_LEN];
        -:  233:			strcpy(buf, "");
        -:  234:			snprintf(buf, BUF_LEN - 1, "%i", value);
        -:  235:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  236:				ret = -1;
        -:  237:				break;
        -:  238:			}
        -:  239:		} else if (arg.type == PrintTypeU16) {
        -:  240:			u16 value;
        -:  241:			memcpy(&value, arg.buf, sizeof(u16));
        -:  242:			u8 buf[BUF_LEN];
        -:  243:			strcpy(buf, "");
        -:  244:			snprintf(buf, BUF_LEN - 1, "%u", value);
        -:  245:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  246:				ret = -1;
        -:  247:				break;
        -:  248:			}
        -:  249:		} else if (arg.type == PrintTypeI8) {
        -:  250:			i8 value;
        -:  251:			memcpy(&value, arg.buf, sizeof(i8));
        -:  252:			u8 buf[BUF_LEN];
        -:  253:			strcpy(buf, "");
        -:  254:			snprintf(buf, BUF_LEN - 1, "%i", value);
        -:  255:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  256:				ret = -1;
        -:  257:				break;
        -:  258:			}
        -:  259:		} else if (arg.type == PrintTypeU8) {
        -:  260:			u8 value;
        -:  261:			memcpy(&value, arg.buf, sizeof(u8));
        -:  262:			u8 buf[BUF_LEN];
        -:  263:			strcpy(buf, "");
        -:  264:			snprintf(buf, BUF_LEN - 1, "%u", value);
        -:  265:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  266:				ret = -1;
        -:  267:				break;
        -:  268:			}
        -:  269:		} else if (arg.type == PrintTypeString) {
        -:  270:			if (write_loop(strm, s, &capacity, max, arg.data, strlen(arg.data))) {
        -:  271:				ret = -1;
        -:  272:				break;
        -:  273:			}
        -:  274:		}
        -:  275:		if (is_hex)
        -:  276:			fmt = next + 5;
        -:  277:		else
        -:  278:			fmt = next + 2;
        -:  279:	}
        -:  280:
        -:  281:	va_end(args);
        -:  282:
        -:  283:	if (do_exit) {
        -:  284:		Backtrace bt;
        -:  285:		backtrace_generate(&bt);
        -:  286:		backtrace_print(&bt);
        -:  287:
        -:  288:		exit(code);
        -:  289:	}
        -:  290:
        -:  291:	if (ret == -1)
        -:  292:		return ret;
        -:  293:	return capacity;
        -:  294:}
        -:  295:*/
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/print_util.h>
        -:   18:#include <base/slabs.h>
        -:   19:#include <stdio.h>
        -:   20:
        -:   21:#define MAX_SLAB_TYPES 256
        -:   22:#define SLAB_SIZES 256
        -:   23:#define SLABS_PER_RESIZE 128
        -:   24:#define INITIAL_CHUNKS 0
        -:   25:
        -:   26:typedef struct Type {
        -:   27:	// slab id used internally by sa
        -:   28:	unsigned int id;
        -:   29:	// len of slab
        -:   30:	unsigned int len;
        -:   31:	int64 aux; // aux data can be used by caller as desired
        -:   32:	// user data
        -:   33:	byte data[];
        -:   34:} Type;
        -:   35:
        -:   36:const Type null_impl = {.id = 0, .len = 0};
        -:   37:const struct Type *null = &null_impl;
        -:   38:
        -:   39:#define SLAB_OVERHEAD sizeof(Type)
        -:   40:
    22141:   41:unsigned int ptr_len(const Ptr ptr) {
    22141:   42:	return ptr->len;
        -:   43:}
        -:   44:
     9224:   45:unsigned int ptr_id(const Ptr ptr) {
     9224:   46:	return ptr->id;
        -:   47:}
        -:   48:
        -:   49:// reutrn pointer to slab data
     9011:   50:void *ptr_data(const Ptr ptr) {
     9011:   51:	return ptr->data;
        -:   52:}
        -:   53:
      148:   54:void *ptr_aux(const Ptr ptr) {
      148:   55:	return &ptr->aux;
        -:   56:}
        -:   57:
        -:   58:// Direct alloc (len not used)
    #####:   59:Ptr ptr_direct_alloc(unsigned int size) {
        -:   60:	if (size < 0) {
        -:   61:		SetErr(IllegalArgument);
        -:   62:		return NULL;
        -:   63:	}
    #####:   64:	Ptr ret = alloc(size, false);
    #####:   65:	ret->len = size;
    #####:   66:	return ret;
        -:   67:}
    #####:   68:void ptr_direct_release(Ptr ptr) {
    #####:   69:	release(ptr);
    #####:   70:}
        -:   71:
        -:   72:// Slab Type definition
        -:   73:typedef struct SlabType {
        -:   74:	unsigned int slab_size;
        -:   75:	unsigned int slabs_per_resize;
        -:   76:	unsigned int initial_chunks;
        -:   77:	unsigned int max_slabs;
        -:   78:} SlabType;
        -:   79:
        -:   80:typedef struct SlabData {
        -:   81:	SlabType type;
        -:   82:	byte **data;
        -:   83:	unsigned int *free_list;
        -:   84:	unsigned int cur_chunks;
        -:   85:	unsigned int cur_slabs;
        -:   86:	unsigned int free_list_head;
        -:   87:} SlabData;
        -:   88:
        -:   89:typedef struct SlabAllocatorImpl {
        -:   90:	int64 sd_count;
        -:   91:	SlabData sd_arr[];
        -:   92:} SlabAllocatorImpl;
        -:   93:
       18:   94:void slab_allocator_cleanup(SlabAllocator *ptr) {
       18:   95:	SlabAllocatorNc sa = *ptr;
       18:   96:	if (sa) {
       10:   97:		if (sa->sd_count) {
     2570:   98:			for (int i = 0; i < sa->sd_count; i++) {
     2560:   99:				SlabData *sd = &sa->sd_arr[i];
     2560:  100:				if (sd->cur_chunks) {
        7:  101:					release(sd->free_list);
       46:  102:					for (int64 j = 0; j < sd->cur_chunks; j++)
       39:  103:						release(sd->data[j]);
        7:  104:					release(sd->data);
        7:  105:					sd->cur_chunks = 0;
        -:  106:				}
        -:  107:			}
        -:  108:		}
       10:  109:		release(sa);
       10:  110:		*ptr = NULL;
        -:  111:	}
       18:  112:}
        -:  113:
     4630:  114:int64 slab_allocator_slab_data_index(SlabData *sd, int64 id) {
     4630:  115:	return id / sd->type.slabs_per_resize;
        -:  116:}
        -:  117:
     4630:  118:int64 slab_allocator_slab_data_offset(SlabData *sd, int64 id) {
     4630:  119:	return (id % sd->type.slabs_per_resize) * (SLAB_OVERHEAD + sd->type.slab_size);
        -:  120:}
        -:  121:
       39:  122:void slab_allocator_init_free_list(SlabData *sd, int64 chunks) {
       39:  123:	sd->free_list_head = sd->cur_chunks * sd->type.slabs_per_resize;
       39:  124:	int64 count = chunks * (int64)sd->type.slabs_per_resize;
     5031:  125:	for (int64 i = 0; i < count; i++) {
     4992:  126:		if (i == count - 1) {
       39:  127:			sd->free_list[i + sd->free_list_head] = UINT32_MAX;
        -:  128:		} else {
     4953:  129:			sd->free_list[i + sd->free_list_head] = 1 + i + sd->free_list_head;
        -:  130:		}
        -:  131:	}
       39:  132:}
        -:  133:
       39:  134:int slab_allocator_increase_chunks(SlabData *sd, int64 chunks) {
       39:  135:	if (sd->cur_chunks == 0) {
        7:  136:		sd->free_list = alloc(chunks * sd->type.slabs_per_resize * sizeof(unsigned int), false);
        7:  137:		if (sd->free_list == NULL)
    #####:  138:			return -1;
        7:  139:		sd->data = alloc(chunks * sizeof(byte *), false);
        7:  140:		if (sd->data == NULL) {
    #####:  141:			release(sd->free_list);
    #####:  142:			return -1;
        -:  143:		}
       14:  144:		for (int64 i = 0; i < chunks; i++) {
       14:  145:			sd->data[i] =
        7:  146:				alloc(sd->type.slabs_per_resize * (SLAB_OVERHEAD + sd->type.slab_size), false);
        7:  147:			if (sd->data[i] == NULL) {
    #####:  148:				release(sd->free_list);
    #####:  149:				for (int64 j = i - 1; j >= 0; j--) {
    #####:  150:					release(sd->data[j]);
        -:  151:				}
    #####:  152:				release(sd->data);
    #####:  153:				return -1;
        -:  154:			}
        -:  155:		}
        -:  156:	} else {
       32:  157:		if ((chunks + (int64)sd->cur_chunks) * (int64)sd->type.slabs_per_resize >
       32:  158:			sd->type.max_slabs) {
    #####:  159:			SetErr(Overflow);
    #####:  160:			return -1;
        -:  161:		}
       32:  162:		void *tmp = resize(sd->free_list, (chunks + sd->cur_chunks) * sd->type.slabs_per_resize *
        -:  163:											  sizeof(unsigned int));
       32:  164:		if (tmp == NULL)
    #####:  165:			return -1;
       32:  166:		sd->free_list = tmp;
       32:  167:		void *tmp2 = resize(sd->data, (chunks + sd->cur_chunks) * sizeof(byte *));
       32:  168:		if (tmp2 == NULL) {
    #####:  169:			release(sd->free_list);
    #####:  170:			return -1;
        -:  171:		}
       32:  172:		sd->data = tmp2;
       64:  173:		for (int64 i = 0; i < chunks; i++) {
       64:  174:			sd->data[i + sd->cur_chunks] =
       32:  175:				alloc(sd->type.slabs_per_resize * (SLAB_OVERHEAD + sd->type.slab_size), false);
       32:  176:			if (sd->data[i + sd->cur_chunks] == NULL) {
    #####:  177:				release(sd->free_list);
    #####:  178:				for (int64 j = i - 1; j >= 0; j--) {
    #####:  179:					release(sd->data[j + sd->cur_chunks]);
        -:  180:				}
    #####:  181:				release(sd->data);
    #####:  182:				return -1;
        -:  183:			}
        -:  184:		}
        -:  185:	}
        -:  186:
       39:  187:	slab_allocator_init_free_list(sd, chunks);
       39:  188:	sd->cur_chunks += chunks;
       39:  189:	return 0;
        -:  190:}
        -:  191:
     2560:  192:int slab_allocator_init_data(SlabData *sd) {
     2560:  193:	sd->cur_slabs = 0;
     2560:  194:	sd->cur_chunks = 0;
     2560:  195:	sd->free_list_head = UINT32_MAX;
     2560:  196:	sd->free_list = NULL;
     2560:  197:	sd->data = NULL;
        -:  198:
     2560:  199:	if (sd->type.initial_chunks) {
    #####:  200:		if (slab_allocator_increase_chunks(sd, sd->type.initial_chunks))
    #####:  201:			return -1;
        -:  202:	}
     2560:  203:	return 0;
        -:  204:}
        -:  205:
       10:  206:int slab_allocator_init_state(SlabAllocator sa) {
     2570:  207:	for (int i = 0; i < sa->sd_count; i++) {
     2560:  208:		if (slab_allocator_init_data(&sa->sd_arr[i]))
    #####:  209:			return -1;
        -:  210:	}
        -:  211:
       10:  212:	return 0;
        -:  213:}
        -:  214:
       10:  215:SlabAllocator slab_allocator_create() {
       10:  216:	SlabAllocatorNc ret = (SlabAllocatorImpl *)alloc(
        -:  217:		sizeof(SlabAllocatorImpl) + SLAB_SIZES * sizeof(SlabData), false);
       10:  218:	if (ret == NULL)
    #####:  219:		return NULL;
       10:  220:	ret->sd_count = SLAB_SIZES;
     2570:  221:	for (int i = 0; i < ret->sd_count; i++) {
     2560:  222:		SlabData *sd = &ret->sd_arr[i];
     2560:  223:		sd->type = (const SlabType) {.slab_size = (1 + i) * 16,
        -:  224:									 .slabs_per_resize = SLABS_PER_RESIZE,
        -:  225:									 .initial_chunks = INITIAL_CHUNKS,
        -:  226:									 .max_slabs = UINT32_MAX};
     2560:  227:		sd->cur_chunks = 0;
        -:  228:	}
        -:  229:
       10:  230:	if (slab_allocator_init_state(ret)) {
    #####:  231:		slab_allocator_cleanup(&ret);
    #####:  232:		return NULL;
        -:  233:	}
       10:  234:	return ret;
        -:  235:}
        -:  236:
     9257:  237:int slab_allocator_index(SlabAllocator sa, unsigned int size) {
     9257:  238:	int ret = (size - 1) / 16;
     9257:  239:	if (size <= 0 || ret >= SLAB_SIZES)
        1:  240:		return -1;
     9256:  241:	return ret;
        -:  242:}
        -:  243:
     4630:  244:Ptr slab_allocator_allocate_sd(SlabData *sd) {
     4630:  245:	if (sd->free_list_head == UINT32_MAX) {
       39:  246:		if (slab_allocator_increase_chunks(sd, 1)) {
    #####:  247:			return NULL;
        -:  248:		}
       39:  249:		if (sd->free_list_head == UINT32_MAX) {
    #####:  250:			SetErr(CapacityExceeded);
    #####:  251:			return NULL;
        -:  252:		}
        -:  253:	}
     4630:  254:	int64 index = slab_allocator_slab_data_index(sd, sd->free_list_head);
     4630:  255:	int64 offset = slab_allocator_slab_data_offset(sd, sd->free_list_head);
     4630:  256:	Ptr ptr = (Type *)(sd->data[index] + offset);
     4630:  257:	ptr->id = sd->free_list_head;
     4630:  258:	ptr->len = sd->type.slab_size;
     4630:  259:	sd->free_list_head = sd->free_list[ptr->id];
     4630:  260:	sd->cur_slabs++;
        -:  261:
     4630:  262:	return ptr;
        -:  263:}
        -:  264:
     4626:  265:void slab_allocator_data_free(SlabData *sd, int64 id) {
     4626:  266:	sd->free_list[id] = sd->free_list_head;
     4626:  267:	sd->free_list_head = id;
     4626:  268:	sd->cur_slabs--;
     4626:  269:}
        -:  270:
     4631:  271:Ptr slab_allocator_allocate(SlabAllocator sa, unsigned int size) {
     4631:  272:	int index = slab_allocator_index(sa, size);
     4631:  273:	if (index < 0)
        1:  274:		return NULL;
        -:  275:
     4630:  276:	return slab_allocator_allocate_sd(&sa->sd_arr[index]);
        -:  277:}
        -:  278:
     4626:  279:void slab_allocator_free(SlabAllocator sa, Ptr ptr) {
     4626:  280:	if (ptr == NULL || sa == NULL) {
    #####:  281:		panic("Invalid ptr sent to slab_allocator free!");
        -:  282:	}
     4626:  283:	unsigned int len = ptr_len(ptr);
     4626:  284:	int index = slab_allocator_index(sa, len);
     4626:  285:	if (index < 0) {
    #####:  286:		panic("Invalid ptr sent to slab_allocator free! Unknown size %lli.", len);
        -:  287:	}
     4626:  288:	if (sa->sd_arr[index].type.slab_size != len) {
    #####:  289:		panic("Invalid ptr sent to slab_allocator free! Size mismatch %lli vs. %lli.",
        -:  290:			  sa->sd_arr[index].type.slab_size, len);
        -:  291:	}
        -:  292:
     4626:  293:	slab_allocator_data_free(&sa->sd_arr[index], ptr->id);
        -:  294:
     4626:  295:	*ptr = null_impl;
     4626:  296:}
       16:  297:int64 slab_allocator_cur_slabs_allocated(const SlabAllocator sa) {
       16:  298:	int64 slabs = 0;
     4112:  299:	for (int i = 0; i < sa->sd_count; i++) {
     4096:  300:		SlabData *sd = &sa->sd_arr[i];
     4096:  301:		slabs += sd->cur_slabs;
        -:  302:	}
       16:  303:	return slabs;
        -:  304:}
        -:    0:Source:string.c
        -:    0:Graph:string.gcno
        -:    0:Data:string.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/os.h>
        -:   18:#include <base/osdef.h>
        -:   19:#include <base/slabs.h>
        -:   20:#include <base/string.h>
        -:   21:
        -:   22:#include <stdio.h>
        -:   23:
        3:   24:int64 cstring_len(const byte *S) {
        3:   25:	if (S == NULL) {
    #####:   26:		SetErr(IllegalArgument);
    #####:   27:		return -1;
        -:   28:	}
        3:   29:	int64 ret = 0;
       16:   30:	while (*S != '\0') {
       13:   31:		S++;
       13:   32:		ret++;
        -:   33:	}
        3:   34:	return ret;
        -:   35:}
        -:   36:
        4:   37:byte *cstring(const string s) {
        4:   38:	return $(s);
        -:   39:}
        -:   40:
    #####:   41:string string_create() {
    #####:   42:	return string_create_b("", 0);
        -:   43:}
        3:   44:string string_create_cs(const char *s) {
        3:   45:	if (s == NULL) {
    #####:   46:		SetErr(IllegalArgument);
    #####:   47:		return NULL;
        -:   48:	}
        3:   49:	return string_create_b(s, cstring_len(s));
        -:   50:}
        4:   51:string string_create_b(const byte *s, unsigned int len) {
        4:   52:	if (s == NULL) {
    #####:   53:		SetErr(IllegalArgument);
    #####:   54:		return NULL;
        -:   55:	}
        -:   56:	if (len > UINT32_MAX) {
        -:   57:		SetErr(Overflow);
        -:   58:		return NULL;
        -:   59:	}
        4:   60:	Ptr ret = fam_alloc(len + 1, false);
        4:   61:	if (ret == NULL) {
    #####:   62:		return NULL;
        -:   63:	}
        4:   64:	int64 *aux = ptr_aux(ret);
        4:   65:	int64 flags = *aux & 0xFF00000000000000LL;
        4:   66:	*aux = flags | len;
        4:   67:	memcpy($(ret), s, len);
        4:   68:	((byte *)$(ret))[len] = '\0';
        4:   69:	return ret;
        -:   70:}
    #####:   71:string string_clone(string s) {
    #####:   72:	if (nil(s)) {
    #####:   73:		SetErr(IllegalArgument);
    #####:   74:		return NULL;
        -:   75:	}
    #####:   76:	return string_create_b(cstring(s), string_len(s));
        -:   77:}
        1:   78:string string_append_bytes(const string s, const byte *bytes, unsigned int len) {
        1:   79:	if (nil(s) || bytes == NULL) {
    #####:   80:		SetErr(IllegalArgument);
    #####:   81:		return NULL;
        -:   82:	}
        1:   83:	unsigned int slen = string_len(s);
        1:   84:	int64 nlen = (int64)len + (int64)slen;
        1:   85:	if (nlen > UINT32_MAX) {
    #####:   86:		SetErr(Overflow);
    #####:   87:		return NULL;
        -:   88:	}
        1:   89:	Ptr ret = fam_alloc(nlen + 1, false);
        1:   90:	if (ret == NULL)
    #####:   91:		return ret;
        -:   92:
        1:   93:	int64 *aux = ptr_aux(ret);
        1:   94:	int64 flags = *aux & 0xFF00000000000000LL;
        1:   95:	*aux = flags | nlen;
        1:   96:	memcpy($(ret), $(s), slen);
        1:   97:	memcpy($(ret) + slen, bytes, len);
        1:   98:	((byte *)$(ret))[nlen] = '\0';
        -:   99:
        1:  100:	return ret;
        -:  101:}
    #####:  102:string string_append_cstring(const string s, const char *bytes) {
    #####:  103:	return string_append_bytes(s, bytes, cstring_len(bytes));
        -:  104:}
        1:  105:string string_append_string(const string s, const string s2) {
        1:  106:	return string_append_bytes(s, cstring(s2), string_len(s2));
        -:  107:}
       27:  108:int64 string_len(const string s) {
       27:  109:	if (nil(s)) {
    #####:  110:		SetErr(IllegalArgument);
    #####:  111:		return -1;
        -:  112:	}
       27:  113:	int64 *aux = ptr_aux(s);
       27:  114:	return (*aux & 0x00FFFFFFFFFFFFFFLL);
        -:  115:}
    #####:  116:int64 string_index_of(const string s1, const string s2) {
        -:  117:	// TODO: look into optimization with Boyer-Moore or KMP
    #####:  118:	if (nil(s1) || nil(s2)) {
    #####:  119:		SetErr(IllegalArgument);
    #####:  120:		return -1;
        -:  121:	}
    #####:  122:	const char *si1 = $(s1);
    #####:  123:	const char *si2 = $(s2);
        -:  124:
    #####:  125:	unsigned int s1len = string_len(s1);
    #####:  126:	unsigned int s2len = string_len(s2);
        -:  127:
    #####:  128:	if (s2len > s1len)
    #####:  129:		return -1;
        -:  130:
    #####:  131:	if (s2len == 0)
    #####:  132:		return 0;
        -:  133:
    #####:  134:	unsigned int max = 1 + (s1len - s2len);
    #####:  135:	for (unsigned int i = 0; i < max; i++) {
    #####:  136:		if (!memcmp(si1 + i, si2, s2len))
    #####:  137:			return i;
        -:  138:	}
        -:  139:
    #####:  140:	return -1;
        -:  141:}
    #####:  142:int64 string_last_index_of(const string s1, const string s2) {
        -:  143:	// TODO: look into optimization with Boyer-Moore or KMP
    #####:  144:	if (nil(s1) || nil(s2)) {
    #####:  145:		SetErr(IllegalArgument);
    #####:  146:		return -1;
        -:  147:	}
    #####:  148:	const char *si1 = $(s1);
    #####:  149:	const char *si2 = $(s2);
        -:  150:
    #####:  151:	unsigned int s1len = string_len(s1);
    #####:  152:	unsigned int s2len = string_len(s2);
        -:  153:
    #####:  154:	if (s2len > s1len)
    #####:  155:		return -1;
        -:  156:
    #####:  157:	if (s2len == 0)
    #####:  158:		return 0;
        -:  159:
    #####:  160:	int64 max = s1len - s2len;
    #####:  161:	for (unsigned int i = max; i >= 0; i--) {
    #####:  162:		if (!memcmp(si1 + i, si2, s2len))
    #####:  163:			return i;
        -:  164:	}
        -:  165:	return -1;
        -:  166:}
    #####:  167:string string_substring(const string src, unsigned int start) {
    #####:  168:	return string_substring_s(src, start, string_len(src));
        -:  169:}
        1:  170:string string_substring_s(const string src, unsigned int start, unsigned int end) {
        1:  171:	if (nil(src) || end < start) {
    #####:  172:		SetErr(IllegalArgument);
    #####:  173:		return NULL;
        -:  174:	}
        -:  175:
        1:  176:	if (end > string_len(src)) {
    #####:  177:		SetErr(IndexOutOfBounds);
    #####:  178:		return NULL;
        -:  179:	}
        -:  180:
        1:  181:	return string_create_b($(src) + start, end - start);
        -:  182:}
       11:  183:byte string_char_at(const string s, unsigned int index) {
       11:  184:	if (nil(s)) {
    #####:  185:		SetErr(IllegalArgument);
    #####:  186:		return '\0';
        -:  187:	}
        -:  188:
       11:  189:	if (index >= string_len(s)) {
        1:  190:		SetErr(IndexOutOfBounds);
        1:  191:		return '\0';
        -:  192:	}
        -:  193:
       10:  194:	return ((char *)$(s))[index];
        -:  195:}
    #####:  196:bool string_equal(const string s1, const string s2) {
    #####:  197:	if (nil(s1) && nil(s2))
    #####:  198:		return true;
    #####:  199:	if (nil(s1) || nil(s2))
    #####:  200:		return false;
        -:  201:
    #####:  202:	int64 len = string_len(s1);
    #####:  203:	if (len != string_len(s2))
    #####:  204:		return false;
        -:  205:
    #####:  206:	const char *si1 = $(s1);
    #####:  207:	const char *si2 = $(s2);
        -:  208:
    #####:  209:	for (int64 i = 0; i < len; i++) {
    #####:  210:		if (si1[i] != si2[i])
    #####:  211:			return false;
        -:  212:	}
        -:  213:
    #####:  214:	return true;
        -:  215:}
        -:  216:
    #####:  217:int string_compare(const string s1, const string s2) {
    #####:  218:	if (nil(s1) && nil(s2))
    #####:  219:		return 0;
    #####:  220:	if (nil(s1))
    #####:  221:		return -1;
    #####:  222:	if (nil(s2))
    #####:  223:		return 1;
    #####:  224:	const char *s1c = $(s1);
    #####:  225:	const char *s2c = $(s2);
    #####:  226:	unsigned int s1len = string_len(s1);
    #####:  227:	unsigned int s2len = string_len(s2);
        -:  228:	unsigned int len;
    #####:  229:	if (s1len < s2len)
    #####:  230:		len = s1len;
        -:  231:	else
    #####:  232:		len = s2len;
    #####:  233:	unsigned int i = 0;
        -:  234:
    #####:  235:	while (i < len) {
    #####:  236:		if (s1c[i] != s2c[i]) {
    #####:  237:			if (s1c[i] < s2c[i])
    #####:  238:				return -1;
        -:  239:			else
    #####:  240:				return 1;
        -:  241:		}
    #####:  242:		i++;
        -:  243:	}
    #####:  244:	if (s2len > s1len)
    #####:  245:		return 1;
    #####:  246:	else if (s2len < s1len)
    #####:  247:		return -1;
    #####:  248:	return 0;
        -:  249:}
        -:  250:
        -:  251:// Functions that require override of const
        -:  252:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  253:#pragma clang diagnostic ignored "-Wunknown-warning-option"
        -:  254:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        5:  255:void string_cleanup(const string *ptr) {
        5:  256:	if (!nil(*ptr)) {
        5:  257:		fam_release(ptr);
        -:  258:	}
        5:  259:}
        -:  260:
        -:  261:/*
        -:  262:void string2_cleanup(string2 *ptr) {
        -:  263:	if (ptr == NULL)
        -:  264:		return;
        -:  265:	fam_release(ptr);
        -:  266:	*ptr = NULL;
        -:  267:}
        -:  268:string2 string2_create(const char *s) {
        -:  269:	int64 len = cstring_len(s);
        -:  270:	Ptr ret = fam_alloc(len + 1, false);
        -:  271:	if (ret == NULL) {
        -:  272:		return NULL;
        -:  273:	}
        -:  274:	unsigned int *p = ptr_aux2(ret);
        -:  275:	*p = len;
        -:  276:	memcpy($(ret), s, len);
        -:  277:	((byte *)$(ret))[len] = 0;
        -:  278:	return ret;
        -:  279:}
        -:  280:
        -:  281:unsigned int string2_len(const string2 s) {
        -:  282:	if (s == NULL) {
        -:  283:		SetErr(IllegalArgument);
        -:  284:		return -1;
        -:  285:	}
        -:  286:	return *((unsigned int *)ptr_aux2(s));
        -:  287:}
        -:  288:
        -:  289:typedef struct stringImpl {
        -:  290:	int64 len;
        -:  291:	byte data[];
        -:  292:} stringImpl;
        -:  293:
        -:  294:int64 cstring_len(const byte *S) {
        -:  295:	int64 ret = 0;
        -:  296:	while (*S != '\0') {
        -:  297:		S++;
        -:  298:		ret++;
        -:  299:	}
        -:  300:	return ret;
        -:  301:}
        -:  302:
        -:  303:void string_cleanup(stringNc *ptr) {
        -:  304:	if (ptr == NULL || ptr->impl == NULL)
        -:  305:		return;
        -:  306:	release(ptr->impl);
        -:  307:	ptr->impl = NULL;
        -:  308:}
        -:  309:
        -:  310:int64 string_create(string *s) {
        -:  311:	return string_create_cs(s, "");
        -:  312:}
        -:  313:
        -:  314:int64 string_create_cs(string *s, const char *s2) {
        -:  315:	if (s2 == NULL) {
        -:  316:		SetErr(IllegalArgument);
        -:  317:		return -1;
        -:  318:	}
        -:  319:	return string_create_ch(s, s2, cstring_len(s2));
        -:  320:}
        -:  321:
        -:  322:int64 string_create_ch(string *s, const byte *s2, int64 len) {
        -:  323:	if (s == NULL || s2 == NULL || len < 0) {
        -:  324:		SetErr(IllegalArgument);
        -:  325:		return -1;
        -:  326:	}
        -:  327:
        -:  328:	s->impl = alloc(1 + len + sizeof(stringImpl), false);
        -:  329:	if (s->impl == NULL)
        -:  330:		return -1;
        -:  331:	stringImpl *si = s->impl;
        -:  332:	si->len = len;
        -:  333:	memcpy(si->data, s2, len);
        -:  334:	si->data[len] = 0;
        -:  335:
        -:  336:	return 0;
        -:  337:}
        -:  338:
        -:  339:int64 string_create_s(string *s, const string *s2) {
        -:  340:	return string_create_cs(s, cstring(s2));
        -:  341:}
        -:  342:
        -:  343:int64 string_append_s(string *s, const string *s2) {
        -:  344:	stringImpl *si2 = s2->impl;
        -:  345:	return string_append_ch(s, si2->data, si2->len);
        -:  346:}
        -:  347:
        -:  348:int64 string_append_ch(string *s, const byte *s2, int64 len) {
        -:  349:	if (s == NULL || s2 == NULL || len < 0) {
        -:  350:		SetErr(IllegalArgument);
        -:  351:		return -1;
        -:  352:	}
        -:  353:
        -:  354:	stringImpl *si = s->impl;
        -:  355:	if (si == NULL) {
        -:  356:		SetErr(IllegalState);
        -:  357:		return -1;
        -:  358:	}
        -:  359:	int64 len_sum = si->len + len;
        -:  360:	void *tmp = resize(si, 1 + len_sum + sizeof(stringImpl));
        -:  361:
        -:  362:	if (tmp == NULL) {
        -:  363:		return -1;
        -:  364:	}
        -:  365:
        -:  366:	s->impl = si = tmp;
        -:  367:
        -:  368:	memcpy(si->data + si->len, s2, len);
        -:  369:	si->data[len_sum] = 0;
        -:  370:
        -:  371:	si->len = len_sum;
        -:  372:
        -:  373:	return 0;
        -:  374:}
        -:  375:
        -:  376:int64 string_len(const string *s) {
        -:  377:	if (s == NULL)
        -:  378:		return 0;
        -:  379:	stringImpl *si = s->impl;
        -:  380:	if (si == NULL)
        -:  381:		return 0;
        -:  382:	return si->len;
        -:  383:}
        -:  384:
        -:  385:int64 string_index_of(const string *s1, const string *s2) {
        -:  386:	if (s1 == NULL || s2 == NULL) {
        -:  387:		SetErr(IllegalArgument);
        -:  388:		return -1;
        -:  389:	}
        -:  390:	stringImpl *si1 = s1->impl;
        -:  391:	stringImpl *si2 = s2->impl;
        -:  392:
        -:  393:	if (si1 == NULL || si2 == NULL) {
        -:  394:		SetErr(IllegalState);
        -:  395:		return -1;
        -:  396:	}
        -:  397:
        -:  398:	int64 s1len = si1->len;
        -:  399:	int64 s2len = si2->len;
        -:  400:
        -:  401:	if (s2len > s1len)
        -:  402:		return -1;
        -:  403:
        -:  404:	if (s2len == 0)
        -:  405:		return 0;
        -:  406:
        -:  407:	int64 max = 1 + (s1len - s2len);
        -:  408:	for (int64 i = 0; i < max; i++) {
        -:  409:		if (!memcmp(si1->data + i, si2->data, s2len))
        -:  410:			return i;
        -:  411:	}
        -:  412:
        -:  413:	return -1;
        -:  414:}
        -:  415:
        -:  416:int64 string_last_index_of(const string *s1, const string *s2) {
        -:  417:	if (s1 == NULL || s2 == NULL) {
        -:  418:		SetErr(IllegalArgument);
        -:  419:		return -1;
        -:  420:	}
        -:  421:	stringImpl *si1 = s1->impl;
        -:  422:	stringImpl *si2 = s2->impl;
        -:  423:
        -:  424:	if (si1 == NULL || si2 == NULL) {
        -:  425:		SetErr(IllegalState);
        -:  426:		return -1;
        -:  427:	}
        -:  428:
        -:  429:	int64 s1len = si1->len;
        -:  430:	int64 s2len = si2->len;
        -:  431:
        -:  432:	if (s2len > s1len)
        -:  433:		return -1;
        -:  434:
        -:  435:	if (s2len == 0)
        -:  436:		return s1len;
        -:  437:
        -:  438:	int64 max = s1len - s2len;
        -:  439:	for (int64 i = max; i >= 0; i--) {
        -:  440:		if (!memcmp(si1->data + i, si2->data, s2len))
        -:  441:			return i;
        -:  442:	}
        -:  443:
        -:  444:	return -1;
        -:  445:}
        -:  446:
        -:  447:int64 string_substring(string *dst, const string *src, int64 begin) {
        -:  448:	return string_substring_s(dst, src, begin, string_len(src));
        -:  449:}
        -:  450:
        -:  451:int64 string_substring_s(string *dst, const string *src, int64 begin, int64 end) {
        -:  452:	byte ret = '\0';
        -:  453:	if (src == NULL || end < begin) {
        -:  454:		SetErr(IllegalArgument);
        -:  455:		return ret;
        -:  456:	}
        -:  457:
        -:  458:	stringImpl *si = src->impl;
        -:  459:	if (si == NULL) {
        -:  460:		SetErr(IllegalState);
        -:  461:		return ret;
        -:  462:	}
        -:  463:
        -:  464:	if (end > si->len || begin < 0) {
        -:  465:		SetErr(IndexOutOfBounds);
        -:  466:		return ret;
        -:  467:	}
        -:  468:
        -:  469:	return string_create_ch(dst, si->data + begin, end - begin);
        -:  470:}
        -:  471:byte string_char_at(const string *s, int64 index) {
        -:  472:	byte ret = '\0';
        -:  473:	if (s == NULL) {
        -:  474:		SetErr(IllegalArgument);
        -:  475:		return ret;
        -:  476:	}
        -:  477:
        -:  478:	stringImpl *si = s->impl;
        -:  479:	if (si == NULL) {
        -:  480:		SetErr(IllegalState);
        -:  481:		return ret;
        -:  482:	}
        -:  483:
        -:  484:	if (index >= si->len || index < 0) {
        -:  485:		SetErr(IndexOutOfBounds);
        -:  486:		return ret;
        -:  487:	}
        -:  488:
        -:  489:	ret = si->data[index];
        -:  490:	return ret;
        -:  491:}
        -:  492:
        -:  493:int64 string_equal(const string *s1, const string *s2) {
        -:  494:	if (s1 == NULL && s2 == NULL)
        -:  495:		return true;
        -:  496:	if (s1 == NULL || s2 == NULL)
        -:  497:		return false;
        -:  498:
        -:  499:	stringImpl *si1 = s1->impl;
        -:  500:	stringImpl *si2 = s2->impl;
        -:  501:	if (si1 == NULL && si2 == NULL)
        -:  502:		return true;
        -:  503:	if (si1 == NULL || si2 == NULL)
        -:  504:		return false;
        -:  505:	if (si1->len != si2->len)
        -:  506:		return false;
        -:  507:
        -:  508:	for (int64 i = 0; i < si1->len; i++) {
        -:  509:		if (si1->data[i] != si2->data[i])
        -:  510:			return false;
        -:  511:	}
        -:  512:
        -:  513:	return true;
        -:  514:}
        -:  515:
        -:  516:void string_move(string *dst, string *src) {
        -:  517:	string_cleanup(dst);
        -:  518:	dst->impl = src->impl;
        -:  519:	src->impl = NULL;
        -:  520:}
        -:  521:
        -:  522:byte *cstring(const string *s) {
        -:  523:	if (s == NULL || s->impl == NULL) {
        -:  524:		SetErr(IllegalArgument);
        -:  525:		return NULL;
        -:  526:	}
        -:  527:	stringImpl *si = s->impl;
        -:  528:	return si->data;
        -:  529:}
        -:  530:*/
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:10
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <base/types.h>
        -:   18:#include <stdio.h>
        -:   19:
       10:   20:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   21:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   22:	panic("Supported architectures: __x86_64__, _M_X64, and __aarch64__");
        -:   23:#endif // arch
        -:   24:
        -:   25:	// check size_t
        -:   26:	if (__SIZEOF_SIZE_T__ != 8)
        -:   27:		panic("size_t must be 8 bytes. Invalid arch!");
        -:   28:	// check primitive types
        -:   29:	if (sizeof(byte) != 1)
        -:   30:		panic("byte must be 1 byte. Invalid arch!");
        -:   31:
        -:   32:	if (sizeof(int64) != 8)
        -:   33:		panic("must be 8 bytes. Invalid arch!");
        -:   34:
        -:   35:	if (sizeof(int) != 4)
        -:   36:		panic("int must be 4 bytes. Invalid arch!");
        -:   37:
        -:   38:	if (sizeof(float64) != 8)
        -:   39:		panic("float64 must be 8 bytes. Invalid arch!");
        -:   40:
        -:   41:	if (sizeof(bool) != 1)
        -:   42:		panic("bool must be 1 byte. Invalid arch!");
        -:   43:
        -:   44:	if (sizeof(aint64) != 8)
        -:   45:		panic("aint64 must be 8 bytes. Invalid arch!");
        -:   46:
        -:   47:	if (sizeof(abool) != 1)
        -:   48:		panic("abool must be 1 byte. Invalid arch!");
        -:   49:
        -:   50:	// little endian check
       10:   51:	int test = 0x1;
       10:   52:	if (*(byte *)&test != 0x1) {
    #####:   53:		panic("Big endian is not supported!");
        -:   54:	}
       10:   55:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
