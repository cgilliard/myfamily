        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <assert.h>
        -:   17:#include <base/misc.h>
        -:   18:#include <base/path.h>
        -:   19:#include <base/sha3.h>
        -:   20:#include <limits.h>
        -:   21:#include <main/main.h>
        -:   22:#include <stdio.h>
        -:   23:#include <string.h>
        -:   24:
        -:   25:bool __is_debug_real_main_res_mkdir = false;
        -:   26:
       16:   27:void write_to_disk(const char *dir, const char *file_name, const unsigned char *data, u64 size) {
        -:   28:	char path[PATH_MAX + 1];
       16:   29:	snprintf(path, sizeof(path), "%s/%s", dir, file_name);
       16:   30:	Path ensure_parent;
       16:   31:	path_for(&ensure_parent, path);
       16:   32:	const char *pfile_name = path_file_name(&ensure_parent);
        -:   33:	char pfile_name_copy[PATH_MAX + 1];
       16:   34:	strcpy(pfile_name_copy, pfile_name);
       16:   35:	path_pop(&ensure_parent);
       16:   36:	path_canonicalize(&ensure_parent);
       16:   37:	path_mkdir(&ensure_parent, 0700, true);
       16:   38:	path_push(&ensure_parent, pfile_name_copy);
       16:   39:	MYFILE *f = myfopen(&ensure_parent, "wb");
       16:   40:	if (f) {
       15:   41:		myfwrite(data, 1, size, f);
       15:   42:		myfclose(f);
        -:   43:	} else {
        1:   44:		exit_error("Could not open file for writing");
        -:   45:	}
       16:   46:}
        -:   47:
        4:   48:bool check_build_id(const char *config_dir) {
        4:   49:	Path bid_file;
        4:   50:	path_for(&bid_file, config_dir);
        4:   51:	path_push(&bid_file, "build_id");
        4:   52:	path_canonicalize(&bid_file);
        -:   53:	// check build id
        4:   54:	MYFILE *fp = myfopen(&bid_file, "r");
        4:   55:	if (!fp) {
        1:   56:		exit_error("could not open the build file");
        1:   57:		return false;
        -:   58:	}
        -:   59:	char bid_file_contents[1024];
        3:   60:	size_t rlen = read_all(bid_file_contents, 1, 100, fp);
        3:   61:	bid_file_contents[rlen] = 0;
        3:   62:	myfclose(fp);
        3:   63:	return !strcmp(bid_file_contents, get_build_id());
        -:   64:}
        -:   65:
        6:   66:void setup_config_dir(const char *config_dir) {
        6:   67:	Path cd;
        6:   68:	path_for(&cd, config_dir);
        6:   69:	path_canonicalize(&cd);
        6:   70:	if (path_exists(&cd)) {
        2:   71:		if (check_build_id(config_dir))
        1:   72:			return;
        1:   73:		remove_directory(&cd, false);
        -:   74:	}
        5:   75:	fprintf(stderr, "Installing config directory at %s. Build id = %s.\n", config_dir,
        -:   76:			get_build_id());
        -:   77:
        5:   78:	if (!path_mkdir(&cd, 0700, false)) {
        1:   79:		exit_error("Could not create config directory at path [%s].", path_to_string(&cd));
        1:   80:		return;
        -:   81:	}
        -:   82:
        4:   83:	Path rd;
        4:   84:	path_copy(&rd, &cd);
        4:   85:	path_push(&rd, "resources");
        -:   86:
        4:   87:	if (__is_debug_real_main_res_mkdir || !path_mkdir(&rd, 0700, true)) {
        1:   88:		exit_error("Could not create resources directory at path [%s].", path_to_string(&rd));
        1:   89:		return;
        -:   90:	}
        -:   91:
       15:   92:	BUILD_RESOURCE_DIR(path_to_string(&rd), fam);
        3:   93:	WRITE_BUILD_ID(config_dir);
        -:   94:}
        -:   95:
        1:   96:void build_args(Args *args, int argc, char **argv) {
        1:   97:	SubCommand sc1;
       1*:   98:	assert(!sub_command_build(&sc1, "sc1", "sc1 help", 1, 2, "<arg doc>"));
        1:   99:	ArgsParam p1;
       1*:  100:	assert(!args_param_build(&p1, "name", "name help here", "n", false, false, "myname"));
        1:  101:	sub_command_add_param(&sc1, &p1);
        -:  102:
        1:  103:	ArgsParam p2;
        1:  104:	args_param_build(&p2, "name2", "name2 help here", "x", true, false, NULL);
        -:  105:
        1:  106:	args_build(args, "prog", "ver1.0", "me", 2, 3, "Darwin arm64");
        1:  107:	args_add_param(args, &p2);
        1:  108:	args_add_sub_command(args, &sc1);
        1:  109:}
        -:  110:
        1:  111:int real_main(int argc, char **argv) {
        1:  112:	Args args;
        1:  113:	build_args(&args, argc, argv);
        -:  114:
        1:  115:	setup_config_dir(DEFAULT_CONFIG_DIR);
        1:  116:	return 0;
        -:  117:}
        -:    0:Source:args.c
        -:    0:Graph:args.gcno
        -:    0:Data:args.gcda
        -:    0:Runs:20
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <base/colors.h>
        -:   17:#include <base/misc.h>
        -:   18:#include <base/resources.h>
        -:   19:#include <errno.h>
        -:   20:#include <stdarg.h>
        -:   21:#include <stdio.h>
        -:   22:#include <stdlib.h>
        -:   23:#include <string.h>
        -:   24:
       54:   25:bool args_param_copy(ArgsParam *dst, const ArgsParam *src) {
       54:   26:	dst->help = mymalloc(strlen(src->help) + 1);
       54:   27:	if (dst->help == NULL)
        1:   28:		return false;
        -:   29:
       53:   30:	if (src->default_value) {
       40:   31:		dst->default_value = mymalloc(strlen(src->default_value) + 1);
       40:   32:		if (dst->default_value == NULL) {
        1:   33:			myfree(dst->help);
        1:   34:			return false;
        -:   35:		}
        -:   36:	}
        -:   37:
       52:   38:	strcpy(dst->name, src->name);
       52:   39:	strcpy(dst->help, src->help);
       52:   40:	strcpy(dst->short_name, src->short_name);
       52:   41:	dst->takes_value = src->takes_value;
       52:   42:	dst->multiple = src->multiple;
       52:   43:	if (src->default_value)
       39:   44:		strcpy(dst->default_value, src->default_value);
        -:   45:	else
       13:   46:		dst->default_value = NULL;
        -:   47:
       52:   48:	return true;
        -:   49:}
        -:   50:
       72:   51:void args_param_cleanup(ArgsParamImpl *ptr) {
       72:   52:	if (ptr->help) {
       71:   53:		myfree(ptr->help);
       71:   54:		ptr->help = NULL;
        -:   55:	}
       72:   56:	if (ptr->default_value) {
       52:   57:		myfree(ptr->default_value);
       52:   58:		ptr->default_value = NULL;
        -:   59:	}
       72:   60:}
        -:   61:
       32:   62:int args_param_build(ArgsParam *ptr, const char *name, const char *help, const char *short_name,
        -:   63:					 const bool takes_value, const bool multiple, const char *default_value) {
       32:   64:	if (ptr == NULL || name == NULL || help == NULL || short_name == NULL) {
        1:   65:		print_error("Input may not be NULL");
        1:   66:		errno = EINVAL;
        1:   67:		return -1;
        -:   68:	}
        -:   69:
       31:   70:	if (strlen(name) > ARGS_MAX_ARGUMENT_NAME_LENGTH ||
       30:   71:		strlen(short_name) > ARGS_MAX_ARGUMENT_NAME_LENGTH) {
        1:   72:		print_error("Input too long");
        1:   73:		errno = EINVAL;
        1:   74:		return -1;
        -:   75:	}
        -:   76:
       30:   77:	u64 help_len = strlen(help);
       30:   78:	u64 default_value_len = 0;
       30:   79:	if (default_value)
       20:   80:		default_value_len = strlen(default_value);
        -:   81:
       30:   82:	ptr->help = mymalloc(sizeof(char) * (help_len + 1));
       30:   83:	if (default_value)
       20:   84:		ptr->default_value = mymalloc(sizeof(char) * (default_value_len + 1));
        -:   85:
       30:   86:	if (ptr->help == NULL || (ptr->default_value == NULL && default_value)) {
        1:   87:		print_error("Input may not be NULL");
        1:   88:		args_param_cleanup(ptr);
        1:   89:		return -1;
        -:   90:	}
        -:   91:
       29:   92:	strcpy(ptr->name, name);
       29:   93:	strcpy(ptr->short_name, short_name);
       29:   94:	strcpy(ptr->help, help);
       29:   95:	if (default_value)
       19:   96:		strcpy(ptr->default_value, default_value);
        -:   97:	else
       10:   98:		ptr->default_value = NULL;
       29:   99:	ptr->takes_value = takes_value;
       29:  100:	ptr->multiple = multiple;
        -:  101:
       29:  102:	return 0;
        -:  103:}
        -:  104:
       49:  105:bool sub_command_copy(SubCommand *dst, const SubCommand *src) {
       49:  106:	if (src->help == NULL)
        2:  107:		return false;
       47:  108:	dst->help = mymalloc(strlen(src->help) + 1);
       47:  109:	if (dst->help == NULL)
        1:  110:		return false;
        -:  111:
       46:  112:	if (src->arg_doc) {
       45:  113:		dst->arg_doc = mymalloc(strlen(src->arg_doc) + 1);
       45:  114:		if (dst->arg_doc == NULL) {
        1:  115:			myfree(dst->help);
        1:  116:			return false;
        -:  117:		}
        -:  118:	}
        -:  119:
       45:  120:	if (src->param_count == 0) {
       32:  121:		dst->param_count = 0;
       32:  122:		dst->is_specified = NULL;
       32:  123:		dst->params = NULL;
        -:  124:	} else {
       13:  125:		dst->params = mymalloc(sizeof(ArgsParam) * src->param_count);
       13:  126:		dst->is_specified = mymalloc(sizeof(bool) * src->param_count);
        -:  127:
       13:  128:		if (dst->params == NULL || dst->is_specified == NULL) {
        2:  129:			if (dst->params)
        1:  130:				myfree(dst->params);
        2:  131:			if (dst->is_specified)
        1:  132:				myfree(dst->is_specified);
        2:  133:			if (dst->help)
        2:  134:				myfree(dst->help);
        2:  135:			if (dst->arg_doc)
        2:  136:				myfree(dst->arg_doc);
        2:  137:			return false;
        -:  138:		}
        -:  139:
       11:  140:		memcpy(dst->is_specified, src->is_specified, sizeof(bool) * src->param_count);
       23:  141:		for (u32 i = 0; i < src->param_count; i++) {
       12:  142:			args_param_copy(&dst->params[i], &src->params[i]);
        -:  143:		}
       11:  144:		dst->param_count = src->param_count;
        -:  145:	}
        -:  146:
       43:  147:	strcpy(dst->name, src->name);
       43:  148:	strcpy(dst->help, src->help);
       43:  149:	if (src->arg_doc)
       42:  150:		strcpy(dst->arg_doc, src->arg_doc);
        -:  151:	else
        1:  152:		dst->arg_doc = NULL;
        -:  153:
       43:  154:	dst->min_args = src->min_args;
       43:  155:	dst->max_args = src->max_args;
        -:  156:
       43:  157:	return true;
        -:  158:}
        -:  159:
       77:  160:void sub_command_cleanup(SubCommandImpl *sc) {
      123:  161:	for (u32 i = 0; i < sc->param_count; i++) {
       46:  162:		args_param_cleanup(&sc->params[i]);
        -:  163:	}
       77:  164:	if (sc->params) {
       34:  165:		myfree(sc->params);
       34:  166:		sc->params = NULL;
        -:  167:	}
       77:  168:	if (sc->help) {
       77:  169:		myfree(sc->help);
       77:  170:		sc->help = NULL;
        -:  171:	}
       77:  172:	if (sc->arg_doc) {
       74:  173:		myfree(sc->arg_doc);
       74:  174:		sc->arg_doc = NULL;
        -:  175:	}
       77:  176:	if (sc->is_specified) {
       34:  177:		myfree(sc->is_specified);
       34:  178:		sc->is_specified = NULL;
        -:  179:	}
       77:  180:}
        -:  181:
       45:  182:int sub_command_build(SubCommand *sc, const char *name, const char *help, const u32 min_args,
        -:  183:					  const u32 max_args, const char *arg_doc) {
       45:  184:	if (sc == NULL || name == NULL || help == NULL || min_args > max_args) {
        2:  185:		errno = EINVAL;
        2:  186:		print_error("Invalid input");
        2:  187:		return -1;
        -:  188:	}
       43:  189:	sc->params = NULL;
       43:  190:	sc->help = NULL;
       43:  191:	sc->arg_doc = NULL;
       43:  192:	sc->is_specified = NULL;
       43:  193:	sc->param_count = 0;
        -:  194:
       43:  195:	if (strlen(name) > ARGS_MAX_SUBCOMMAND_LENGTH || min_args > max_args) {
        1:  196:		print_error("Invalid input");
        1:  197:		errno = EINVAL;
        1:  198:		return -1;
        -:  199:	}
        -:  200:
       42:  201:	if (help) {
       42:  202:		sc->help = mymalloc(sizeof(char) * strlen(help) + 1);
       42:  203:		if (sc->help == NULL) {
        1:  204:			print_error("Could not allocate sufficient memory");
        1:  205:			return -1;
        -:  206:		}
       41:  207:		strcpy(sc->help, help);
        -:  208:	}
        -:  209:
       41:  210:	if (arg_doc) {
       40:  211:		sc->arg_doc = mymalloc(sizeof(char) * strlen(arg_doc) + 1);
       40:  212:		if (sc->arg_doc == NULL) {
        1:  213:			print_error("Could not allocate sufficient memory");
        1:  214:			sub_command_cleanup(sc);
        1:  215:			return -1;
        -:  216:		}
       39:  217:		strcpy(sc->arg_doc, arg_doc);
        -:  218:	}
        -:  219:
       40:  220:	strcpy(sc->name, name);
       40:  221:	sc->min_args = min_args;
       40:  222:	sc->max_args = max_args;
        -:  223:
       40:  224:	return 0;
        -:  225:}
        -:  226:
       44:  227:int sub_command_add_param(SubCommand *sc, const ArgsParam *ap) {
       44:  228:	if (sc->params) {
        -:  229:		// already exists so realloc
        -:  230:		void *tmp;
       13:  231:		tmp = myrealloc(sc->params, sizeof(ArgsParam) * (sc->param_count + 1));
       13:  232:		if (tmp == NULL) {
        1:  233:			print_error("Could not allocate sufficient memory");
        1:  234:			return -1;
        -:  235:		}
       12:  236:		sc->params = tmp;
       12:  237:		tmp = myrealloc(sc->is_specified, sizeof(bool) * (sc->param_count + 1));
       12:  238:		if (tmp == NULL) {
        1:  239:			print_error("Could not allocate sufficient memory");
        1:  240:			return -1;
        -:  241:		}
       11:  242:		sc->is_specified = tmp;
        -:  243:
       11:  244:		args_param_copy(&sc->params[sc->param_count], ap);
       11:  245:		sc->is_specified[sc->param_count] = false;
        -:  246:
       11:  247:		sc->param_count += 1;
        -:  248:	} else {
       31:  249:		sc->params = mymalloc(sizeof(ArgsParam));
       31:  250:		sc->is_specified = mymalloc(sizeof(bool));
        -:  251:
       31:  252:		if (sc->params == NULL || sc->is_specified == NULL) {
        2:  253:			if (sc->params) {
        1:  254:				myfree(sc->params);
        1:  255:				sc->params = NULL;
        -:  256:			}
        2:  257:			if (sc->is_specified) {
        1:  258:				myfree(sc->is_specified);
        1:  259:				sc->is_specified = NULL;
        -:  260:			}
        2:  261:			print_error("Could not allocate sufficient memory");
        2:  262:			return -1;
        -:  263:		}
        -:  264:
       29:  265:		args_param_copy(&sc->params[sc->param_count], ap);
       29:  266:		sc->is_specified[sc->param_count] = false;
       29:  267:		sc->param_count += 1;
        -:  268:	}
       40:  269:	return 0;
        -:  270:}
        -:  271:
       24:  272:void args_cleanup(ArgsImpl *ptr) {
       61:  273:	for (u32 i = 0; i < ptr->subs_count; i++) {
       37:  274:		sub_command_cleanup(&ptr->subs[i]);
        -:  275:	}
       24:  276:	ptr->subs_count = 0;
       24:  277:	if (ptr->subs) {
       24:  278:		myfree(ptr->subs);
       24:  279:		ptr->subs = NULL;
        -:  280:	}
      104:  281:	for (u64 i = 0; i < ptr->argc; i++) {
       80:  282:		myfree(ptr->argv[i]);
        -:  283:	}
       24:  284:	if (ptr->argc) {
       15:  285:		myfree(ptr->argv);
       15:  286:		ptr->argc = 0;
        -:  287:	}
       24:  288:}
        -:  289:
       30:  290:int args_build(Args *args, const char *prog, const char *version, const char *author,
        -:  291:			   const u32 min_args, const u32 max_args, const char *arch) {
       30:  292:	if (prog == NULL || version == NULL || author == NULL) {
        1:  293:		print_error("Input may not be NULL");
        1:  294:		errno = EINVAL;
        1:  295:		return -1;
        -:  296:	}
        -:  297:
       29:  298:	if (strlen(prog) > ARGS_MAX_DETAIL_LENGTH || strlen(version) > ARGS_MAX_DETAIL_LENGTH ||
       28:  299:		strlen(author) > ARGS_MAX_DETAIL_LENGTH) {
        1:  300:		print_error("Input too long");
        1:  301:		errno = EINVAL;
        1:  302:		return -1;
        -:  303:	}
        -:  304:
        -:  305:	// first subcommand is our params (set it up)
       28:  306:	args->subs_count = 0;
       28:  307:	args->subs = NULL;
        -:  308:
        -:  309:	SubCommandImpl sc;
       28:  310:	if (sub_command_build(&sc, "", "", min_args, max_args, "")) {
        1:  311:		args->subs_count = 0;
        1:  312:		args->subs = NULL;
        1:  313:		return -1;
        -:  314:	}
       27:  315:	args_add_sub_command(args, &sc);
       27:  316:	sub_command_cleanup(&sc);
        -:  317:
       27:  318:	strcpy(args->prog, prog);
       27:  319:	strcpy(args->version, version);
       27:  320:	strcpy(args->author, author);
        -:  321:
       27:  322:	if (arch != NULL)
       23:  323:		strcpy(args->arch, arch);
        -:  324:	else
        4:  325:		strcpy(args->arch, "");
        -:  326:
       27:  327:	args->argv = NULL;
       27:  328:	args->argc = 0;
        -:  329:
       27:  330:	return 0;
        -:  331:}
        -:  332:
       27:  333:void args_exit_error(const Args *args, char *format, ...) {
        -:  334:	va_list va_args;
       27:  335:	va_start(va_args, format);
       27:  336:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
       27:  337:	vfprintf(stderr, format, va_args);
       27:  338:	fprintf(stderr, "\n\n");
       54:  339:	fprintf(stderr,
        -:  340:			"%sUSAGE%s:\n    %s%s%s [%sOPTIONS%s]\n\nFor more information "
        -:  341:			"try %s--help%s\n",
       27:  342:			DIMMED, RESET, BRIGHT_RED, args->prog, RESET, DIMMED, RESET, GREEN, RESET);
       27:  343:	va_end(va_args);
      27*:  344:	EXIT_ERR_IF_NO_DEBUG(-1);
       27:  345:}
        -:  346:
       30:  347:int args_add_param(Args *args, const ArgsParam *ap) {
       30:  348:	return sub_command_add_param(&args->subs[0], ap);
        -:  349:}
       45:  350:int args_add_sub_command(Args *args, SubCommand *sc) {
       45:  351:	if (args->subs_count == 0) {
       28:  352:		args->subs = mymalloc(sizeof(SubCommand));
       28:  353:		if (args->subs == NULL) {
        1:  354:			print_error("Could not allocate sufficient memory");
        1:  355:			return -1;
        -:  356:		}
        -:  357:	} else {
       17:  358:		void *tmp = myrealloc(args->subs, sizeof(SubCommand) * (args->subs_count + 1));
       17:  359:		if (tmp == NULL) {
        1:  360:			print_error("Could not allocate sufficient memory");
        1:  361:			return -1;
        -:  362:		}
       16:  363:		args->subs = tmp;
        -:  364:	}
        -:  365:
       43:  366:	bool ret = sub_command_copy(&args->subs[args->subs_count], sc);
       43:  367:	if (ret)
       42:  368:		args->subs_count++;
        -:  369:
       43:  370:	if (ret)
       42:  371:		return 0;
        -:  372:	else
        1:  373:		return -1;
        -:  374:}
        -:  375:
       10:  376:u64 args_subi_for(const Args *args, const char *sub) {
       10:  377:	u64 subi = 0;
       20:  378:	for (u64 i = 1; i < args->subs_count; i++) {
       10:  379:		if (!strcmp(sub, args->subs[i].name)) {
        9:  380:			subi = i;
        -:  381:		}
        -:  382:	}
       10:  383:	return subi;
        -:  384:}
        -:  385:
       45:  386:bool args_sub_takes_value(const Args *args, u64 subi, const char *name, bool is_short) {
       77:  387:	for (u64 i = 0; i < args->subs[subi].param_count; i++) {
       67:  388:		if (is_short && !strcmp(name, args->subs[subi].params[i].short_name)) {
       15:  389:			if (args->subs[subi].params[i].takes_value) {
       13:  390:				return true;
        -:  391:			} else
        2:  392:				break;
       52:  393:		} else if (!strcmp(name, args->subs[subi].params[i].name)) {
       20:  394:			if (args->subs[subi].params[i].takes_value) {
       18:  395:				return true;
        -:  396:			} else
        2:  397:				break;
        -:  398:		}
        -:  399:	}
       14:  400:	return false;
        -:  401:}
        -:  402:
       21:  403:bool args_check_option(const Args *args, u64 subi, const char *name, bool is_short,
        -:  404:					   const char *argv) {
       21:  405:	bool found = false;
       37:  406:	for (u64 j = 0; j < args->subs[subi].param_count; j++) {
       32:  407:		bool multi = args->subs[subi].params[j].multiple;
       32:  408:		if (is_short && !strcmp(args->subs[subi].params[j].short_name, name)) {
        7:  409:			found = true;
        7:  410:			if (args->subs[subi].is_specified[j] && !multi) {
        1:  411:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
        1:  412:				return false;
        -:  413:			}
        6:  414:			args->subs[subi].is_specified[j] = true;
        6:  415:			break;
       25:  416:		} else if (!is_short && !strcmp(args->subs[subi].params[j].name, name)) {
        9:  417:			found = true;
        9:  418:			if (args->subs[subi].is_specified[j] && !multi) {
        1:  419:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
        1:  420:				return false;
        -:  421:			}
        8:  422:			args->subs[subi].is_specified[j] = true;
        8:  423:			break;
        -:  424:		}
        -:  425:	}
       19:  426:	return found;
        -:  427:}
        -:  428:
       13:  429:void args_check_validity(const Args *args, int argc, const char **argv) {
        -:  430:	// check if there's a sub command and check arg count
       13:  431:	const char *sub = NULL;
       13:  432:	u32 arg_count = 0;
       13:  433:	u64 subi = 0;
       13:  434:	u64 sub_arg = UINT64_MAX;
       61:  435:	for (u64 i = 1; i < argc; i++) {
       48:  436:		u64 len = strlen(argv[i]);
       69:  437:		if (len > 0 && argv[i][0] == '-') {
       21:  438:			char name[len];
        -:  439:			bool is_short;
       21:  440:			bool found = false;
       21:  441:			if (len > 1 && args->argv[i][1] == '-') {
       14:  442:				strcpy(name, args->argv[i] + 2);
       14:  443:				is_short = false;
        -:  444:			} else {
        7:  445:				strcpy(name, args->argv[i] + 1);
        7:  446:				is_short = true;
        -:  447:			}
       21:  448:			if (args_sub_takes_value(args, subi, name, is_short)) {
       14:  449:				i += 1;
        -:  450:			}
        -:  451:		} else {
       27:  452:			if (!sub && args->subs_count > 1) {
       10:  453:				sub = argv[i];
       10:  454:				sub_arg = i;
       10:  455:				subi = args_subi_for(args, sub);
        -:  456:			} else
       17:  457:				arg_count += 1;
        -:  458:		}
        -:  459:	}
        -:  460:
       13:  461:	u64 sub_index = 0;
       13:  462:	if (sub) {
        -:  463:		// there's a sub so validate it
       10:  464:		bool valid = false;
       11:  465:		for (u64 i = 1; i < args->subs_count; i++) {
       10:  466:			if (!strcmp(sub, args->subs[i].name)) {
        9:  467:				valid = true;
        9:  468:				if (arg_count > args->subs[i].max_args || arg_count < args->subs[i].min_args) {
        4:  469:					args_exit_error(args,
        -:  470:									"Incorrect number of "
        -:  471:									"arguments for sub command '%s' "
        -:  472:									"(%i specified). "
        -:  473:									"Number of arguments must be "
        -:  474:									"between %i and %i.",
        4:  475:									args->subs[i].name, arg_count, args->subs[i].min_args,
        4:  476:									args->subs[i].max_args);
        -:  477:				}
        9:  478:				sub_index = i;
        -:  479:
        9:  480:				break;
        -:  481:			}
        -:  482:		}
       10:  483:		if (!valid) {
        1:  484:			args_exit_error(args, "Unknown SubCommand \"%s\"", sub);
        -:  485:		}
        3:  486:	} else if (args->subs_count > 1) {
        1:  487:		args_usage(args, NULL);
        -:  488:	} else {
        -:  489:		// no sub commands so we check the base min/max args.
        -:  490:		// check number of args
       2*:  491:		if (arg_count > args->subs[0].max_args || arg_count < args->subs[0].min_args) {
        2:  492:			args_exit_error(args,
        -:  493:							"Incorrect number of arguments "
        -:  494:							"(%i specified). "
        -:  495:							"Number of arguments must be "
        -:  496:							"between %i and %i.",
        2:  497:							arg_count, args->subs[0].min_args, args->subs[0].max_args);
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	// check options
       60:  502:	for (u64 i = 1; i < argc; i++) {
        -:  503:		u64 subi;
       48:  504:		if (i <= sub_arg) {
       29:  505:			subi = 0;
        -:  506:		} else {
       19:  507:			subi = sub_index;
        -:  508:		}
        -:  509:
       48:  510:		u64 len = strlen(argv[i]);
       48:  511:		if (len > 0 && argv[i][0] == '-') {
        -:  512:			// option to check
       21:  513:			char name[len];
        -:  514:			bool is_short;
       21:  515:			bool found = false;
       21:  516:			if (len > 1 && args->argv[i][1] == '-') {
       14:  517:				strcpy(name, args->argv[i] + 2);
       14:  518:				is_short = false;
        -:  519:			} else {
        7:  520:				strcpy(name, args->argv[i] + 1);
        7:  521:				is_short = true;
        -:  522:			}
        -:  523:
       21:  524:			found = args_check_option(args, subi, name, is_short, argv[i]);
       21:  525:			if (args_sub_takes_value(args, subi, name, is_short)) {
       14:  526:				i += 1;
        -:  527:			}
       21:  528:			if (!found) {
        7:  529:				if (subi == 0) {
        3:  530:					args_exit_error(args, "Unknown option: %s", argv[i]);
        -:  531:				} else {
        4:  532:					args_exit_error(args,
        -:  533:									"Unknown option: %s. Not valid for "
        -:  534:									"SubCommand \"%s\".",
        4:  535:									argv[i], args->subs[subi].name);
        -:  536:				}
        -:  537:			}
        -:  538:		}
        -:  539:	}
       12:  540:}
        -:  541:
        5:  542:void process_lines(Args *args, const char *arg1, char config_file[], size_t fsize) {
        -:  543:
        5:  544:	args->argv = mymalloc(sizeof(char *));
        5:  545:	if (args->argv == NULL) {
        1:  546:		args_exit_error(args, "Could not allocate sufficient memory");
        1:  547:		return;
        -:  548:	}
        -:  549:
        4:  550:	args->argv[0] = mymalloc(sizeof(char) * (strlen(arg1) + 1));
        4:  551:	if (args->argv[0] == NULL) {
        1:  552:		myfree(args->argv);
        1:  553:		args_exit_error(args, "Could not allocate sufficient memory");
        1:  554:		return;
        -:  555:	}
        3:  556:	strcpy(args->argv[0], arg1);
        -:  557:
        3:  558:	args->argc = 1;
        -:  559:
        -:  560:	// Use strtok to split the string into lines
        3:  561:	char *line = strtok(config_file, "\n");
        -:  562:
        8:  563:	while (line != NULL) {
        -:  564:		// allow for comments using '#'.
       41:  565:		for (int i = 0; i < strlen(line); i++) {
       37:  566:			if (line[i] == '#') {
        3:  567:				line[i] = 0;
        3:  568:				break;
        -:  569:			}
        -:  570:		}
        -:  571:		// trim
        7:  572:		char *trimmed = trim_whitespace(line);
        -:  573:
        7:  574:		if (*trimmed == '\0') {
        1:  575:			line = strtok(NULL, "\n"); // Skip empty lines
        1:  576:			continue;
        -:  577:		}
        -:  578:
        6:  579:		void *tmp = myrealloc(args->argv, sizeof(char *) * (args->argc + 1));
        6:  580:		if (tmp == NULL) {
        1:  581:			args_exit_error(args, "Could not allocate sufficient memory");
        1:  582:			return;
        -:  583:		}
        5:  584:		args->argv = tmp;
        5:  585:		args->argv[args->argc] = mymalloc(sizeof(char) * (strlen(trimmed) + 1));
        5:  586:		if (args->argv[args->argc] == NULL) {
        1:  587:			args_exit_error(args, "Could not allocate sufficient memory");
        1:  588:			return;
        -:  589:		}
        4:  590:		strcpy(args->argv[args->argc], trimmed);
        4:  591:		args->argc++;
        -:  592:
        -:  593:		// Get the next line
        4:  594:		line = strtok(NULL, "\n");
        -:  595:	}
        -:  596:}
        -:  597:
        -:  598:// Return 1 on successful file config created
        -:  599:// Return 0 if no file was specified
        -:  600:// Return -1 if an error occurs
       23:  601:int check_file_config(Args *args, const int argc, const char **argv) {
        -:  602:	// if file config is used there must be exactly two arguments fam @config.txt for example
       23:  603:	if (argc != 2)
       14:  604:		return 0;
        -:  605:
        -:  606:	// If the second argument does not start with an '@' symbol it is not a file.
        9:  607:	u64 arg_len = strlen(argv[1]);
        9:  608:	if (arg_len > 0 && argv[1][0] != '@') {
        3:  609:		return 0;
        -:  610:	}
        -:  611:
        -:  612:	// We have a file config process it.
        -:  613:	// get file size
        6:  614:	const char *file_name = argv[1] + 1;
        -:  615:
        6:  616:	Path path;
        6:  617:	path_for(&path, file_name);
        6:  618:	if (!path_exists(&path) || path_is_dir(&path)) {
        1:  619:		args_exit_error(args, "File not found at '%s'", path_to_string(&path));
        1:  620:		return -1;
        -:  621:	}
        5:  622:	u64 fsize = path_file_size(&path);
        -:  623:
        5:  624:	char config_file[fsize + 1];
        5:  625:	MYFILE *fp = myfopen(&path, "r");
        5:  626:	read_all(config_file, 1, fsize, fp);
        5:  627:	config_file[fsize] = 0;
        5:  628:	myfclose(fp);
        -:  629:
        5:  630:	process_lines(args, argv[0], config_file, fsize);
        -:  631:
        5:  632:	return 1;
        -:  633:}
        -:  634:
       24:  635:void args_init(Args *args, const int argc, const char **argv) {
        -:  636:	// check for NULLs (not allowed)
      120:  637:	for (int i = 0; i < argc; i++) {
       97:  638:		if (argv[i] == NULL) {
        1:  639:			args_exit_error(args, "argv may not have NULL value where i < argc");
        1:  640:			return;
        -:  641:		}
        -:  642:	}
        -:  643:	int r;
       23:  644:	if (check_file_config(args, argc, argv)) {
        -:  645:		// if true the file config as been loaded
        6:  646:		return;
        -:  647:	}
        -:  648:
        -:  649:	// scan args for an arg starting with '@'. Not valid here. It must be the first and only param.
        -:  650:	// Report error.
        -:  651:
        -:  652:	// If any args start with '@' it's an error because we already checked for file config
       82:  653:	for (u64 i = 1; i < argc; i++) {
       66:  654:		u64 arg_len = strlen(argv[i]);
       66:  655:		if (arg_len > 0 && argv[i][0] == '@') {
        1:  656:			args_exit_error(args,
        -:  657:							"File speicified with the '@' symbol must be the first argument.");
        1:  658:			return;
        -:  659:		}
        -:  660:	}
        -:  661:
       16:  662:	args->argc = argc;
       16:  663:	args->argv = mymalloc(sizeof(char *) * argc);
       16:  664:	if (args->argv == NULL) {
        1:  665:		args->argc = 0;
        1:  666:		args_exit_error(args, "Could not allocate sufficient memory");
        1:  667:		return;
        -:  668:	}
       91:  669:	for (u64 i = 0; i < argc; i++) {
       77:  670:		args->argv[i] = mymalloc(sizeof(char) * (strlen(argv[i]) + 1));
       77:  671:		if (args->argv[i] == NULL) {
        1:  672:			args->argc = 0;
        1:  673:			myfree(args->argv);
        1:  674:			args_exit_error(args, "Could not allocate sufficient memory");
        1:  675:			return;
        -:  676:		}
       76:  677:		strcpy(args->argv[i], argv[i]);
        -:  678:	}
        -:  679:
       75:  680:	for (u64 i = 1; i < argc; i++) {
       62:  681:		if (!strcmp(argv[i], "--version") || !strcmp(argv[i], "-V")) {
    #####:  682:			args_print_version(args);
        -:  683:		}
       62:  684:		if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
        5:  685:			const char *sub = NULL;
        8:  686:			for (u64 j = 1; j < i; j++) {
        7:  687:				u64 len = strlen(argv[j]);
        7:  688:				if (len > 0) {
        7:  689:					if (argv[j][0] != '-') {
        4:  690:						sub = argv[j];
        4:  691:						break;
        3:  692:					} else {
        3:  693:						char name[len + 1];
        -:  694:						bool is_short;
        3:  695:						if (len > 1 && args->argv[j][1] == '-') {
        2:  696:							strcpy(name, args->argv[j] + 2);
        2:  697:							is_short = false;
        -:  698:						} else {
        1:  699:							strcpy(name, args->argv[j] + 1);
        1:  700:							is_short = true;
        -:  701:						}
        -:  702:
        3:  703:						u64 subi = 0;
        3:  704:						if (args_sub_takes_value(args, subi, name, is_short)) {
        3:  705:							j += 1;
        -:  706:						}
        -:  707:					}
        -:  708:				}
        -:  709:			}
        5:  710:			args_usage(args, sub);
        -:  711:		}
        -:  712:	}
        -:  713:
       13:  714:	args_check_validity(args, argc, argv);
        -:  715:}
        -:  716:
        -:  717:// Returns -2 if an error occurs and sets errno.
        -:  718:// Returns -1 if the value is not present.
        -:  719:// Returns 0 if the value is found (flags or max_value_len == 0)
        -:  720:// Returns the length of the value (takes_value true and max_value_len > 0)
       13:  721:int args_value_of(const Args *args, const char *param_name, char *value_buf,
       13:  722:				  const u64 max_value_len, const u32 index) {
       13:  723:	if (args == NULL || param_name == NULL) {
        1:  724:		errno = EINVAL;
        1:  725:		print_error("Input may not be NULL");
        1:  726:		return -2;
        -:  727:	}
       12:  728:	u64 plen = strlen(param_name);
        -:  729:
       12:  730:	char param_name_buf[plen + 3];
       12:  731:	strcpy(param_name_buf, "--");
       12:  732:	strcat(param_name_buf, param_name);
        -:  733:
       12:  734:	char short_name_buf[plen + 3];
       12:  735:	strcpy(short_name_buf, "-");
       12:  736:	bool found = false;
       12:  737:	char *default_value = NULL;
       12:  738:	bool takes_value = false;
        -:  739:
        -:  740:	// linear search through all elements. Potential to improve here.
       36:  741:	for (u64 i = 0; i < args->subs_count; i++) {
       48:  742:		for (u64 j = 0; j < args->subs[i].param_count; j++) {
       24:  743:			if (!strcmp(args->subs[i].params[j].name, param_name)) {
       17:  744:				found = true;
       17:  745:				strcat(short_name_buf, args->subs[i].params[j].short_name);
       17:  746:				default_value = args->subs[i].params[j].default_value;
       17:  747:				takes_value = args->subs[i].params[j].takes_value;
        -:  748:			}
        -:  749:		}
        -:  750:	}
        -:  751:
       12:  752:	if (!found) {
        1:  753:		print_error("Unknown parameter tested");
        1:  754:		errno = ENOENT;
        1:  755:		return -2;
        -:  756:	}
       11:  757:	u64 itt_index = 0;
       26:  758:	for (u64 i = 1; i < args->argc; i++) {
       23:  759:		if (!strcmp(args->argv[i], param_name_buf) || !strcmp(args->argv[i], short_name_buf)) {
        9:  760:			if (itt_index == index) {
        8:  761:				if (takes_value && i + 1 < args->argc) {
        4:  762:					if (value_buf == NULL) {
        1:  763:						errno = EINVAL;
        1:  764:						print_error("Input may not be NULL");
        1:  765:						return -2;
        -:  766:					}
        3:  767:					return snprintf(value_buf, max_value_len, "%s", args->argv[i + 1]);
        4:  768:				} else if (takes_value && max_value_len > 0) {
        2:  769:					if (value_buf == NULL) {
        1:  770:						errno = EINVAL;
        1:  771:						print_error("Input may not be NULL");
        1:  772:						return -2;
        -:  773:					}
        1:  774:					strcpy(value_buf, "");
        1:  775:					return 0;
        -:  776:				} else {
        2:  777:					return 0;
        -:  778:				}
        -:  779:			} else {
        1:  780:				itt_index += 1;
        -:  781:			}
        -:  782:		}
        -:  783:	}
        -:  784:
        3:  785:	if (default_value != NULL && index == 0) {
        2:  786:		if (value_buf == NULL && max_value_len > 0) {
        1:  787:			errno = EINVAL;
        1:  788:			print_error("Input may not be NULL");
        1:  789:			return -2;
        -:  790:		}
        1:  791:		return snprintf(value_buf, max_value_len, "%s", default_value);
        -:  792:	}
        -:  793:
        1:  794:	return -1;
        -:  795:}
        -:  796:
       14:  797:int args_get_argument(const Args *args, const u32 index, char *value_buf, const u64 max_value_len) {
       14:  798:	if (args == NULL) {
        1:  799:		print_error("Input may not be NULL");
        1:  800:		errno = EINVAL;
        1:  801:		return -2;
        -:  802:	}
       13:  803:	u64 index_itt = 0;
       49:  804:	for (u64 i = 1; i < args->argc; i++) {
       46:  805:		i32 len = strlen(args->argv[i]);
       62:  806:		if (len > 1 && args->argv[i][0] == '-') {
       16:  807:			char name[len];
        -:  808:			bool is_short;
       16:  809:			bool found = false;
       16:  810:			if (len > 1 && args->argv[i][1] == '-') {
       11:  811:				strcpy(name, args->argv[i] + 2);
       11:  812:				is_short = false;
        -:  813:			} else {
        5:  814:				strcpy(name, args->argv[i] + 1);
        5:  815:				is_short = true;
        -:  816:			}
        -:  817:
        -:  818:			// linear search through all elements. Potential to improve here.
       48:  819:			for (u64 k = 0; k < args->subs_count; k++) {
       59:  820:				for (u64 j = 0; j < args->subs[k].param_count; j++) {
       37:  821:					if (is_short && !strcmp(name, args->subs[k].params[j].short_name)) {
        5:  822:						if (args->subs[k].params[j].takes_value) {
        5:  823:							i += 1;
        5:  824:							found = true;
        5:  825:							break;
        -:  826:						}
       32:  827:					} else if (!strcmp(name, args->subs[k].params[j].name)) {
       11:  828:						if (args->subs[k].params[j].takes_value) {
        5:  829:							i += 1;
        5:  830:							found = true;
        5:  831:							break;
        -:  832:						}
        -:  833:					}
        -:  834:				}
        -:  835:			}
        -:  836:		} else {
       30:  837:			if (index_itt == index) {
       10:  838:				if (value_buf == NULL && max_value_len != 0) {
        1:  839:					print_error("Input may not be NULL");
        1:  840:					errno = EINVAL;
        1:  841:					return -2;
        -:  842:				}
        9:  843:				return snprintf(value_buf, max_value_len, "%s", args->argv[i]);
        -:  844:			}
       20:  845:			index_itt += 1;
        -:  846:		}
        -:  847:	}
        3:  848:	return -1;
        -:  849:}
        -:  850:
        1:  851:void args_print_version(const Args *args) {
        1:  852:	const char *prog = args->prog;
        1:  853:	const char *version = args->version;
        1:  854:	const char *arch = args->arch;
        1:  855:	if (strlen(arch) == 0) {
        1:  856:		arch = "";
        -:  857:	}
        1:  858:	fprintf(stderr, "%s%s%s %s%s%s (%s%s%s)\n", BRIGHT_RED, prog, RESET, CYAN, version, RESET,
        -:  859:			YELLOW, arch, RESET);
       1*:  860:	EXIT_ERR_IF_NO_DEBUG(0);
        1:  861:}
        -:  862:
       10:  863:void args_usage(const Args *args, const char *sub_command) {
       10:  864:	bool found = false;
       10:  865:	u64 subs_count = args->subs_count;
       10:  866:	u64 sub_index = 0;
        -:  867:
       10:  868:	if (sub_command) {
       12:  869:		for (u64 i = 1; i < subs_count; i++) {
        6:  870:			char *name = args->subs[i].name;
        6:  871:			if (!strcmp(name, sub_command)) {
        5:  872:				sub_index = i;
        5:  873:				found = true;
        -:  874:			}
        -:  875:		}
        -:  876:	} else // general help displayed
        4:  877:		found = true;
        -:  878:
       10:  879:	if (!found) {
        1:  880:		args_exit_error(args, "Unknown SubCommand \"%s\"", sub_command);
        1:  881:		return;
        -:  882:	}
        -:  883:
        9:  884:	u64 count = args->subs[0].param_count;
        9:  885:	u64 max_len = 0;
       24:  886:	for (u64 i = 0; i < count; i++) {
       15:  887:		bool takes_value = args->subs[0].params[i].takes_value;
       15:  888:		bool multi = args->subs[0].params[i].multiple;
       15:  889:		char *name = args->subs[0].params[i].name;
       15:  890:		char *short_name = args->subs[0].params[i].short_name;
        -:  891:		u64 len;
       15:  892:		if (!takes_value)
        4:  893:			len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
       11:  894:		else if (multi)
        3:  895:			len = snprintf(NULL, 0, "    -%s, --%s (<%s>, ...)", short_name, name, name);
        -:  896:		else
        8:  897:			len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
       15:  898:		if (len > max_len)
       11:  899:			max_len = len;
        -:  900:	}
        -:  901:
        9:  902:	max_len += 4;
        -:  903:
        9:  904:	if (max_len < 17)
        2:  905:		max_len = 17;
        -:  906:
        9:  907:	const char *prog = args->prog;
        9:  908:	const char *author = args->author;
        9:  909:	const char *version = args->version;
        -:  910:	char buffer[1025];
        -:  911:	char buffer2[1025];
        -:  912:	u64 i;
      324:  913:	for (i = 0; i < max_len - 13 && i < 1024; i++)
      315:  914:		buffer[i] = ' ';
        9:  915:	buffer[i] = 0;
        -:  916:
      297:  917:	for (i = 0; i < max_len - 16 && i < 1024; i++)
      288:  918:		buffer2[i] = ' ';
        9:  919:	buffer2[i] = 0;
        -:  920:	u64 sub_command_str_len;
        9:  921:	if (sub_command)
        5:  922:		sub_command_str_len = strlen(sub_command);
        -:  923:	else
        4:  924:		sub_command_str_len = 0;
        9:  925:	char sub_command_str[sub_command_str_len + 30];
        9:  926:	char *sub_arg_doc_str = "";
        -:  927:
        9:  928:	if (sub_command) {
        5:  929:		snprintf(sub_command_str, sub_command_str_len + 30, "%s%s%s", BRIGHT_RED, sub_command,
        -:  930:				 RESET);
        5:  931:		sub_arg_doc_str = args->subs[sub_index].arg_doc;
        -:  932:	} else {
        4:  933:		snprintf(sub_command_str, sub_command_str_len + 30, "[%sSUB_COMMAND%s]", DIMMED, RESET);
        -:  934:	}
        -:  935:
        9:  936:	fprintf(stderr,
        -:  937:			"%s%s%s %s%s%s\n%s%s%s\n\n%sUSAGE%s:\n    %s%s%s "
        -:  938:			"[%sCORE_OPTIONS%s] %s [%sSUB_OPTIONS%s] %s\n\n"
        -:  939:			"%sCORE_FLAGS%s:\n"
        -:  940:			"    %s-h%s, %s--help%s%sPrints help information\n"
        -:  941:			"    %s-V%s, %s--version%s%sPrints version "
        -:  942:			"information\n",
        -:  943:			CYAN, prog, RESET, YELLOW, version, RESET, GREEN, author, RESET, DIMMED, RESET,
        -:  944:			BRIGHT_RED, prog, RESET, DIMMED, RESET, sub_command_str, DIMMED, RESET, sub_arg_doc_str,
        -:  945:			DIMMED, RESET, CYAN, RESET, YELLOW, RESET, buffer, CYAN, RESET, YELLOW, RESET, buffer2);
        -:  946:
       24:  947:	for (u64 i = 0; i < count; i++) {
       15:  948:		bool takes_value = args->subs[0].params[i].takes_value;
       15:  949:		if (!takes_value) {
        4:  950:			char *name = args->subs[0].params[i].name;
        4:  951:			char *short_name = args->subs[0].params[i].short_name;
        4:  952:			char *help = args->subs[0].params[i].help;
        4:  953:			u64 len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
        4:  954:			if (len > max_len)
    #####:  955:				len = max_len;
        -:  956:			u64 i;
      458:  957:			for (i = 0; i < max_len - len && i < 1024; i++)
      454:  958:				buffer[i] = ' ';
        4:  959:			buffer[i] = 0;
        4:  960:			fprintf(stderr, "    %s-%s%s, %s--%s%s %s%s\n", CYAN, short_name, RESET, YELLOW, name,
        -:  961:					RESET, buffer, help);
        -:  962:		}
        -:  963:	}
        -:  964:
        9:  965:	if (count) {
        7:  966:		fprintf(stderr, "\n%sCORE_OPTIONS%s:\n", DIMMED, RESET);
        -:  967:
       22:  968:		for (u64 i = 0; i < count; i++) {
       15:  969:			bool takes_value = args->subs[0].params[i].takes_value;
       15:  970:			if (takes_value) {
       11:  971:				char *name = args->subs[0].params[i].name;
       11:  972:				char *short_name = args->subs[0].params[i].short_name;
       11:  973:				char *help = args->subs[0].params[i].help;
       11:  974:				bool multi = args->subs[0].params[i].multiple;
       11:  975:				char *default_value = args->subs[0].params[i].default_value;
        -:  976:				u64 default_value_str_len;
       11:  977:				if (default_value == NULL) {
        4:  978:					default_value_str_len = 1;
        -:  979:				} else {
        7:  980:					default_value_str_len = strlen(default_value) + 100;
        -:  981:				}
       11:  982:				char default_value_str[default_value_str_len];
       11:  983:				if (default_value == NULL)
        4:  984:					strcpy(default_value_str, "");
        -:  985:				else
        7:  986:					snprintf(default_value_str, default_value_str_len, " (default value: '%s')",
        -:  987:							 default_value);
        -:  988:
       11:  989:				if (multi) {
        3:  990:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>, ...", short_name, name, name);
        3:  991:					if (len > max_len)
    #####:  992:						len = max_len;
        -:  993:					u64 i;
       21:  994:					for (i = 0; i < max_len - len && i < 1024; i++)
       18:  995:						buffer[i] = ' ';
        3:  996:					buffer[i] = 0;
        3:  997:					fprintf(stderr,
        -:  998:							"    %s-%s%s, %s--%s%s "
        -:  999:							"<%s>, "
        -: 1000:							"... %s%s%s\n",
        -: 1001:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -: 1002:							default_value_str);
        -: 1003:				} else {
        -: 1004:
        8: 1005:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
        8: 1006:					if (len > max_len)
    #####: 1007:						len = max_len;
        -: 1008:					u64 i;
       56: 1009:					for (i = 0; i < max_len - len && i < 1024; i++)
       48: 1010:						buffer[i] = ' ';
        8: 1011:					buffer[i] = 0;
        -: 1012:
        8: 1013:					fprintf(stderr,
        -: 1014:							"    %s-%s%s, %s--%s%s "
        -: 1015:							"<%s> "
        -: 1016:							"%s%s%s\n",
        -: 1017:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -: 1018:							default_value_str);
        -: 1019:				}
        -: 1020:			}
        -: 1021:		}
        -: 1022:	}
        -: 1023:
        9: 1024:	if (subs_count > 1 && sub_command == NULL) {
        3: 1025:		fprintf(stderr, "\n%sSUB_COMMANDS%s:\n", DIMMED, RESET);
        6: 1026:		for (u64 i = 1; i < subs_count; i++) {
        -: 1027:
        3: 1028:			char *name = args->subs[i].name;
        3: 1029:			char *help = args->subs[i].help;
        3: 1030:			char *arg_doc = args->subs[i].arg_doc;
        -: 1031:
        3: 1032:			u64 len = strlen(name) + strlen(arg_doc) + 4;
        3: 1033:			if (len > max_len)
    #####: 1034:				len = max_len;
        -: 1035:			char buffer[1025];
        -: 1036:			u64 j;
      130: 1037:			for (j = 0; j < (max_len - len) && j < 1024; j++)
      127: 1038:				buffer[j] = ' ';
        3: 1039:			buffer[j] = 0;
        -: 1040:
        3: 1041:			fprintf(stderr, "    %s%s%s %s%s%s\n", CYAN, name, RESET, arg_doc, buffer, help);
        -: 1042:		}
        -: 1043:	}
        9: 1044:	if (sub_command) {
        5: 1045:		u64 param_index = 0;
       10: 1046:		for (u64 i = 1; i < subs_count; i++) {
        5: 1047:			char *name = args->subs[i].name;
        5: 1048:			if (!strcmp(name, sub_command)) {
        5: 1049:				param_index = i;
        -: 1050:			}
        -: 1051:		}
        -: 1052:
        5: 1053:		if (param_index > 0) {
        5: 1054:			count = args->subs[param_index].param_count;
        5: 1055:			fprintf(stderr, "\n%sSUB_FLAGS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -: 1056:					RESET);
        -: 1057:
        9: 1058:			for (u64 i = 0; i < count; i++) {
        4: 1059:				char *name = args->subs[param_index].params[i].name;
        4: 1060:				char *short_name = args->subs[param_index].params[i].short_name;
        4: 1061:				bool takes_value = args->subs[param_index].params[i].takes_value;
        4: 1062:				char *help = args->subs[param_index].params[i].help;
        -: 1063:
        4: 1064:				if (!takes_value) {
        3: 1065:					u64 len = strlen(name) + 10;
        3: 1066:					if (len > max_len)
    #####: 1067:						len = max_len;
        -: 1068:					char buffer[1025];
        -: 1069:					u64 j;
       32: 1070:					for (j = 0; j < (max_len - len) && j < 1024; j++)
       29: 1071:						buffer[j] = ' ';
        3: 1072:					buffer[j] = 0;
        3: 1073:					fprintf(stderr,
        -: 1074:							"    %s-%s%s, "
        -: 1075:							"%s--%s%s%s %s\n",
        -: 1076:							CYAN, short_name, RESET, YELLOW, name, RESET, buffer, help);
        -: 1077:				}
        -: 1078:			}
        5: 1079:			fprintf(stderr, "\n%sSUB_OPTIONS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -: 1080:					RESET);
        9: 1081:			for (u64 i = 0; i < count; i++) {
        4: 1082:				char *name = args->subs[param_index].params[i].name;
        4: 1083:				char *short_name = args->subs[param_index].params[i].short_name;
        4: 1084:				bool takes_value = args->subs[param_index].params[i].takes_value;
        4: 1085:				char *help = args->subs[param_index].params[i].help;
        4: 1086:				bool multiple = args->subs[param_index].params[i].multiple;
        -: 1087:
        4: 1088:				char *default_value = args->subs[param_index].params[i].default_value;
        -: 1089:				u64 default_value_str_len;
        4: 1090:				if (default_value == NULL) {
        1: 1091:					default_value_str_len = 1;
        -: 1092:				} else {
        3: 1093:					default_value_str_len = strlen(default_value) + 100;
        -: 1094:				}
        4: 1095:				char default_value_str[default_value_str_len];
        4: 1096:				if (default_value == NULL)
        1: 1097:					strcpy(default_value_str, "");
        -: 1098:				else
        3: 1099:					snprintf(default_value_str, default_value_str_len, " (default value: %s)",
        -: 1100:							 default_value);
        -: 1101:
        4: 1102:				if (takes_value) {
        1: 1103:					if (multiple) {
    #####: 1104:						u64 len = 2 * strlen(name) + 19;
        -: 1105:						char buffer[1025];
        -: 1106:						u64 j;
    #####: 1107:						if (len > max_len)
    #####: 1108:							len = max_len;
    #####: 1109:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####: 1110:							buffer[j] = ' ';
    #####: 1111:						buffer[j] = ' ';
    #####: 1112:						buffer[j + 1] = 0;
    #####: 1113:						fprintf(stderr,
        -: 1114:								"    %s-%s%s, "
        -: 1115:								"%s--%s%s "
        -: 1116:								"<%s>, ...%s %s"
        -: 1117:								"%s\n",
        -: 1118:								CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -: 1119:								default_value_str);
        -: 1120:					} else {
        1: 1121:						u64 len = 2 * strlen(name) + 13;
        -: 1122:						char buffer[1025];
        -: 1123:						u64 j;
        1: 1124:						if (len > max_len)
        1: 1125:							len = max_len;
       1*: 1126:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####: 1127:							buffer[j] = ' ';
        1: 1128:						buffer[j] = 0;
        1: 1129:						fprintf(stderr,
        -: 1130:								"    %s-%s%s, "
        -: 1131:								"%s--%s%s "
        -: 1132:								"<%s>%s "
        -: 1133:								"%s%s\n",
        -: 1134:								CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -: 1135:								default_value_str);
        -: 1136:					}
        -: 1137:				}
        -: 1138:			}
        -: 1139:		}
        -: 1140:	}
        -: 1141:
        9: 1142:	EXIT_ERR_IF_NO_DEBUG(0);
        -: 1143:}
        -:    0:Source:chain_alloc.c
        -:    0:Graph:chain_alloc.gcno
        -:    0:Data:chain_alloc.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_alloc.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <errno.h>
        -:   19:#include <pthread.h>
        -:   20:#include <stdio.h>
        -:   21:#include <string.h>
        -:   22:
        -:   23:typedef struct ChainGuardEntry {
        -:   24:	struct ChainGuardEntry *next;
        -:   25:	struct ChainGuardEntry *prev;
        -:   26:	SlabAllocator *sa;
        -:   27:	bool sync;
        -:   28:	pthread_mutex_t lock;
        -:   29:	bool is_locked; // used in case of a panic on cleanup to determine if we're locked
        -:   30:} ChainGuardEntry;
        -:   31:
        -:   32:_Thread_local ChainGuardEntry *chain_guard_entry_root = NULL;
        -:   33:_Thread_local ChainGuardEntry *chain_guard_entry_cur = NULL;
        -:   34:SlabAllocator *global_sync_allocator = NULL;
        -:   35:
       14:   36:SlabAllocator *init_default_slab_allocator() {
       14:   37:	SlabAllocatorNc *sa = mymalloc(sizeof(SlabAllocator));
       14:   38:	if (sa == NULL)
    #####:   39:		panic("Could not initialize default slab allocator");
       14:   40:	SlabAllocatorConfig sac;
        -:   41:
        -:   42:	// default slab allocator no_malloc = false, zeroed = false, is_64_bit = false
       14:   43:	if (slab_allocator_config_build(&sac, false, false, false))
    #####:   44:		panic("Could not initialize config for default slab allocator");
        -:   45:
       14:   46:	u64 max_slabs = (INT32_MAX / 100) * 100;
     1806:   47:	for (i32 i = 0; i < 128; i++) {
     1792:   48:		SlabType st = {.slab_size = (i + 3) * 8,
        -:   49:					   .slabs_per_resize = 100,
        -:   50:					   .initial_chunks = 0,
        -:   51:					   .max_slabs = max_slabs};
     1792:   52:		if (slab_allocator_config_add_type(&sac, &st))
    #####:   53:			panic("Could not add slab type to default slab allocator");
        -:   54:	}
     1806:   55:	for (i32 i = 0; i < 128; i++) {
     1792:   56:		SlabType st = {.slab_size = (128 + 3) * 8 + (i + 1) * 1024,
        -:   57:					   .slabs_per_resize = 100,
        -:   58:					   .initial_chunks = 0,
        -:   59:					   .max_slabs = max_slabs};
     1792:   60:		if (slab_allocator_config_add_type(&sac, &st))
    #####:   61:			panic("Could not add config to default slab allocator");
        -:   62:	}
        -:   63:
       14:   64:	if (slab_allocator_build(sa, &sac))
    #####:   65:		panic("Could not initialize default slab allocator");
        -:   66:
       14:   67:	return sa;
        -:   68:}
        -:   69:
       13:   70:SlabAllocator *get_global_sync_allocator() {
       13:   71:	if (global_sync_allocator == NULL)
        3:   72:		global_sync_allocator = init_default_slab_allocator();
       13:   73:	return global_sync_allocator;
        -:   74:}
        -:   75:
       60:   76:u64 alloc_count_global_sync_allocator() {
       60:   77:	if (global_sync_allocator == NULL)
       57:   78:		return 0;
        3:   79:	return slab_allocator_cur_slabs_allocated(global_sync_allocator);
        -:   80:}
        -:   81:
       60:   82:u64 alloc_count_default_slab_allocator() {
       60:   83:	if (chain_guard_entry_root == NULL)
       50:   84:		return 0;
       10:   85:	return slab_allocator_cur_slabs_allocated(chain_guard_entry_root->sa);
        -:   86:}
        -:   87:
       60:   88:void cleanup_default_slab_allocator() {
       60:   89:	if (chain_guard_entry_root) {
       10:   90:		slab_allocator_cleanup(chain_guard_entry_root->sa);
       10:   91:		myfree(chain_guard_entry_root->sa);
       10:   92:		myfree(chain_guard_entry_root);
       10:   93:		chain_guard_entry_root = NULL;
        -:   94:	}
       60:   95:	if (global_sync_allocator) {
        3:   96:		slab_allocator_cleanup(global_sync_allocator);
        3:   97:		myfree(global_sync_allocator);
        3:   98:		global_sync_allocator = NULL;
        -:   99:	}
       60:  100:}
        -:  101:
       11:  102:void chain_guard_init_root() {
       11:  103:	chain_guard_entry_root = mymalloc(sizeof(ChainGuardEntry));
       11:  104:	chain_guard_entry_cur = chain_guard_entry_root;
       11:  105:	chain_guard_entry_root->next = NULL;
       11:  106:	chain_guard_entry_root->prev = NULL;
       11:  107:	chain_guard_entry_root->sync = false;
       11:  108:	chain_guard_entry_root->sa = init_default_slab_allocator();
       11:  109:}
        -:  110:
     2036:  111:void chain_guard_cleanup(ChainGuardNc *ptr) {
     2036:  112:	if (ptr->impl) {
       18:  113:		ChainGuardEntry *entry = ptr->impl;
       18:  114:		chain_guard_entry_cur = entry->prev;
       18:  115:		chain_guard_entry_cur->next = NULL;
       18:  116:		if (chain_guard_entry_cur->sync) {
    #####:  117:			pthread_mutex_destroy(&chain_guard_entry_cur->lock);
        -:  118:		}
       18:  119:		myfree(entry);
        -:  120:	}
     2036:  121:}
        -:  122:
       18:  123:ChainGuard set_slab_allocator(SlabAllocator *sa, bool sync) {
       18:  124:	if (chain_guard_entry_root == NULL) {
        5:  125:		chain_guard_init_root();
        -:  126:	}
       18:  127:	ChainGuardEntry *entry = mymalloc(sizeof(ChainGuardEntry));
       18:  128:	entry->sa = sa;
       18:  129:	entry->sync = sync;
       18:  130:	if (entry->sync) {
       13:  131:		pthread_mutex_init(&entry->lock, NULL);
        -:  132:	}
       18:  133:	entry->is_locked = false;
       18:  134:	entry->next = NULL;
       18:  135:	entry->prev = chain_guard_entry_cur;
       18:  136:	chain_guard_entry_cur->next = entry;
       18:  137:	chain_guard_entry_cur = entry;
       18:  138:	ChainGuardNc ret = {entry};
       18:  139:	return ret;
        -:  140:}
        -:  141:
     1047:  142:int chain_malloc(FatPtr *ptr, u64 size) {
     1047:  143:	if (ptr == NULL || size == 0) {
    #####:  144:		errno = EINVAL;
    #####:  145:		return -1;
        -:  146:	}
     1047:  147:	if (chain_guard_entry_root == NULL) {
        6:  148:		chain_guard_init_root();
        -:  149:	}
     1047:  150:	if (chain_guard_entry_cur->sync) {
        -:  151:	}
        -:  152:	int ret;
     1047:  153:	if (chain_guard_entry_cur->sync) {
        9:  154:		pthread_mutex_lock(&chain_guard_entry_cur->lock);
        9:  155:		chain_guard_entry_cur->is_locked = true;
        9:  156:		ret = slab_allocator_allocate(chain_guard_entry_cur->sa, size, ptr);
        9:  157:		chain_guard_entry_cur->is_locked = false;
        9:  158:		pthread_mutex_unlock(&chain_guard_entry_cur->lock);
        -:  159:	} else {
     1038:  160:		ret = slab_allocator_allocate(chain_guard_entry_cur->sa, size, ptr);
        -:  161:	}
     1047:  162:	return ret;
        -:  163:}
        1:  164:int chain_realloc(FatPtr *ptr, u64 size) {
        1:  165:	if (chain_guard_entry_root == NULL)
    #####:  166:		panic("Reallocating a FatPtr when it was never allocated!");
        -:  167:
        1:  168:	if (ptr == NULL || nil(*ptr) || size == 0) {
    #####:  169:		errno = EINVAL;
    #####:  170:		return -1;
        -:  171:	}
        -:  172:
        1:  173:	int ret = 0;
        -:  174:
        1:  175:	if (chain_guard_entry_cur->sync) {
    #####:  176:		pthread_mutex_lock(&chain_guard_entry_cur->lock);
    #####:  177:		chain_guard_entry_cur->is_locked = true;
        -:  178:	}
        -:  179:
        1:  180:	FatPtr tmp = null;
        1:  181:	chain_malloc(&tmp, size);
        1:  182:	if (nil(tmp)) {
    #####:  183:		ret = -1;
        -:  184:	} else {
        -:  185:
        1:  186:		u64 len = fat_ptr_len(ptr);
        1:  187:		u64 nlen = fat_ptr_len(&tmp);
        1:  188:		if (nlen < len) {
    #####:  189:			len = nlen;
        -:  190:		}
        -:  191:
        1:  192:		memcpy(fat_ptr_data(&tmp), fat_ptr_data(ptr), len);
        -:  193:
        1:  194:		chain_free(ptr);
        1:  195:		*ptr = tmp;
        -:  196:	}
        1:  197:	if (chain_guard_entry_cur->sync) {
    #####:  198:		chain_guard_entry_cur->is_locked = false;
    #####:  199:		pthread_mutex_unlock(&chain_guard_entry_cur->lock);
        -:  200:	}
        1:  201:	return 0;
        -:  202:}
     1033:  203:void chain_free(FatPtr *ptr) {
     1033:  204:	if (ptr == NULL) {
    #####:  205:		panic("attempt to free a NULL FatPtr");
        -:  206:	}
     1033:  207:	if (chain_guard_entry_root == NULL)
    #####:  208:		panic("Freeing a FatPtr when it was never allocated!");
        -:  209:
     1033:  210:	if (chain_guard_entry_cur->sync) {
        9:  211:		pthread_mutex_lock(&chain_guard_entry_cur->lock);
        9:  212:		chain_guard_entry_cur->is_locked = true;
        9:  213:		slab_allocator_free(chain_guard_entry_cur->sa, ptr);
        9:  214:		chain_guard_entry_cur->is_locked = false;
        9:  215:		pthread_mutex_unlock(&chain_guard_entry_cur->lock);
        -:  216:	} else {
     1024:  217:		slab_allocator_free(chain_guard_entry_cur->sa, ptr);
        -:  218:	}
     1033:  219:}
        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:#ifdef __linux__
        -:   19:#define getenv(x) secure_getenv(x)
        -:   20:#endif // __linux__
        -:   21:
      116:   22:char *get_dimmed() {
      116:   23:	if (getenv("NO_COLOR") != NULL) {
        1:   24:		return "";
        -:   25:	} else {
      115:   26:		return "\x1b[2m";
        -:   27:	}
        -:   28:}
        -:   29:
        2:   30:char *get_red() {
        2:   31:	if (getenv("NO_COLOR") != NULL) {
        1:   32:		return "";
        -:   33:	} else {
        1:   34:		return "\x1b[31m";
        -:   35:	}
        -:   36:}
        -:   37:
      110:   38:char *get_bright_red() {
      110:   39:	if (getenv("NO_COLOR") != NULL) {
        1:   40:		return "";
        -:   41:	} else {
      109:   42:		return "\x1b[91m";
        -:   43:	}
        -:   44:}
        -:   45:
       38:   46:char *get_green() {
       38:   47:	if (getenv("NO_COLOR") != NULL) {
        1:   48:		return "";
        -:   49:	} else {
       37:   50:		return "\x1b[32m";
        -:   51:	}
        -:   52:}
        -:   53:
       50:   54:char *get_yellow() {
       50:   55:	if (getenv("NO_COLOR") != NULL) {
        1:   56:		return "";
        -:   57:	} else {
       49:   58:		return "\x1b[33m";
        -:   59:	}
        -:   60:}
        -:   61:
     5788:   62:char *get_cyan() {
     5788:   63:	if (getenv("NO_COLOR") != NULL) {
        1:   64:		return "";
        -:   65:	} else {
     5787:   66:		return "\x1b[36m";
        -:   67:	}
        -:   68:}
        -:   69:
        2:   70:char *get_magenta() {
        2:   71:	if (getenv("NO_COLOR") != NULL) {
        1:   72:		return "";
        -:   73:	} else {
        1:   74:		return "\x1b[35m";
        -:   75:	}
        -:   76:}
        -:   77:
        2:   78:char *get_blue() {
        2:   79:	if (getenv("NO_COLOR") != NULL) {
        1:   80:		return "";
        -:   81:	} else {
        1:   82:		return "\x1b[34m";
        -:   83:	}
        -:   84:}
        -:   85:
     6094:   86:char *get_reset() {
     6094:   87:	if (getenv("NO_COLOR") != NULL) {
        1:   88:		return "";
        -:   89:	} else {
     6093:   90:		return "\x1b[0m";
        -:   91:	}
        -:   92:}
        -:    0:Source:misc.c
        -:    0:Graph:misc.gcno
        -:    0:Data:misc.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/macro_utils.h>
        -:   17:#include <base/misc.h>
        -:   18:#include <base/resources.h>
        -:   19:#include <base/types.h>
        -:   20:#include <ctype.h>
        -:   21:#include <dirent.h>
        -:   22:#include <errno.h>
        -:   23:#include <limits.h>
        -:   24:#include <stdarg.h>
        -:   25:#include <stdio.h>
        -:   26:#include <stdlib.h>
        -:   27:#include <string.h>
        -:   28:#include <sys/stat.h>
        -:   29:#include <unistd.h>
        -:   30:
        -:   31:bool __is_debug_misc_ferror = false;
        -:   32:bool __is_debug_misc_fwrite = false;
        -:   33:bool __is_debug_misc_stat = false;
        -:   34:bool __is_debug_misc_remove_dir = false;
        -:   35:bool __is_debug_misc_unlink = false;
        -:   36:bool __is_debug_misc_no_exit = false;
        -:   37:bool __is_debug_misc_preserve = false;
        -:   38:
      299:   39:char *myfgets(char *str, int n, MYFILE *stream) {
      299:   40:	return fgets(str, n, (FILE *)stream);
        -:   41:}
        -:   42:
       17:   43:u64 myfread(void *buffer, u64 size, u64 count, MYFILE *stream) {
       17:   44:	return fread(buffer, size, count, (FILE *)stream);
        -:   45:}
        -:   46:
       18:   47:u64 myfwrite(const void *buffer, u64 size, u64 count, MYFILE *stream) {
       18:   48:	return fwrite(buffer, size, count, (FILE *)stream);
        -:   49:}
        -:   50:
       11:   51:int myfeof(MYFILE *stream) {
       11:   52:	return feof((FILE *)stream);
        -:   53:}
        -:   54:
        6:   55:int myferror(MYFILE *stream) {
        6:   56:	return ferror((FILE *)stream);
        -:   57:}
        -:   58:
       11:   59:long myftell(MYFILE *stream) {
       11:   60:	return ftell((FILE *)stream);
        -:   61:}
        -:   62:
       15:   63:int myfseek(MYFILE *stream, long pos, int type) {
       15:   64:	return fseek((FILE *)stream, pos, type);
        -:   65:}
        -:   66:
       11:   67:u64 mystrlen(const char *s) {
       11:   68:	int ret = 0;
        -:   69:	loop {
      231:   70:		if (s[ret] == 0)
       11:   71:			return ret;
      220:   72:		ret++;
        -:   73:	}
        -:   74:}
        -:   75:
        6:   76:int myfprintf(MYFILE *fptr, const char *str, ...) {
        -:   77:	va_list args;
        6:   78:	va_start(args, str);
        6:   79:	int ret = vfprintf((FILE *)fptr, str, args);
        6:   80:	va_end(args);
        6:   81:	return ret;
        -:   82:}
        -:   83:
      137:   84:const char *rstrstr(const char *s1, const char *s2) {
      137:   85:	size_t s1len = strlen(s1);
      137:   86:	size_t s2len = strlen(s2);
        -:   87:	const char *s;
        -:   88:
      137:   89:	if (s2len > s1len)
        1:   90:		return NULL;
      753:   91:	for (s = s1 + s1len - s2len; s >= s1; --s)
      750:   92:		if (strncmp(s, s2, s2len) == 0)
      133:   93:			return s;
        3:   94:	return NULL;
        -:   95:}
        -:   96:
       12:   97:u64 read_all(void *buffer, u64 size, u64 count, MYFILE *stream) {
       12:   98:	size_t total_read = 0;
       12:   99:	size_t bytes_to_read = size * count;
        -:  100:	size_t bytes_read;
        -:  101:
       17:  102:	while (total_read < bytes_to_read || __is_debug_misc_ferror) {
       12:  103:		bytes_read = myfread((char *)buffer + total_read, 1, bytes_to_read - total_read, stream);
       12:  104:		if (bytes_read == 0 || __is_debug_misc_ferror) {
        -:  105:			// Check for EOF or error
        2:  106:			if (myferror(stream) || __is_debug_misc_ferror) {
        1:  107:				errno = EIO;
        1:  108:				break; // Error occurred
        -:  109:			}
        -:  110:		}
       11:  111:		total_read += bytes_read;
       11:  112:		if (myfeof(stream))
        6:  113:			break;
        -:  114:	}
        -:  115:
       12:  116:	return total_read;
        -:  117:}
        -:  118:
        6:  119:int copy_file(const Path *dst_path, const Path *src_path) {
        6:  120:	if (dst_path == NULL || src_path == NULL) {
        1:  121:		errno = EINVAL;
        1:  122:		return -1;
        -:  123:	}
        -:  124:	MYFILE *source_file, *dest_file;
        -:  125:	size_t bytes;
        -:  126:
        -:  127:	// Open the source file in binary read mode
        5:  128:	source_file = myfopen(src_path, "rb");
        5:  129:	if (source_file == NULL) {
        1:  130:		errno = EINVAL;
        1:  131:		return -1;
        -:  132:	}
        -:  133:
        -:  134:	// Determine the file size
        4:  135:	myfseek(source_file, 0, SEEK_END);
        4:  136:	long file_size = myftell(source_file);
        4:  137:	myfseek(source_file, 0, SEEK_SET);
        4:  138:	char buffer[file_size];
        -:  139:
        -:  140:	// Open the destination file in binary write mode
        4:  141:	dest_file = myfopen(dst_path, "wb");
        4:  142:	if (dest_file == NULL) {
        1:  143:		errno = ENOENT;
        1:  144:		myfclose(source_file);
        1:  145:		return -1;
        -:  146:	}
        -:  147:
        -:  148:	// Copy the file content
        5:  149:	while ((bytes = myfread(buffer, 1, file_size, source_file)) > 0) {
        3:  150:		if (myferror(source_file) || myfwrite(buffer, 1, bytes, dest_file) != bytes ||
        -:  151:			__is_debug_misc_fwrite) {
        1:  152:			errno = EIO;
        1:  153:			myfclose(source_file);
        1:  154:			myfclose(dest_file);
        1:  155:			return -1;
        -:  156:		}
        -:  157:	}
        -:  158:
        -:  159:	// Close both files
        2:  160:	myfclose(source_file);
        2:  161:	myfclose(dest_file);
        -:  162:
        2:  163:	return 0;
        -:  164:}
        -:  165:
        -:  166:// Function to recursively remove a directory and its contents
      155:  167:int remove_directory(const Path *p, bool preserve_dir) {
      155:  168:	const char *path = path_to_string(p);
        -:  169:	struct dirent *entry;
      155:  170:	DIR *dir = opendir(path);
        -:  171:
      155:  172:	if (dir == NULL) {
       63:  173:		return -1;
        -:  174:	}
        -:  175:
      319:  176:	while ((entry = readdir(dir)) != NULL) {
        -:  177:		char full_path[PATH_MAX];
        -:  178:
        -:  179:		// Skip the special entries "." and ".."
      232:  180:		if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
      183:  181:			continue;
        -:  182:		}
        -:  183:
        -:  184:		// Construct the full path to the file/directory
       49:  185:		snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        -:  186:
        -:  187:		struct stat statbuf;
       49:  188:		if (stat(full_path, &statbuf) == -1 || __is_debug_misc_stat) {
        1:  189:			errno = EIO;
        1:  190:			closedir(dir);
        5:  191:			return -1;
        -:  192:		}
        -:  193:
       48:  194:		if (S_ISDIR(statbuf.st_mode)) {
        -:  195:			// It's a directory, recurse into it
       24:  196:			Path full_path_p;
       24:  197:			path_for(&full_path_p, full_path);
       24:  198:			if (remove_directory(&full_path_p, false) == -1 || __is_debug_misc_remove_dir) {
        3:  199:				closedir(dir);
        3:  200:				return -1;
        -:  201:			}
        -:  202:		} else {
        -:  203:			// It's a file, unlink (delete) it
       24:  204:			if (unlink(full_path) == -1 || __is_debug_misc_unlink) {
        1:  205:				errno = EIO;
        1:  206:				closedir(dir);
        1:  207:				return -1;
        -:  208:			}
        -:  209:		}
        -:  210:	}
        -:  211:
       87:  212:	closedir(dir);
        -:  213:
        -:  214:	// Now the directory is empty, so we can remove it
       87:  215:	if (!preserve_dir) {
       86:  216:		if (rmdir(path) == -1 || __is_debug_misc_preserve) {
        1:  217:			errno = EIO;
        1:  218:			return -1;
        -:  219:		}
        -:  220:	}
        -:  221:
       86:  222:	return 0;
        -:  223:}
        -:  224:
        5:  225:void exit_error(char *format, ...) {
        -:  226:	va_list va_args;
        5:  227:	va_start(va_args, format);
        5:  228:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
        5:  229:	vfprintf(stderr, format, va_args);
        5:  230:	fprintf(stderr, "\n");
        5:  231:	va_end(va_args);
       5*:  232:	EXIT_ERR_IF_NO_DEBUG(-1);
        5:  233:}
        -:  234:
       23:  235:void print_error(char *format, ...) {
        -:  236:	va_list va_args;
       23:  237:	va_start(va_args, format);
       23:  238:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
       23:  239:	vfprintf(stderr, format, va_args);
       23:  240:	fprintf(stderr, "\n");
       23:  241:	va_end(va_args);
       23:  242:}
        -:  243:
        -:  244:// Helper function to trim leading and trailing whitespace
        7:  245:char *trim_whitespace(char *str) {
        -:  246:	// Trim leading whitespace
       15:  247:	while (isspace((unsigned char)*str))
        8:  248:		str++;
        -:  249:	// Trim trailing whitespace
        7:  250:	char *end = str + strlen(str) - 1;
       15:  251:	while (end > str && isspace((unsigned char)*end))
        8:  252:		end--;
        7:  253:	*(end + 1) = '\0'; // Null-terminate the trimmed string
        7:  254:	return str;		   // Return the trimmed string
        -:  255:}
        -:    0:Source:panic.c
        -:    0:Graph:panic.gcno
        -:    0:Data:panic.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/panic.h>
        -:   16:#include <setjmp.h>
        -:   17:#include <signal.h>
        -:   18:#include <stdarg.h>
        -:   19:#include <stdio.h>
        -:   20:#include <stdlib.h>
        -:   21:#include <string.h>
        -:   22:
        -:   23:void exit(int value);
        -:   24:
        -:   25:#define MAX_PANIC_MSG 1024
        -:   26:
        -:   27:_Thread_local jmp_buf return_jmp;
        -:   28:_Thread_local bool jmp_return_set = false;
        -:   29:_Thread_local char panic_buf[MAX_PANIC_MSG];
        -:   30:
    #####:   31:void panic(const char *fmt, ...) {
        -:   32:	va_list args;
        -:   33:
    #####:   34:	fprintf(stderr, "thread panicked: ");
    #####:   35:	va_start(args, fmt);
    #####:   36:	vfprintf(stderr, fmt, args);
    #####:   37:	vsnprintf(panic_buf, MAX_PANIC_MSG, fmt, args);
    #####:   38:	va_end(args);
    #####:   39:	fprintf(stderr, "\n");
        -:   40:
        -:   41:	// If jump return has not been set, we resort to an exit with an error
        -:   42:	// status.
    #####:   43:	if (!jmp_return_set)
    #####:   44:		exit(-1);
    #####:   45:	longjmp(return_jmp, THREAD_PANIC);
        -:   46:}
        -:   47:
    #####:   48:void signal_handler(int signal) {
        -:   49:	// Handle the signal and call the _on_panic function
    #####:   50:	panic("Caught signal: %d", signal);
    #####:   51:}
        -:   52:
    #####:   53:void set_on_panic(panic_handler_t on_panic) {
        -:   54:	struct sigaction sa;
    #####:   55:	memset(&sa, 0, sizeof(sa));
    #####:   56:	sa.sa_handler = signal_handler;
        -:   57:	// Catching only error signals
    #####:   58:	sigaction(SIGSEGV, &sa, NULL); // Segmentation fault
    #####:   59:	sigaction(SIGABRT, &sa, NULL); // Abort signal
    #####:   60:	sigaction(SIGTRAP, &sa, NULL); // Signal trap
    #####:   61:	sigaction(SIGILL, &sa, NULL);  // Illegal instruction
    #####:   62:	sigaction(SIGFPE, &sa, NULL);  // Arithmetic error
    #####:   63:	sigaction(SIGBUS, &sa, NULL);  // Bus error
        -:   64:
    #####:   65:	jmp_return_set = true;
    #####:   66:	int value = setjmp(return_jmp);
    #####:   67:	if (value)
    #####:   68:		on_panic(panic_buf);
    #####:   69:}
        -:    0:Source:path.c
        -:    0:Graph:path.gcno
        -:    0:Data:path.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <errno.h>
        -:   19:#include <limits.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:#include <sys/stat.h>
        -:   24:#include <unistd.h>
        -:   25:
        -:   26:bool __is_debug_path_homedir_null = false;
        -:   27:
      252:   28:void path_cleanup(PathImpl *ptr) {
      252:   29:	if (ptr->ptr) {
      246:   30:		myfree(ptr->ptr);
      246:   31:		ptr->ptr = NULL;
        -:   32:	}
      252:   33:}
        -:   34:
      257:   35:int path_for(Path *p, const char *path) {
      257:   36:	if (p == NULL) {
        1:   37:		errno = EINVAL;
        1:   38:		return -1;
        -:   39:	}
      256:   40:	if (path == NULL) {
        1:   41:		errno = EINVAL;
        1:   42:		p->ptr = NULL;
        1:   43:		return -1;
        -:   44:	}
      255:   45:	int len = strlen(path);
      255:   46:	if (len == 0) {
        1:   47:		errno = EINVAL;
        1:   48:		p->ptr = NULL;
        1:   49:		return -1;
        -:   50:	}
      254:   51:	p->ptr = mymalloc(len + 1);
      254:   52:	if (!p->ptr)
        2:   53:		return -1;
      252:   54:	p->len = len;
      252:   55:	strcpy(p->ptr, path);
      252:   56:	return 0;
        -:   57:}
        -:   58:
       33:   59:int path_replace_home(Path *p) {
       33:   60:	const char *home_dir = getenv("HOME");
       33:   61:	if (home_dir == NULL || __is_debug_path_homedir_null) {
        1:   62:		errno = EINVAL;
        1:   63:		return -1;
        -:   64:	}
       32:   65:	if (((char *)(p->ptr))[0] == '~') {
        4:   66:		int nlen = strlen(home_dir) + strlen(PATH_SEPARATOR) + strlen(p->ptr);
        4:   67:		if (nlen >= PATH_MAX) {
        1:   68:			errno = E2BIG;
        2:   69:			return -1;
        -:   70:		}
        3:   71:		if (nlen >= p->len) {
        3:   72:			void *nptr = myrealloc(p->ptr, nlen + 1);
        3:   73:			if (nptr == NULL)
        1:   74:				return -1;
        2:   75:			p->ptr = nptr;
        2:   76:			p->len = nlen;
        -:   77:		}
        -:   78:		char buf[PATH_MAX + 1];
        2:   79:		if (strlen(p->ptr) > 1 && ((char *)(p->ptr))[1] == PATH_SEPARATOR_CHAR)
        1:   80:			snprintf(buf, PATH_MAX, "%s%s", home_dir, (char *)(p->ptr + 1));
        -:   81:		else
        1:   82:			snprintf(buf, PATH_MAX, "%s%s%s", home_dir, PATH_SEPARATOR, (char *)(p->ptr + 1));
        2:   83:		strcpy(p->ptr, buf);
        -:   84:	}
       30:   85:	return 0;
        -:   86:}
        -:   87:
        8:   88:u64 path_file_size(Path *p) {
        8:   89:	MYFILE *fp = myfopen(p, "r");
        8:   90:	if (!fp) {
        1:   91:		errno = EIO;
        1:   92:		return 0;
        -:   93:	}
        7:   94:	myfseek(fp, 0L, SEEK_END);
        7:   95:	u64 ret = myftell(fp);
        7:   96:	myfclose(fp);
        7:   97:	return ret;
        -:   98:}
        -:   99:
       33:  100:int path_canonicalize(Path *p) {
        -:  101:	char buf[PATH_MAX];
        -:  102:	int nlen;
       33:  103:	if (path_replace_home(p) || realpath(p->ptr, buf) == NULL || (nlen = strlen(buf)) == 0) {
       19:  104:		errno = EINVAL;
       19:  105:		return -1;
        -:  106:	}
       14:  107:	errno = 0;
       14:  108:	if (nlen >= p->len) {
       12:  109:		void *nptr = myrealloc(p->ptr, nlen + 1);
       12:  110:		if (nptr == NULL)
        1:  111:			return -1;
       11:  112:		p->ptr = nptr;
       11:  113:		p->len = nlen;
        -:  114:	}
       13:  115:	strcpy(p->ptr, buf);
       13:  116:	return 0;
        -:  117:}
      172:  118:int path_push(Path *p, const char *next) {
      172:  119:	if (p == NULL) {
        1:  120:		errno = EINVAL;
        1:  121:		return -1;
        -:  122:	}
      171:  123:	if (next == NULL) {
        1:  124:		errno = EINVAL;
        1:  125:		return -1;
        -:  126:	}
      170:  127:	int slen = strlen(p->ptr);
      170:  128:	if (slen <= 0 || strlen(next) == 0) {
        1:  129:		errno = EFAULT;
        1:  130:		return -1;
        -:  131:	}
      169:  132:	bool need_sep = false;
      169:  133:	if (((char *)p->ptr)[slen - 1] != PATH_SEPARATOR_CHAR) {
      169:  134:		need_sep = true;
        -:  135:	}
        -:  136:
      169:  137:	int nlen = slen + strlen(next);
      169:  138:	if (need_sep)
      169:  139:		nlen += strlen(PATH_SEPARATOR);
        -:  140:
      169:  141:	if (nlen >= p->len) {
      165:  142:		void *nptr = myrealloc(p->ptr, nlen + 1);
      165:  143:		if (nptr == NULL)
        1:  144:			return -1;
      164:  145:		p->ptr = nptr;
      164:  146:		p->len = nlen;
        -:  147:	}
        -:  148:
      168:  149:	if (need_sep)
      168:  150:		strcat(p->ptr, PATH_SEPARATOR);
      168:  151:	strcat(p->ptr, next);
      168:  152:	return 0;
        -:  153:}
       48:  154:int path_pop(Path *p) {
       48:  155:	const char *res = rstrstr(p->ptr, PATH_SEPARATOR);
       48:  156:	if (res) {
       47:  157:		int index = res - (char *)p->ptr;
       47:  158:		((char *)(p->ptr))[index] = 0;
        -:  159:	} else {
        1:  160:		((char *)(p->ptr))[0] = '.';
        1:  161:		((char *)(p->ptr))[1] = 0;
        -:  162:	}
       48:  163:	return 0;
        -:  164:}
        -:  165:
     2204:  166:char *path_to_string(const Path *p) {
     2204:  167:	return p->ptr;
        -:  168:}
        -:  169:
       88:  170:const char *path_file_name(const Path *p) {
       88:  171:	const char *ret = rstrstr(p->ptr, PATH_SEPARATOR);
       88:  172:	if (ret != NULL && strlen(ret) > 0)
       86:  173:		return ret + 1;
        -:  174:
        2:  175:	return ret;
        -:  176:}
        -:  177:
       30:  178:bool path_exists(const Path *p) {
       30:  179:	if (p->ptr == NULL || p->len == 0) {
        1:  180:		errno = EINVAL;
        1:  181:		return false;
        -:  182:	}
       29:  183:	return access(p->ptr, F_OK) == 0;
        -:  184:}
       11:  185:bool path_is_dir(const Path *p) {
       11:  186:	if (p->ptr == NULL || p->len == 0) {
        1:  187:		errno = EINVAL;
        1:  188:		return false;
        -:  189:	}
        -:  190:	struct stat s;
       10:  191:	if (stat(p->ptr, &s) == 0) {
        7:  192:		return s.st_mode & S_IFDIR;
        -:  193:	}
        3:  194:	return false;
        -:  195:}
        -:  196:
      144:  197:bool path_mkdir(Path *p, u64 mode, bool parent) {
      144:  198:	if (p->ptr == NULL || p->len == 0) {
        1:  199:		errno = EINVAL;
        1:  200:		return false;
        -:  201:	}
        -:  202:
        -:  203:	struct stat s;
        -:  204:
        -:  205:	// Check if the path exists
      143:  206:	if (stat(p->ptr, &s) == 0) {
        -:  207:		// If the path exists and it's a directory, return success
        8:  208:		if (s.st_mode & S_IFDIR) {
        7:  209:			return true;
        -:  210:		} else {
        -:  211:			// Path exists but it's not a directory
        1:  212:			errno = ENOTDIR;
        1:  213:			return false;
        -:  214:		}
        -:  215:	}
        -:  216:
        -:  217:	// If parent is false, attempt to create only the target directory
      135:  218:	if (!parent) {
      117:  219:		if (mkdir(p->ptr, mode) != 0) {
       28:  220:			return false;
        -:  221:		}
       89:  222:		return true;
        -:  223:	}
        -:  224:
        -:  225:	// Create the directory structure (parent is true)
       18:  226:	Path temp_path;
       18:  227:	if (path_copy(&temp_path, p) != 0) {
        1:  228:		return false;
        -:  229:	}
        -:  230:
       17:  231:	int i = 0;
        -:  232:	char path_bufs[20][PATH_MAX];
       43:  233:	while (i < 20 && path_file_name(&temp_path) != NULL) {
       41:  234:		if (path_mkdir(&temp_path, mode, false)) {
       15:  235:			bool ret = true;
       21:  236:			for (int j = i - 1; ret && j >= 0; j--) {
        6:  237:				path_push(&temp_path, path_bufs[j]);
        6:  238:				ret = path_mkdir(&temp_path, mode, false);
        -:  239:			}
       15:  240:			return true;
        -:  241:		}
       26:  242:		const char *dir_part = path_file_name(&temp_path);
       26:  243:		path_pop(&temp_path);
       26:  244:		strcpy(path_bufs[i], dir_part);
       26:  245:		i++;
        -:  246:	}
        2:  247:	return false;
        -:  248:}
        -:  249:
       54:  250:int path_copy(Path *dst, const Path *src) {
       54:  251:	return path_for(dst, path_to_string(src));
        -:  252:}
        -:  253:
        2:  254:int path_file_stem(const Path *p, char *buf, u64 limit) {
        -:  255:	// Copy the file name into the buffer, ensuring proper null termination
        2:  256:	strncpy(buf, path_file_name(p), limit - 1);
        2:  257:	buf[limit - 1] = '\0'; // Manually ensure null-termination
        -:  258:
        2:  259:	u64 buflen = strlen(buf); // Compute length once
       12:  260:	for (u64 i = buflen - 1; i > 0; i--) {
       11:  261:		if (buf[i] == '.') {
        1:  262:			buf[i] = '\0'; // Null-terminate at the dot
        1:  263:			break;
        -:  264:		}
        -:  265:	}
        2:  266:	return 0;
        -:  267:}
        -:    0:Source:rand.c
        -:    0:Graph:rand.gcno
        -:    0:Data:rand.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <base/types.h>
        -:   17:#include <sys/random.h>
        -:   18:
    #####:   19:int rand_i8(i8 *v) {
    #####:   20:	return getentropy(v, sizeof(i8));
        -:   21:}
        -:   22:
    #####:   23:int rand_u8(u8 *v) {
    #####:   24:	return getentropy(v, sizeof(u8));
        -:   25:}
        -:   26:
    #####:   27:int rand_i16(i16 *v) {
    #####:   28:	return getentropy(v, sizeof(i16));
        -:   29:}
        -:   30:
    #####:   31:int rand_u16(u16 *v) {
    #####:   32:	return getentropy(v, sizeof(u16));
        -:   33:}
        -:   34:
    #####:   35:int rand_i32(i32 *v) {
    #####:   36:	return getentropy(v, sizeof(i32));
        -:   37:}
        -:   38:
    #####:   39:int rand_u32(u32 *v) {
    #####:   40:	return getentropy(v, sizeof(u32));
        -:   41:}
        -:   42:
    #####:   43:int rand_i64(i64 *v) {
    #####:   44:	return getentropy(v, sizeof(i64));
        -:   45:}
        -:   46:
     1000:   47:int rand_u64(u64 *v) {
     1000:   48:	return getentropy(v, sizeof(u64));
        -:   49:}
        -:   50:
    #####:   51:int rand_i128(i128 *v) {
    #####:   52:	return getentropy(v, sizeof(i128));
        -:   53:}
        -:   54:
    #####:   55:int rand_u128(u128 *v) {
    #####:   56:	return getentropy(v, sizeof(u128));
        -:   57:}
        -:   58:
    #####:   59:int rand_bytes(void *buf, u64 length) {
    #####:   60:	return getentropy(buf, length);
        -:   61:}
        -:    0:Source:resources.c
        -:    0:Graph:resources.gcno
        -:    0:Data:resources.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <base/types.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:
        -:   20:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   21:#ifdef TEST
        -:   22:bool __is_debug_malloc = false;
        -:   23:bool __is_debug_realloc = false;
        -:   24:u64 __is_debug_malloc_counter_ = UINT64_MAX;
        -:   25:u64 __is_debug_realloc_counter_ = UINT64_MAX;
        -:   26:#endif // TEST
        -:   27:
     4972:   28:void *mymalloc(u64 size) {
        -:   29:#ifdef TEST
     4972:   30:	if (__is_debug_malloc || __is_debug_malloc_counter_ == 0) {
       21:   31:		__is_debug_malloc_counter_ = UINT64_MAX;
       21:   32:		return NULL;
        -:   33:	}
     4951:   34:	__is_debug_malloc_counter_--;
        -:   35:#endif // TEST
        -:   36:	void *ret;
     4951:   37:	ret = malloc(size);
        -:   38:
     4951:   39:	if (ret) {
     4951:   40:		THREAD_LOCAL_RESOURCE_STATS.malloc_sum += 1;
        -:   41:	}
     4951:   42:	return ret;
        -:   43:}
     3830:   44:void *myrealloc(void *ptr, u64 size) {
        -:   45:#ifdef TEST
     3830:   46:	if (__is_debug_realloc || __is_debug_realloc_counter_ == 0) {
        7:   47:		__is_debug_realloc_counter_ = UINT64_MAX;
        7:   48:		return NULL;
        -:   49:	}
     3823:   50:	__is_debug_realloc_counter_--;
        -:   51:#endif // TEST
        -:   52:	void *ret;
     3823:   53:	ret = realloc(ptr, size);
        -:   54:
     3823:   55:	if (ret) {
     3823:   56:		THREAD_LOCAL_RESOURCE_STATS.realloc_sum += 1;
        -:   57:	}
     3823:   58:	return ret;
        -:   59:}
     4891:   60:void myfree(void *ptr) {
     4891:   61:	THREAD_LOCAL_RESOURCE_STATS.free_sum += 1;
     4891:   62:	free(ptr);
     4891:   63:}
       58:   64:MYFILE *myfopen(const Path *path, const char *mode) {
       58:   65:	const char *path_str = path_to_string(path);
       58:   66:	FILE *ret = fopen(path_str, mode);
       58:   67:	if (ret) {
       53:   68:		THREAD_LOCAL_RESOURCE_STATS.fopen_sum += 1;
        -:   69:	}
       58:   70:	return (MYFILE *)ret;
        -:   71:}
        -:   72:
    #####:   73:void *mymalloc_no_stat(u64 size) {
    #####:   74:	return malloc(size);
        -:   75:}
        -:   76:
       53:   77:void myfclose(MYFILE *ptr) {
       53:   78:	THREAD_LOCAL_RESOURCE_STATS.fclose_sum += 1;
       53:   79:	fclose((FILE *)ptr);
       53:   80:}
      125:   81:u64 mymalloc_sum() {
      125:   82:	return THREAD_LOCAL_RESOURCE_STATS.malloc_sum;
        -:   83:}
        2:   84:u64 myrealloc_sum() {
        2:   85:	return THREAD_LOCAL_RESOURCE_STATS.realloc_sum;
        -:   86:}
      125:   87:u64 myfree_sum() {
      125:   88:	return THREAD_LOCAL_RESOURCE_STATS.free_sum;
        -:   89:}
      186:   90:u64 myfopen_sum() {
      186:   91:	return THREAD_LOCAL_RESOURCE_STATS.fopen_sum;
        -:   92:}
      186:   93:u64 myfclose_sum() {
      186:   94:	return THREAD_LOCAL_RESOURCE_STATS.fclose_sum;
        -:   95:}
        -:    0:Source:sha3.c
        -:    0:Graph:sha3.gcno
        -:    0:Data:sha3.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:/* -------------------------------------------------------------------------
        -:   16: * Works when compiled for either 32-bit or 64-bit targets, optimized for
        -:   17: * 64 bit.
        -:   18: *
        -:   19: * Canonical implementation of Init/Update/Finalize for SHA-3 byte input.
        -:   20: *
        -:   21: * SHA3-256, SHA3-384, SHA-512 are implemented. SHA-224 can easily be added.
        -:   22: *
        -:   23: * Based on code from http://keccak.noekeon.org/ .
        -:   24: *
        -:   25: * I place the code that I wrote into public domain, free to use.
        -:   26: *
        -:   27: * I would appreciate if you give credits to this work if you used it to
        -:   28: * write or test * your code.
        -:   29: *
        -:   30: * Aug 2015. Andrey Jivsov. crypto@brainhub.org
        -:   31: * ---------------------------------------------------------------------- */
        -:   32:
        -:   33:#include <stdint.h>
        -:   34:#include <stdio.h>
        -:   35:#include <string.h>
        -:   36:
        -:   37:#include <base/sha3.h>
        -:   38:
        -:   39:#define SHA3_ASSERT(x)
        -:   40:#define SHA3_TRACE(format, ...)
        -:   41:#define SHA3_TRACE_BUF(format, buf, l)
        -:   42:
        -:   43:/*
        -:   44: * This flag is used to configure "pure" Keccak, as opposed to NIST SHA3.
        -:   45: */
        -:   46:#define SHA3_USE_KECCAK_FLAG 0x80000000
        -:   47:#define SHA3_CW(x) ((x) & (~SHA3_USE_KECCAK_FLAG))
        -:   48:
        -:   49:#if defined(_MSC_VER)
        -:   50:#define SHA3_CONST(x) x
        -:   51:#else
        -:   52:#define SHA3_CONST(x) x##L
        -:   53:#endif
        -:   54:
        -:   55:#ifndef SHA3_ROTL64
        -:   56:#define SHA3_ROTL64(x, y) (((x) << (y)) | ((x) >> ((sizeof(u64) * 8) - (y))))
        -:   57:#endif
        -:   58:
        -:   59:static const u64 keccakf_rndc[24] = {
        -:   60:	SHA3_CONST(0x0000000000000001UL), SHA3_CONST(0x0000000000008082UL),
        -:   61:	SHA3_CONST(0x800000000000808aUL), SHA3_CONST(0x8000000080008000UL),
        -:   62:	SHA3_CONST(0x000000000000808bUL), SHA3_CONST(0x0000000080000001UL),
        -:   63:	SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008009UL),
        -:   64:	SHA3_CONST(0x000000000000008aUL), SHA3_CONST(0x0000000000000088UL),
        -:   65:	SHA3_CONST(0x0000000080008009UL), SHA3_CONST(0x000000008000000aUL),
        -:   66:	SHA3_CONST(0x000000008000808bUL), SHA3_CONST(0x800000000000008bUL),
        -:   67:	SHA3_CONST(0x8000000000008089UL), SHA3_CONST(0x8000000000008003UL),
        -:   68:	SHA3_CONST(0x8000000000008002UL), SHA3_CONST(0x8000000000000080UL),
        -:   69:	SHA3_CONST(0x000000000000800aUL), SHA3_CONST(0x800000008000000aUL),
        -:   70:	SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008080UL),
        -:   71:	SHA3_CONST(0x0000000080000001UL), SHA3_CONST(0x8000000080008008UL)};
        -:   72:
        -:   73:static const unsigned keccakf_rotc[24] = {1,  3,  6,  10, 15, 21, 28, 36, 45, 55, 2,  14,
        -:   74:										  27, 41, 56, 8,  25, 43, 62, 18, 39, 61, 20, 44};
        -:   75:
        -:   76:static const unsigned keccakf_piln[24] = {10, 7,  11, 17, 18, 3, 5,	 16, 8,	 21, 24, 4,
        -:   77:										  15, 23, 19, 13, 12, 2, 20, 14, 22, 9,	 6,	 1};
        -:   78:
        -:   79:/* generally called after SHA3_KECCAK_SPONGE_WORDS-ctx->capacityWords words
        -:   80: * are XORed into the state s
        -:   81: */
       11:   82:static void keccakf(u64 s[25]) {
        -:   83:	int i, j, round;
        -:   84:	u64 t, bc[5];
        -:   85:#define KECCAK_ROUNDS 24
        -:   86:
      275:   87:	for (round = 0; round < KECCAK_ROUNDS; round++) {
        -:   88:
        -:   89:		/* Theta */
     1584:   90:		for (i = 0; i < 5; i++)
     1320:   91:			bc[i] = s[i] ^ s[i + 5] ^ s[i + 10] ^ s[i + 15] ^ s[i + 20];
        -:   92:
     1584:   93:		for (i = 0; i < 5; i++) {
     1320:   94:			t = bc[(i + 4) % 5] ^ SHA3_ROTL64(bc[(i + 1) % 5], 1);
     7920:   95:			for (j = 0; j < 25; j += 5)
     6600:   96:				s[j + i] ^= t;
        -:   97:		}
        -:   98:
        -:   99:		/* Rho Pi */
      264:  100:		t = s[1];
     6600:  101:		for (i = 0; i < 24; i++) {
     6336:  102:			j = keccakf_piln[i];
     6336:  103:			bc[0] = s[j];
     6336:  104:			s[j] = SHA3_ROTL64(t, keccakf_rotc[i]);
     6336:  105:			t = bc[0];
        -:  106:		}
        -:  107:
        -:  108:		/* Chi */
     1584:  109:		for (j = 0; j < 25; j += 5) {
     7920:  110:			for (i = 0; i < 5; i++)
     6600:  111:				bc[i] = s[j + i];
     7920:  112:			for (i = 0; i < 5; i++)
     6600:  113:				s[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
        -:  114:		}
        -:  115:
        -:  116:		/* Iota */
      264:  117:		s[0] ^= keccakf_rndc[round];
        -:  118:	}
       11:  119:}
        -:  120:
        -:  121:/* *************************** Public Inteface ************************ */
        -:  122:
        -:  123:/* For Init or Reset call these: */
       11:  124:sha3_return_t sha3_Init(void *priv, unsigned bitSize) {
       11:  125:	sha3_context *ctx = (sha3_context *)priv;
      11*:  126:	if (bitSize != 256 && bitSize != 384 && bitSize != 512)
    #####:  127:		return SHA3_RETURN_BAD_PARAMS;
       11:  128:	memset(ctx, 0, sizeof(*ctx));
       11:  129:	ctx->capacityWords = 2 * bitSize / (8 * sizeof(u64));
       11:  130:	return SHA3_RETURN_OK;
        -:  131:}
        -:  132:
       11:  133:void sha3_Init256(void *priv) {
       11:  134:	sha3_Init(priv, 256);
       11:  135:}
        -:  136:
    #####:  137:void sha3_Init384(void *priv) {
    #####:  138:	sha3_Init(priv, 384);
    #####:  139:}
        -:  140:
    #####:  141:void sha3_Init512(void *priv) {
    #####:  142:	sha3_Init(priv, 512);
    #####:  143:}
        -:  144:
    #####:  145:enum SHA3_FLAGS sha3_SetFlags(void *priv, enum SHA3_FLAGS flags) {
    #####:  146:	sha3_context *ctx = (sha3_context *)priv;
    #####:  147:	flags &= SHA3_FLAGS_KECCAK;
    #####:  148:	ctx->capacityWords |= (flags == SHA3_FLAGS_KECCAK ? SHA3_USE_KECCAK_FLAG : 0);
    #####:  149:	return flags;
        -:  150:}
        -:  151:
       11:  152:void sha3_Update(void *priv, void const *bufIn, u64 len) {
       11:  153:	sha3_context *ctx = (sha3_context *)priv;
        -:  154:
        -:  155:	/* 0...7 -- how much is needed to have a word */
       11:  156:	unsigned old_tail = (8 - ctx->byteIndex) & 7;
        -:  157:
        -:  158:	u64 words;
        -:  159:	unsigned tail;
        -:  160:	u64 i;
        -:  161:
       11:  162:	const u8 *buf = bufIn;
        -:  163:
        -:  164:	SHA3_TRACE_BUF("called to update with:", buf, len);
        -:  165:
        -:  166:	SHA3_ASSERT(ctx->byteIndex < 8);
        -:  167:	SHA3_ASSERT(ctx->wordIndex < sizeof(ctx->u.s) / sizeof(ctx->u.s[0]));
        -:  168:
       11:  169:	if (len < old_tail) { /* have no complete word or haven't started
        -:  170:						   * the word yet */
        -:  171:		SHA3_TRACE("because %d<%d, store it and return", (unsigned)len, (unsigned)old_tail);
        -:  172:		/* endian-independent code follows: */
    #####:  173:		while (len--)
    #####:  174:			ctx->saved |= (u64)(*(buf++)) << ((ctx->byteIndex++) * 8);
        -:  175:		SHA3_ASSERT(ctx->byteIndex < 8);
    #####:  176:		return;
        -:  177:	}
        -:  178:
       11:  179:	if (old_tail) { /* will have one word to process */
        -:  180:		SHA3_TRACE("completing one word with %d bytes", (unsigned)old_tail);
        -:  181:		/* endian-independent code follows: */
    #####:  182:		len -= old_tail;
    #####:  183:		while (old_tail--)
    #####:  184:			ctx->saved |= (u64)(*(buf++)) << ((ctx->byteIndex++) * 8);
        -:  185:
        -:  186:		/* now ready to add saved to the sponge */
    #####:  187:		ctx->u.s[ctx->wordIndex] ^= ctx->saved;
        -:  188:		SHA3_ASSERT(ctx->byteIndex == 8);
    #####:  189:		ctx->byteIndex = 0;
    #####:  190:		ctx->saved = 0;
    #####:  191:		if (++ctx->wordIndex == (SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords))) {
    #####:  192:			keccakf(ctx->u.s);
    #####:  193:			ctx->wordIndex = 0;
        -:  194:		}
        -:  195:	}
        -:  196:
        -:  197:	/* now work in full words directly from input */
        -:  198:
        -:  199:	SHA3_ASSERT(ctx->byteIndex == 0);
        -:  200:
       11:  201:	words = len / sizeof(u64);
       11:  202:	tail = len - words * sizeof(u64);
        -:  203:
        -:  204:	SHA3_TRACE("have %d full words to process", (unsigned)words);
        -:  205:
       33:  206:	for (i = 0; i < words; i++, buf += sizeof(u64)) {
       22:  207:		const u64 t = (u64)(buf[0]) | ((u64)(buf[1]) << 8 * 1) | ((u64)(buf[2]) << 8 * 2) |
       22:  208:					  ((u64)(buf[3]) << 8 * 3) | ((u64)(buf[4]) << 8 * 4) |
       22:  209:					  ((u64)(buf[5]) << 8 * 5) | ((u64)(buf[6]) << 8 * 6) |
       22:  210:					  ((u64)(buf[7]) << 8 * 7);
        -:  211:#if defined(__x86_64__) || defined(__i386__)
        -:  212:		SHA3_ASSERT(memcmp(&t, buf, 8) == 0);
        -:  213:#endif
       22:  214:		ctx->u.s[ctx->wordIndex] ^= t;
       22:  215:		if (++ctx->wordIndex == (SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords))) {
    #####:  216:			keccakf(ctx->u.s);
    #####:  217:			ctx->wordIndex = 0;
        -:  218:		}
        -:  219:	}
        -:  220:
        -:  221:	SHA3_TRACE("have %d bytes left to process, save them", (unsigned)tail);
        -:  222:
        -:  223:	/* finally, save the partial word */
        -:  224:	SHA3_ASSERT(ctx->byteIndex == 0 && tail < 8);
       55:  225:	while (tail--) {
        -:  226:		SHA3_TRACE("Store byte %02x '%c'", *buf, *buf);
       44:  227:		ctx->saved |= (u64)(*(buf++)) << ((ctx->byteIndex++) * 8);
        -:  228:	}
        -:  229:	SHA3_ASSERT(ctx->byteIndex < 8);
        -:  230:	SHA3_TRACE("Have saved=0x%016" PRIx64 " at the end", ctx->saved);
        -:  231:}
        -:  232:
        -:  233:/* This is simply the 'update' with the padding block.
        -:  234: * The padding block is 0x01 || 0x00* || 0x80. First 0x01 and last 0x80
        -:  235: * bytes are always present, but they can be the same byte.
        -:  236: */
       11:  237:void const *sha3_Finalize(void *priv) {
       11:  238:	sha3_context *ctx = (sha3_context *)priv;
        -:  239:
        -:  240:	SHA3_TRACE("called with %d bytes in the buffer", ctx->byteIndex);
        -:  241:
        -:  242:	/* Append 2-bit suffix 01, per SHA-3 spec. Instead of 1 for padding we
        -:  243:	 * use 1<<2 below. The 0x02 below corresponds to the suffix 01.
        -:  244:	 * Overall, we feed 0, then 1, and finally 1 to start padding. Without
        -:  245:	 * M || 01, we would simply use 1 to start padding. */
        -:  246:
        -:  247:	u64 t;
        -:  248:
       11:  249:	if (ctx->capacityWords & SHA3_USE_KECCAK_FLAG) {
        -:  250:		/* Keccak version */
    #####:  251:		t = (u64)(((u64)1) << (ctx->byteIndex * 8));
        -:  252:	} else {
        -:  253:		/* SHA3 version */
       11:  254:		t = (u64)(((u64)(0x02 | (1 << 2))) << ((ctx->byteIndex) * 8));
        -:  255:	}
        -:  256:
       11:  257:	ctx->u.s[ctx->wordIndex] ^= ctx->saved ^ t;
        -:  258:
       11:  259:	ctx->u.s[SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords) - 1] ^=
        -:  260:		SHA3_CONST(0x8000000000000000UL);
       11:  261:	keccakf(ctx->u.s);
        -:  262:
        -:  263:	/* Return first bytes of the ctx->s. This conversion is not needed for
        -:  264:	 * little-endian platforms e.g. wrap with #if !defined(__BYTE_ORDER__)
        -:  265:	 * || !defined(__ORDER_LITTLE_ENDIAN__) || __BYTE_ORDER__!=__ORDER_LITTLE_ENDIAN__
        -:  266:	 *    ... the conversion below ...
        -:  267:	 * #endif */
        -:  268:	{
        -:  269:		unsigned i;
      286:  270:		for (i = 0; i < SHA3_KECCAK_SPONGE_WORDS; i++) {
      275:  271:			const unsigned t1 = (uint32_t)ctx->u.s[i];
      275:  272:			const unsigned t2 = (uint32_t)((ctx->u.s[i] >> 16) >> 16);
      275:  273:			ctx->u.sb[i * 8 + 0] = (uint8_t)(t1);
      275:  274:			ctx->u.sb[i * 8 + 1] = (uint8_t)(t1 >> 8);
      275:  275:			ctx->u.sb[i * 8 + 2] = (uint8_t)(t1 >> 16);
      275:  276:			ctx->u.sb[i * 8 + 3] = (uint8_t)(t1 >> 24);
      275:  277:			ctx->u.sb[i * 8 + 4] = (uint8_t)(t2);
      275:  278:			ctx->u.sb[i * 8 + 5] = (uint8_t)(t2 >> 8);
      275:  279:			ctx->u.sb[i * 8 + 6] = (uint8_t)(t2 >> 16);
      275:  280:			ctx->u.sb[i * 8 + 7] = (uint8_t)(t2 >> 24);
        -:  281:		}
        -:  282:	}
        -:  283:
        -:  284:	SHA3_TRACE_BUF("Hash: (first 32 bytes)", ctx->u.sb, 256 / 8);
        -:  285:
       11:  286:	return (ctx->u.sb);
        -:  287:}
        -:  288:
    #####:  289:sha3_return_t sha3_HashBuffer(unsigned bitSize, enum SHA3_FLAGS flags, const void *in,
        -:  290:							  unsigned inBytes, void *out, unsigned outBytes) {
        -:  291:	sha3_return_t err;
        -:  292:	sha3_context c;
        -:  293:
    #####:  294:	err = sha3_Init(&c, bitSize);
    #####:  295:	if (err != SHA3_RETURN_OK)
    #####:  296:		return err;
    #####:  297:	if (sha3_SetFlags(&c, flags) != flags) {
    #####:  298:		return SHA3_RETURN_BAD_PARAMS;
        -:  299:	}
    #####:  300:	sha3_Update(&c, in, inBytes);
    #####:  301:	const void *h = sha3_Finalize(&c);
        -:  302:
    #####:  303:	if (outBytes > bitSize / 8)
    #####:  304:		outBytes = bitSize / 8;
    #####:  305:	memcpy(out, h, outBytes);
    #####:  306:	return SHA3_RETURN_OK;
        -:  307:}
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/macro_utils.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <base/slabs.h>
        -:   19:#include <errno.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:#define MALLOC_64_ID (INT64_MAX - 8)
        -:   24:#define MALLOC_32_ID (INT32_MAX - 8)
        -:   25:
        -:   26:// Define both 64/32 bit impls the slab allocator will build the approproate types
        -:   27:// based on configuration.
        -:   28:typedef struct FatPtr64Impl {
        -:   29:	u64 id;
        -:   30:	u64 len;
        -:   31:	void *data;
        -:   32:} FatPtr64Impl;
        -:   33:
        -:   34:typedef struct FatPtr32Impl {
        -:   35:	u32 id;
        -:   36:	u32 len;
        -:   37:	void *data;
        -:   38:} FatPtr32Impl;
        -:   39:
        -:   40:// deteremine which kind of fat pointer this is. 32 bit fat pointers are restricted to having an ID
        -:   41:// that does not set the most significant bit. Therefore they must be less than 2^31 or the
        -:   42:// maximum signed int value (INT32_MAX). Conversely, the 64 bit ids must have this bit set.
        -:   43:// This is the slab allocator's responsibility to ensure the bit is set correctly.
        -:   44:// Users need not worry about these details as they are handled internally.
  4018651:   45:bool fat_ptr_is64(const FatPtr *ptr) {
  4018651:   46:	return ((FatPtr32Impl *)ptr->data)->id & 0x1;
        -:   47:}
        -:   48:
        -:   49:// Return the id of the FatPtr. First check bit for u64/u32 status, then return value.
      200:   50:u64 fat_ptr_id(const FatPtr *ptr) {
      200:   51:	if (fat_ptr_is64(ptr))
      100:   52:		return ((FatPtr64Impl *)ptr->data)->id;
        -:   53:	else
      100:   54:		return ((FatPtr32Impl *)ptr->data)->id;
        -:   55:}
        -:   56:
        -:   57:// Get the length of this FatPtr. Once again use the status bit in the id then return value.
  3006860:   58:u64 fat_ptr_len(const FatPtr *ptr) {
  3006860:   59:	if (fat_ptr_is64(ptr))
      266:   60:		return ((FatPtr64Impl *)ptr->data)->len;
        -:   61:	else
  3006594:   62:		return ((FatPtr32Impl *)ptr->data)->len;
        -:   63:}
        -:   64:
        -:   65:// Get the data pointer of this FatPtr. Once again use the status bit in the id then return value.
  1011591:   66:void *fat_ptr_data(const FatPtr *ptr) {
  1011591:   67:	if (fat_ptr_is64(ptr))
      105:   68:		return ((FatPtr64Impl *)ptr->data)->data;
        -:   69:	else
  1011486:   70:		return ((FatPtr32Impl *)ptr->data)->data;
        -:   71:}
        -:   72:
        -:   73:// Test function to free the 64 bit objects.
      100:   74:void fat_ptr_free_test_obj64(FatPtr *ptr) {
      100:   75:	if (ptr && ptr->data) {
      100:   76:		myfree(ptr->data);
      100:   77:		ptr->data = NULL;
        -:   78:	}
      100:   79:}
        -:   80:
        -:   81:// Test function to free the 32 bit objects.
      100:   82:void fat_ptr_free_test_obj32(FatPtr *ptr) {
      100:   83:	if (ptr && ptr->data) {
      100:   84:		myfree(ptr->data);
      100:   85:		ptr->data = NULL;
        -:   86:	}
      100:   87:}
        -:   88:
        -:   89:// Test function to allocate the 64 bit objects.
      100:   90:void fat_ptr_test_obj64(FatPtr *ptr, u64 id, u64 len) {
      100:   91:	ptr->data = mymalloc(3 * sizeof(u64) + len);
      100:   92:	FatPtr64Impl *fptr = ptr->data;
      100:   93:	fptr->id = id;
      100:   94:	fptr->len = len;
      100:   95:	fptr->data = ptr->data + 3 * sizeof(u64);
      100:   96:}
        -:   97:
        -:   98:// Test function to allocate the 32 bit objects.
      100:   99:void fat_ptr_test_obj32(FatPtr *ptr, u32 id, u32 len) {
      100:  100:	ptr->data = mymalloc(2 * sizeof(u32) + sizeof(u64) + len);
      100:  101:	FatPtr32Impl *fptr = ptr->data;
      100:  102:	fptr->id = id;
      100:  103:	fptr->len = len;
      100:  104:	fptr->data = ptr->data + 2 * sizeof(u32) + sizeof(u64);
      100:  105:}
        -:  106:
        -:  107:// SlabAllocator Config
       32:  108:void slab_allocator_config_cleanup(SlabAllocatorConfigNc *sc) {
       32:  109:	if (sc->slab_types) {
       32:  110:		myfree(sc->slab_types);
       32:  111:		sc->slab_types = NULL;
        -:  112:	}
       32:  113:}
        -:  114:
       35:  115:int slab_allocator_config_build(SlabAllocatorConfig *sc, bool zeroed, bool no_malloc,
        -:  116:								bool is_64_bit) {
       35:  117:	sc->zeroed = zeroed;
       35:  118:	sc->no_malloc = no_malloc;
       35:  119:	sc->is_64_bit = is_64_bit;
       35:  120:	sc->slab_types_count = 0;
       35:  121:	sc->slab_types = NULL;
        -:  122:
       35:  123:	return 0;
        -:  124:}
     3603:  125:int slab_allocator_config_add_type(SlabAllocatorConfig *sc, const SlabType *st) {
     3603:  126:	if (sc->slab_types) {
     3571:  127:		void *tmp = myrealloc(sc->slab_types, sizeof(SlabType) * (1 + sc->slab_types_count));
     3571:  128:		if (tmp == NULL)
    #####:  129:			return -1;
     3571:  130:		sc->slab_types = tmp;
        -:  131:	} else {
       32:  132:		sc->slab_types = mymalloc(sizeof(SlabType));
       32:  133:		if (sc->slab_types == NULL)
    #####:  134:			return -1;
        -:  135:	}
        -:  136:
     3603:  137:	sc->slab_types[sc->slab_types_count] = *st;
     3603:  138:	sc->slab_types_count++;
        -:  139:
     3603:  140:	return 0;
        -:  141:}
        -:  142:
        -:  143:// Slab Allocator
        -:  144:
        -:  145:typedef struct SlabData {
        -:  146:	SlabType type; // This slab data's type information (slab_size, slabs_per_resize, initial, max)
        -:  147:	void **data;   // Pointers to each chunk
        -:  148:	void *free_list;	// The free list pointers
        -:  149:	u64 cur_chunks;		// number of chunks currently allocated
        -:  150:	u64 cur_slabs;		// number of slabs currently allocated
        -:  151:	u64 free_list_head; // the free list head
        -:  152:} SlabData;
        -:  153:
        -:  154:typedef struct SlabAllocatorImpl {
        -:  155:	u64 sd_size;	  // size of the SlabData array
        -:  156:	SlabData *sd_arr; // slab data array one for each SlabType
        -:  157:	bool no_malloc;	  // config no_malloc
        -:  158:	bool zeroed;	  // config zeroed
        -:  159:	bool is_64_bit;	  // config 64 bit id/len
        -:  160:	u64 cur_mallocs;  // number of slabs allocated via malloc
        -:  161:} SlabAllocatorImpl;
        -:  162:
        -:  163:int slab_data_allocate(SlabData *sd, FatPtr *fptr, bool is_64_bit, bool zeroed);
        -:  164:
       30:  165:void slab_allocator_cleanup(SlabAllocatorNc *ptr) {
       30:  166:	if (ptr->impl) {
       30:  167:		SlabAllocatorImpl *impl = ptr->impl;
       30:  168:		if (impl->sd_arr) {
     3375:  169:			for (u64 i = 0; i < impl->sd_size; i++) {
     3394:  170:				for (int j = 0; j < impl->sd_arr[i].cur_chunks; j++) {
       49:  171:					if (impl->sd_arr[i].data[j]) {
       49:  172:						myfree(impl->sd_arr[i].data[j]);
       49:  173:						impl->sd_arr[i].data[j] = NULL;
        -:  174:					}
        -:  175:				}
     3345:  176:				if (impl->sd_arr[i].data) {
       35:  177:					myfree(impl->sd_arr[i].data);
       35:  178:					impl->sd_arr[i].data = NULL;
        -:  179:				}
     3345:  180:				if (impl->sd_arr[i].free_list) {
       35:  181:					myfree(impl->sd_arr[i].free_list);
       35:  182:					impl->sd_arr[i].free_list = NULL;
        -:  183:				}
        -:  184:			}
        -:  185:
       30:  186:			myfree(impl->sd_arr);
       30:  187:			impl->sd_arr = NULL;
        -:  188:		}
       30:  189:		myfree(ptr->impl);
       30:  190:		ptr->impl = NULL;
        -:  191:	}
       30:  192:}
        -:  193:
     3639:  194:int slab_allocator_init_free_list(SlabData *sd, u64 slabs, u64 offset, bool is_64_bit) {
        -:  195:	//  initialize the values of the free list.
  1006783:  196:	for (u64 i = 0; i < slabs; i++) {
  1003144:  197:		if (i == (slabs - 1)) {
       49:  198:			if (is_64_bit)
        2:  199:				((u64 *)(sd->free_list))[i + offset] = UINT64_MAX;
        -:  200:			else
       47:  201:				((u32 *)(sd->free_list))[i + offset] = UINT32_MAX;
        -:  202:		} else {
  1003095:  203:			if (is_64_bit)
      108:  204:				((u64 *)(sd->free_list))[i + offset] = offset + i + 1;
        -:  205:			else
  1002987:  206:				((u32 *)(sd->free_list))[i + offset] = offset + i + 1;
        -:  207:		}
        -:  208:	}
        -:  209:
     3639:  210:	return 0;
        -:  211:}
        -:  212:
     3601:  213:int slab_allocator_init_slab_data(SlabAllocatorImpl *impl, SlabType *st, u64 index) {
     3601:  214:	impl->sd_arr[index].type = *st;
     3601:  215:	if (impl->is_64_bit)
        2:  216:		impl->sd_arr[index].type.slab_size += sizeof(u64) * 3;
        -:  217:	else
     3599:  218:		impl->sd_arr[index].type.slab_size += sizeof(u64) + sizeof(u32) * 2;
     3601:  219:	impl->sd_arr[index].cur_slabs = 0;
     3601:  220:	impl->sd_arr[index].cur_chunks = st->initial_chunks;
     3601:  221:	if (st->initial_chunks > 0) {
       11:  222:		impl->sd_arr[index].free_list_head = 0;
       11:  223:		impl->sd_arr[index].data = mymalloc(sizeof(void *) * st->initial_chunks);
       11:  224:		if (impl->sd_arr[index].data == NULL)
    #####:  225:			return -1;
        -:  226:	} else {
     3590:  227:		impl->sd_arr[index].data = NULL;
     3590:  228:		if (impl->is_64_bit)
    #####:  229:			impl->sd_arr[index].free_list_head = UINT64_MAX;
        -:  230:		else
     3590:  231:			impl->sd_arr[index].free_list_head = UINT32_MAX;
        -:  232:	}
        -:  233:
     3601:  234:	if (st->initial_chunks > 0) {
       11:  235:		if (impl->is_64_bit)
        2:  236:			impl->sd_arr[index].free_list =
        2:  237:				mymalloc(sizeof(u64) * st->slabs_per_resize * st->initial_chunks);
        -:  238:		else
        9:  239:			impl->sd_arr[index].free_list =
        9:  240:				mymalloc(sizeof(u32) * st->slabs_per_resize * st->initial_chunks);
       11:  241:		if (impl->sd_arr[index].free_list == NULL) {
    #####:  242:			myfree(impl->sd_arr[index].data);
    #####:  243:			return -1;
        -:  244:		}
        -:  245:	} else {
     3590:  246:		impl->sd_arr[index].free_list = NULL;
        -:  247:	}
        -:  248:
     3612:  249:	for (u64 i = 0; i < st->initial_chunks; i++) {
       22:  250:		impl->sd_arr[index].data[i] =
       11:  251:			mymalloc(impl->sd_arr[index].type.slab_size * st->slabs_per_resize);
        -:  252:
       11:  253:		if (impl->sd_arr[index].data[i] == NULL) {
    #####:  254:			for (u64 j = 0; j < i; j++) {
    #####:  255:				myfree(impl->sd_arr[index].data[j]);
        -:  256:			}
    #####:  257:			myfree(impl->sd_arr[index].data);
    #####:  258:			return -1;
        -:  259:		}
        -:  260:	}
        -:  261:
     3601:  262:	bool is_64_bit = impl->is_64_bit;
     3601:  263:	slab_allocator_init_free_list(&impl->sd_arr[index], st->initial_chunks * st->slabs_per_resize,
        -:  264:								  0, is_64_bit);
        -:  265:
     3601:  266:	return 0;
        -:  267:}
        -:  268:
    14336:  269:int compare_sd(const void *a, const void *b) {
    14336:  270:	const SlabData *sda = a;
    14336:  271:	const SlabData *sdb = b;
    14336:  272:	if (sda->type.slab_size < sdb->type.slab_size)
    14336:  273:		return -1;
    #####:  274:	else if (sda->type.slab_size > sdb->type.slab_size)
    #####:  275:		return 1;
    #####:  276:	return 0;
        -:  277:}
        -:  278:
       31:  279:int slab_allocator_sort_slab_data(SlabAllocator *ptr) {
       31:  280:	SlabAllocatorImpl *impl = ptr->impl;
       31:  281:	qsort(impl->sd_arr, impl->sd_size, sizeof(SlabData), compare_sd);
       31:  282:	u32 last_slab_size = 0;
     3631:  283:	for (u64 i = 0; i < impl->sd_size; i++) {
     3601:  284:		if (last_slab_size >= impl->sd_arr[i].type.slab_size) {
    #####:  285:			errno = EINVAL;
    #####:  286:			return -1;
        -:  287:		}
        -:  288:		// for alignment, must be divisible by 8
     3601:  289:		if (impl->sd_arr[i].type.slab_size % 8 != 0) {
    #####:  290:			errno = EINVAL;
    #####:  291:			return -1;
        -:  292:		}
        -:  293:		// can't have higher max slabs than initial
     3601:  294:		if (impl->sd_arr[i].type.slabs_per_resize * impl->sd_arr[i].type.initial_chunks >
     3601:  295:			impl->sd_arr[i].type.max_slabs) {
    #####:  296:			errno = EINVAL;
    #####:  297:			return -1;
        -:  298:		}
        -:  299:		// max slabs for 32 bit and 64 bit
    3601*:  300:		if (impl->sd_arr[i].type.max_slabs > (INT32_MAX - 10) && !impl->is_64_bit) {
    #####:  301:			errno = EINVAL;
    #####:  302:			return -1;
    3601*:  303:		} else if (impl->sd_arr[i].type.max_slabs > (INT64_MAX - 10) && impl->is_64_bit) {
    #####:  304:			errno = EINVAL;
    #####:  305:			return -1;
        -:  306:		}
        -:  307:
        -:  308:		// max slabs must be dividisble by slabs_per_resize
     3601:  309:		if (impl->sd_arr[i].type.max_slabs % impl->sd_arr[i].type.slabs_per_resize) {
        1:  310:			errno = EINVAL;
        1:  311:			return -1;
        -:  312:		}
     3600:  313:		last_slab_size = impl->sd_arr[i].type.slab_size;
        -:  314:	}
       30:  315:	return 0;
        -:  316:}
        -:  317:
       31:  318:int slab_allocator_build(SlabAllocator *ptr, const SlabAllocatorConfig *config) {
       31:  319:	ptr->impl = mymalloc(sizeof(SlabAllocatorImpl));
       31:  320:	if (ptr->impl == NULL)
    #####:  321:		return -1;
       31:  322:	SlabAllocatorImpl *impl = ptr->impl;
        -:  323:
       31:  324:	impl->no_malloc = config->no_malloc;
       31:  325:	impl->zeroed = config->zeroed;
       31:  326:	impl->is_64_bit = config->is_64_bit;
       31:  327:	impl->sd_size = config->slab_types_count;
       31:  328:	impl->sd_arr = mymalloc(sizeof(SlabData) * impl->sd_size);
       31:  329:	impl->cur_mallocs = 0;
       31:  330:	if (impl->sd_arr == NULL) {
    #####:  331:		myfree(ptr->impl);
    #####:  332:		return -1;
        -:  333:	}
        -:  334:
     3632:  335:	for (u64 i = 0; i < config->slab_types_count; i++) {
     3601:  336:		if (slab_allocator_init_slab_data(impl, &config->slab_types[i], i)) {
        -:  337:			// cleanup previously allocated slabs
    #####:  338:			impl->sd_size = i;
    #####:  339:			slab_allocator_cleanup(ptr);
    #####:  340:			return -1;
        -:  341:		}
        -:  342:	}
       31:  343:	int ret = slab_allocator_sort_slab_data(ptr);
       31:  344:	if (ret)
        1:  345:		slab_allocator_cleanup(ptr);
       31:  346:	return ret;
        -:  347:}
        -:  348:
  2002379:  349:int slab_allocator_index(const SlabAllocator *ptr, u32 size) {
  2002379:  350:	SlabAllocatorImpl *impl = ptr->impl;
  2002379:  351:	int ret = -1;
  2002379:  352:	if (impl->sd_size == 0)
    #####:  353:		return ret;
        -:  354:
  2002379:  355:	int left = 0;
  2002379:  356:	int right = impl->sd_size - 1;
        -:  357:
  3016896:  358:	while (left <= right) {
  2015717:  359:		int mid = left + (right - left) / 2;
  2015717:  360:		u32 slab_size = impl->sd_arr[mid].type.slab_size;
  2015717:  361:		if (slab_size == size) {
  1001200:  362:			ret = mid;
  1001200:  363:			break;
  1014517:  364:		} else if (slab_size > size)
  1011400:  365:			right = mid - 1;
        -:  366:		else
     3117:  367:			left = mid + 1;
        -:  368:	}
        -:  369:
  2002379:  370:	if (ret == -1 && right + 1 <= impl->sd_size - 1) {
  1001172:  371:		return right + 1;
        -:  372:	}
        -:  373:
  1001207:  374:	return ret;
        -:  375:}
        -:  376:
       51:  377:int slab_data_try_resize(SlabData *sd, FatPtr *fptr, bool is_64_bit, bool zeroed) {
       51:  378:	if (sd->cur_slabs < sd->type.max_slabs) {
        -:  379:		// we can try to resize
        -:  380:		// first try to reallocate the free list
       38:  381:		void *nfree_list = NULL;
        -:  382:		u64 factor;
       38:  383:		if (is_64_bit)
    #####:  384:			factor = sizeof(u64);
        -:  385:		else
       38:  386:			factor = sizeof(u32);
       38:  387:		if (sd->free_list) {
        -:  388:			nfree_list =
       14:  389:				myrealloc(sd->free_list, (1 + sd->cur_chunks) * sd->type.slabs_per_resize * factor);
        -:  390:		} else {
        -:  391:
       24:  392:			nfree_list = mymalloc(sd->type.slabs_per_resize * factor);
        -:  393:		}
       38:  394:		if (nfree_list == NULL)
    #####:  395:			return -1;
       38:  396:		sd->free_list = nfree_list;
        -:  397:
        -:  398:		// now try to allocate more slab chunks
        -:  399:		void *ndata;
       38:  400:		if (sd->data == NULL) {
       24:  401:			ndata = mymalloc(sizeof(void *));
        -:  402:		} else {
       14:  403:			ndata = myrealloc(sd->data, sizeof(void *) * (1 + sd->cur_chunks));
        -:  404:		}
       38:  405:		if (ndata == NULL) {
    #####:  406:			return -1;
        -:  407:		}
        -:  408:
       38:  409:		sd->data = ndata;
       38:  410:		sd->data[sd->cur_chunks] = mymalloc(sd->type.slab_size * sd->type.slabs_per_resize);
       38:  411:		if (sd->data[sd->cur_chunks] == NULL)
    #####:  412:			return -1;
        -:  413:
        -:  414:		// data was successfully allocated, make updates.
       38:  415:		slab_allocator_init_free_list(sd, sd->type.slabs_per_resize, sd->cur_slabs, is_64_bit);
       38:  416:		sd->free_list_head = sd->cur_slabs;
       38:  417:		sd->cur_chunks += 1;
        -:  418:
       38:  419:		return slab_data_allocate(sd, fptr, is_64_bit, zeroed);
        -:  420:	}
       13:  421:	return -1;
        -:  422:}
        -:  423:
  1001231:  424:int slab_data_allocate(SlabData *sd, FatPtr *fptr, bool is_64_bit, bool zeroed) {
  1001231:  425:	u64 id = sd->free_list_head;
  1001231:  426:	if (is_64_bit && id == UINT64_MAX) {
        1:  427:		return slab_data_try_resize(sd, fptr, is_64_bit, zeroed);
  1001230:  428:	} else if (!is_64_bit && id == UINT32_MAX) {
       50:  429:		return slab_data_try_resize(sd, fptr, is_64_bit, zeroed);
        -:  430:	}
        -:  431:
  1001180:  432:	if (is_64_bit) {
       22:  433:		sd->free_list_head = ((u64 *)sd->free_list)[id];
        -:  434:
        -:  435:	} else {
  1001158:  436:		sd->free_list_head = ((u32 *)sd->free_list)[id];
        -:  437:	}
        -:  438:
        -:  439:	// set to MAX-1 as a marker that this is allocated
        -:  440:	// if any freed without this value, it's an error
  1001180:  441:	if (is_64_bit)
       22:  442:		((u64 *)sd->free_list)[id] = (UINT64_MAX - 1);
        -:  443:	else
  1001158:  444:		((u32 *)sd->free_list)[id] = (UINT32_MAX - 1);
        -:  445:
  1001180:  446:	u64 len = sd->type.slab_size;
  1001180:  447:	u64 slab_data_index = id / sd->type.slabs_per_resize;
  1001180:  448:	u64 offset_mod = id % sd->type.slabs_per_resize;
        -:  449:
  1001180:  450:	fptr->data = sd->data[slab_data_index] + offset_mod * sd->type.slab_size;
        -:  451:
        -:  452:	u64 data_len;
        -:  453:	u8 *data_ptr;
  1001180:  454:	if (is_64_bit) {
       22:  455:		FatPtr64Impl *fptr64 = fptr->data;
       22:  456:		fptr64->id = (id * 2) + 1;
       22:  457:		fptr64->len = len - 3 * sizeof(u64);
       22:  458:		fptr64->data = fptr->data + 3 * sizeof(u64);
       22:  459:		data_len = fptr64->len;
       22:  460:		data_ptr = fptr64->data;
        -:  461:	} else {
  1001158:  462:		FatPtr32Impl *fptr32 = fptr->data;
  1001158:  463:		fptr32->id = (id * 2);
  1001158:  464:		fptr32->len = len - (2 * sizeof(u32) + sizeof(u64));
  1001158:  465:		fptr32->data = fptr->data + 2 * sizeof(u32) + sizeof(u64);
  1001158:  466:		data_len = fptr32->len;
  1001158:  467:		data_ptr = fptr32->data;
        -:  468:	}
        -:  469:
  1001180:  470:	sd->cur_slabs += 1;
  1001180:  471:	if (zeroed) {
      500:  472:		for (u64 i = 0; i < data_len; i++) {
      480:  473:			data_ptr[i] = 0;
        -:  474:		}
        -:  475:	}
        -:  476:
  1001180:  477:	return 0;
        -:  478:}
        -:  479:
  1001179:  480:void slab_data_free(SlabData *sd, const FatPtr *fptr, bool is_64_bit, bool zeroed) {
        -:  481:	u64 data_len;
        -:  482:	u8 *data_ptr;
  1001179:  483:	if (is_64_bit) {
       22:  484:		FatPtr64Impl *fptr64 = fptr->data;
       22:  485:		data_len = fptr64->len;
       22:  486:		data_ptr = fptr64->data;
       22:  487:		u64 id = (fptr64->id - 1) / 2;
       22:  488:		if (((u64 *)sd->free_list)[id] != (UINT64_MAX - 1)) {
    #####:  489:			panic("Potential double free. Id = %llu.\n", id);
        -:  490:		}
       22:  491:		((u64 *)sd->free_list)[id] = sd->free_list_head;
       22:  492:		sd->free_list_head = id;
       22:  493:		if (sd->cur_slabs == 0)
    #####:  494:			panic("Potential double free. Id = %llu. Freeing slabs when none are allocated.\n", id);
       22:  495:		sd->cur_slabs -= 1;
        -:  496:	} else {
  1001157:  497:		FatPtr32Impl *fptr32 = fptr->data;
  1001157:  498:		data_len = fptr32->len;
  1001157:  499:		data_ptr = fptr32->data;
  1001157:  500:		u32 id = (fptr32->id) / 2;
  1001157:  501:		if (((u32 *)sd->free_list)[id] != (UINT32_MAX - 1)) {
    #####:  502:			panic("Potential double free. Id = %llu.\n", id);
        -:  503:		}
  1001157:  504:		((u32 *)sd->free_list)[id] = sd->free_list_head;
  1001157:  505:		sd->free_list_head = id;
  1001157:  506:		if (sd->cur_slabs == 0)
    #####:  507:			panic("Potential double free. Id = %llu. Freeing slabs when none are allocated.\n", id);
  1001157:  508:		sd->cur_slabs -= 1;
        -:  509:	}
        -:  510:
  1001179:  511:	if (zeroed) {
      500:  512:		for (u64 i = 0; i < data_len; i++) {
      480:  513:			data_ptr[i] = 0;
        -:  514:		}
        -:  515:	}
  1001179:  516:}
        -:  517:
  1001200:  518:int slab_allocator_allocate(SlabAllocator *ptr, u32 size, FatPtr *fptr) {
  1001200:  519:	if (size == 0) {
    #####:  520:		errno = EINVAL;
    #####:  521:		return -1;
        -:  522:	}
        -:  523:
  1001200:  524:	SlabAllocatorImpl *impl = ((SlabAllocatorImpl *)ptr->impl);
  1001200:  525:	bool is_64_bit = impl->is_64_bit;
  1001200:  526:	bool zeroed = impl->zeroed;
        -:  527:	u32 needed;
  1001200:  528:	if (is_64_bit)
       23:  529:		needed = size + 3 * sizeof(u64);
        -:  530:	else
  1001177:  531:		needed = size + 2 * sizeof(u32) + sizeof(u64);
  1001200:  532:	int index = slab_allocator_index(ptr, needed);
        -:  533:	int ret;
  1001200:  534:	if (impl->no_malloc && index < 0) {
        7:  535:		return -1;
  1001193:  536:	} else if (index < 0) {
    #####:  537:		ret = -1;
        -:  538:	} else {
  1001193:  539:		SlabData *sd = &impl->sd_arr[index];
  1001193:  540:		ret = slab_data_allocate(sd, fptr, is_64_bit, zeroed);
        -:  541:	}
        -:  542:
        -:  543:	// we couldn't allocate via slabs. Use malloc if configured.
  1001193:  544:	if (ret && !impl->no_malloc) {
        -:  545:		void *val;
        -:  546:		u64 data_len;
        -:  547:
        2:  548:		if (is_64_bit) {
    #####:  549:			data_len = size + (3 * sizeof(u64));
    #####:  550:			val = mymalloc(data_len);
        -:  551:		} else {
        2:  552:			data_len = size + (2 * sizeof(u32) + sizeof(u64));
        2:  553:			val = mymalloc(data_len);
        -:  554:		}
        -:  555:
        -:  556:		// malloc error
        2:  557:		if (!val)
    #####:  558:			return -1;
        -:  559:
        2:  560:		if (zeroed) {
       25:  561:			for (u64 i = 0; i < data_len; i++) {
       24:  562:				((u8 *)val)[i] = 0;
        -:  563:			}
        -:  564:		}
        -:  565:
        2:  566:		impl->cur_mallocs++;
        2:  567:		ret = 0;
        2:  568:		fptr->data = val;
        -:  569:
        2:  570:		if (is_64_bit) {
    #####:  571:			FatPtr64Impl *fptr64 = fptr->data;
    #####:  572:			fptr64->id = MALLOC_64_ID;
    #####:  573:			fptr64->len = size;
    #####:  574:			fptr64->data = fptr->data + 3 * sizeof(u64);
        -:  575:		} else {
        2:  576:			FatPtr32Impl *fptr32 = fptr->data;
        2:  577:			fptr32->id = MALLOC_32_ID;
        2:  578:			fptr32->len = size;
        2:  579:			fptr32->data = fptr->data + 2 * sizeof(u32) + sizeof(u64);
        -:  580:		}
        -:  581:	}
  1001193:  582:	return ret;
        -:  583:}
  1001181:  584:void slab_allocator_free(SlabAllocator *ptr, FatPtr *fptr) {
  1001181:  585:	if (fptr == NULL || nil(*fptr)) {
    #####:  586:		panic("Freeing a slab that's already nil. Double free?");
        -:  587:	}
  1001181:  588:	SlabAllocatorImpl *impl = ptr->impl;
  1001181:  589:	bool is_64_bit = impl->is_64_bit;
        -:  590:
  1001181:  591:	if (is_64_bit) {
       22:  592:		FatPtr64Impl *fptr64 = fptr->data;
       22:  593:		if (fptr64->id == MALLOC_64_ID) {
    #####:  594:			if (fptr->data) {
    #####:  595:				if (impl->zeroed) {
    #####:  596:					for (u64 i = 0; i < fptr64->len + 3 * sizeof(u64); i++) {
    #####:  597:						((u8 *)fptr->data)[i] = 0;
        -:  598:					}
        -:  599:				}
    #####:  600:				if (impl->cur_mallocs == 0)
    #####:  601:					panic("Freeing malloc allocated pointer when none are pending. Double free?");
    #####:  602:				myfree(fptr->data);
    #####:  603:				impl->cur_mallocs--;
        -:  604:			}
    #####:  605:			*fptr = null;
    #####:  606:			return;
        -:  607:		}
        -:  608:	} else {
  1001159:  609:		FatPtr32Impl *fptr32 = fptr->data;
  1001159:  610:		if (fptr32->id == MALLOC_32_ID) {
        2:  611:			if (fptr->data) {
        2:  612:				if (impl->zeroed) {
       17:  613:					for (u64 i = 0; i < fptr32->len + 2 * sizeof(u32) + sizeof(u64); i++) {
       16:  614:						((u8 *)fptr->data)[i] = 0;
        -:  615:					}
        -:  616:				}
        2:  617:				if (impl->cur_mallocs == 0)
    #####:  618:					panic("Freeing malloc allocated pointer when none are pending. Double free?");
        2:  619:				myfree(fptr->data);
        2:  620:				impl->cur_mallocs--;
        -:  621:			}
        2:  622:			*fptr = null;
        2:  623:			return;
        -:  624:		}
        -:  625:	}
        -:  626:
        -:  627:	u32 needed;
  1001179:  628:	if (is_64_bit)
       22:  629:		needed = fat_ptr_len(fptr) + 3 * sizeof(u64);
        -:  630:	else
  1001157:  631:		needed = fat_ptr_len(fptr) + 2 * sizeof(u32) + sizeof(u64);
  1001179:  632:	int index = slab_allocator_index(ptr, needed);
  1001179:  633:	if (index < 0)
    #####:  634:		panic("Freeing a slab with an unknown slab size %llu.\n", needed);
  1001179:  635:	SlabData *sd = &((SlabAllocatorImpl *)ptr->impl)->sd_arr[index];
  1001179:  636:	if (needed != sd->type.slab_size)
    #####:  637:		panic("Freeing a slab with an unknown slab size %llu.\n", needed);
  1001179:  638:	slab_data_free(sd, fptr, ((SlabAllocatorImpl *)ptr->impl)->is_64_bit,
  1001179:  639:				   ((SlabAllocatorImpl *)ptr->impl)->zeroed);
  1001179:  640:	*fptr = null;
        -:  641:}
       32:  642:u64 slab_allocator_cur_slabs_allocated(const SlabAllocator *ptr) {
       32:  643:	SlabAllocatorImpl *impl = ptr->impl;
       32:  644:	u64 ret = impl->cur_mallocs;
        -:  645:
     3379:  646:	for (u64 i = 0; i < impl->sd_size; i++) {
     3347:  647:		ret += impl->sd_arr[i].cur_slabs;
        -:  648:	}
       32:  649:	return ret;
        -:  650:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:#include <stddef.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:
       69:   20:bool __is_little_endian() {
       69:   21:	u16 test = 0x1;
       69:   22:	return (*(u8 *)&test == 0x1);
        -:   23:}
        -:   24:
       69:   25:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   26:	if (sizeof(size_t) != 8) {
        -:   27:		fprintf(stderr, "Error: This program requires a 64-bit architecture to run.\n");
        -:   28:		exit(EXIT_FAILURE);
        -:   29:	}
        -:   30:
        -:   31:	if (sizeof(u8) != 1 || sizeof(u16) != 2 || sizeof(u32) != 4 || sizeof(u64) != 8 ||
        -:   32:		sizeof(u128) != 16 || sizeof(i8) != 1 || sizeof(i16) != 2 || sizeof(i32) != 4 ||
        -:   33:		sizeof(i64) != 8 || sizeof(i128) != 16 || sizeof(f32) != 4 || sizeof(f64) != 8 ||
        -:   34:		sizeof(bool) != 1) {
        -:   35:		fprintf(stderr, "Invalid data type size! Check your c compiler configuration options.\n");
        -:   36:		exit(EXIT_FAILURE);
        -:   37:	}
        -:   38:
       69:   39:	if (!__is_little_endian()) {
    #####:   40:		fprintf(stderr, "Big endian systems not supported");
    #####:   41:		exit(EXIT_FAILURE);
        -:   42:	}
       69:   43:}
        -:    0:Source:lexer.c
        -:    0:Graph:lexer.gcno
        -:    0:Data:lexer.gcda
        -:    0:Runs:17
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/misc.h>
        -:   17:#include <errno.h>
        -:   18:#include <lexer/lexer.h>
        -:   19:#include <lexer/lexer_state.h>
        -:   20:#include <lexer/tokenizer_state.h>
        -:   21:#include <stdio.h>
        -:   22:#include <stdlib.h>
        -:   23:#include <string.h>
        -:   24:
      297:   25:char *lexer_read_line(Lexer *l) {
      297:   26:	char *ret = NULL;
      297:   27:	u64 count = 0;
        2:   28:	while (true) {
      299:   29:		if (ret == NULL) {
      297:   30:			ret = mymalloc(sizeof(char) * LEXER_BUF_SIZE);
      297:   31:			strcpy(ret, "");
        -:   32:		} else {
        2:   33:			char *tmp = myrealloc(ret, sizeof(char) * LEXER_BUF_SIZE * (1 + count));
        2:   34:			if (tmp == NULL) {
    #####:   35:				myfree(ret);
    #####:   36:				return NULL;
        -:   37:			}
        2:   38:			ret = tmp;
        -:   39:		}
      299:   40:		u64 str_len = strlen(ret);
      299:   41:		if (myfgets(ret + str_len, LEXER_BUF_SIZE, l->fp) == NULL) {
        5:   42:			myfree(ret);
        5:   43:			return NULL;
        -:   44:		}
        -:   45:
      294:   46:		count += 1;
      294:   47:		str_len = strlen(ret);
      294:   48:		if (str_len >= (count * (LEXER_BUF_SIZE - 1)))
        2:   49:			continue;
        -:   50:
      292:   51:		return ret;
        -:   52:	}
        -:   53:}
        -:   54:
        5:   55:int lexer_init(Lexer *l, const Path *file) {
        -:   56:	// file/lexer cannot be null
        5:   57:	if (file == NULL || l == NULL) {
    #####:   58:		errno = EINVAL;
    #####:   59:		return LexerStateErr;
        -:   60:	}
        -:   61:
        5:   62:	l->fp = NULL;
        5:   63:	l->tokenizer = NULL;
        5:   64:	l->line_num = 1;
        -:   65:
        5:   66:	if (path_copy(&l->file, file)) {
    #####:   67:		errno = ENOMEM;
    #####:   68:		return LexerStateErr;
        -:   69:	}
        -:   70:
        -:   71:	// open the file for reading
        5:   72:	l->fp = myfopen(file, "r");
        -:   73:
        -:   74:	// if file cannot be read return error
        5:   75:	if (l->fp == NULL) {
    #####:   76:		return LexerStateErr;
        -:   77:	}
        -:   78:
        -:   79:	// allocate memory for the tokenizer
        5:   80:	l->tokenizer = mymalloc(sizeof(Tokenizer));
        -:   81:
        5:   82:	if (l->tokenizer == NULL) {
        -:   83:		// memory allocation err
    #####:   84:		lexer_cleanup(l);
    #####:   85:		return LexerStateErr;
        -:   86:	}
        -:   87:
        5:   88:	char *buf = lexer_read_line(l);
        5:   89:	if (buf == NULL) {
    #####:   90:		lexer_cleanup(l);
    #####:   91:		return LexerStateErr;
        -:   92:	}
        -:   93:
        -:   94:	// try to init the tokenizer
        5:   95:	if (tokenizer_init(l->tokenizer, buf) != TokenizerStateOk) {
    #####:   96:		lexer_cleanup(l);
    #####:   97:		myfree(buf);
    #####:   98:		return LexerStateErr;
        -:   99:	} else {
        5:  100:		myfree(buf);
        5:  101:		return LexerStateOk;
        -:  102:	}
        -:  103:}
        -:  104:
      964:  105:int lexer_next_token(Lexer *l, Token *token) {
        -:  106:	// read the next token
      964:  107:	int state = tokenizer_next_token(l->tokenizer, token);
      964:  108:	char *line = NULL;
      964:  109:	token->span = NULL;
        -:  110:
        -:  111:	// if we're complete keep trying to get more lines until we have a token
        -:  112:	// or we're at the end of file
     1251:  113:	while (state == TokenizerStateComplete || state == TokenizerStateCompleteInComment) {
        -:  114:		// cleanup the previous tokenizer
      292:  115:		tokenizer_cleanup(l->tokenizer);
        -:  116:
      292:  117:		char *buf = lexer_read_line(l);
        -:  118:
      292:  119:		if (buf == NULL) {
        5:  120:			if (line)
        1:  121:				myfree(line);
        5:  122:			if (state == TokenizerStateCompleteInComment)
    #####:  123:				return LexerStateErr;
        -:  124:			else
        5:  125:				return LexerStateComplete;
        -:  126:		}
        -:  127:
      287:  128:		l->line_num += 1;
        -:  129:
        -:  130:		// try to init again
      287:  131:		if (tokenizer_init(l->tokenizer, buf) != TokenizerStateOk) {
    #####:  132:			myfree(buf);
    #####:  133:			if (line) {
    #####:  134:				myfree(line);
        -:  135:			}
    #####:  136:			return LexerStateErr;
        -:  137:		}
        -:  138:
      287:  139:		state = tokenizer_next_token(l->tokenizer, token);
      287:  140:		if (line)
       89:  141:			myfree(line);
      287:  142:		line = mymalloc(sizeof(char) * (1 + strlen(buf)));
      287:  143:		strcpy(line, buf);
      287:  144:		myfree(buf);
        -:  145:	}
        -:  146:
      959:  147:	if (line == NULL) {
      762:  148:		line = mymalloc((strlen(l->tokenizer->s) + 1) * sizeof(char));
      762:  149:		strcpy(line, l->tokenizer->s);
        -:  150:	}
        -:  151:
      959:  152:	if (state == TokenizerStateOk) {
      956:  153:		token->line_num = l->line_num;
      956:  154:		if (line == NULL)
    #####:  155:			token->span = NULL;
      956:  156:		else {
      956:  157:			int num_width = snprintf(NULL, 0, "%llu", l->line_num);
      956:  158:			int token_width = snprintf(NULL, 0, "%s", token->token);
        -:  159:			char spacer[100];
      956:  160:			int lsl = (l->tokenizer->pos + 1) - (token_width - 1);
      956:  161:			if (lsl <= 0)
    #####:  162:				lsl = 1;
      956:  163:			char long_spacer[lsl];
      956:  164:			bool has_tab = false;
    39764:  165:			for (int i = 0; i < lsl; i++) {
    38808:  166:				if (i < l->tokenizer->pos && l->tokenizer->s[i] == '\t') {
     1423:  167:					has_tab = true;
     1423:  168:					long_spacer[i] = '\t';
        -:  169:				} else {
    37385:  170:					long_spacer[i] = ' ';
        -:  171:				}
        -:  172:			}
      956:  173:			if (has_tab)
      798:  174:				long_spacer[lsl - 2] = 0;
      956:  175:			long_spacer[lsl - 1] = 0;
     3401:  176:			for (int i = 0; i < num_width && i < 100; i++) {
     2445:  177:				spacer[i] = ' ';
        -:  178:			}
      956:  179:			if (num_width < 100)
      956:  180:				spacer[num_width] = 0;
        -:  181:
        -:  182:			int span_len =
     1912:  183:				snprintf(NULL, 0,
        -:  184:						 "%s%s-->%s %s:%llu:%i\n%s %s|\n%llu | %s%s"
        -:  185:						 "%s %s|%s%s^\n",
      956:  186:						 spacer, CYAN, RESET, path_to_string(&l->file), l->line_num, lsl, spacer,
        -:  187:						 CYAN, l->line_num, RESET, line, spacer, CYAN, RESET, long_spacer);
      956:  188:			token->span = mymalloc((span_len + 1) * sizeof(char));
      956:  189:			if (token->span == NULL) {
    #####:  190:				myfree(line);
    #####:  191:				return LexerStateErr;
        -:  192:			}
     1912:  193:			snprintf(token->span, span_len + 1,
        -:  194:					 "%s%s-->%s %s:%llu:%i\n%s %s|\n%llu | %s%s"
        -:  195:					 "%s %s|%s%s^\n",
      956:  196:					 spacer, CYAN, RESET, path_to_string(&l->file), l->line_num, lsl, spacer, CYAN,
        -:  197:					 l->line_num, RESET, line, spacer, CYAN, RESET, long_spacer);
      956:  198:			myfree(line);
        -:  199:		}
        -:  200:
      956:  201:		return LexerStateOk;
        -:  202:	} else {
        3:  203:		if (line)
        3:  204:			myfree(line);
        3:  205:		return LexerStateErr;
        -:  206:	}
        -:  207:}
        -:  208:
        8:  209:void lexer_cleanup(Lexer *l) {
        -:  210:	// check if fp is NULL and close it then set to NULL so this can be
        -:  211:	// called multiple times
        8:  212:	if (l->fp != NULL) {
        5:  213:		myfclose(l->fp);
        5:  214:		l->fp = NULL;
        -:  215:	}
        -:  216:
        -:  217:	// same for the tokenizer
        8:  218:	if (l->tokenizer != NULL) {
        5:  219:		tokenizer_cleanup(l->tokenizer);
        5:  220:		myfree(l->tokenizer);
        5:  221:		l->tokenizer = NULL;
        -:  222:	}
        -:  223:
        -:  224:	// cleanup file path
        8:  225:	path_cleanup(&l->file);
        8:  226:}
        -:    0:Source:tokenizer.c
        -:    0:Graph:tokenizer.gcno
        -:    0:Data:tokenizer.gcda
        -:    0:Runs:17
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/resources.h>
        -:   17:#include <errno.h>
        -:   18:#include <lexer/tokenizer.h>
        -:   19:#include <lexer/tokenizer_state.h>
        -:   20:#include <stdarg.h>
        -:   21:#include <stdio.h>
        -:   22:#include <string.h>
        -:   23:
      318:   24:int tokenizer_init(Tokenizer *t, const char *line) {
        -:   25:	// check input
      318:   26:	if (line == NULL || t == NULL) {
        1:   27:		errno = EINVAL;
        1:   28:		return TokenizerStateErr;
        -:   29:	}
        -:   30:
        -:   31:	// copy the input string
      317:   32:	t->len = strlen(line);
      317:   33:	t->s = mymalloc(sizeof(char) * (1 + t->len));
      317:   34:	if (t->s == NULL) {
        1:   35:		return TokenizerStateErr;
        -:   36:	}
      316:   37:	strcpy(t->s, line);
        -:   38:
        -:   39:	// set pos to 0
      316:   40:	t->pos = 0;
        -:   41:
      316:   42:	t->in_comment = false;
        -:   43:
      316:   44:	return TokenizerStateOk;
        -:   45:}
        -:   46:
     2506:   47:bool tokenizer_is_white_space(Tokenizer *t) {
     2506:   48:	char ch = t->s[t->pos];
        -:   49:	// check for std whitespace chars
     2506:   50:	if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\v' || ch == '\f' || ch == '\r')
     1225:   51:		return true;
     1281:   52:	return false;
        -:   53:}
        -:   54:
     1487:   55:int tokenizer_skip_comments(Tokenizer *t, Token *next) {
     1487:   56:	if (t->pos + 1 >= t->len)
      312:   57:		return TokenizerStateOk;
        -:   58:
     1175:   59:	char ch1 = t->s[t->pos];
     1175:   60:	char ch2 = t->s[t->pos + 1];
     1175:   61:	bool is_doc_comment = false;
        -:   62:
     1267:   63:	if (ch1 == '/' && ch2 == '/') {
       92:   64:		u64 start_doc = t->pos;
       92:   65:		if (t->pos + 2 < t->len) {
        -:   66:			// check if we're in a doc comment
       91:   67:			if (t->s[t->pos + 2] == '/') {
        -:   68:				// in doc comment
       13:   69:				is_doc_comment = true;
       13:   70:				t->pos = t->pos + 3;
       13:   71:				start_doc = t->pos;
        -:   72:			}
        -:   73:		}
        -:   74:
       92:   75:		bool found_start = false;
        -:   76:
        -:   77:		while (true) {
     3861:   78:			if (t->pos >= t->len || t->s[t->pos] == '\n')
        -:   79:				break;
        -:   80:
     3769:   81:			if (!found_start && tokenizer_is_white_space(t)) {
       23:   82:				start_doc = t->pos + 1;
        -:   83:			} else {
     3746:   84:				found_start = true;
        -:   85:			}
     3769:   86:			t->pos += 1;
        -:   87:		}
        -:   88:
       92:   89:		if (is_doc_comment) {
       13:   90:			next->type = TokenTypeDoc;
       13:   91:			u64 end_doc = t->pos;
       13:   92:			if (end_doc < start_doc)
    #####:   93:				end_doc = start_doc;
       13:   94:			u64 doc_size = end_doc - start_doc;
       13:   95:			next->token = mymalloc(sizeof(char) * (doc_size + 1));
       13:   96:			memcpy(next->token, t->s + start_doc, doc_size);
       13:   97:			next->token[doc_size] = 0;
        -:   98:		}
        -:   99:
     1083:  100:	} else if (ch1 == '/' && ch2 == '*') {
       12:  101:		t->in_comment = true;
       12:  102:		t->pos += 1;
        -:  103:		while (true) {
      172:  104:			if (t->pos >= t->len || (t->s[t->pos - 1] == '*' && t->s[t->pos] == '/')) {
       12:  105:				if (t->pos < t->len) {
       11:  106:					t->in_comment = false;
       11:  107:					t->pos += 1;
        -:  108:				}
        -:  109:
       16:  110:				while (t->pos < t->len) {
       12:  111:					if (!tokenizer_is_white_space(t))
        8:  112:						break;
        4:  113:					t->pos += 1;
        -:  114:				}
       12:  115:				break;
        -:  116:			}
      160:  117:			t->pos += 1;
        -:  118:		}
        -:  119:	}
        -:  120:
     1175:  121:	return TokenizerStateOk;
        -:  122:}
        -:  123:
     2685:  124:int tokenizer_skip_white_space(Tokenizer *t, Token *next) {
        -:  125:	while (true) {
        -:  126:		// if we're at the end of the string or not in white space break
     2685:  127:		if (t->pos >= t->len || !tokenizer_is_white_space(t))
        -:  128:			break;
        -:  129:
     1198:  130:		t->pos += 1;
        -:  131:	}
        -:  132:
     1487:  133:	return TokenizerStateOk;
        -:  134:}
        -:  135:
     1487:  136:int tokenizer_skip_to_token(Tokenizer *t, Token *next) {
        -:  137:	while (true) {
     1487:  138:		tokenizer_skip_white_space(t, next);
     1487:  139:		tokenizer_skip_comments(t, next);
        -:  140:
     1487:  141:		if (t->pos >= t->len || (t->s[t->pos] != '\n' && t->s[t->pos] != '/') ||
       89:  142:			next->type == TokenTypeDoc)
        -:  143:			break;
        -:  144:	}
        -:  145:
     1410:  146:	if (t->pos >= t->len && next->type != TokenTypeDoc) {
      315:  147:		if (t->in_comment)
        1:  148:			return TokenizerStateCompleteInComment;
      314:  149:		return TokenizerStateComplete;
        -:  150:	}
        -:  151:
     1095:  152:	return TokenizerStateOk;
        -:  153:}
        -:  154:
      414:  155:int tokenizer_proc_ident(Tokenizer *t, Token *next) {
      414:  156:	next->type = TokenTypeIdent;
      414:  157:	u64 start = t->pos;
     3588:  158:	while (true) {
        -:  159:		// if we're at the end of the string, break
     4002:  160:		if (t->pos >= t->len)
        3:  161:			break;
        -:  162:
     3999:  163:		char ch = t->s[t->pos];
        -:  164:
        -:  165:		// continue until non-ident char
     3999:  166:		if (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_' ||
     2427:  167:			  (ch >= '0' && ch <= '9'))) {
        -:  168:			break;
        -:  169:		}
     3588:  170:		t->pos += 1;
        -:  171:	}
      414:  172:	u64 end = t->pos;
      414:  173:	u64 tlen = end - start;
        -:  174:
        -:  175:	// allocate and copy over the token
      414:  176:	next->token = mymalloc(sizeof(char) * (tlen + 1));
      414:  177:	if (next->token == NULL)
    #####:  178:		return TokenizerStateErr;
      414:  179:	memcpy(next->token, t->s + start, tlen);
      414:  180:	next->token[tlen] = 0;
        -:  181:
      414:  182:	return TokenizerStateOk;
        -:  183:}
        -:  184:
       12:  185:int tokenizer_proc_string_literal(Tokenizer *t, Token *next) {
       12:  186:	next->type = TokenTypeStringLiteral;
       12:  187:	u64 start = t->pos;
       97:  188:	while (true) {
        -:  189:		// if we're at the end of the string, break
      109:  190:		if (t->pos >= t->len)
    #####:  191:			break;
        -:  192:
      109:  193:		char ch = t->s[t->pos];
        -:  194:
        -:  195:		// continue until literal termination char
      109:  196:		if (ch == '\"' && t->pos != start) {
       12:  197:			t->pos += 1;
       12:  198:			break;
        -:  199:		}
       97:  200:		t->pos += 1;
        -:  201:	}
       12:  202:	u64 end = t->pos;
       12:  203:	u64 tlen = end - start;
        -:  204:
        -:  205:	// allocate and copy over the token
       12:  206:	next->token = mymalloc(sizeof(char) * (tlen + 1));
       12:  207:	if (next->token == NULL)
    #####:  208:		return TokenizerStateErr;
       12:  209:	memcpy(next->token, t->s + start, tlen);
       12:  210:	next->token[tlen] = 0;
        -:  211:
       12:  212:	return TokenizerStateOk;
        -:  213:}
        -:  214:
        1:  215:int tokenizer_proc_char_literal(Tokenizer *t, Token *next) {
        1:  216:	next->type = TokenTypeCharLiteral;
        1:  217:	u64 start = t->pos;
        2:  218:	while (true) {
        -:  219:		// if we're at the end of the string, break
        3:  220:		if (t->pos >= t->len)
    #####:  221:			break;
        -:  222:
        3:  223:		char ch = t->s[t->pos];
        -:  224:
        -:  225:		// continue until literal termination char
        3:  226:		if (ch == '\'' && t->pos != start) {
        1:  227:			t->pos += 1;
        1:  228:			break;
        -:  229:		}
        2:  230:		t->pos += 1;
        -:  231:	}
        1:  232:	u64 end = t->pos;
        1:  233:	u64 tlen = end - start;
        -:  234:
        -:  235:	// allocate and copy over the token
        1:  236:	next->token = mymalloc(sizeof(char) * (tlen + 1));
        1:  237:	if (next->token == NULL)
    #####:  238:		return TokenizerStateErr;
        1:  239:	memcpy(next->token, t->s + start, tlen);
        1:  240:	next->token[tlen] = 0;
        -:  241:
        1:  242:	return TokenizerStateOk;
        -:  243:}
        -:  244:
       76:  245:int tokenizer_proc_num_literal(Tokenizer *t, Token *next) {
       76:  246:	int ret = TokenizerStateOk;
       76:  247:	next->type = TokenTypeNumLiteral;
       76:  248:	u64 start = t->pos;
      195:  249:	while (true) {
        -:  250:		// if we're at the end of the string, break
      271:  251:		if (t->pos >= t->len)
        4:  252:			break;
        -:  253:
      267:  254:		char ch = t->s[t->pos];
        -:  255:
        -:  256:		// continue until literal termination char (we allow all
        -:  257:		// chars needed for the various types at the tokenizer
        -:  258:		// level. Checking the order, etc is done at a later
        -:  259:		// phase)
      267:  260:		if (t->pos == start) {
       76:  261:			if (!(ch == '-' || (ch >= '0' && ch <= '9')))
        -:  262:				break;
      261:  263:		} else if (!((ch >= '0' && ch <= '9') || ch == '.' || ch == '_' || ch == 'u' || ch == 'i' ||
       77:  264:					 ch == 's' || ch == 'z' || ch == 'e' || ch == 'f' || ch == 'x'))
       69:  265:			break;
      198:  266:		if (ch == '.') {
       10:  267:			if (next->type == TokenTypeFloatLiteral) {
        -:  268:				// cannot have more than one dot.
        3:  269:				return TokenizerStateErr;
        -:  270:			}
        7:  271:			next->type = TokenTypeFloatLiteral;
        -:  272:		}
      195:  273:		t->pos += 1;
        -:  274:	}
       73:  275:	u64 end = t->pos;
       73:  276:	u64 tlen = end - start;
        -:  277:
        -:  278:	// special case of lone minus sign is a punct, not a literal
       73:  279:	if (tlen == 1 && t->s[start] == '-') {
       20:  280:		next->type = TokenTypePunct;
        -:  281:		// we also must deal with these: -= and ->
       20:  282:		if (t->pos < t->len) {
       20:  283:			if (t->s[t->pos] == '=' || t->s[t->pos] == '>') {
       18:  284:				t->pos += 1;
       18:  285:				end = t->pos;
       18:  286:				tlen = end - start;
        -:  287:			}
        -:  288:		}
        -:  289:	}
        -:  290:
        -:  291:	// allocate and copy over the token
       73:  292:	next->token = mymalloc(sizeof(char) * (tlen + 1));
       73:  293:	if (next->token == NULL)
    #####:  294:		return TokenizerStateErr;
       73:  295:	memcpy(next->token, t->s + start, tlen);
       73:  296:	next->token[tlen] = 0;
        -:  297:
       73:  298:	return ret;
        -:  299:}
        -:  300:
      574:  301:bool is_second_punct(char ch1, char ch2) {
      574:  302:	if (ch1 == '!' && ch2 == '=')
        2:  303:		return true;
     572*:  304:	if (ch1 == '%' && ch2 == '%')
    #####:  305:		return true;
      572:  306:	if (ch1 == '&' && (ch2 == '&' || ch2 == '='))
    #####:  307:		return true;
      572:  308:	if (ch1 == '*' && ch2 == '=')
    #####:  309:		return true;
      572:  310:	if (ch1 == '+' && ch2 == '=')
        2:  311:		return true;
     570*:  312:	if (ch1 == '-' && (ch2 == '=' || ch2 == '>'))
    #####:  313:		return true;
     570*:  314:	if (ch1 == '/' && ch2 == '=')
    #####:  315:		return true;
     570*:  316:	if (ch1 == '^' && ch2 == '=')
    #####:  317:		return true;
      570:  318:	if (ch1 == '|' && (ch2 == '=' || ch2 == '|'))
    #####:  319:		return true;
      570:  320:	if (ch1 == '=' && (ch2 == '>' || ch2 == '='))
        6:  321:		return true;
      564:  322:	if (ch1 == ':' && ch2 == ':')
       17:  323:		return true;
      547:  324:	if (ch1 == '<' && (ch2 == '<' || ch2 == '=' || ch2 == '-'))
    #####:  325:		return true;
      547:  326:	if (ch1 == '>' && (ch2 == '>' || ch2 == '='))
    #####:  327:		return true;
      547:  328:	if (ch1 == '.' && ch2 == '.')
    #####:  329:		return true;
        -:  330:
      547:  331:	return false;
        -:  332:}
    #####:  333:bool is_third_punct(char ch1, char ch2, char ch3) {
    #####:  334:	if (ch1 == '<' && ch2 == '<' && ch3 == '=')
    #####:  335:		return true;
    #####:  336:	if (ch1 == '>' && ch2 == '>' && ch3 == '=')
    #####:  337:		return true;
    #####:  338:	if (ch1 == '.' && ch2 == '.' && ch3 == '.')
    #####:  339:		return true;
    #####:  340:	if (ch1 == '.' && ch2 == '.' && ch3 == '=')
    #####:  341:		return true;
    #####:  342:	return false;
        -:  343:}
        -:  344:
      579:  345:int tokenizer_proc_punct(Tokenizer *t, Token *next) {
      579:  346:	next->type = TokenTypePunct;
        -:  347:
      579:  348:	char ch1 = t->s[t->pos];
      579:  349:	char ch2 = t->pos + 1 < t->len && is_second_punct(ch1, t->s[t->pos + 1]) ? t->s[t->pos + 1] : 0;
     579*:  350:	char ch3 = t->pos + 2 < t->len && ch3 != 0 && is_third_punct(ch1, ch2, t->s[t->pos + 2])
    #####:  351:				   ? t->s[t->pos + 2]
        -:  352:				   : 0;
        -:  353:
        -:  354:	// allocate and copy over the token
      579:  355:	next->token = mymalloc(sizeof(char) * 5);
      579:  356:	if (next->token == NULL)
    #####:  357:		return TokenizerStateErr;
        -:  358:
      579:  359:	next->token[0] = ch1;
      579:  360:	next->token[1] = ch2;
      579:  361:	next->token[2] = ch3;
      579:  362:	next->token[4] = 0;
        -:  363:
      579:  364:	t->pos += 1;
      579:  365:	if (ch2 != 0)
       27:  366:		t->pos += 1;
     579*:  367:	if (ch3 != 0 && ch2 != 0)
    #####:  368:		t->pos += 1;
        -:  369:
      579:  370:	return TokenizerStateOk;
        -:  371:}
        -:  372:
     1410:  373:int tokenizer_next_token(Tokenizer *t, Token *next) {
     1410:  374:	next->span = NULL;
     1410:  375:	next->type = TokenTypeIdent; // init so that we know when it's been set to doc
        -:  376:	// first skip all whitespace / comments
     1410:  377:	int skip = tokenizer_skip_to_token(t, next);
     1410:  378:	if (skip != TokenizerStateOk || next->type == TokenTypeDoc)
      328:  379:		return skip;
        -:  380:
        -:  381:	// check first char to determine which type of token we're in
     1082:  382:	char first = t->s[t->pos];
     1082:  383:	if ((first >= 'a' && first <= 'z') || (first >= 'A' && first <= 'Z') || first == '_') {
        -:  384:		// ident
      414:  385:		int ret = tokenizer_proc_ident(t, next);
        -:  386:
        -:  387:		// special cases
      414:  388:		if (ret == TokenizerStateOk &&
      414:  389:			(!strcmp(next->token, "true") || !strcmp(next->token, "false"))) {
        3:  390:			next->type = TokenTypeBoolLiteral;
        -:  391:		}
      414:  392:		return ret;
      668:  393:	} else if (first == '\"') {
        -:  394:		// string literal
       12:  395:		return tokenizer_proc_string_literal(t, next);
      656:  396:	} else if (first == '\'') {
        -:  397:		// char literal
        1:  398:		return tokenizer_proc_char_literal(t, next);
      655:  399:	} else if ((first >= '0' && first <= '9') || first == '-') {
        -:  400:		// number literal
       76:  401:		return tokenizer_proc_num_literal(t, next);
        -:  402:	} else {
        -:  403:		// punct or error
      579:  404:		return tokenizer_proc_punct(t, next);
        -:  405:	}
        -:  406:}
        -:  407:
      326:  408:void tokenizer_cleanup(Tokenizer *t) {
        -:  409:	// check if it's null to be safe in case it's called twice
      326:  410:	if (t->s != NULL) {
      316:  411:		myfree(t->s);
      316:  412:		t->s = NULL;
        -:  413:	}
      326:  414:}
        -:  415:
     1107:  416:void token_cleanup(Token *t) {
        -:  417:	// check if it's null to be safe in case it's called twice
     1107:  418:	if (t->token != NULL) {
     1092:  419:		myfree(t->token);
     1092:  420:		t->token = NULL;
        -:  421:	}
        -:  422:
        -:  423:	// check if it's null to be safe in case it's called twice
     1107:  424:	if (t->span != NULL) {
      957:  425:		myfree(t->span);
      957:  426:		t->span = NULL;
        -:  427:	}
     1107:  428:}
        -:  429:
        -:  430:typedef enum TokenDisplayType {
        -:  431:	TokenDisplayTypeError = 0,
        -:  432:	TokenDisplayTypeWarning = 1
        -:  433:} TokenDisplayType;
        -:  434:
        2:  435:int token_display_impl(const Token *token, TokenDisplayType type, const char *fmt,
        -:  436:					   va_list va_args) {
        2:  437:	if (type == TokenDisplayTypeError)
        1:  438:		fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
        -:  439:	else
        1:  440:		fprintf(stderr, "%sWarning%s: ", YELLOW, RESET);
        2:  441:	vfprintf(stderr, fmt, va_args);
        2:  442:	fprintf(stderr, "\n%s", token->span);
        2:  443:	return 0;
        -:  444:}
        -:  445:
        1:  446:int token_display_error(const Token *token, const char *fmt, ...) {
        -:  447:	va_list va_args;
        1:  448:	va_start(va_args, fmt);
        1:  449:	int ret = token_display_impl(token, TokenDisplayTypeError, fmt, va_args);
        1:  450:	va_end(va_args);
        1:  451:	return ret;
        -:  452:}
        -:  453:
        1:  454:int token_display_warning(const Token *token, const char *fmt, ...) {
        -:  455:	va_list va_args;
        1:  456:	va_start(va_args, fmt);
        1:  457:	int ret = token_display_impl(token, TokenDisplayTypeWarning, fmt, va_args);
        1:  458:	va_end(va_args);
        1:  459:	return ret;
        -:  460:}
        -:    0:Source:faml.c
        -:    0:Graph:faml.gcno
        -:    0:Data:faml.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <faml/parser.h>
        -:   17:
        -:   18:typedef enum FamlType {
        -:   19:	FamlTypeObj,
        -:   20:	FamlTypeArray,
        -:   21:	FamlTypeTuple,
        -:   22:	FamlTypeI8,
        -:   23:	FamlTypeI16,
        -:   24:} FamlType;
        -:   25:
        -:   26:typedef struct FamlObjImpl {
        -:   27:	FamlType *types;
        -:   28:	void *data;
        -:   29:} FamlObjImpl;
        -:   30:
        1:   31:void famlobj_cleanup(FamlObj *obj) {
        1:   32:	if (obj->opaque) {
        1:   33:		myfree(obj->opaque);
        1:   34:		obj->opaque = NULL;
        -:   35:	}
        1:   36:}
        -:   37:
        1:   38:int famlobj_init(FamlObj *obj) {
        1:   39:	obj->opaque = mymalloc(sizeof(FamlObjImpl));
        1:   40:	if (obj->opaque == NULL)
    #####:   41:		return -1;
        1:   42:	return 0;
        -:   43:}
    #####:   44:int famlobj_add_i8(FamlObj *obj, const char *key, const i8 value) {
    #####:   45:	return 0;
        -:   46:}
    #####:   47:int famlobj_add_i16(FamlObj *obj, const char *key, const i16 value) {
    #####:   48:	return 0;
        -:   49:}
        -:    0:Source:rbtree.c
        -:    0:Graph:rbtree.gcno
        -:    0:Data:rbtree.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <base/chain_alloc.h>
        -:   17:#include <base/macro_utils.h>
        -:   18:#include <base/panic.h>
        -:   19:#include <base/resources.h>
        -:   20:#include <errno.h>
        -:   21:#include <math.h>
        -:   22:#include <stdio.h>
        -:   23:#include <string.h>
        -:   24:#include <util/rbtree.h>
        -:   25:
        -:   26:#define BOOLEAN_SIZE 1
        -:   27:#define KEY_PAD 0
        -:   28:#define VALUE_PAD(key_size) (16 - (key_size % 16))
        -:   29:#define RED_OFFSET(key_size, value_size) (KEY_PAD + key_size + value_size + VALUE_PAD(key_size))
        -:   30:#define RED(node, key_size, value_size) *(bool *)(node->data + RED_OFFSET(key_size, value_size))
        -:   31:
        -:   32:typedef struct RBTreeNode {
        -:   33:	FatPtr self;
        -:   34:	struct RBTreeNode *right;
        -:   35:	struct RBTreeNode *left;
        -:   36:	struct RBTreeNode *parent;
        -:   37:	// bool red;
        -:   38:	char data[];
        -:   39:} RBTreeNode;
        -:   40:
        -:   41:typedef struct RBTreeImpl {
        -:   42:	u64 key_size;
        -:   43:	u64 value_size;
        -:   44:	int (*compare)(const void *, const void *);
        -:   45:	RBTreeNode *root;
        -:   46:	u64 size;
        -:   47:	bool send;
        -:   48:} RBTreeImpl;
        -:   49:
        -:   50:typedef struct RBTreeIteratorImpl {
        -:   51:	RBTreeNode *cur;
        -:   52:	RBTreeNode *stack[128];
        -:   53:	u64 key_size;
        -:   54:	u8 stack_pointer;
        -:   55:	bool send;
        -:   56:} RBTreeIteratorImpl;
        -:   57:
        4:   58:void rbtree_iterator_cleanup(RBTreeIteratorNc *ptr) {
        4:   59:	if (ptr != NULL && !nil(ptr->impl)) {
        -:   60:		// obtain referent to internal RBTreeImpl structure
        4:   61:		RBTreeIteratorImpl *impl = $Ref(&ptr->impl);
        -:   62:		// set appropriate chainguard status
        8:   63:		ChainGuard _ = ChainSend(impl->send);
        -:   64:
        -:   65:		// free RBTreeImpl structure
        4:   66:		chain_free(&ptr->impl);
        -:   67:	}
        4:   68:}
        -:   69:
     1008:   70:bool rbtree_iterator_next(RBTreeIterator *ptr, RbTreeKeyValue *kv) {
     1008:   71:	RBTreeIteratorImpl *impl = $Ref(&ptr->impl);
        -:   72:
        -:   73:	// If the iterator is empty, we're done
     1008:   74:	if (!impl->cur && impl->stack_pointer == 0) {
        3:   75:		return false; // No more nodes to traverse
        -:   76:	}
        -:   77:
        -:   78:	// Traverse the tree
     2010:   79:	while (impl->cur || impl->stack_pointer > 0) {
        -:   80:		// Traverse left subtree
     2010:   81:		if (impl->cur) {
     1005:   82:			if (impl->stack_pointer < 128) {
        -:   83:				// Push the current node pointer onto the stack
     1005:   84:				impl->stack[impl->stack_pointer++] = impl->cur;
        -:   85:			} else {
    #####:   86:				panic("Iterator stack overflow");
        -:   87:			}
        -:   88:
        -:   89:			// Move to the left child
     1005:   90:			impl->cur = impl->cur->left;
        -:   91:		} else {
        -:   92:			// Pop the top node from the stack
     1005:   93:			impl->cur = impl->stack[--impl->stack_pointer];
        -:   94:
        -:   95:			// Store the current node's data to return
     1005:   96:			void *ret = impl->cur->data;
        -:   97:
        -:   98:			// Move to the right child after visiting this node
     1005:   99:			impl->cur = impl->cur->right;
        -:  100:
     1005:  101:			kv->key = ret + KEY_PAD;
     1005:  102:			kv->value = ret + KEY_PAD + VALUE_PAD(impl->key_size) + impl->key_size;
     1005:  103:			return true; // Return the node's data
        -:  104:		}
        -:  105:	}
        -:  106:
    #####:  107:	return false; // Traversal complete
        -:  108:}
        -:  109:
        -:  110:// Utility function to perform left rotation
      323:  111:void leftRotate(RBTree *ptr, RBTreeNode *x) {
      323:  112:	RBTreeImpl *impl = $Ref(&ptr->impl);
      323:  113:	RBTreeNode *y = x->right;
      323:  114:	x->right = y->left;
      323:  115:	if (y->left != NULL) {
       98:  116:		y->left->parent = x;
        -:  117:	}
      323:  118:	y->parent = x->parent;
      323:  119:	if (x->parent == NULL) {
        4:  120:		impl->root = y;
      319:  121:	} else if (x == x->parent->left) {
      187:  122:		x->parent->left = y;
        -:  123:	} else {
      132:  124:		x->parent->right = y;
        -:  125:	}
      323:  126:	y->left = x;
      323:  127:	x->parent = y;
      323:  128:}
        -:  129:
        -:  130:// Utility function to perform right rotation
      321:  131:void rightRotate(RBTree *ptr, RBTreeNode *x) {
      321:  132:	RBTreeImpl *impl = $Ref(&ptr->impl);
      321:  133:	RBTreeNode *y = x->left;
      321:  134:	x->left = y->right;
      321:  135:	if (y->right != NULL) {
       97:  136:		y->right->parent = x;
        -:  137:	}
      321:  138:	y->parent = x->parent;
      321:  139:	if (x->parent == NULL) {
        3:  140:		impl->root = y;
      318:  141:	} else if (x == x->parent->right) {
      209:  142:		x->parent->right = y;
        -:  143:	} else {
      109:  144:		x->parent->left = y;
        -:  145:	}
      321:  146:	y->right = x;
      321:  147:	x->parent = y;
      321:  148:}
        -:  149:
     1010:  150:void rbtree_fix_up(RBTree *ptr, RBTreeNode *k) {
     1010:  151:	RBTreeImpl *impl = $Ref(&ptr->impl);
     1010:  152:	u64 key_size = impl->key_size;
     1010:  153:	u64 value_size = impl->value_size;
        -:  154:
     1902:  155:	while (k && k != impl->root && k->parent && RED(k->parent, key_size, value_size)) {
        -:  156:
      892:  157:		if (k->parent == k->parent->parent->left) {
      440:  158:			RBTreeNode *u = k->parent->parent->right; // Uncle
        -:  159:
      440:  160:			if (u && RED(u, key_size, value_size)) {
        -:  161:				// Case 1: Uncle is red
      260:  162:				RED(k->parent, key_size, value_size) = false;		 // Parent to black
      260:  163:				RED(u, key_size, value_size) = false;				 // Uncle to black
      260:  164:				RED(k->parent->parent, key_size, value_size) = true; // GP to red
      260:  165:				k = k->parent->parent;								 // Move up
        -:  166:			} else {
        -:  167:				// Case 2: Uncle is black or NULL
      180:  168:				if (k == k->parent->right) {
       89:  169:					k = k->parent;
       89:  170:					leftRotate(ptr, k);
        -:  171:				}
      180:  172:				RED(k->parent, key_size, value_size) = false;		 // Parent to black
      180:  173:				RED(k->parent->parent, key_size, value_size) = true; // GP to red
      180:  174:				rightRotate(ptr, k->parent->parent);
        -:  175:			}
        -:  176:		} else {
      452:  177:			RBTreeNode *u = k->parent->parent->left; // Uncle
        -:  178:
      452:  179:			if (u && RED(u, key_size, value_size)) {
        -:  180:				// Case 1: Uncle is red
      249:  181:				RED(k->parent, key_size, value_size) = false;		 // Parent to black
      249:  182:				RED(u, key_size, value_size) = false;				 // Uncle to black
      249:  183:				RED(k->parent->parent, key_size, value_size) = true; // GP to red
      249:  184:				k = k->parent->parent;								 // Move up
        -:  185:			} else {
        -:  186:				// Case 2: Uncle is black or NULL
      203:  187:				if (k == k->parent->left) {
      100:  188:					k = k->parent;
      100:  189:					rightRotate(ptr, k);
        -:  190:				}
      203:  191:				RED(k->parent, key_size, value_size) = false;		 // Parent to black
      203:  192:				RED(k->parent->parent, key_size, value_size) = true; // GP to red
      203:  193:				leftRotate(ptr, k->parent->parent);
        -:  194:			}
        -:  195:		}
        -:  196:
        -:  197:		// After the adjustments, check the colors again for debugging
        -:  198:	}
        -:  199:
        -:  200:	// Ensure the root is always black
     1010:  201:	if (impl->root) {
     1010:  202:		RED(impl->root, key_size, value_size) = false;
        -:  203:	}
     1010:  204:}
        -:  205:
      561:  206:void rbtree_delete_fixup(RBTree *ptr, RBTreeNode *x) {
      561:  207:	RBTreeImpl *impl = $Ref(&ptr->impl);
      561:  208:	u64 key_size = impl->key_size;
      561:  209:	u64 value_size = impl->value_size;
        -:  210:
      735:  211:	while (x != impl->root && (!x || !RED(x, key_size, value_size))) {
      573:  212:		if (x == NULL || x->parent == NULL) {
        -:  213:			break; // No more fixup needed, exit the loop
        -:  214:		}
        -:  215:
      174:  216:		if (x == x->parent->left) {
       78:  217:			RBTreeNode *w = x->parent->right; // sibling
        -:  218:
       78:  219:			if (w != NULL && RED(w, key_size, value_size)) {
       12:  220:				RED(w, key_size, value_size) = false;		 // Case 1: Sibling is red
       12:  221:				RED(x->parent, key_size, value_size) = true; // Parent becomes red
       12:  222:				leftRotate(ptr, x->parent);					 // Rotate around parent
       12:  223:				w = x->parent->right;						 // Update w to the new sibling
        -:  224:			}
        -:  225:
       78:  226:			if (w == NULL) {
       14:  227:				x = x->parent; // Move up the tree if the sibling is NULL
       64:  228:			} else if ((!w->left || !RED(w->left, key_size, value_size)) &&
       53:  229:					   (!w->right || !RED(w->right, key_size, value_size))) {
       48:  230:				RED(w, key_size, value_size) = true; // Case 2: Both children are black
       48:  231:				x = x->parent;						 // Move up the tree
        -:  232:			} else {
       16:  233:				if (!w->right || !RED(w->right, key_size, value_size)) {
        -:  234:					// Case 3: Left child is red, right child is black
        7:  235:					if (w->left) {
        7:  236:						RED(w->left, key_size, value_size) = false; // Set left child to black
        -:  237:					}
        7:  238:					RED(w, key_size, value_size) = true; // Set sibling to red
        7:  239:					rightRotate(ptr, w);				 // Rotate around w
        7:  240:					w = x->parent->right;				 // Update w
        -:  241:				}
        -:  242:
        -:  243:				// Case 4: Right child is red
       16:  244:				RED(w, key_size, value_size) =
       16:  245:					RED(x->parent, key_size, value_size);	  // Copy parent's color
       16:  246:				RED(x->parent, key_size, value_size) = false; // Parent becomes black
       16:  247:				if (w->right) {
       16:  248:					RED(w->right, key_size, value_size) = false; // Make the right child black
        -:  249:				}
       16:  250:				leftRotate(ptr, x->parent); // Rotate around parent
       16:  251:				x = impl->root;				// Break out of the loop
        -:  252:			}
        -:  253:		} else {
       96:  254:			RBTreeNode *w = x->parent->left; // sibling
        -:  255:
       96:  256:			if (w != NULL && RED(w, key_size, value_size)) {
       16:  257:				RED(w, key_size, value_size) = false;		 // Case 1: Sibling is red
       16:  258:				RED(x->parent, key_size, value_size) = true; // Parent becomes red
       16:  259:				rightRotate(ptr, x->parent);				 // Rotate around parent
       16:  260:				w = x->parent->left;						 // Update w to the new sibling
        -:  261:			}
        -:  262:
       96:  263:			if (w == NULL) {
        9:  264:				x = x->parent; // Move up the tree if the sibling is NULL
       87:  265:			} else if ((!w->right || !RED(w->right, key_size, value_size)) &&
       84:  266:					   (!w->left || !RED(w->left, key_size, value_size))) {
       69:  267:				RED(w, key_size, value_size) = true; // Case 2: Both children are black
       69:  268:				x = x->parent;						 // Move up the tree
        -:  269:			} else {
       18:  270:				if (!w->left || !RED(w->left, key_size, value_size)) {
        -:  271:					// Case 3: Right child is red, left child is black
        3:  272:					if (w->right) {
        3:  273:						RED(w->right, key_size, value_size) = false; // Set right child to black
        -:  274:					}
        3:  275:					RED(w, key_size, value_size) = true; // Set sibling to red
        3:  276:					leftRotate(ptr, w);					 // Rotate around w
        3:  277:					w = x->parent->left;				 // Update w
        -:  278:				}
        -:  279:
        -:  280:				// Case 4: Left child is red
       18:  281:				RED(w, key_size, value_size) =
       18:  282:					RED(x->parent, key_size, value_size);	  // Copy parent's color
       18:  283:				RED(x->parent, key_size, value_size) = false; // Parent becomes black
       18:  284:				if (w->left) {
       18:  285:					RED(w->left, key_size, value_size) = false; // Make the left child black
        -:  286:				}
       18:  287:				rightRotate(ptr, x->parent); // Rotate around parent
       18:  288:				x = impl->root;				 // Break out of the loop
        -:  289:			}
        -:  290:		}
        -:  291:	}
      561:  292:	if (impl->size != 0 && x) {
      160:  293:		RED(x, key_size, value_size) = false; // Ensure the root is black
        -:  294:	}
      561:  295:}
        -:  296:
        -:  297:// Rbtree build function has the 'send' parameter. This parameter indicates whether or
        -:  298:// not the Rbtree can be send into another thread. If it can be sent into another
        -:  299:// thread, the globaly sync allocator is used for all functions.
        4:  300:int rbtree_build(RBTree *ptr, const u64 key_size, const u64 value_size,
        -:  301:				 int (*compare)(const void *, const void *), bool send) {
        -:  302:	// Obtain the chainguard based on the boolean 'send'. If this is a send, the
        -:  303:	// ChainGuard macro returns the global sync allocator's send guard and all memory
        -:  304:	// allocations will use the thread-safe global_sync allocator. Otherwise, the thread
        -:  305:	// local version will be used.
        8:  306:	ChainGuard _ = ChainSend(send);
        -:  307:
        -:  308:	// validate input
        4:  309:	if (ptr == NULL || key_size == 0 || value_size == 0 || compare == NULL) {
    #####:  310:		errno = EINVAL;
    #####:  311:		return -1;
        -:  312:	}
        -:  313:
        -:  314:	// try to allocate required size for RBTreeImpl
        4:  315:	if (chain_malloc(&ptr->impl, sizeof(RBTreeImpl))) {
        -:  316:		// set the fatptr to null so it's not cleaned up in cleanup function
    #####:  317:		ptr->impl = null;
    #####:  318:		return -1;
        -:  319:	}
        -:  320:
        -:  321:	// Obtain the reference to the fat pointers data using the $Ref macro
        4:  322:	RBTreeImpl *impl = $Ref(&ptr->impl);
        -:  323:
        -:  324:	// initialize values of the RBTree structure
        4:  325:	impl->send = send;
        4:  326:	impl->key_size = key_size;
        4:  327:	impl->value_size = value_size;
        4:  328:	impl->compare = compare;
        4:  329:	impl->root = NULL;
        4:  330:	impl->size = 0;
        -:  331:
        -:  332:	// return success
        4:  333:	return 0;
        -:  334:}
        -:  335:
       20:  336:void rbtree_free_node(RBTreeNode *ptr) {
       20:  337:	if (ptr != NULL) {
        8:  338:		rbtree_free_node(ptr->right);
        8:  339:		rbtree_free_node(ptr->left);
        8:  340:		chain_free(&ptr->self);
        -:  341:	}
       20:  342:}
        -:  343:
        -:  344:// cleanup function selects appropriate ChainGuard based on configuration and
        -:  345:// deallocates memory
        4:  346:void rbtree_cleanup(RBTreeNc *ptr) {
        -:  347:	// check non-initialized conditions
        4:  348:	if (ptr != NULL && !nil(ptr->impl)) {
        -:  349:		// obtain referent to internal RBTree structure
        4:  350:		RBTreeImpl *impl = $Ref(&ptr->impl);
        -:  351:		// set appropriate chainguard status
        8:  352:		ChainGuard _ = ChainSend(impl->send);
        -:  353:
        4:  354:		rbtree_free_node(impl->root);
        -:  355:
        -:  356:		// free RBTreeImpl structure
        4:  357:		chain_free(&ptr->impl);
        -:  358:	}
        4:  359:}
        -:  360:
     1010:  361:int rbtree_insert(RBTree *ptr, const void *key, const void *value) {
     1010:  362:	if (ptr == NULL || nil(ptr->impl)) {
    #####:  363:		errno = EINVAL;
    #####:  364:		return -1;
        -:  365:	}
     1010:  366:	RBTreeImpl *impl = $Ref(&ptr->impl);
     2020:  367:	ChainGuard _ = ChainSend(impl->send);
     1010:  368:	RBTreeNode *parent = NULL;
     1010:  369:	RBTreeNode *check = impl->root;
     1010:  370:	bool is_right = false;
        -:  371:
     8811:  372:	loop {
     9821:  373:		RBTreeNode *node = NULL;
     9821:  374:		if (check == NULL) {
        -:  375:			FatPtr self;
     1010:  376:			u64 size = sizeof(RBTreeNode) + (impl->key_size + impl->value_size) * sizeof(char) +
     1010:  377:					   KEY_PAD + VALUE_PAD(impl->key_size) + BOOLEAN_SIZE;
     1010:  378:			if (chain_malloc(&self, size)) {
    #####:  379:				return -1;
        -:  380:			}
     1010:  381:			node = $Ref(&self);
     1010:  382:			if (impl->root == NULL)
        5:  383:				impl->root = node;
     1005:  384:			else if (is_right)
      502:  385:				parent->right = node;
        -:  386:			else
      503:  387:				parent->left = node;
        -:  388:
     1010:  389:			memcpy((char *)node->data + KEY_PAD, key, impl->key_size);
     1010:  390:			memcpy(node->data + KEY_PAD + VALUE_PAD(impl->key_size) + impl->key_size, value,
     1010:  391:				   impl->value_size);
     1010:  392:			node->data[KEY_PAD + VALUE_PAD(impl->key_size) + impl->key_size + impl->value_size] =
        -:  393:				true;
     1010:  394:			node->self = self;
     1010:  395:			node->right = NULL;
     1010:  396:			node->left = NULL;
     1010:  397:			node->parent = parent;
     1010:  398:			impl->size++;
     1010:  399:			rbtree_fix_up(ptr, node);
     1010:  400:			break;
        -:  401:		}
     8811:  402:		parent = check;
     8811:  403:		int v = impl->compare(check->data + KEY_PAD, key);
     8811:  404:		if (v == 0) {
    #####:  405:			return -1;
     8811:  406:		} else if (v < 0) {
     4350:  407:			is_right = true;
     4350:  408:			check = check->right;
        -:  409:		} else {
     4461:  410:			is_right = false;
     4461:  411:			check = check->left;
        -:  412:		}
        -:  413:	}
        -:  414:
     1010:  415:	return 0;
        -:  416:}
        -:  417:
     1002:  418:int rbtree_delete(RBTree *ptr, const void *key) {
     1002:  419:	if (ptr == NULL || nil(ptr->impl)) {
    #####:  420:		errno = EINVAL;
    #####:  421:		return -1;
        -:  422:	}
        -:  423:
     1002:  424:	RBTreeImpl *impl = $Ref(&ptr->impl);
     1002:  425:	u64 key_size = impl->key_size;
     1002:  426:	u64 value_size = impl->value_size;
     2004:  427:	ChainGuard _ = ChainSend(impl->send);
        -:  428:
     1002:  429:	RBTreeNode *check = impl->root;
     1002:  430:	RBTreeNode *nodeToDelete = NULL; // Node to be deleted
     1002:  431:	RBTreeNode *child = NULL;		 // Child to replace the node
     1002:  432:	bool wasBlack = false;			 // To track if the deleted node is black
        -:  433:
        -:  434:	// Find the node to delete
     8727:  435:	while (check != NULL) {
     8727:  436:		int v = impl->compare(check->data + KEY_PAD, key);
     8727:  437:		if (v == 0) {
     1002:  438:			nodeToDelete = check; // Found the node to delete
     1002:  439:			break;
     7725:  440:		} else if (v < 0) {
     3740:  441:			check = check->right;
        -:  442:		} else {
     3985:  443:			check = check->left;
        -:  444:		}
        -:  445:	}
        -:  446:
     1002:  447:	if (nodeToDelete == NULL) {
    #####:  448:		return -1; // Node not found
        -:  449:	}
        -:  450:
        -:  451:	// Store the color of the node to delete
     1002:  452:	wasBlack = !RED(nodeToDelete, key_size, value_size);
     1002:  453:	FatPtr fptr_to_delete = nodeToDelete->self;
        -:  454:	// Case 1: Node has two children
     1002:  455:	if (nodeToDelete->left != NULL && nodeToDelete->right != NULL) {
        -:  456:		// Find the in-order successor (smallest node in the right subtree)
      187:  457:		RBTreeNode *successor = nodeToDelete->right;
      254:  458:		while (successor->left != NULL) {
       67:  459:			successor = successor->left;
        -:  460:		}
        -:  461:
        -:  462:		// Copy the successor's data to the node to delete
      187:  463:		memcpy(nodeToDelete->data + KEY_PAD, successor->data + KEY_PAD,
      187:  464:			   (impl->key_size + impl->value_size + VALUE_PAD(impl->key_size)) + BOOLEAN_SIZE);
        -:  465:
      187:  466:		nodeToDelete->self = successor->self;
        -:  467:
        -:  468:		// Now we need to delete the successor
      187:  469:		nodeToDelete = successor; // Update to the successor nodeAA
        -:  470:	}
        -:  471:
        -:  472:	// Case 2: Node has at most one child
     1002:  473:	child = (nodeToDelete->left != NULL) ? nodeToDelete->left : nodeToDelete->right;
        -:  474:
        -:  475:	// Remove nodeToDelete from the tree
     1002:  476:	if (child != NULL) {
      225:  477:		child->parent = nodeToDelete->parent; // Update childs parent
        -:  478:	}
        -:  479:
     1002:  480:	if (nodeToDelete->parent == NULL) {
        -:  481:		// Node is root
        2:  482:		impl->root = child; // Update the root if necessary
        -:  483:	} else {
        -:  484:		// Update the parent's child pointer
     1000:  485:		if (nodeToDelete == nodeToDelete->parent->left) {
      469:  486:			nodeToDelete->parent->left = child; // Update left child
        -:  487:		} else {
      531:  488:			nodeToDelete->parent->right = child; // Update right child
        -:  489:		}
        -:  490:	}
        -:  491:
        -:  492:	// Free the node
     1002:  493:	chain_free(&fptr_to_delete);
        -:  494:
     1002:  495:	impl->size--;
        -:  496:	// If the deleted node was black, we need to fix up the tree
     1002:  497:	if (wasBlack) {
      561:  498:		rbtree_delete_fixup(ptr, child); // Call fix-up function
        -:  499:	}
     1002:  500:	return 0; // Successful deletion
        -:  501:}
        -:  502:
        -:  503:int max_depth = 0;
        -:  504:
     1011:  505:const void *rbtree_get(const RBTree *ptr, const void *key) {
     1011:  506:	if (ptr == NULL || nil(ptr->impl)) {
    #####:  507:		errno = EINVAL;
    #####:  508:		return NULL;
        -:  509:	}
     1011:  510:	RBTreeImpl *impl = $Ref(&ptr->impl);
        -:  511:
     1011:  512:	RBTreeNode *check = impl->root;
     1011:  513:	int local_depth = 0;
     8286:  514:	loop {
     9297:  515:		if (check == NULL)
        4:  516:			return NULL;
     9293:  517:		int v = impl->compare(check->data + KEY_PAD, key);
     9293:  518:		if (v == 0) {
     1007:  519:			return check->data + KEY_PAD + impl->key_size + VALUE_PAD(impl->key_size);
     8286:  520:		} else if (v < 0) {
     4103:  521:			check = check->right;
        -:  522:		} else {
     4183:  523:			check = check->left;
        -:  524:		}
     8286:  525:		local_depth++;
     8286:  526:		if (local_depth > max_depth) {
        -:  527:
       13:  528:			max_depth = local_depth;
       13:  529:			printf("new max_depth=%i\n", max_depth);
        -:  530:		}
        -:  531:	}
        -:  532:
        -:  533:	return NULL;
        -:  534:}
        -:  535:
     1008:  536:i64 rbtree_size(const RBTree *ptr) {
     1008:  537:	if (ptr == NULL || nil(ptr->impl)) {
    #####:  538:		errno = EINVAL;
    #####:  539:		return -1;
        -:  540:	}
     1008:  541:	RBTreeImpl *impl = $Ref(&ptr->impl);
     1008:  542:	return impl->size;
        -:  543:}
        -:  544:
        4:  545:int rbtree_iterator(const RBTree *ptr, RBTreeIterator *iter) {
        4:  546:	if (ptr == NULL || nil(ptr->impl)) {
    #####:  547:		errno = EINVAL;
    #####:  548:		return -1;
        -:  549:	}
        -:  550:
        4:  551:	RBTreeImpl *impl = $Ref(&ptr->impl);
        4:  552:	ChainGuard _ = ChainSend(impl->send);
        -:  553:
        4:  554:	chain_malloc(&iter->impl, sizeof(RBTreeIteratorImpl));
        4:  555:	RBTreeIteratorImpl *rbimpl = $Ref(&iter->impl);
        4:  556:	rbimpl->stack_pointer = 0;
        4:  557:	rbimpl->cur = impl->root;
        4:  558:	rbimpl->send = impl->send;
        4:  559:	rbimpl->key_size = impl->key_size;
        4:  560:	return 0;
        -:  561:}
        -:  562:
  1002015:  563:bool validate_rbtree(const RBTree *ptr, const RBTreeNode *node, int *black_count,
        -:  564:					 int current_black_count) {
  1002015:  565:	RBTreeImpl *impl = $Ref(&ptr->impl);
  1002015:  566:	u64 key_size = impl->key_size;
  1002015:  567:	u64 value_size = impl->value_size;
        -:  568:
        -:  569:	// Base case: when we reach a NIL node
  1002015:  570:	if (node == NULL) {
        -:  571:		// If this is the first NIL node reached, set the black count
   501509:  572:		if (*black_count == 0) {
     1003:  573:			*black_count = current_black_count; // Set the black count for the first path
        -:  574:		} else {
        -:  575:			// Check for black count consistency
   500506:  576:			if (current_black_count != *black_count) {
    #####:  577:				printf("NIL node reached: current_black_count = %d, expected_black_count = %d\n",
        -:  578:					   current_black_count, *black_count);
    #####:  579:				return false; // If counts do not match, return false
        -:  580:			}
        -:  581:		}
   501509:  582:		return true; // Return true for NIL nodes
        -:  583:	}
        -:  584:
        -:  585:	// Increment black count if the current node is black
   500506:  586:	if (!RED(node, key_size, value_size)) {
   256710:  587:		current_black_count++;
        -:  588:	} else {
        -:  589:		//  Check if the node is red
        -:  590:		//  If the parent is red, return false (Red property violation)
   243796:  591:		if (node->parent != NULL && RED(node->parent, key_size, value_size)) {
    #####:  592:			printf("Red property violation at node with key\n");
    #####:  593:			return false;
        -:  594:		}
        -:  595:	}
        -:  596:
        -:  597:	// Recursive calls for left and right children
   500506:  598:	bool left_valid = validate_rbtree(ptr, node->left, black_count, current_black_count);
        -:  599:
   500506:  600:	bool right_valid = validate_rbtree(ptr, node->right, black_count, current_black_count);
        -:  601:
  500506*:  602:	return left_valid && right_valid;
        -:  603:}
        -:  604:
     1003:  605:bool rbtree_validate(const RBTree *ptr) {
     1003:  606:	RBTreeImpl *impl = $Ref(&ptr->impl);
     1003:  607:	int black_count = 0;
        -:  608:	// Validate from the root and check if the root is black
     1003:  609:	if (impl->root != NULL) {
     1003:  610:		if (!RED(impl->root, impl->key_size, impl->value_size)) {
     1003:  611:			bool ret = validate_rbtree(ptr, impl->root, &black_count, 0);
     1003:  612:			return ret;
        -:  613:		}
    #####:  614:		printf("root is not black\n");
    #####:  615:		return false; // Root should be black
        -:  616:	}
    #####:  617:	return true;
        -:  618:}
