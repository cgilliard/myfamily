        -:    0:Source:backtrace.c
        -:    0:Graph:backtrace.gcno
        -:    0:Data:backtrace.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/backtrace.h>
        -:   16:#include <base/colors.h>
        -:   17:#include <base/fam_err.h>
        -:   18:#include <base/types.h>
        -:   19:
    #####:   20:i32 backtrace_generate(Backtrace *ptr) {
    #####:   21:	return 0;
        -:   22:}
        -:   23:
    #####:   24:void backtrace_print(const Backtrace *ptr) {
    #####:   25:}
        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/deps.h>
        -:   17:
        -:   18:#ifdef __linux__
        -:   19:#define getenv(x) secure_getenv(x)
        -:   20:#endif // __linux__
        -:   21:
    #####:   22:char *get_dimmed() {
    #####:   23:	if (getenv("NO_COLOR") != NULL) {
    #####:   24:		return "";
        -:   25:	} else {
    #####:   26:		return "\x1b[2m";
        -:   27:	}
        -:   28:}
        -:   29:
    #####:   30:char *get_red() {
    #####:   31:	if (getenv("NO_COLOR") != NULL) {
    #####:   32:		return "";
        -:   33:	} else {
    #####:   34:		return "\x1b[31m";
        -:   35:	}
        -:   36:}
        -:   37:
    #####:   38:char *get_bright_red() {
    #####:   39:	if (getenv("NO_COLOR") != NULL) {
    #####:   40:		return "";
        -:   41:	} else {
    #####:   42:		return "\x1b[91m";
        -:   43:	}
        -:   44:}
        -:   45:
    #####:   46:char *get_green() {
    #####:   47:	if (getenv("NO_COLOR") != NULL) {
    #####:   48:		return "";
        -:   49:	} else {
    #####:   50:		return "\x1b[32m";
        -:   51:	}
        -:   52:}
        -:   53:
    #####:   54:char *get_yellow() {
    #####:   55:	if (getenv("NO_COLOR") != NULL) {
    #####:   56:		return "";
        -:   57:	} else {
    #####:   58:		return "\x1b[33m";
        -:   59:	}
        -:   60:}
        -:   61:
    #####:   62:char *get_cyan() {
    #####:   63:	if (getenv("NO_COLOR") != NULL) {
    #####:   64:		return "";
        -:   65:	} else {
    #####:   66:		return "\x1b[36m";
        -:   67:	}
        -:   68:}
        -:   69:
    #####:   70:char *get_magenta() {
    #####:   71:	if (getenv("NO_COLOR") != NULL) {
    #####:   72:		return "";
        -:   73:	} else {
    #####:   74:		return "\x1b[35m";
        -:   75:	}
        -:   76:}
        -:   77:
    #####:   78:char *get_blue() {
    #####:   79:	if (getenv("NO_COLOR") != NULL) {
    #####:   80:		return "";
        -:   81:	} else {
    #####:   82:		return "\x1b[34m";
        -:   83:	}
        -:   84:}
        -:   85:
    #####:   86:char *get_reset() {
    #####:   87:	if (getenv("NO_COLOR") != NULL) {
    #####:   88:		return "";
        -:   89:	} else {
    #####:   90:		return "\x1b[0m";
        -:   91:	}
        -:   92:}
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/deps.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/macro_util.h>
        -:   18:#include <base/misc.h>
        -:   19:#include <base/print_util.h>
        -:   20:
        -:   21:_Thread_local u8 fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local i32 fam_err = NoErrors;
        -:   24:_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const u8 *get_err() {
    #####:   27:	return mystrcpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
        -:   28:}
        -:   29:
    #####:   30:void print_err(const u8 *text) {
    #####:   31:	println("%s: %s", FamErrText[fam_err], text);
    #####:   32:	if (getenv("CBACKTRACE") != NULL) {
        -:   33:		// backtrace_print(&thread_local_bt__);
        -:   34:	} else {
    #####:   35:		println("Backtrace currently disabled set env variable CBACKTRACE to enable");
        -:   36:	}
    #####:   37:}
        -:   38:
    #####:   39:void do_backtrace_generate(Backtrace *bt) {
    #####:   40:	if (getenv("CBACKTRACE") != NULL) {
        -:   41:		// backtrace_generate(bt);
        -:   42:	}
    #####:   43:}
        -:    0:Source:mem_util.c
        -:    0:Graph:mem_util.gcno
        -:    0:Data:mem_util.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/mem_util.h>
        -:   17:#include <base/types.h>
        -:   18:
        -:   19:// set memory at memory location 'ptr' of size 'size' to 0.
    #####:   20:void memzero(void *ptr, u64 size) {
    #####:   21:	if (!ptr) {
    #####:   22:		SetErr(IllegalArgument);
    #####:   23:		return;
        -:   24:	}
    #####:   25:	if (size == 0)
    #####:   26:		return;
    #####:   27:	while (size--)
    #####:   28:		*(u8 *)ptr = '\0';
        -:   29:}
        -:    0:Source:misc.c
        -:    0:Graph:misc.gcno
        -:    0:Data:misc.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/misc.h>
        -:   17:#include <base/types.h>
        -:   18:
        7:   19:i32 mymemcmp(const u8 *X, const u8 *Y, u64 len) {
        7:   20:	if (!X || !Y) {
    #####:   21:		SetErr(IllegalArgument);
    #####:   22:		return -1;
        -:   23:	}
        7:   24:	if (len == 0)
    #####:   25:		return 0;
       17:   26:	while (*X && *Y && len--) {
       17:   27:		if (*X > *Y)
    #####:   28:			return 1;
       17:   29:		else if (*X < *Y)
    #####:   30:			return -1;
        -:   31:
       17:   32:		X++;
       17:   33:		Y++;
       17:   34:		if (len == 0)
        7:   35:			return 0;
        -:   36:	}
    #####:   37:	if (*X != '\0')
    #####:   38:		return -1;
        -:   39:	else
    #####:   40:		return 1;
        -:   41:}
        -:   42:
       11:   43:i32 mystrcmp(const u8 *X, const u8 *Y) {
       11:   44:	if (!X || !Y) {
    #####:   45:		SetErr(IllegalArgument);
    #####:   46:		return -1;
        -:   47:	}
       45:   48:	while (*X && *Y) {
       38:   49:		if (*X > *Y)
        2:   50:			return 1;
       36:   51:		else if (*X < *Y)
        2:   52:			return -1;
        -:   53:
       34:   54:		X++;
       34:   55:		Y++;
        -:   56:	}
        -:   57:
        7:   58:	if (*X != '\0')
        1:   59:		return 1;
        -:   60:
        6:   61:	else if (*Y != '\0')
        1:   62:		return -1;
        -:   63:	else
        5:   64:		return 0;
        -:   65:}
        -:   66:
       20:   67:i32 mystrlen(const u8 *Y) {
       20:   68:	if (!Y) {
    #####:   69:		SetErr(IllegalArgument);
    #####:   70:		return -1;
        -:   71:	}
       20:   72:	u64 ret = 0;
       90:   73:	while (*Y) {
       70:   74:		ret++;
       70:   75:		Y++;
       70:   76:		if (ret == INT32_MAX) {
    #####:   77:			SetErr(Overflow);
    #####:   78:			return -1;
        -:   79:		}
        -:   80:	}
       20:   81:	return ret;
        -:   82:}
        -:   83:
       11:   84:const u8 *mystrstr(const u8 *X, const u8 *Y) {
       11:   85:	if (!X || !Y) {
    #####:   86:		SetErr(IllegalArgument);
    #####:   87:		return NULL;
        -:   88:	}
       11:   89:	u64 len = mystrlen(Y);
       83:   90:	while (*X != '\0') {
        -:   91:
       79:   92:		if ((*X == *Y) && !mymemcmp(X, Y, len)) {
        7:   93:			return X;
        -:   94:		}
        -:   95:
       72:   96:		X++;
        -:   97:	}
        -:   98:
        4:   99:	return NULL;
        -:  100:}
        -:  101:
        6:  102:u8 *mystrcpy(u8 *X, const u8 *Y, u64 limit) {
        6:  103:	if (!X || !Y) {
    #####:  104:		SetErr(IllegalArgument);
    #####:  105:		return NULL;
        -:  106:	}
        6:  107:	u8 *ret = X;
        -:  108:
        6:  109:	if (limit == 0)
    #####:  110:		return ret;
        6:  111:	limit--;
        -:  112:
       54:  113:	while (*Y != '\0' && limit) {
       48:  114:		*X = *Y;
       48:  115:		X++;
       48:  116:		Y++;
       48:  117:		limit--;
        -:  118:	}
        6:  119:	*X = '\0';
        6:  120:	return ret;
        -:  121:}
        -:  122:
        6:  123:void *mymemcpy(void *X, const void *Y, u64 limit) {
        6:  124:	if (!X || !Y) {
    #####:  125:		SetErr(IllegalArgument);
    #####:  126:		return NULL;
        -:  127:	}
        6:  128:	u8 *ret = X;
        6:  129:	if (limit == 0)
    #####:  130:		return ret;
        -:  131:
       34:  132:	while (limit) {
       28:  133:		*(u8 *)X = *(u8 *)Y;
       28:  134:		X++;
       28:  135:		Y++;
       28:  136:		limit--;
        -:  137:	}
        -:  138:
        6:  139:	return ret;
        -:  140:}
        -:  141:
        -:  142:// A utility function to reverse a string
        3:  143:void reverse(u8 str[], u64 length) {
        3:  144:	int start = 0;
        3:  145:	int end = length - 1;
        8:  146:	while (start < end) {
        5:  147:		char temp = str[start];
        5:  148:		str[start] = str[end];
        5:  149:		str[end] = temp;
        5:  150:		end--;
        5:  151:		start++;
        -:  152:	}
        3:  153:}
        -:  154:
        1:  155:u8 *citoau64(u64 num, u8 *str, u64 base) {
        1:  156:	u64 i = 0;
        -:  157:
        1:  158:	if (num == 0) {
    #####:  159:		str[i++] = '0';
    #####:  160:		str[i] = '\0';
    #####:  161:		return str;
        -:  162:	}
        -:  163:
        4:  164:	while (num != 0) {
        3:  165:		u64 rem = num % base;
       3*:  166:		str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
        3:  167:		num = num / base;
        -:  168:	}
        -:  169:
        1:  170:	str[i] = '\0';
        -:  171:
        1:  172:	reverse(str, i);
        -:  173:
        1:  174:	return str;
        -:  175:}
        -:  176:
        2:  177:u8 *citoai64(i64 num, u8 *str, u64 base) {
        2:  178:	u64 i = 0;
        2:  179:	bool isNegative = false;
        -:  180:
        2:  181:	if (num == 0) {
    #####:  182:		str[i++] = '0';
    #####:  183:		str[i] = '\0';
    #####:  184:		return str;
        -:  185:	}
        -:  186:
        2:  187:	if (num < 0 && base == 10) {
        1:  188:		isNegative = true;
        1:  189:		num = -num;
        -:  190:	}
        -:  191:
       10:  192:	while (num != 0) {
        8:  193:		u64 rem = num % base;
       8*:  194:		str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
        8:  195:		num = num / base;
        -:  196:	}
        -:  197:
        2:  198:	if (isNegative)
        1:  199:		str[i++] = '-';
        -:  200:
        2:  201:	str[i] = '\0';
        -:  202:
        2:  203:	reverse(str, i);
        -:  204:
        2:  205:	return str;
        -:  206:}
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/deps.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/macro_util.h>
        -:   18:#include <base/misc.h>
        -:   19:#include <base/print_util.h>
        -:   20:
        -:   21:// get the va functionality (with GCC/Clang use the builtin version, otherwise use stdarg)
        -:   22:#if defined(__GNUC__) || defined(__clang__)
        -:   23:typedef __builtin_va_list va_list;
        -:   24:#define va_start(ap, param) __builtin_va_start(ap, param)
        -:   25:#define va_end(ap) __builtin_va_end(ap)
        -:   26:#define va_arg(ap, type) __builtin_va_arg(ap, type)
        -:   27:#else // __GNUC__ or __clang__
        -:   28:#include <stdarg.h>
        -:   29:#endif // __GNUC__ or __clang__
        -:   30:
        -:   31:#define BUF_LEN 64
        -:   32:
       13:   33:i32 write_loop(const Stream *strm, const u8 *buf, u64 len) {
       26:   34:	while (len > 0) {
       13:   35:		i64 w = write(strm->handle, buf, len);
       13:   36:		if (w < 0) {
    #####:   37:			SetErr(IO);
    #####:   38:			return w;
        -:   39:		}
        -:   40:
       13:   41:		len -= w;
        -:   42:	}
       13:   43:	return 0;
        -:   44:}
        -:   45:
        3:   46:i32 print_impl(const Stream *strm, u8 *s, i32 capacity, bool nl, bool do_exit, i32 code,
        -:   47:			   const u8 *prefix, const u8 *fmt, ...) {
        3:   48:	i32 ret = 0;
        -:   49:	va_list args;
        3:   50:	va_start(args, fmt);
        -:   51:
        3:   52:	if (prefix) {
    #####:   53:		if (write_loop(strm, prefix, mystrlen(prefix)))
    #####:   54:			ret = -1;
        -:   55:	}
        -:   56:
        4:   57:	loop {
        7:   58:		const u8 *next = mystrstr(fmt, "{}");
        -:   59:
        7:   60:		if (next == NULL) {
        3:   61:			if (write_loop(strm, fmt, mystrlen(fmt))) {
    #####:   62:				ret = -1;
    #####:   63:				break;
        -:   64:			}
        3:   65:			if (nl)
        2:   66:				if (write_loop(strm, "\n", 1)) {
    #####:   67:					ret = -1;
    #####:   68:					break;
        -:   69:				}
        3:   70:			break;
        4:   71:		} else {
        4:   72:			u64 diff = next - fmt;
        4:   73:			u8 buf[1 + diff];
        4:   74:			mystrcpy(buf, fmt, 1 + diff);
        4:   75:			if (write_loop(strm, buf, diff)) {
    #####:   76:				ret = -1;
    #####:   77:				break;
        -:   78:			}
        -:   79:		}
        -:   80:
        4:   81:		PrintPair arg = va_arg(args, PrintPair);
        -:   82:
        4:   83:		if (arg.type == PrintTypeTerm) {
    #####:   84:			if (next) {
    #####:   85:				if (write_loop(strm, next, mystrlen(next))) {
    #####:   86:					ret = -1;
    #####:   87:					break;
        -:   88:				}
    #####:   89:				if (nl)
    #####:   90:					if (write_loop(strm, "\n", 1)) {
    #####:   91:						ret = -1;
    #####:   92:						break;
        -:   93:					}
        -:   94:			}
    #####:   95:			break;
        4:   96:		} else if (arg.type == PrintTypeU64) {
        -:   97:			u64 value;
        1:   98:			mymemcpy(&value, arg.buf, sizeof(u64));
        -:   99:			u8 buf[BUF_LEN];
        1:  100:			citoau64(value, buf, 10);
        1:  101:			if (write_loop(strm, buf, mystrlen(buf))) {
    #####:  102:				ret = -1;
    #####:  103:				break;
        -:  104:			}
        3:  105:		} else if (arg.type == PrintTypeI32) {
        -:  106:			i32 value;
        1:  107:			mymemcpy(&value, arg.buf, sizeof(i32));
        -:  108:			u8 buf[BUF_LEN];
        1:  109:			citoai64(value, buf, 10);
        1:  110:			if (write_loop(strm, buf, mystrlen(buf))) {
    #####:  111:				ret = -1;
    #####:  112:				break;
        -:  113:			}
        2:  114:		} else if (arg.type == PrintTypeI16) {
        -:  115:			i16 value;
        1:  116:			mymemcpy(&value, arg.buf, sizeof(i16));
        -:  117:			u8 buf[BUF_LEN];
        1:  118:			citoai64(value, buf, 10);
        1:  119:			if (write_loop(strm, buf, mystrlen(buf))) {
    #####:  120:				ret = -1;
    #####:  121:				break;
        -:  122:			}
        1:  123:		} else if (arg.type == PrintTypeString) {
        1:  124:			if (write_loop(strm, arg.data, mystrlen(arg.data))) {
    #####:  125:				ret = -1;
    #####:  126:				break;
        -:  127:			}
        -:  128:		}
        4:  129:		fmt = next + 2;
        -:  130:	}
        -:  131:
        3:  132:	va_end(args);
        -:  133:
        3:  134:	if (do_exit) {
    #####:  135:		exit(code);
        -:  136:	}
        -:  137:
        3:  138:	return ret;
        -:  139:}
        -:    0:Source:resources.c
        -:    0:Graph:resources.gcno
        -:    0:Data:resources.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/deps.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <base/types.h>
        -:   19:
        -:   20:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   21:#ifdef TEST
        -:   22:bool __is_debug_malloc = false;
        -:   23:bool __is_debug_realloc = false;
        -:   24:u64 __is_debug_malloc_counter_ = UINT64_MAX;
        -:   25:u64 __is_debug_realloc_counter_ = UINT64_MAX;
        -:   26:#endif // TEST
        -:   27:
    #####:   28:void *mymalloc(u64 size) {
        -:   29:#ifdef TEST
    #####:   30:	if (__is_debug_malloc || __is_debug_malloc_counter_ == 0) {
    #####:   31:		__is_debug_malloc_counter_ = UINT64_MAX;
    #####:   32:		return NULL;
        -:   33:	}
    #####:   34:	__is_debug_malloc_counter_--;
        -:   35:#endif // TEST
        -:   36:	void *ret;
    #####:   37:	ret = malloc(size);
        -:   38:
    #####:   39:	if (ret) {
    #####:   40:		THREAD_LOCAL_RESOURCE_STATS.malloc_sum += 1;
        -:   41:	} else
    #####:   42:		SetErr(AllocErr);
    #####:   43:	return ret;
        -:   44:}
    #####:   45:void *myrealloc(void *ptr, u64 size) {
        -:   46:#ifdef TEST
    #####:   47:	if (__is_debug_realloc || __is_debug_realloc_counter_ == 0) {
    #####:   48:		__is_debug_realloc_counter_ = UINT64_MAX;
    #####:   49:		return NULL;
        -:   50:	}
    #####:   51:	__is_debug_realloc_counter_--;
        -:   52:#endif // TEST
        -:   53:	void *ret;
    #####:   54:	ret = realloc(ptr, size);
        -:   55:
    #####:   56:	if (ret) {
    #####:   57:		THREAD_LOCAL_RESOURCE_STATS.realloc_sum += 1;
        -:   58:	} else
    #####:   59:		SetErr(AllocErr);
    #####:   60:	return ret;
        -:   61:}
    #####:   62:void myfree(void *ptr) {
    #####:   63:	THREAD_LOCAL_RESOURCE_STATS.free_sum += 1;
    #####:   64:	free(ptr);
    #####:   65:}
        -:   66:
        -:   67:/*
        -:   68:MYFILE *myfopen(const Path *path, const char *mode) {
        -:   69:	const char *path_str = path_to_string(path);
        -:   70:	FILE *ret = fopen(path_str, mode);
        -:   71:	if (ret) {
        -:   72:		THREAD_LOCAL_RESOURCE_STATS.fopen_sum += 1;
        -:   73:	}
        -:   74:	return (MYFILE *)ret;
        -:   75:}
        -:   76:*/
        -:   77:
    #####:   78:void *mymalloc_no_stat(u64 size) {
    #####:   79:	return malloc(size);
        -:   80:}
        -:   81:
        -:   82:/*
        -:   83:void myfclose(MYFILE *ptr) {
        -:   84:	THREAD_LOCAL_RESOURCE_STATS.fclose_sum += 1;
        -:   85:	fclose((FILE *)ptr);
        -:   86:}
        -:   87:*/
    #####:   88:u64 mymalloc_sum() {
    #####:   89:	return THREAD_LOCAL_RESOURCE_STATS.malloc_sum;
        -:   90:}
    #####:   91:u64 myrealloc_sum() {
    #####:   92:	return THREAD_LOCAL_RESOURCE_STATS.realloc_sum;
        -:   93:}
    #####:   94:u64 myfree_sum() {
    #####:   95:	return THREAD_LOCAL_RESOURCE_STATS.free_sum;
        -:   96:}
    #####:   97:u64 myfopen_sum() {
    #####:   98:	return THREAD_LOCAL_RESOURCE_STATS.fopen_sum;
        -:   99:}
    #####:  100:u64 myfclose_sum() {
    #####:  101:	return THREAD_LOCAL_RESOURCE_STATS.fclose_sum;
        -:  102:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:8
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/panic.h>
        -:   16:#include <base/types.h>
        -:   17:
        8:   18:bool __is_little_endian() {
        8:   19:	u16 test = 0x1;
        8:   20:	return (*(u8 *)&test == 0x1);
        -:   21:}
        -:   22:
        8:   23:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   24:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   25:	panic("Error: This program requires a 64-bit architecture to run.");
        -:   26:#endif // arch
        -:   27:
        -:   28:	if (__SIZEOF_SIZE_T__ != 8)
        -:   29:		panic("Error: This program requires a 64-bit architecture to run.");
        -:   30:	if (sizeof(u8) != 1 || sizeof(u16) != 2 || sizeof(u32) != 4 || sizeof(u64) != 8 ||
        -:   31:		sizeof(u128) != 16 || sizeof(i8) != 1 || sizeof(i16) != 2 || sizeof(i32) != 4 ||
        -:   32:		sizeof(i64) != 8 || sizeof(i128) != 16 || sizeof(f32) != 4 || sizeof(f64) != 8 ||
        -:   33:		sizeof(bool) != 1) {
        -:   34:		panic("Invalid data type size! Check your c compiler configuration options.");
        -:   35:	}
        -:   36:
        8:   37:	if (!__is_little_endian()) {
    #####:   38:		panic("Big endian systems not supported");
        -:   39:	}
        -:   40:
        -:   41:	if (sizeof(au64) != 8) {
        -:   42:		panic("Error: Unexpected size for atomic_ullong. Check your compiler and architecture.");
        -:   43:	}
        -:   44:	if (sizeof(au32) != 4) {
        -:   45:		panic("Error: Unexpected size for atomic_uint. Check your compiler and architecture.");
        -:   46:	}
        8:   47:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
