        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
    #####:   16:int main(int argc, char **argv) {
    #####:   17:	return real_main(argc, argv);
        -:   18:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <base/version.h>
        -:   17:#include <bible/bible.h>
        -:   18:#include <build/build.h>
        -:   19:#include <core/std.h>
        -:   20:#include <dirent.h>
        -:   21:#include <errno.h>
        -:   22:#include <main/main.h>
        -:   23:#include <main/resources.h>
        -:   24:#include <stdio.h>
        -:   25:#include <string.h>
        -:   26:#include <sys/stat.h>
        -:   27:#include <unistd.h>
        -:   28:
    #####:   29:void build_args(Args *args)
    #####:   30:{
    #####:   31:	const char *home_dir = get_home_directory();
        -:   32:
    #####:   33:	args_build(args, "fam", FAM_VERSION, "The MyFamily Developers", 0, 0, 0);
        -:   34:
        -:   35:	// build the init SubCommand
        -:   36:	SubCommand init;
        -:   37:	ArgsParam cfg_dir;
    #####:   38:	args_param_build(&cfg_dir, "dir",
        -:   39:		"Directory to initialize the project in (defaults to "
        -:   40:		"the project name if not specified)",
        -:   41:		"p", true, false, NULL);
        -:   42:	ArgsParam cfg_authors;
    #####:   43:	args_param_build(&cfg_authors, "author", "Author of this project", "a", true, true,
        -:   44:		"The MyFamily Developers");
        -:   45:	ArgsParam cfg_lib;
    #####:   46:	args_param_build(&cfg_lib, "lib",
        -:   47:		"Initialize the project as a library project. (If not set, the project will be a binary "
        -:   48:		"project)",
        -:   49:		"l", false, false, NULL);
        -:   50:	ArgsParam cfg_description;
    #####:   51:	args_param_build(&cfg_description, "description",
        -:   52:		"Project description (defaults to the project name)", "d", true, false, NULL);
    #####:   53:	sub_command_build(&init, "init", "Initialize project", 1, 1, "<project_name>");
    #####:   54:	sub_command_add_param(&init, &cfg_dir);
    #####:   55:	sub_command_add_param(&init, &cfg_authors);
    #####:   56:	sub_command_add_param(&init, &cfg_lib);
    #####:   57:	sub_command_add_param(&init, &cfg_description);
        -:   58:
    #####:   59:	args_add_sub_command(args, &init);
        -:   60:
        -:   61:	// build the build SubCommand
        -:   62:	SubCommand build;
    #####:   63:	sub_command_build(&build, "build", "Build project in release mode", 0, 0, "");
        -:   64:
    #####:   65:	args_add_sub_command(args, &build);
        -:   66:
        -:   67:	// build the debug SubCommand
        -:   68:	SubCommand bdebug;
    #####:   69:	sub_command_build(&bdebug, "debug", "Build project in debug mode", 0, 0, "");
        -:   70:
    #####:   71:	args_add_sub_command(args, &bdebug);
        -:   72:
        -:   73:	// build the test SubCommand
        -:   74:	SubCommand test;
    #####:   75:	sub_command_build(&test, "test", "Run tests", 0, 0, "");
        -:   76:
    #####:   77:	args_add_sub_command(args, &test);
        -:   78:
        -:   79:	// build the doc SubCommand
        -:   80:	SubCommand doc;
    #####:   81:	sub_command_build(&doc, "doc", "Build documentation", 0, 0, "");
        -:   82:
    #####:   83:	args_add_sub_command(args, &doc);
        -:   84:
        -:   85:	// build the verse SubCommand
        -:   86:	SubCommand verse;
    #####:   87:	sub_command_build(&verse, "verse", "Print a random Bible verse", 0, 0, "");
        -:   88:	ArgsParam no_colors_param, book_param, chapter_param, verse_param;
    #####:   89:	args_param_build(
        -:   90:		&no_colors_param, "no_colors", "Do not display colors", "n", false, false, NULL);
    #####:   91:	args_param_build(&book_param, "book",
        -:   92:		"Randomly select a verse from the specified book of the Bible", "b", true, false, NULL);
    #####:   93:	args_param_build(&chapter_param, "chapter",
        -:   94:		"Randomly select a verse from the specified chapter of the Bible. "
        -:   95:		"This option requires that --book be specified as well.",
        -:   96:		"x", true, false, NULL);
    #####:   97:	args_param_build(&verse_param, "verse",
        -:   98:		"Select the specified verse. This option requires "
        -:   99:		"that --book and --chapter be specified as well.",
        -:  100:		"v", true, false, NULL);
        -:  101:
    #####:  102:	sub_command_add_param(&verse, &no_colors_param);
    #####:  103:	sub_command_add_param(&verse, &book_param);
    #####:  104:	sub_command_add_param(&verse, &chapter_param);
    #####:  105:	sub_command_add_param(&verse, &verse_param);
        -:  106:
    #####:  107:	args_add_sub_command(args, &verse);
        -:  108:
        -:  109:	// build the node SubCommand
        -:  110:	SubCommand node;
        -:  111:	ArgsParam cfg_threads, cfg_show;
    #####:  112:	args_param_build(
        -:  113:		&cfg_show, "show_request", "Show request information", "s", false, false, NULL);
    #####:  114:	args_param_build(
        -:  115:		&cfg_threads, "threads", "Number of threads to execute", "t", true, false, "1");
        -:  116:
    #####:  117:	sub_command_build(&node, "node", "Run full node", 0, 0, "");
    #####:  118:	sub_command_add_param(&node, &cfg_threads);
    #####:  119:	sub_command_add_param(&node, &cfg_show);
        -:  120:
    #####:  121:	args_add_sub_command(args, &node);
        -:  122:
        -:  123:	// build core options
        -:  124:	ArgsParam cfg_config_dir;
        -:  125:	ArgsParam cfg_debug;
        -:  126:
    #####:  127:	args_param_build(
        -:  128:		&cfg_debug, "debug", "Prints additional debugging information", "d", false, false, NULL);
        -:  129:
    #####:  130:	char default_config_dir[strlen(home_dir) + 100];
    #####:  131:	snprintf(default_config_dir, strlen(home_dir) + 100, "%s/.fam", home_dir);
    #####:  132:	args_param_build(&cfg_config_dir, "config_dir",
        -:  133:		"Directory where configuration files are stored", "c", true, false, default_config_dir);
        -:  134:
    #####:  135:	args_add_param(args, &cfg_debug);
    #####:  136:	args_add_param(args, &cfg_config_dir);
    #####:  137:}
        -:  138:
    #####:  139:void process_verse(Args *args, char *config_dir)
    #####:  140:{
    #####:  141:	bool no_colors = args_value_of(args, "no_colors", NULL, 0, 0) >= 0;
        -:  142:	char book[100];
    #####:  143:	args_value_of(args, "book", book, 100, 0);
        -:  144:	char chapter_buf[100];
    #####:  145:	int chapter_int = -1;
    #####:  146:	if (args_value_of(args, "chapter", chapter_buf, 100, 0) != -1) {
    #####:  147:		chapter_int = atoi(chapter_buf);
    #####:  148:		if (chapter_int <= 0 || chapter_int > 255) {
    #####:  149:			fprintf(stderr,
        -:  150:				"The chapter specified must be a positive "
        -:  151:				"integer which is equal to or less than 255.\n");
    #####:  152:			exit(-1);
        -:  153:		}
        -:  154:	}
        -:  155:	char verse_buf[100];
    #####:  156:	int verse_int = -1;
    #####:  157:	if (args_value_of(args, "verse", verse_buf, 100, 0) != -1) {
    #####:  158:		verse_int = atoi(verse_buf);
    #####:  159:		if (verse_int <= 0 || verse_int > 255) {
    #####:  160:			fprintf(stderr,
        -:  161:				"The verse specified must be a positive "
        -:  162:				"integer which is equal to or less than 255.\n");
    #####:  163:			exit(-1);
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	Bible bible;
    #####:  168:	char bible_path[strlen(config_dir) + 10];
    #####:  169:	strcpy(bible_path, config_dir);
    #####:  170:	strcat(bible_path, "/resources/akjv.txt");
    #####:  171:	if (bible_build(&bible, bible_path)) {
    #####:  172:		fprintf(stderr, "Could not load bible at path %s: %s\n", bible_path, strerror(errno));
    #####:  173:		exit(-1);
        -:  174:	}
        -:  175:
        -:  176:	char buf[1024];
        -:  177:	char book_buf[100];
        -:  178:	u8 chapter, verse;
        -:  179:
    #####:  180:	u8 *chapter_ptr = NULL;
    #####:  181:	if (chapter_int != -1) {
    #####:  182:		chapter = chapter_int;
    #####:  183:		chapter_ptr = &chapter;
        -:  184:	}
    #####:  185:	u8 *verse_ptr = NULL;
    #####:  186:	if (verse_int != -1) {
    #####:  187:		verse = verse_int;
    #####:  188:		verse_ptr = &verse;
        -:  189:	}
        -:  190:
    #####:  191:	if (verse_int != -1 && chapter_int == -1) {
    #####:  192:		fprintf(stderr,
        -:  193:			"If --verse is specified, --chapter must also "
        -:  194:			"be specified\n");
    #####:  195:		exit(-1);
        -:  196:	}
    #####:  197:	if (chapter_int != -1 && (strlen(book) == 0)) {
    #####:  198:		fprintf(stderr,
        -:  199:			"If --chapter is specified, --book must also "
        -:  200:			"be specified\n");
    #####:  201:		exit(-1);
        -:  202:	}
    #####:  203:	if (bible_random_verse_to_string(&bible, buf, 1024, !no_colors, book, chapter_ptr, verse_ptr)
        -:  204:		< 0) {
    #####:  205:		fprintf(stderr, "Could not find random verse due to: %s\n", strerror(errno));
    #####:  206:		exit(-1);
        -:  207:	}
        -:  208:
    #####:  209:	printf("%s\n", buf);
    #####:  210:	bible_cleanup(&bible);
    #####:  211:}
        -:  212:
    #####:  213:void process_init(Args *args, char *config_dir)
        -:  214:{
        -:  215:	char proj_name[128];
    #####:  216:	strcpy(proj_name, "");
    #####:  217:	args_get_argument(args, 1, proj_name, 127);
        -:  218:	char proj_path[1024];
    #####:  219:	strcpy(proj_path, proj_name);
    #####:  220:	args_value_of(args, "dir", proj_path, 1023, 0);
        -:  221:
        -:  222:	char author[11][1024];
    #####:  223:	int count = 0;
        -:  224:	loop
    #####:  225:	{
    #####:  226:		int v = args_value_of(args, "author", author[count], 1023, count);
    #####:  227:		if (v == -1)
    #####:  228:			break;
    #####:  229:		count++;
    #####:  230:		if (count >= 10) {
    #####:  231:			fprintf(stderr, "A maximum of 10 authors is allowed.");
    #####:  232:			exit(-1);
        -:  233:		}
        -:  234:	}
        -:  235:
    #####:  236:	bool lib = args_value_of(args, "lib", NULL, 0, 0) >= 0;
        -:  237:
        -:  238:	char description[1024];
    #####:  239:	args_value_of(args, "description", description, 1023, 0);
    #####:  240:	proc_build_init(proj_name, proj_path, (char **)author, count, lib, description);
    #####:  241:}
        -:  242:
    #####:  243:void setup_config_dir(const char *config_dir)
    #####:  244:{
    #####:  245:	if (mkdir(config_dir, 0700)) {
    #####:  246:		perror("Failed to create specified config directory");
    #####:  247:		exit(-1);
        -:  248:	}
        -:  249:
    #####:  250:	char resources_dir[strlen(config_dir) + 100];
    #####:  251:	strcpy(resources_dir, config_dir);
    #####:  252:	strcat(resources_dir, "/resources");
        -:  253:
    #####:  254:	if (mkdir(resources_dir, 0700)) {
    #####:  255:		perror("Failed to create specified resources directory");
    #####:  256:		exit(-1);
        -:  257:	}
        -:  258:
    #####:  259:	BUILD_RESOURCE_DIR(resources_dir, fam);
    #####:  260:}
        -:  261:
    #####:  262:int real_main(int argc, char **argv)
    #####:  263:{
        -:  264:	Args args;
    #####:  265:	build_args(&args);
    #####:  266:	args_init(&args, argc, argv);
        -:  267:
        -:  268:	// we always ensure that the config directory exists.
    #####:  269:	int config_dir_len = args_value_of(&args, "config_dir", NULL, 0, 0);
    #####:  270:	char config_dir[config_dir_len + 1];
    #####:  271:	args_value_of(&args, "config_dir", config_dir, config_dir_len + 1, 0);
    #####:  272:	if (access(config_dir, F_OK)) {
    #####:  273:		setup_config_dir(config_dir);
        -:  274:	}
        -:  275:
        -:  276:	// get first argument (subcommand)
        -:  277:	char command[100];
    #####:  278:	int ret = args_get_argument(&args, 0, command, 100);
    #####:  279:	if (ret > 0) {
    #####:  280:		if (!strcmp(command, "verse")) {
    #####:  281:			process_verse(&args, config_dir);
    #####:  282:		} else if (!strcmp(command, "init")) {
    #####:  283:			process_init(&args, config_dir);
        -:  284:		} else {
    #####:  285:			printf("Not implemented!\n");
        -:  286:		}
        -:  287:	}
        -:  288:
    #####:  289:	args_cleanup(&args);
        -:  290:
    #####:  291:	return 0;
        -:  292:}
        -:    0:Source:toml.c
        -:    0:Graph:toml.gcno
        -:    0:Data:toml.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2:
        -:    3:  MIT License
        -:    4:
        -:    5:  Copyright (c) CK Tan
        -:    6:  https://github.com/cktan/tomlc99
        -:    7:
        -:    8:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    9:  of this software and associated documentation files (the "Software"), to deal
        -:   10:  in the Software without restriction, including without limitation the rights
        -:   11:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   12:  copies of the Software, and to permit persons to whom the Software is
        -:   13:  furnished to do so, subject to the following conditions:
        -:   14:
        -:   15:  The above copyright notice and this permission notice shall be included in all
        -:   16:  copies or substantial portions of the Software.
        -:   17:
        -:   18:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   19:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   20:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   21:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   22:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   23:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   24:  SOFTWARE.
        -:   25:
        -:   26:*/
        -:   27:#define _POSIX_C_SOURCE 200809L
        -:   28:#include <assert.h>
        -:   29:#include <ctype.h>
        -:   30:#include <errno.h>
        -:   31:#include <stdbool.h>
        -:   32:#include <stdint.h>
        -:   33:#include <stdio.h>
        -:   34:#include <stdlib.h>
        -:   35:#include <string.h>
        -:   36:#include <toml/toml.h>
        -:   37:
        -:   38:static void* (*ppmalloc)(size_t) = malloc;
        -:   39:static void (*ppfree)(void*) = free;
        -:   40:
    #####:   41:void toml_set_memutil(void* (*xxmalloc)(size_t), void (*xxfree)(void*))
        -:   42:{
    #####:   43:	if (xxmalloc)
    #####:   44:		ppmalloc = xxmalloc;
    #####:   45:	if (xxfree)
    #####:   46:		ppfree = xxfree;
    #####:   47:}
        -:   48:
        -:   49:#define ALIGN8(sz) (((sz) + 7) & ~7)
        -:   50:#define MALLOC(a) ppmalloc(a)
        -:   51:#define FREE(a) ppfree(a)
        -:   52:
        -:   53:#define malloc(x) error - forbidden - use MALLOC instead
        -:   54:#define free(x) error - forbidden - use FREE instead
        -:   55:#define calloc(x, y) error - forbidden - use CALLOC instead
        -:   56:
    #####:   57:static void* CALLOC(size_t nmemb, size_t sz)
        -:   58:{
    #####:   59:	int nb = ALIGN8(sz) * nmemb;
    #####:   60:	void* p = MALLOC(nb);
    #####:   61:	if (p)
        -:   62:	{
    #####:   63:		memset(p, 0, nb);
        -:   64:	}
    #####:   65:	return p;
        -:   66:}
        -:   67:
        -:   68:// some old platforms define strdup macro -- drop it.
        -:   69:#undef strdup
        -:   70:#define strdup(x) error - forbidden - use STRDUP instead
        -:   71:
    #####:   72:static char* STRDUP(const char* s)
        -:   73:{
    #####:   74:	int len = strlen(s);
    #####:   75:	char* p = MALLOC(len + 1);
    #####:   76:	if (p)
        -:   77:	{
    #####:   78:		memcpy(p, s, len);
    #####:   79:		p[len] = 0;
        -:   80:	}
    #####:   81:	return p;
        -:   82:}
        -:   83:
        -:   84:// some old platforms define strndup macro -- drop it.
        -:   85:#undef strndup
        -:   86:#define strndup(x) error - forbiden - use STRNDUP instead
        -:   87:
    #####:   88:static char* STRNDUP(const char* s, size_t n)
        -:   89:{
    #####:   90:	size_t len = strnlen(s, n);
    #####:   91:	char* p = MALLOC(len + 1);
    #####:   92:	if (p)
        -:   93:	{
    #####:   94:		memcpy(p, s, len);
    #####:   95:		p[len] = 0;
        -:   96:	}
    #####:   97:	return p;
        -:   98:}
        -:   99:
        -:  100:/**
        -:  101: * Convert a char in utf8 into UCS, and store it in *ret.
        -:  102: * Return bytes consumed or -1 on failure.
        -:  103: */
    #####:  104:int toml_utf8_to_ucs(const char* orig, int len, int64_t* ret)
        -:  105:{
    #####:  106:	const unsigned char* buf = (const unsigned char*)orig;
    #####:  107:	unsigned i = *buf++;
        -:  108:	int64_t v;
        -:  109:
        -:  110:	/* 0x00000000 - 0x0000007F:
        -:  111:	   0xxxxxxx
        -:  112:	*/
    #####:  113:	if (0 == (i >> 7))
        -:  114:	{
    #####:  115:		if (len < 1)
    #####:  116:			return -1;
    #####:  117:		v = i;
    #####:  118:		return *ret = v, 1;
        -:  119:	}
        -:  120:	/* 0x00000080 - 0x000007FF:
        -:  121:	   110xxxxx 10xxxxxx
        -:  122:	*/
    #####:  123:	if (0x6 == (i >> 5))
        -:  124:	{
    #####:  125:		if (len < 2)
    #####:  126:			return -1;
    #####:  127:		v = i & 0x1f;
    #####:  128:		for (int j = 0; j < 1; j++)
        -:  129:		{
    #####:  130:			i = *buf++;
    #####:  131:			if (0x2 != (i >> 6))
    #####:  132:				return -1;
    #####:  133:			v = (v << 6) | (i & 0x3f);
        -:  134:		}
    #####:  135:		return *ret = v, (const char*)buf - orig;
        -:  136:	}
        -:  137:
        -:  138:	/* 0x00000800 - 0x0000FFFF:
        -:  139:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  140:	*/
    #####:  141:	if (0xE == (i >> 4))
        -:  142:	{
    #####:  143:		if (len < 3)
    #####:  144:			return -1;
    #####:  145:		v = i & 0x0F;
    #####:  146:		for (int j = 0; j < 2; j++)
        -:  147:		{
    #####:  148:			i = *buf++;
    #####:  149:			if (0x2 != (i >> 6))
    #####:  150:				return -1;
    #####:  151:			v = (v << 6) | (i & 0x3f);
        -:  152:		}
    #####:  153:		return *ret = v, (const char*)buf - orig;
        -:  154:	}
        -:  155:
        -:  156:	/* 0x00010000 - 0x001FFFFF:
        -:  157:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  158:	*/
    #####:  159:	if (0x1E == (i >> 3))
        -:  160:	{
    #####:  161:		if (len < 4)
    #####:  162:			return -1;
    #####:  163:		v = i & 0x07;
    #####:  164:		for (int j = 0; j < 3; j++)
        -:  165:		{
    #####:  166:			i = *buf++;
    #####:  167:			if (0x2 != (i >> 6))
    #####:  168:				return -1;
    #####:  169:			v = (v << 6) | (i & 0x3f);
        -:  170:		}
    #####:  171:		return *ret = v, (const char*)buf - orig;
        -:  172:	}
        -:  173:
        -:  174:	/* 0x00200000 - 0x03FFFFFF:
        -:  175:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  176:	*/
    #####:  177:	if (0x3E == (i >> 2))
        -:  178:	{
    #####:  179:		if (len < 5)
    #####:  180:			return -1;
    #####:  181:		v = i & 0x03;
    #####:  182:		for (int j = 0; j < 4; j++)
        -:  183:		{
    #####:  184:			i = *buf++;
    #####:  185:			if (0x2 != (i >> 6))
    #####:  186:				return -1;
    #####:  187:			v = (v << 6) | (i & 0x3f);
        -:  188:		}
    #####:  189:		return *ret = v, (const char*)buf - orig;
        -:  190:	}
        -:  191:
        -:  192:	/* 0x04000000 - 0x7FFFFFFF:
        -:  193:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  194:	*/
    #####:  195:	if (0x7e == (i >> 1))
        -:  196:	{
    #####:  197:		if (len < 6)
    #####:  198:			return -1;
    #####:  199:		v = i & 0x01;
    #####:  200:		for (int j = 0; j < 5; j++)
        -:  201:		{
    #####:  202:			i = *buf++;
    #####:  203:			if (0x2 != (i >> 6))
    #####:  204:				return -1;
    #####:  205:			v = (v << 6) | (i & 0x3f);
        -:  206:		}
    #####:  207:		return *ret = v, (const char*)buf - orig;
        -:  208:	}
    #####:  209:	return -1;
        -:  210:}
        -:  211:
        -:  212:/**
        -:  213: *	Convert a UCS char to utf8 code, and return it in buf.
        -:  214: *	Return bytes used in buf to encode the char, or
        -:  215: *	-1 on error.
        -:  216: */
    #####:  217:int toml_ucs_to_utf8(int64_t code, char buf[6])
        -:  218:{
        -:  219:	/* http://stackoverflow.com/questions/6240055/manually-converting-unicode-codepoints-into-utf-8-and-utf-16
        -:  220:	 */
        -:  221:	/* The UCS code values 0xd800â€“0xdfff (UTF-16 surrogates) as well
        -:  222:	 * as 0xfffe and 0xffff (UCS noncharacters) should not appear in
        -:  223:	 * conforming UTF-8 streams.
        -:  224:	 */
    #####:  225:	if (0xd800 <= code && code <= 0xdfff)
    #####:  226:		return -1;
    #####:  227:	if (0xfffe <= code && code <= 0xffff)
    #####:  228:		return -1;
        -:  229:
        -:  230:	/* 0x00000000 - 0x0000007F:
        -:  231:	   0xxxxxxx
        -:  232:	*/
    #####:  233:	if (code < 0)
    #####:  234:		return -1;
    #####:  235:	if (code <= 0x7F)
        -:  236:	{
    #####:  237:		buf[0] = (unsigned char)code;
    #####:  238:		return 1;
        -:  239:	}
        -:  240:
        -:  241:	/* 0x00000080 - 0x000007FF:
        -:  242:	   110xxxxx 10xxxxxx
        -:  243:	*/
    #####:  244:	if (code <= 0x000007FF)
        -:  245:	{
    #####:  246:		buf[0] = (unsigned char)(0xc0 | (code >> 6));
    #####:  247:		buf[1] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  248:		return 2;
        -:  249:	}
        -:  250:
        -:  251:	/* 0x00000800 - 0x0000FFFF:
        -:  252:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  253:	*/
    #####:  254:	if (code <= 0x0000FFFF)
        -:  255:	{
    #####:  256:		buf[0] = (unsigned char)(0xe0 | (code >> 12));
    #####:  257:		buf[1] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  258:		buf[2] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  259:		return 3;
        -:  260:	}
        -:  261:
        -:  262:	/* 0x00010000 - 0x001FFFFF:
        -:  263:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  264:	*/
    #####:  265:	if (code <= 0x001FFFFF)
        -:  266:	{
    #####:  267:		buf[0] = (unsigned char)(0xf0 | (code >> 18));
    #####:  268:		buf[1] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  269:		buf[2] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  270:		buf[3] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  271:		return 4;
        -:  272:	}
        -:  273:
        -:  274:	/* 0x00200000 - 0x03FFFFFF:
        -:  275:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  276:	*/
    #####:  277:	if (code <= 0x03FFFFFF)
        -:  278:	{
    #####:  279:		buf[0] = (unsigned char)(0xf8 | (code >> 24));
    #####:  280:		buf[1] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  281:		buf[2] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  282:		buf[3] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  283:		buf[4] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  284:		return 5;
        -:  285:	}
        -:  286:
        -:  287:	/* 0x04000000 - 0x7FFFFFFF:
        -:  288:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  289:	*/
    #####:  290:	if (code <= 0x7FFFFFFF)
        -:  291:	{
    #####:  292:		buf[0] = (unsigned char)(0xfc | (code >> 30));
    #####:  293:		buf[1] = (unsigned char)(0x80 | ((code >> 24) & 0x3f));
    #####:  294:		buf[2] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  295:		buf[3] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  296:		buf[4] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  297:		buf[5] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  298:		return 6;
        -:  299:	}
        -:  300:
    #####:  301:	return -1;
        -:  302:}
        -:  303:
        -:  304:/*
        -:  305: *	TOML has 3 data structures: value, array, table.
        -:  306: *	Each of them can have identification key.
        -:  307: */
        -:  308:typedef struct toml_keyval_t toml_keyval_t;
        -:  309:struct toml_keyval_t
        -:  310:{
        -:  311:	const char* key; /* key to this value */
        -:  312:	const char* val; /* the raw value */
        -:  313:};
        -:  314:
        -:  315:typedef struct toml_arritem_t toml_arritem_t;
        -:  316:struct toml_arritem_t
        -:  317:{
        -:  318:	int valtype; /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring,
        -:  319:			't'ime, 'D'ate, 'T'imestamp */
        -:  320:	char* val;
        -:  321:	toml_array_t* arr;
        -:  322:	toml_table_t* tab;
        -:  323:};
        -:  324:
        -:  325:struct toml_array_t
        -:  326:{
        -:  327:	const char* key; /* key to this array */
        -:  328:	int kind;	 /* element kind: 'v'alue, 'a'rray, or 't'able, 'm'ixed */
        -:  329:	int type;	 /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring, 't'ime,
        -:  330:			    'D'ate, 'T'imestamp, 'm'ixed */
        -:  331:
        -:  332:	int nitem; /* number of elements */
        -:  333:	toml_arritem_t* item;
        -:  334:};
        -:  335:
        -:  336:struct toml_table_t
        -:  337:{
        -:  338:	const char* key; /* key to this table */
        -:  339:	bool implicit;	 /* table was created implicitly */
        -:  340:	bool readonly;	 /* no more modification allowed */
        -:  341:
        -:  342:	/* key-values in the table */
        -:  343:	int nkval;
        -:  344:	toml_keyval_t** kval;
        -:  345:
        -:  346:	/* arrays in the table */
        -:  347:	int narr;
        -:  348:	toml_array_t** arr;
        -:  349:
        -:  350:	/* tables in the table */
        -:  351:	int ntab;
        -:  352:	toml_table_t** tab;
        -:  353:};
        -:  354:
    #####:  355:static inline void xfree(const void* x)
        -:  356:{
    #####:  357:	if (x)
    #####:  358:		FREE((void*)(intptr_t)x);
    #####:  359:}
        -:  360:
        -:  361:enum tokentype_t
        -:  362:{
        -:  363:	INVALID,
        -:  364:	DOT,
        -:  365:	COMMA,
        -:  366:	EQUAL,
        -:  367:	LBRACE,
        -:  368:	RBRACE,
        -:  369:	NEWLINE,
        -:  370:	LBRACKET,
        -:  371:	RBRACKET,
        -:  372:	STRING,
        -:  373:};
        -:  374:typedef enum tokentype_t tokentype_t;
        -:  375:
        -:  376:typedef struct token_t token_t;
        -:  377:struct token_t
        -:  378:{
        -:  379:	tokentype_t tok;
        -:  380:	int lineno;
        -:  381:	char* ptr; /* points into context->start */
        -:  382:	int len;
        -:  383:	int eof;
        -:  384:};
        -:  385:
        -:  386:typedef struct context_t context_t;
        -:  387:struct context_t
        -:  388:{
        -:  389:	char* start;
        -:  390:	char* stop;
        -:  391:	char* errbuf;
        -:  392:	int errbufsz;
        -:  393:
        -:  394:	token_t tok;
        -:  395:	toml_table_t* root;
        -:  396:	toml_table_t* curtab;
        -:  397:
        -:  398:	struct
        -:  399:	{
        -:  400:		int top;
        -:  401:		char* key[10];
        -:  402:		token_t tok[10];
        -:  403:	} tpath;
        -:  404:};
        -:  405:
        -:  406:#define STRINGIFY(x) #x
        -:  407:#define TOSTRING(x) STRINGIFY(x)
        -:  408:#define FLINE __FILE__ ":" TOSTRING(__LINE__)
        -:  409:
        -:  410:static int next_token(context_t* ctx, int dotisspecial);
        -:  411:
        -:  412:/*
        -:  413:  Error reporting. Call when an error is detected. Always return -1.
        -:  414:*/
    #####:  415:static int e_outofmemory(context_t* ctx, const char* fline)
        -:  416:{
    #####:  417:	snprintf(ctx->errbuf, ctx->errbufsz, "ERROR: out of memory (%s)",
        -:  418:		 fline);
    #####:  419:	return -1;
        -:  420:}
        -:  421:
    #####:  422:static int e_internal(context_t* ctx, const char* fline)
        -:  423:{
    #####:  424:	snprintf(ctx->errbuf, ctx->errbufsz, "internal error (%s)", fline);
    #####:  425:	return -1;
        -:  426:}
        -:  427:
    #####:  428:static int e_syntax(context_t* ctx, int lineno, const char* msg)
        -:  429:{
    #####:  430:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  431:	return -1;
        -:  432:}
        -:  433:
    #####:  434:static int e_badkey(context_t* ctx, int lineno)
        -:  435:{
    #####:  436:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: bad key", lineno);
    #####:  437:	return -1;
        -:  438:}
        -:  439:
    #####:  440:static int e_keyexists(context_t* ctx, int lineno)
        -:  441:{
    #####:  442:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: key exists", lineno);
    #####:  443:	return -1;
        -:  444:}
        -:  445:
    #####:  446:static int e_forbid(context_t* ctx, int lineno, const char* msg)
        -:  447:{
    #####:  448:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  449:	return -1;
        -:  450:}
        -:  451:
    #####:  452:static void* expand(void* p, int sz, int newsz)
        -:  453:{
    #####:  454:	void* s = MALLOC(newsz);
    #####:  455:	if (!s)
    #####:  456:		return 0;
        -:  457:
    #####:  458:	if (p)
        -:  459:	{
    #####:  460:		memcpy(s, p, sz);
    #####:  461:		FREE(p);
        -:  462:	}
    #####:  463:	return s;
        -:  464:}
        -:  465:
    #####:  466:static void** expand_ptrarr(void** p, int n)
        -:  467:{
    #####:  468:	void** s = MALLOC((n + 1) * sizeof(void*));
    #####:  469:	if (!s)
    #####:  470:		return 0;
        -:  471:
    #####:  472:	s[n] = 0;
    #####:  473:	if (p)
        -:  474:	{
    #####:  475:		memcpy(s, p, n * sizeof(void*));
    #####:  476:		FREE(p);
        -:  477:	}
    #####:  478:	return s;
        -:  479:}
        -:  480:
    #####:  481:static toml_arritem_t* expand_arritem(toml_arritem_t* p, int n)
        -:  482:{
    #####:  483:	toml_arritem_t* pp = expand(p, n * sizeof(*p), (n + 1) * sizeof(*p));
    #####:  484:	if (!pp)
    #####:  485:		return 0;
        -:  486:
    #####:  487:	memset(&pp[n], 0, sizeof(pp[n]));
    #####:  488:	return pp;
        -:  489:}
        -:  490:
    #####:  491:static char* norm_lit_str(const char* src, int srclen, int multiline,
        -:  492:			  char* errbuf, int errbufsz)
        -:  493:{
    #####:  494:	char* dst = 0; /* will write to dst[] and return it */
    #####:  495:	int max = 0;   /* max size of dst[] */
    #####:  496:	int off = 0;   /* cur offset in dst[] */
    #####:  497:	const char* sp = src;
    #####:  498:	const char* sq = src + srclen;
        -:  499:	int ch;
        -:  500:
        -:  501:	/* scan forward on src */
        -:  502:	for (;;)
        -:  503:	{
    #####:  504:		if (off >= max - 10)
        -:  505:		{ /* have some slack for misc stuff */
    #####:  506:			int newmax = max + 50;
    #####:  507:			char* x = expand(dst, max, newmax);
    #####:  508:			if (!x)
        -:  509:			{
    #####:  510:				xfree(dst);
    #####:  511:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  512:				return 0;
        -:  513:			}
    #####:  514:			dst = x;
    #####:  515:			max = newmax;
        -:  516:		}
        -:  517:
        -:  518:		/* finished? */
    #####:  519:		if (sp >= sq)
    #####:  520:			break;
        -:  521:
    #####:  522:		ch = *sp++;
        -:  523:		/* control characters other than tab is not allowed */
    #####:  524:		if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f))
        -:  525:		{
    #####:  526:			if (!(multiline && (ch == '\r' || ch == '\n')))
        -:  527:			{
    #####:  528:				xfree(dst);
    #####:  529:				snprintf(errbuf, errbufsz,
        -:  530:					 "invalid char U+%04x", ch);
    #####:  531:				return 0;
        -:  532:			}
        -:  533:		}
        -:  534:
        -:  535:		// a plain copy suffice
    #####:  536:		dst[off++] = ch;
        -:  537:	}
        -:  538:
    #####:  539:	dst[off++] = 0;
    #####:  540:	return dst;
        -:  541:}
        -:  542:
        -:  543:/*
        -:  544: * Convert src to raw unescaped utf-8 string.
        -:  545: * Returns NULL if error with errmsg in errbuf.
        -:  546: */
    #####:  547:static char* norm_basic_str(const char* src, int srclen, int multiline,
        -:  548:			    char* errbuf, int errbufsz)
        -:  549:{
    #####:  550:	char* dst = 0; /* will write to dst[] and return it */
    #####:  551:	int max = 0;   /* max size of dst[] */
    #####:  552:	int off = 0;   /* cur offset in dst[] */
    #####:  553:	const char* sp = src;
    #####:  554:	const char* sq = src + srclen;
        -:  555:	int ch;
        -:  556:
        -:  557:	/* scan forward on src */
        -:  558:	for (;;)
        -:  559:	{
    #####:  560:		if (off >= max - 10)
        -:  561:		{ /* have some slack for misc stuff */
    #####:  562:			int newmax = max + 50;
    #####:  563:			char* x = expand(dst, max, newmax);
    #####:  564:			if (!x)
        -:  565:			{
    #####:  566:				xfree(dst);
    #####:  567:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  568:				return 0;
        -:  569:			}
    #####:  570:			dst = x;
    #####:  571:			max = newmax;
        -:  572:		}
        -:  573:
        -:  574:		/* finished? */
    #####:  575:		if (sp >= sq)
    #####:  576:			break;
        -:  577:
    #####:  578:		ch = *sp++;
    #####:  579:		if (ch != '\\')
        -:  580:		{
        -:  581:			/* these chars must be escaped: U+0000 to U+0008, U+000A
        -:  582:			 * to U+001F, U+007F
        -:  583:			 */
    #####:  584:			if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f))
        -:  585:			{
    #####:  586:				if (!(multiline && (ch == '\r' || ch == '\n')))
        -:  587:				{
    #####:  588:					xfree(dst);
    #####:  589:					snprintf(errbuf, errbufsz,
        -:  590:						 "invalid char U+%04x", ch);
    #####:  591:					return 0;
        -:  592:				}
        -:  593:			}
        -:  594:
        -:  595:			// a plain copy suffice
    #####:  596:			dst[off++] = ch;
    #####:  597:			continue;
        -:  598:		}
        -:  599:
        -:  600:		/* ch was backslash. we expect the escape char. */
    #####:  601:		if (sp >= sq)
        -:  602:		{
    #####:  603:			snprintf(errbuf, errbufsz, "last backslash is invalid");
    #####:  604:			xfree(dst);
    #####:  605:			return 0;
        -:  606:		}
        -:  607:
        -:  608:		/* for multi-line, we want to kill line-ending-backslash ... */
    #####:  609:		if (multiline)
        -:  610:		{
        -:  611:
        -:  612:			// if there is only whitespace after the backslash ...
    #####:  613:			if (sp[strspn(sp, " \t\r")] == '\n')
        -:  614:			{
        -:  615:				/* skip all the following whitespaces */
    #####:  616:				sp += strspn(sp, " \t\r\n");
    #####:  617:				continue;
        -:  618:			}
        -:  619:		}
        -:  620:
        -:  621:		/* get the escaped char */
    #####:  622:		ch = *sp++;
    #####:  623:		switch (ch)
        -:  624:		{
    #####:  625:		case 'u':
        -:  626:		case 'U':
        -:  627:		{
    #####:  628:			int64_t ucs = 0;
    #####:  629:			int nhex = (ch == 'u' ? 4 : 8);
    #####:  630:			for (int i = 0; i < nhex; i++)
        -:  631:			{
    #####:  632:				if (sp >= sq)
        -:  633:				{
    #####:  634:					snprintf(errbuf, errbufsz,
        -:  635:						 "\\%c expects %d hex chars",
        -:  636:						 ch, nhex);
    #####:  637:					xfree(dst);
    #####:  638:					return 0;
        -:  639:				}
    #####:  640:				ch = *sp++;
    #####:  641:				int v = ('0' <= ch && ch <= '9')
        -:  642:					    ? ch - '0'
    #####:  643:					    : (('A' <= ch && ch <= 'F')
        -:  644:						   ? ch - 'A' + 10
    #####:  645:						   : -1);
    #####:  646:				if (-1 == v)
        -:  647:				{
    #####:  648:					snprintf(
        -:  649:					    errbuf, errbufsz,
        -:  650:					    "invalid hex chars for \\u or \\U");
    #####:  651:					xfree(dst);
    #####:  652:					return 0;
        -:  653:				}
    #####:  654:				ucs = ucs * 16 + v;
        -:  655:			}
    #####:  656:			int n = toml_ucs_to_utf8(ucs, &dst[off]);
    #####:  657:			if (-1 == n)
        -:  658:			{
    #####:  659:				snprintf(errbuf, errbufsz,
        -:  660:					 "illegal ucs code in \\u or \\U");
    #####:  661:				xfree(dst);
    #####:  662:				return 0;
        -:  663:			}
    #####:  664:			off += n;
        -:  665:		}
    #####:  666:			continue;
        -:  667:
    #####:  668:		case 'b':
    #####:  669:			ch = '\b';
    #####:  670:			break;
    #####:  671:		case 't':
    #####:  672:			ch = '\t';
    #####:  673:			break;
    #####:  674:		case 'n':
    #####:  675:			ch = '\n';
    #####:  676:			break;
    #####:  677:		case 'f':
    #####:  678:			ch = '\f';
    #####:  679:			break;
    #####:  680:		case 'r':
    #####:  681:			ch = '\r';
    #####:  682:			break;
    #####:  683:		case '"':
    #####:  684:			ch = '"';
    #####:  685:			break;
    #####:  686:		case '\\':
    #####:  687:			ch = '\\';
    #####:  688:			break;
    #####:  689:		default:
    #####:  690:			snprintf(errbuf, errbufsz, "illegal escape char \\%c",
        -:  691:				 ch);
    #####:  692:			xfree(dst);
    #####:  693:			return 0;
        -:  694:		}
        -:  695:
    #####:  696:		dst[off++] = ch;
        -:  697:	}
        -:  698:
        -:  699:	// Cap with NUL and return it.
    #####:  700:	dst[off++] = 0;
    #####:  701:	return dst;
        -:  702:}
        -:  703:
        -:  704:/* Normalize a key. Convert all special chars to raw unescaped utf-8 chars. */
    #####:  705:static char* normalize_key(context_t* ctx, token_t strtok)
        -:  706:{
    #####:  707:	const char* sp = strtok.ptr;
    #####:  708:	const char* sq = strtok.ptr + strtok.len;
    #####:  709:	int lineno = strtok.lineno;
        -:  710:	char* ret;
    #####:  711:	int ch = *sp;
        -:  712:	char ebuf[80];
        -:  713:
        -:  714:	/* handle quoted string */
    #####:  715:	if (ch == '\'' || ch == '\"')
        -:  716:	{
        -:  717:		/* if ''' or """, take 3 chars off front and back. Else, take 1
        -:  718:		 * char off. */
    #####:  719:		int multiline = 0;
    #####:  720:		if (sp[1] == ch && sp[2] == ch)
        -:  721:		{
    #####:  722:			sp += 3, sq -= 3;
    #####:  723:			multiline = 1;
        -:  724:		}
        -:  725:		else
    #####:  726:			sp++, sq--;
        -:  727:
    #####:  728:		if (ch == '\'')
        -:  729:		{
        -:  730:			/* for single quote, take it verbatim. */
    #####:  731:			if (!(ret = STRNDUP(sp, sq - sp)))
        -:  732:			{
    #####:  733:				e_outofmemory(ctx, FLINE);
    #####:  734:				return 0;
        -:  735:			}
        -:  736:		}
        -:  737:		else
        -:  738:		{
        -:  739:			/* for double quote, we need to normalize */
    #####:  740:			ret = norm_basic_str(sp, sq - sp, multiline, ebuf,
        -:  741:					     sizeof(ebuf));
    #####:  742:			if (!ret)
        -:  743:			{
    #####:  744:				e_syntax(ctx, lineno, ebuf);
    #####:  745:				return 0;
        -:  746:			}
        -:  747:		}
        -:  748:
        -:  749:		/* newlines are not allowed in keys */
    #####:  750:		if (strchr(ret, '\n'))
        -:  751:		{
    #####:  752:			xfree(ret);
    #####:  753:			e_badkey(ctx, lineno);
    #####:  754:			return 0;
        -:  755:		}
    #####:  756:		return ret;
        -:  757:	}
        -:  758:
        -:  759:	/* for bare-key allow only this regex: [A-Za-z0-9_-]+ */
        -:  760:	const char* xp;
    #####:  761:	for (xp = sp; xp != sq; xp++)
        -:  762:	{
    #####:  763:		int k = *xp;
    #####:  764:		if (isalnum(k))
    #####:  765:			continue;
    #####:  766:		if (k == '_' || k == '-')
    #####:  767:			continue;
    #####:  768:		e_badkey(ctx, lineno);
    #####:  769:		return 0;
        -:  770:	}
        -:  771:
        -:  772:	/* dup and return it */
    #####:  773:	if (!(ret = STRNDUP(sp, sq - sp)))
        -:  774:	{
    #####:  775:		e_outofmemory(ctx, FLINE);
    #####:  776:		return 0;
        -:  777:	}
    #####:  778:	return ret;
        -:  779:}
        -:  780:
        -:  781:/*
        -:  782: * Look up key in tab. Return 0 if not found, or
        -:  783: * 'v'alue, 'a'rray or 't'able depending on the element.
        -:  784: */
    #####:  785:static int check_key(toml_table_t* tab, const char* key,
        -:  786:		     toml_keyval_t** ret_val, toml_array_t** ret_arr,
        -:  787:		     toml_table_t** ret_tab)
        -:  788:{
        -:  789:	int i;
        -:  790:	void* dummy;
        -:  791:
    #####:  792:	if (!ret_tab)
    #####:  793:		ret_tab = (toml_table_t**)&dummy;
    #####:  794:	if (!ret_arr)
    #####:  795:		ret_arr = (toml_array_t**)&dummy;
    #####:  796:	if (!ret_val)
    #####:  797:		ret_val = (toml_keyval_t**)&dummy;
        -:  798:
    #####:  799:	*ret_tab = 0;
    #####:  800:	*ret_arr = 0;
    #####:  801:	*ret_val = 0;
        -:  802:
    #####:  803:	for (i = 0; i < tab->nkval; i++)
        -:  804:	{
    #####:  805:		if (0 == strcmp(key, tab->kval[i]->key))
        -:  806:		{
    #####:  807:			*ret_val = tab->kval[i];
    #####:  808:			return 'v';
        -:  809:		}
        -:  810:	}
    #####:  811:	for (i = 0; i < tab->narr; i++)
        -:  812:	{
    #####:  813:		if (0 == strcmp(key, tab->arr[i]->key))
        -:  814:		{
    #####:  815:			*ret_arr = tab->arr[i];
    #####:  816:			return 'a';
        -:  817:		}
        -:  818:	}
    #####:  819:	for (i = 0; i < tab->ntab; i++)
        -:  820:	{
    #####:  821:		if (0 == strcmp(key, tab->tab[i]->key))
        -:  822:		{
    #####:  823:			*ret_tab = tab->tab[i];
    #####:  824:			return 't';
        -:  825:		}
        -:  826:	}
    #####:  827:	return 0;
        -:  828:}
        -:  829:
    #####:  830:static int key_kind(toml_table_t* tab, const char* key)
        -:  831:{
    #####:  832:	return check_key(tab, key, 0, 0, 0);
        -:  833:}
        -:  834:
        -:  835:/* Create a keyval in the table.
        -:  836: */
    #####:  837:static toml_keyval_t* create_keyval_in_table(context_t* ctx, toml_table_t* tab,
        -:  838:					     token_t keytok)
        -:  839:{
        -:  840:	/* first, normalize the key to be used for lookup.
        -:  841:	 * remember to free it if we error out.
        -:  842:	 */
    #####:  843:	char* newkey = normalize_key(ctx, keytok);
    #####:  844:	if (!newkey)
    #####:  845:		return 0;
        -:  846:
        -:  847:	/* if key exists: error out. */
    #####:  848:	toml_keyval_t* dest = 0;
    #####:  849:	if (key_kind(tab, newkey))
        -:  850:	{
    #####:  851:		xfree(newkey);
    #####:  852:		e_keyexists(ctx, keytok.lineno);
    #####:  853:		return 0;
        -:  854:	}
        -:  855:
        -:  856:	/* make a new entry */
    #####:  857:	int n = tab->nkval;
        -:  858:	toml_keyval_t** base;
    #####:  859:	if (0 == (base = (toml_keyval_t**)expand_ptrarr((void**)tab->kval, n)))
        -:  860:	{
    #####:  861:		xfree(newkey);
    #####:  862:		e_outofmemory(ctx, FLINE);
    #####:  863:		return 0;
        -:  864:	}
    #####:  865:	tab->kval = base;
        -:  866:
    #####:  867:	if (0 == (base[n] = (toml_keyval_t*)CALLOC(1, sizeof(*base[n]))))
        -:  868:	{
    #####:  869:		xfree(newkey);
    #####:  870:		e_outofmemory(ctx, FLINE);
    #####:  871:		return 0;
        -:  872:	}
    #####:  873:	dest = tab->kval[tab->nkval++];
        -:  874:
        -:  875:	/* save the key in the new value struct */
    #####:  876:	dest->key = newkey;
    #####:  877:	return dest;
        -:  878:}
        -:  879:
        -:  880:/* Create a table in the table.
        -:  881: */
    #####:  882:static toml_table_t* create_keytable_in_table(context_t* ctx, toml_table_t* tab,
        -:  883:					      token_t keytok)
        -:  884:{
        -:  885:	/* first, normalize the key to be used for lookup.
        -:  886:	 * remember to free it if we error out.
        -:  887:	 */
    #####:  888:	char* newkey = normalize_key(ctx, keytok);
    #####:  889:	if (!newkey)
    #####:  890:		return 0;
        -:  891:
        -:  892:	/* if key exists: error out */
    #####:  893:	toml_table_t* dest = 0;
    #####:  894:	if (check_key(tab, newkey, 0, 0, &dest))
        -:  895:	{
    #####:  896:		xfree(newkey); /* don't need this anymore */
        -:  897:
        -:  898:		/* special case: if table exists, but was created implicitly ...
        -:  899:		 */
    #####:  900:		if (dest && dest->implicit)
        -:  901:		{
        -:  902:			/* we make it explicit now, and simply return it. */
    #####:  903:			dest->implicit = false;
    #####:  904:			return dest;
        -:  905:		}
    #####:  906:		e_keyexists(ctx, keytok.lineno);
    #####:  907:		return 0;
        -:  908:	}
        -:  909:
        -:  910:	/* create a new table entry */
    #####:  911:	int n = tab->ntab;
        -:  912:	toml_table_t** base;
    #####:  913:	if (0 == (base = (toml_table_t**)expand_ptrarr((void**)tab->tab, n)))
        -:  914:	{
    #####:  915:		xfree(newkey);
    #####:  916:		e_outofmemory(ctx, FLINE);
    #####:  917:		return 0;
        -:  918:	}
    #####:  919:	tab->tab = base;
        -:  920:
    #####:  921:	if (0 == (base[n] = (toml_table_t*)CALLOC(1, sizeof(*base[n]))))
        -:  922:	{
    #####:  923:		xfree(newkey);
    #####:  924:		e_outofmemory(ctx, FLINE);
    #####:  925:		return 0;
        -:  926:	}
    #####:  927:	dest = tab->tab[tab->ntab++];
        -:  928:
        -:  929:	/* save the key in the new table struct */
    #####:  930:	dest->key = newkey;
    #####:  931:	return dest;
        -:  932:}
        -:  933:
        -:  934:/* Create an array in the table.
        -:  935: */
    #####:  936:static toml_array_t* create_keyarray_in_table(context_t* ctx, toml_table_t* tab,
        -:  937:					      token_t keytok, char kind)
        -:  938:{
        -:  939:	/* first, normalize the key to be used for lookup.
        -:  940:	 * remember to free it if we error out.
        -:  941:	 */
    #####:  942:	char* newkey = normalize_key(ctx, keytok);
    #####:  943:	if (!newkey)
    #####:  944:		return 0;
        -:  945:
        -:  946:	/* if key exists: error out */
    #####:  947:	if (key_kind(tab, newkey))
        -:  948:	{
    #####:  949:		xfree(newkey); /* don't need this anymore */
    #####:  950:		e_keyexists(ctx, keytok.lineno);
    #####:  951:		return 0;
        -:  952:	}
        -:  953:
        -:  954:	/* make a new array entry */
    #####:  955:	int n = tab->narr;
        -:  956:	toml_array_t** base;
    #####:  957:	if (0 == (base = (toml_array_t**)expand_ptrarr((void**)tab->arr, n)))
        -:  958:	{
    #####:  959:		xfree(newkey);
    #####:  960:		e_outofmemory(ctx, FLINE);
    #####:  961:		return 0;
        -:  962:	}
    #####:  963:	tab->arr = base;
        -:  964:
    #####:  965:	if (0 == (base[n] = (toml_array_t*)CALLOC(1, sizeof(*base[n]))))
        -:  966:	{
    #####:  967:		xfree(newkey);
    #####:  968:		e_outofmemory(ctx, FLINE);
    #####:  969:		return 0;
        -:  970:	}
    #####:  971:	toml_array_t* dest = tab->arr[tab->narr++];
        -:  972:
        -:  973:	/* save the key in the new array struct */
    #####:  974:	dest->key = newkey;
    #####:  975:	dest->kind = kind;
    #####:  976:	return dest;
        -:  977:}
        -:  978:
    #####:  979:static toml_arritem_t* create_value_in_array(context_t* ctx,
        -:  980:					     toml_array_t* parent)
        -:  981:{
    #####:  982:	const int n = parent->nitem;
    #####:  983:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####:  984:	if (!base)
        -:  985:	{
    #####:  986:		e_outofmemory(ctx, FLINE);
    #####:  987:		return 0;
        -:  988:	}
    #####:  989:	parent->item = base;
    #####:  990:	parent->nitem++;
    #####:  991:	return &parent->item[n];
        -:  992:}
        -:  993:
        -:  994:/* Create an array in an array
        -:  995: */
    #####:  996:static toml_array_t* create_array_in_array(context_t* ctx, toml_array_t* parent)
        -:  997:{
    #####:  998:	const int n = parent->nitem;
    #####:  999:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####: 1000:	if (!base)
        -: 1001:	{
    #####: 1002:		e_outofmemory(ctx, FLINE);
    #####: 1003:		return 0;
        -: 1004:	}
    #####: 1005:	toml_array_t* ret = (toml_array_t*)CALLOC(1, sizeof(toml_array_t));
    #####: 1006:	if (!ret)
        -: 1007:	{
    #####: 1008:		e_outofmemory(ctx, FLINE);
    #####: 1009:		return 0;
        -: 1010:	}
    #####: 1011:	base[n].arr = ret;
    #####: 1012:	parent->item = base;
    #####: 1013:	parent->nitem++;
    #####: 1014:	return ret;
        -: 1015:}
        -: 1016:
        -: 1017:/* Create a table in an array
        -: 1018: */
    #####: 1019:static toml_table_t* create_table_in_array(context_t* ctx, toml_array_t* parent)
        -: 1020:{
    #####: 1021:	int n = parent->nitem;
    #####: 1022:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####: 1023:	if (!base)
        -: 1024:	{
    #####: 1025:		e_outofmemory(ctx, FLINE);
    #####: 1026:		return 0;
        -: 1027:	}
    #####: 1028:	toml_table_t* ret = (toml_table_t*)CALLOC(1, sizeof(toml_table_t));
    #####: 1029:	if (!ret)
        -: 1030:	{
    #####: 1031:		e_outofmemory(ctx, FLINE);
    #####: 1032:		return 0;
        -: 1033:	}
    #####: 1034:	base[n].tab = ret;
    #####: 1035:	parent->item = base;
    #####: 1036:	parent->nitem++;
    #####: 1037:	return ret;
        -: 1038:}
        -: 1039:
    #####: 1040:static int skip_newlines(context_t* ctx, int isdotspecial)
        -: 1041:{
    #####: 1042:	while (ctx->tok.tok == NEWLINE)
        -: 1043:	{
    #####: 1044:		if (next_token(ctx, isdotspecial))
    #####: 1045:			return -1;
    #####: 1046:		if (ctx->tok.eof)
    #####: 1047:			break;
        -: 1048:	}
    #####: 1049:	return 0;
        -: 1050:}
        -: 1051:
        -: 1052:static int parse_keyval(context_t* ctx, toml_table_t* tab);
        -: 1053:
    #####: 1054:static inline int eat_token(context_t* ctx, tokentype_t typ, int isdotspecial,
        -: 1055:			    const char* fline)
        -: 1056:{
    #####: 1057:	if (ctx->tok.tok != typ)
    #####: 1058:		return e_internal(ctx, fline);
        -: 1059:
    #####: 1060:	if (next_token(ctx, isdotspecial))
    #####: 1061:		return -1;
        -: 1062:
    #####: 1063:	return 0;
        -: 1064:}
        -: 1065:
        -: 1066:/* We are at '{ ... }'.
        -: 1067: * Parse the table.
        -: 1068: */
    #####: 1069:static int parse_inline_table(context_t* ctx, toml_table_t* tab)
        -: 1070:{
    #####: 1071:	if (eat_token(ctx, LBRACE, 1, FLINE))
    #####: 1072:		return -1;
        -: 1073:
        -: 1074:	for (;;)
        -: 1075:	{
    #####: 1076:		if (ctx->tok.tok == NEWLINE)
    #####: 1077:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1078:					"newline not allowed in inline table");
        -: 1079:
        -: 1080:		/* until } */
    #####: 1081:		if (ctx->tok.tok == RBRACE)
    #####: 1082:			break;
        -: 1083:
    #####: 1084:		if (ctx->tok.tok != STRING)
    #####: 1085:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1086:					"expect a string");
        -: 1087:
    #####: 1088:		if (parse_keyval(ctx, tab))
    #####: 1089:			return -1;
        -: 1090:
    #####: 1091:		if (ctx->tok.tok == NEWLINE)
    #####: 1092:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1093:					"newline not allowed in inline table");
        -: 1094:
        -: 1095:		/* on comma, continue to scan for next keyval */
    #####: 1096:		if (ctx->tok.tok == COMMA)
        -: 1097:		{
    #####: 1098:			if (eat_token(ctx, COMMA, 1, FLINE))
    #####: 1099:				return -1;
    #####: 1100:			continue;
        -: 1101:		}
    #####: 1102:		break;
        -: 1103:	}
        -: 1104:
    #####: 1105:	if (eat_token(ctx, RBRACE, 1, FLINE))
    #####: 1106:		return -1;
        -: 1107:
    #####: 1108:	tab->readonly = 1;
        -: 1109:
    #####: 1110:	return 0;
        -: 1111:}
        -: 1112:
    #####: 1113:static int valtype(const char* val)
        -: 1114:{
        -: 1115:	toml_timestamp_t ts;
    #####: 1116:	if (*val == '\'' || *val == '"')
    #####: 1117:		return 's';
    #####: 1118:	if (0 == toml_rtob(val, 0))
    #####: 1119:		return 'b';
    #####: 1120:	if (0 == toml_rtoi(val, 0))
    #####: 1121:		return 'i';
    #####: 1122:	if (0 == toml_rtod(val, 0))
    #####: 1123:		return 'd';
    #####: 1124:	if (0 == toml_rtots(val, &ts))
        -: 1125:	{
    #####: 1126:		if (ts.year && ts.hour)
    #####: 1127:			return 'T'; /* timestamp */
    #####: 1128:		if (ts.year)
    #####: 1129:			return 'D'; /* date */
    #####: 1130:		return 't';	    /* time */
        -: 1131:	}
    #####: 1132:	return 'u'; /* unknown */
        -: 1133:}
        -: 1134:
        -: 1135:/* We are at '[...]' */
    #####: 1136:static int parse_array(context_t* ctx, toml_array_t* arr)
        -: 1137:{
    #####: 1138:	if (eat_token(ctx, LBRACKET, 0, FLINE))
    #####: 1139:		return -1;
        -: 1140:
        -: 1141:	for (;;)
        -: 1142:	{
    #####: 1143:		if (skip_newlines(ctx, 0))
    #####: 1144:			return -1;
        -: 1145:
        -: 1146:		/* until ] */
    #####: 1147:		if (ctx->tok.tok == RBRACKET)
    #####: 1148:			break;
        -: 1149:
    #####: 1150:		switch (ctx->tok.tok)
        -: 1151:		{
    #####: 1152:		case STRING:
        -: 1153:		{
        -: 1154:			/* set array kind if this will be the first entry */
    #####: 1155:			if (arr->kind == 0)
    #####: 1156:				arr->kind = 'v';
    #####: 1157:			else if (arr->kind != 'v')
    #####: 1158:				arr->kind = 'm';
        -: 1159:
    #####: 1160:			char* val = ctx->tok.ptr;
    #####: 1161:			int vlen = ctx->tok.len;
        -: 1162:
        -: 1163:			/* make a new value in array */
        -: 1164:			toml_arritem_t* newval =
    #####: 1165:			    create_value_in_array(ctx, arr);
    #####: 1166:			if (!newval)
    #####: 1167:				return e_outofmemory(ctx, FLINE);
        -: 1168:
    #####: 1169:			if (!(newval->val = STRNDUP(val, vlen)))
    #####: 1170:				return e_outofmemory(ctx, FLINE);
        -: 1171:
    #####: 1172:			newval->valtype = valtype(newval->val);
        -: 1173:
        -: 1174:			/* set array type if this is the first entry */
    #####: 1175:			if (arr->nitem == 1)
    #####: 1176:				arr->type = newval->valtype;
    #####: 1177:			else if (arr->type != newval->valtype)
    #####: 1178:				arr->type = 'm'; /* mixed */
        -: 1179:
    #####: 1180:			if (eat_token(ctx, STRING, 0, FLINE))
    #####: 1181:				return -1;
    #####: 1182:			break;
        -: 1183:		}
        -: 1184:
    #####: 1185:		case LBRACKET:
        -: 1186:		{ /* [ [array], [array] ... ] */
        -: 1187:			/* set the array kind if this will be the first entry */
    #####: 1188:			if (arr->kind == 0)
    #####: 1189:				arr->kind = 'a';
    #####: 1190:			else if (arr->kind != 'a')
    #####: 1191:				arr->kind = 'm';
        -: 1192:
    #####: 1193:			toml_array_t* subarr = create_array_in_array(ctx, arr);
    #####: 1194:			if (!subarr)
    #####: 1195:				return -1;
    #####: 1196:			if (parse_array(ctx, subarr))
    #####: 1197:				return -1;
    #####: 1198:			break;
        -: 1199:		}
        -: 1200:
    #####: 1201:		case LBRACE:
        -: 1202:		{ /* [ {table}, {table} ... ] */
        -: 1203:			/* set the array kind if this will be the first entry */
    #####: 1204:			if (arr->kind == 0)
    #####: 1205:				arr->kind = 't';
    #####: 1206:			else if (arr->kind != 't')
    #####: 1207:				arr->kind = 'm';
        -: 1208:
    #####: 1209:			toml_table_t* subtab = create_table_in_array(ctx, arr);
    #####: 1210:			if (!subtab)
    #####: 1211:				return -1;
    #####: 1212:			if (parse_inline_table(ctx, subtab))
    #####: 1213:				return -1;
    #####: 1214:			break;
        -: 1215:		}
        -: 1216:
    #####: 1217:		default:
    #####: 1218:			return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1219:		}
        -: 1220:
    #####: 1221:		if (skip_newlines(ctx, 0))
    #####: 1222:			return -1;
        -: 1223:
        -: 1224:		/* on comma, continue to scan for next element */
    #####: 1225:		if (ctx->tok.tok == COMMA)
        -: 1226:		{
    #####: 1227:			if (eat_token(ctx, COMMA, 0, FLINE))
    #####: 1228:				return -1;
    #####: 1229:			continue;
        -: 1230:		}
    #####: 1231:		break;
        -: 1232:	}
        -: 1233:
    #####: 1234:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1235:		return -1;
    #####: 1236:	return 0;
        -: 1237:}
        -: 1238:
        -: 1239:/* handle lines like these:
        -: 1240:   key = "value"
        -: 1241:   key = [ array ]
        -: 1242:   key = { table }
        -: 1243:*/
    #####: 1244:static int parse_keyval(context_t* ctx, toml_table_t* tab)
        -: 1245:{
    #####: 1246:	if (tab->readonly)
        -: 1247:	{
    #####: 1248:		return e_forbid(ctx, ctx->tok.lineno,
        -: 1249:				"cannot insert new entry into existing table");
        -: 1250:	}
        -: 1251:
    #####: 1252:	token_t key = ctx->tok;
    #####: 1253:	if (eat_token(ctx, STRING, 1, FLINE))
    #####: 1254:		return -1;
        -: 1255:
    #####: 1256:	if (ctx->tok.tok == DOT)
        -: 1257:	{
        -: 1258:		/* handle inline dotted key.
        -: 1259:		   e.g.
        -: 1260:		   physical.color = "orange"
        -: 1261:		   physical.shape = "round"
        -: 1262:		*/
    #####: 1263:		toml_table_t* subtab = 0;
        -: 1264:		{
    #####: 1265:			char* subtabstr = normalize_key(ctx, key);
    #####: 1266:			if (!subtabstr)
    #####: 1267:				return -1;
        -: 1268:
    #####: 1269:			subtab = toml_table_in(tab, subtabstr);
    #####: 1270:			xfree(subtabstr);
        -: 1271:		}
    #####: 1272:		if (!subtab)
        -: 1273:		{
    #####: 1274:			subtab = create_keytable_in_table(ctx, tab, key);
    #####: 1275:			if (!subtab)
    #####: 1276:				return -1;
        -: 1277:		}
    #####: 1278:		if (next_token(ctx, 1))
    #####: 1279:			return -1;
    #####: 1280:		if (parse_keyval(ctx, subtab))
    #####: 1281:			return -1;
    #####: 1282:		return 0;
        -: 1283:	}
        -: 1284:
    #####: 1285:	if (ctx->tok.tok != EQUAL)
        -: 1286:	{
    #####: 1287:		return e_syntax(ctx, ctx->tok.lineno, "missing =");
        -: 1288:	}
        -: 1289:
    #####: 1290:	if (next_token(ctx, 0))
    #####: 1291:		return -1;
        -: 1292:
    #####: 1293:	switch (ctx->tok.tok)
        -: 1294:	{
    #####: 1295:	case STRING:
        -: 1296:	{ /* key = "value" */
    #####: 1297:		toml_keyval_t* keyval = create_keyval_in_table(ctx, tab, key);
    #####: 1298:		if (!keyval)
    #####: 1299:			return -1;
    #####: 1300:		token_t val = ctx->tok;
        -: 1301:
    #####: 1302:		assert(keyval->val == 0);
    #####: 1303:		if (!(keyval->val = STRNDUP(val.ptr, val.len)))
    #####: 1304:			return e_outofmemory(ctx, FLINE);
        -: 1305:
    #####: 1306:		if (next_token(ctx, 1))
    #####: 1307:			return -1;
        -: 1308:
    #####: 1309:		return 0;
        -: 1310:	}
        -: 1311:
    #####: 1312:	case LBRACKET:
        -: 1313:	{ /* key = [ array ] */
    #####: 1314:		toml_array_t* arr = create_keyarray_in_table(ctx, tab, key, 0);
    #####: 1315:		if (!arr)
    #####: 1316:			return -1;
    #####: 1317:		if (parse_array(ctx, arr))
    #####: 1318:			return -1;
    #####: 1319:		return 0;
        -: 1320:	}
        -: 1321:
    #####: 1322:	case LBRACE:
        -: 1323:	{ /* key = { table } */
    #####: 1324:		toml_table_t* nxttab = create_keytable_in_table(ctx, tab, key);
    #####: 1325:		if (!nxttab)
    #####: 1326:			return -1;
    #####: 1327:		if (parse_inline_table(ctx, nxttab))
    #####: 1328:			return -1;
    #####: 1329:		return 0;
        -: 1330:	}
        -: 1331:
    #####: 1332:	default:
    #####: 1333:		return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1334:	}
        -: 1335:	return 0;
        -: 1336:}
        -: 1337:
        -: 1338:typedef struct tabpath_t tabpath_t;
        -: 1339:struct tabpath_t
        -: 1340:{
        -: 1341:	int cnt;
        -: 1342:	token_t key[10];
        -: 1343:};
        -: 1344:
        -: 1345:/* at [x.y.z] or [[x.y.z]]
        -: 1346: * Scan forward and fill tabpath until it enters ] or ]]
        -: 1347: * There will be at least one entry on return.
        -: 1348: */
    #####: 1349:static int fill_tabpath(context_t* ctx)
        -: 1350:{
    #####: 1351:	int lineno = ctx->tok.lineno;
        -: 1352:	int i;
        -: 1353:
        -: 1354:	/* clear tpath */
    #####: 1355:	for (i = 0; i < ctx->tpath.top; i++)
        -: 1356:	{
    #####: 1357:		char** p = &ctx->tpath.key[i];
    #####: 1358:		xfree(*p);
    #####: 1359:		*p = 0;
        -: 1360:	}
    #####: 1361:	ctx->tpath.top = 0;
        -: 1362:
        -: 1363:	for (;;)
    #####: 1364:	{
    #####: 1365:		if (ctx->tpath.top >= 10)
    #####: 1366:			return e_syntax(
        -: 1367:			    ctx, lineno,
        -: 1368:			    "table path is too deep; max allowed is 10.");
        -: 1369:
    #####: 1370:		if (ctx->tok.tok != STRING)
    #####: 1371:			return e_syntax(ctx, lineno, "invalid or missing key");
        -: 1372:
    #####: 1373:		char* key = normalize_key(ctx, ctx->tok);
    #####: 1374:		if (!key)
    #####: 1375:			return -1;
    #####: 1376:		ctx->tpath.tok[ctx->tpath.top] = ctx->tok;
    #####: 1377:		ctx->tpath.key[ctx->tpath.top] = key;
    #####: 1378:		ctx->tpath.top++;
        -: 1379:
    #####: 1380:		if (next_token(ctx, 1))
    #####: 1381:			return -1;
        -: 1382:
    #####: 1383:		if (ctx->tok.tok == RBRACKET)
    #####: 1384:			break;
        -: 1385:
    #####: 1386:		if (ctx->tok.tok != DOT)
    #####: 1387:			return e_syntax(ctx, lineno, "invalid key");
        -: 1388:
    #####: 1389:		if (next_token(ctx, 1))
    #####: 1390:			return -1;
        -: 1391:	}
        -: 1392:
    #####: 1393:	if (ctx->tpath.top <= 0)
    #####: 1394:		return e_syntax(ctx, lineno, "empty table selector");
        -: 1395:
    #####: 1396:	return 0;
        -: 1397:}
        -: 1398:
        -: 1399:/* Walk tabpath from the root, and create new tables on the way.
        -: 1400: * Sets ctx->curtab to the final table.
        -: 1401: */
    #####: 1402:static int walk_tabpath(context_t* ctx)
        -: 1403:{
        -: 1404:	/* start from root */
    #####: 1405:	toml_table_t* curtab = ctx->root;
        -: 1406:
    #####: 1407:	for (int i = 0; i < ctx->tpath.top; i++)
        -: 1408:	{
    #####: 1409:		const char* key = ctx->tpath.key[i];
        -: 1410:
    #####: 1411:		toml_keyval_t* nextval = 0;
    #####: 1412:		toml_array_t* nextarr = 0;
    #####: 1413:		toml_table_t* nexttab = 0;
    #####: 1414:		switch (check_key(curtab, key, &nextval, &nextarr, &nexttab))
        -: 1415:		{
    #####: 1416:		case 't':
        -: 1417:			/* found a table. nexttab is where we will go next. */
    #####: 1418:			break;
        -: 1419:
    #####: 1420:		case 'a':
        -: 1421:			/* found an array. nexttab is the last table in the
        -: 1422:			 * array. */
    #####: 1423:			if (nextarr->kind != 't')
    #####: 1424:				return e_internal(ctx, FLINE);
        -: 1425:
    #####: 1426:			if (nextarr->nitem == 0)
    #####: 1427:				return e_internal(ctx, FLINE);
        -: 1428:
    #####: 1429:			nexttab = nextarr->item[nextarr->nitem - 1].tab;
    #####: 1430:			break;
        -: 1431:
    #####: 1432:		case 'v':
    #####: 1433:			return e_keyexists(ctx, ctx->tpath.tok[i].lineno);
        -: 1434:
    #####: 1435:		default:
        -: 1436:		{ /* Not found. Let's create an implicit table. */
    #####: 1437:			int n = curtab->ntab;
    #####: 1438:			toml_table_t** base = (toml_table_t**)expand_ptrarr(
    #####: 1439:			    (void**)curtab->tab, n);
    #####: 1440:			if (0 == base)
    #####: 1441:				return e_outofmemory(ctx, FLINE);
        -: 1442:
    #####: 1443:			curtab->tab = base;
        -: 1444:
    #####: 1445:			if (0 == (base[n] = (toml_table_t*)CALLOC(1, sizeof(*base[n]))))
    #####: 1446:				return e_outofmemory(ctx, FLINE);
        -: 1447:
    #####: 1448:			if (0 == (base[n]->key = STRDUP(key)))
    #####: 1449:				return e_outofmemory(ctx, FLINE);
        -: 1450:
    #####: 1451:			nexttab = curtab->tab[curtab->ntab++];
        -: 1452:
        -: 1453:			/* tabs created by walk_tabpath are considered implicit
        -: 1454:			 */
    #####: 1455:			nexttab->implicit = true;
        -: 1456:		}
    #####: 1457:		break;
        -: 1458:		}
        -: 1459:
        -: 1460:		/* switch to next tab */
    #####: 1461:		curtab = nexttab;
        -: 1462:	}
        -: 1463:
        -: 1464:	/* save it */
    #####: 1465:	ctx->curtab = curtab;
        -: 1466:
    #####: 1467:	return 0;
        -: 1468:}
        -: 1469:
        -: 1470:/* handle lines like [x.y.z] or [[x.y.z]] */
    #####: 1471:static int parse_select(context_t* ctx)
        -: 1472:{
    #####: 1473:	assert(ctx->tok.tok == LBRACKET);
        -: 1474:
        -: 1475:	/* true if [[ */
    #####: 1476:	int llb = (ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == '[');
        -: 1477:	/* need to detect '[[' on our own because next_token() will skip
        -: 1478:	   whitespace, and '[ [' would be taken as '[[', which is wrong. */
        -: 1479:
        -: 1480:	/* eat [ or [[ */
    #####: 1481:	if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1482:		return -1;
    #####: 1483:	if (llb)
        -: 1484:	{
    #####: 1485:		assert(ctx->tok.tok == LBRACKET);
    #####: 1486:		if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1487:			return -1;
        -: 1488:	}
        -: 1489:
    #####: 1490:	if (fill_tabpath(ctx))
    #####: 1491:		return -1;
        -: 1492:
        -: 1493:	/* For [x.y.z] or [[x.y.z]], remove z from tpath.
        -: 1494:	 */
    #####: 1495:	token_t z = ctx->tpath.tok[ctx->tpath.top - 1];
    #####: 1496:	xfree(ctx->tpath.key[ctx->tpath.top - 1]);
    #####: 1497:	ctx->tpath.top--;
        -: 1498:
        -: 1499:	/* set up ctx->curtab */
    #####: 1500:	if (walk_tabpath(ctx))
    #####: 1501:		return -1;
        -: 1502:
    #####: 1503:	if (!llb)
        -: 1504:	{
        -: 1505:		/* [x.y.z] -> create z = {} in x.y */
        -: 1506:		toml_table_t* curtab =
    #####: 1507:		    create_keytable_in_table(ctx, ctx->curtab, z);
    #####: 1508:		if (!curtab)
    #####: 1509:			return -1;
    #####: 1510:		ctx->curtab = curtab;
        -: 1511:	}
        -: 1512:	else
        -: 1513:	{
        -: 1514:		/* [[x.y.z]] -> create z = [] in x.y */
    #####: 1515:		toml_array_t* arr = 0;
        -: 1516:		{
    #####: 1517:			char* zstr = normalize_key(ctx, z);
    #####: 1518:			if (!zstr)
    #####: 1519:				return -1;
    #####: 1520:			arr = toml_array_in(ctx->curtab, zstr);
    #####: 1521:			xfree(zstr);
        -: 1522:		}
    #####: 1523:		if (!arr)
        -: 1524:		{
        -: 1525:			arr =
    #####: 1526:			    create_keyarray_in_table(ctx, ctx->curtab, z, 't');
    #####: 1527:			if (!arr)
    #####: 1528:				return -1;
        -: 1529:		}
    #####: 1530:		if (arr->kind != 't')
    #####: 1531:			return e_syntax(ctx, z.lineno, "array mismatch");
        -: 1532:
        -: 1533:		/* add to z[] */
        -: 1534:		toml_table_t* dest;
        -: 1535:		{
    #####: 1536:			toml_table_t* t = create_table_in_array(ctx, arr);
    #####: 1537:			if (!t)
    #####: 1538:				return -1;
        -: 1539:
    #####: 1540:			if (0 == (t->key = STRDUP("__anon__")))
    #####: 1541:				return e_outofmemory(ctx, FLINE);
        -: 1542:
    #####: 1543:			dest = t;
        -: 1544:		}
        -: 1545:
    #####: 1546:		ctx->curtab = dest;
        -: 1547:	}
        -: 1548:
    #####: 1549:	if (ctx->tok.tok != RBRACKET)
        -: 1550:	{
    #####: 1551:		return e_syntax(ctx, ctx->tok.lineno, "expects ]");
        -: 1552:	}
    #####: 1553:	if (llb)
        -: 1554:	{
    #####: 1555:		if (!(ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == ']'))
        -: 1556:		{
    #####: 1557:			return e_syntax(ctx, ctx->tok.lineno, "expects ]]");
        -: 1558:		}
    #####: 1559:		if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1560:			return -1;
        -: 1561:	}
        -: 1562:
    #####: 1563:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1564:		return -1;
        -: 1565:
    #####: 1566:	if (ctx->tok.tok != NEWLINE)
    #####: 1567:		return e_syntax(ctx, ctx->tok.lineno,
        -: 1568:				"extra chars after ] or ]]");
        -: 1569:
    #####: 1570:	return 0;
        -: 1571:}
        -: 1572:
    #####: 1573:toml_table_t* toml_parse(char* conf, char* errbuf, int errbufsz)
        -: 1574:{
        -: 1575:	context_t ctx;
        -: 1576:
        -: 1577:	// clear errbuf
    #####: 1578:	if (errbufsz <= 0)
    #####: 1579:		errbufsz = 0;
    #####: 1580:	if (errbufsz > 0)
    #####: 1581:		errbuf[0] = 0;
        -: 1582:
        -: 1583:	// init context
    #####: 1584:	memset(&ctx, 0, sizeof(ctx));
    #####: 1585:	ctx.start = conf;
    #####: 1586:	ctx.stop = ctx.start + strlen(conf);
    #####: 1587:	ctx.errbuf = errbuf;
    #####: 1588:	ctx.errbufsz = errbufsz;
        -: 1589:
        -: 1590:	// start with an artificial newline of length 0
    #####: 1591:	ctx.tok.tok = NEWLINE;
    #####: 1592:	ctx.tok.lineno = 1;
    #####: 1593:	ctx.tok.ptr = conf;
    #####: 1594:	ctx.tok.len = 0;
        -: 1595:
        -: 1596:	// make a root table
    #####: 1597:	if (0 == (ctx.root = CALLOC(1, sizeof(*ctx.root))))
        -: 1598:	{
    #####: 1599:		e_outofmemory(&ctx, FLINE);
        -: 1600:		// Do not goto fail, root table not set up yet
    #####: 1601:		return 0;
        -: 1602:	}
        -: 1603:
        -: 1604:	// set root as default table
    #####: 1605:	ctx.curtab = ctx.root;
        -: 1606:
        -: 1607:	/* Scan forward until EOF */
    #####: 1608:	for (token_t tok = ctx.tok; !tok.eof; tok = ctx.tok)
        -: 1609:	{
    #####: 1610:		switch (tok.tok)
        -: 1611:		{
        -: 1612:
    #####: 1613:		case NEWLINE:
    #####: 1614:			if (next_token(&ctx, 1))
    #####: 1615:				goto fail;
    #####: 1616:			break;
        -: 1617:
    #####: 1618:		case STRING:
    #####: 1619:			if (parse_keyval(&ctx, ctx.curtab))
    #####: 1620:				goto fail;
        -: 1621:
    #####: 1622:			if (ctx.tok.tok != NEWLINE)
        -: 1623:			{
    #####: 1624:				e_syntax(&ctx, ctx.tok.lineno,
        -: 1625:					 "extra chars after value");
    #####: 1626:				goto fail;
        -: 1627:			}
        -: 1628:
    #####: 1629:			if (eat_token(&ctx, NEWLINE, 1, FLINE))
    #####: 1630:				goto fail;
    #####: 1631:			break;
        -: 1632:
    #####: 1633:		case LBRACKET: /* [ x.y.z ] or [[ x.y.z ]] */
    #####: 1634:			if (parse_select(&ctx))
    #####: 1635:				goto fail;
    #####: 1636:			break;
        -: 1637:
    #####: 1638:		default:
    #####: 1639:			e_syntax(&ctx, tok.lineno, "syntax error");
    #####: 1640:			goto fail;
        -: 1641:		}
        -: 1642:	}
        -: 1643:
        -: 1644:	/* success */
    #####: 1645:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1646:		xfree(ctx.tpath.key[i]);
    #####: 1647:	return ctx.root;
        -: 1648:
    #####: 1649:fail:
        -: 1650:	// Something bad has happened. Free resources and return error.
    #####: 1651:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1652:		xfree(ctx.tpath.key[i]);
    #####: 1653:	toml_free(ctx.root);
    #####: 1654:	return 0;
        -: 1655:}
        -: 1656:
    #####: 1657:toml_table_t* toml_parse_file(FILE* fp, char* errbuf, int errbufsz)
        -: 1658:{
    #####: 1659:	int bufsz = 0;
    #####: 1660:	char* buf = 0;
    #####: 1661:	int off = 0;
        -: 1662:
        -: 1663:	/* read from fp into buf */
    #####: 1664:	while (!feof(fp))
        -: 1665:	{
        -: 1666:
    #####: 1667:		if (off == bufsz)
        -: 1668:		{
    #####: 1669:			int xsz = bufsz + 1000;
    #####: 1670:			char* x = expand(buf, bufsz, xsz);
    #####: 1671:			if (!x)
        -: 1672:			{
    #####: 1673:				snprintf(errbuf, errbufsz, "out of memory");
    #####: 1674:				xfree(buf);
    #####: 1675:				return 0;
        -: 1676:			}
    #####: 1677:			buf = x;
    #####: 1678:			bufsz = xsz;
        -: 1679:		}
        -: 1680:
    #####: 1681:		errno = 0;
    #####: 1682:		int n = fread(buf + off, 1, bufsz - off, fp);
    #####: 1683:		if (ferror(fp))
        -: 1684:		{
    #####: 1685:			snprintf(errbuf, errbufsz, "%s",
    #####: 1686:				 errno ? strerror(errno)
        -: 1687:				       : "Error reading file");
    #####: 1688:			xfree(buf);
    #####: 1689:			return 0;
        -: 1690:		}
    #####: 1691:		off += n;
        -: 1692:	}
        -: 1693:
        -: 1694:	/* tag on a NUL to cap the string */
    #####: 1695:	if (off == bufsz)
        -: 1696:	{
    #####: 1697:		int xsz = bufsz + 1;
    #####: 1698:		char* x = expand(buf, bufsz, xsz);
    #####: 1699:		if (!x)
        -: 1700:		{
    #####: 1701:			snprintf(errbuf, errbufsz, "out of memory");
    #####: 1702:			xfree(buf);
    #####: 1703:			return 0;
        -: 1704:		}
    #####: 1705:		buf = x;
    #####: 1706:		bufsz = xsz;
        -: 1707:	}
    #####: 1708:	buf[off] = 0;
        -: 1709:
        -: 1710:	/* parse it, cleanup and finish */
    #####: 1711:	toml_table_t* ret = toml_parse(buf, errbuf, errbufsz);
    #####: 1712:	xfree(buf);
    #####: 1713:	return ret;
        -: 1714:}
        -: 1715:
    #####: 1716:static void xfree_kval(toml_keyval_t* p)
        -: 1717:{
    #####: 1718:	if (!p)
    #####: 1719:		return;
    #####: 1720:	xfree(p->key);
    #####: 1721:	xfree(p->val);
    #####: 1722:	xfree(p);
        -: 1723:}
        -: 1724:
        -: 1725:static void xfree_tab(toml_table_t* p);
        -: 1726:
    #####: 1727:static void xfree_arr(toml_array_t* p)
        -: 1728:{
    #####: 1729:	if (!p)
    #####: 1730:		return;
        -: 1731:
    #####: 1732:	xfree(p->key);
    #####: 1733:	const int n = p->nitem;
    #####: 1734:	for (int i = 0; i < n; i++)
        -: 1735:	{
    #####: 1736:		toml_arritem_t* a = &p->item[i];
    #####: 1737:		if (a->val)
    #####: 1738:			xfree(a->val);
    #####: 1739:		else if (a->arr)
    #####: 1740:			xfree_arr(a->arr);
    #####: 1741:		else if (a->tab)
    #####: 1742:			xfree_tab(a->tab);
        -: 1743:	}
    #####: 1744:	xfree(p->item);
    #####: 1745:	xfree(p);
        -: 1746:}
        -: 1747:
    #####: 1748:static void xfree_tab(toml_table_t* p)
        -: 1749:{
        -: 1750:	int i;
        -: 1751:
    #####: 1752:	if (!p)
    #####: 1753:		return;
        -: 1754:
    #####: 1755:	xfree(p->key);
        -: 1756:
    #####: 1757:	for (i = 0; i < p->nkval; i++)
    #####: 1758:		xfree_kval(p->kval[i]);
    #####: 1759:	xfree(p->kval);
        -: 1760:
    #####: 1761:	for (i = 0; i < p->narr; i++)
    #####: 1762:		xfree_arr(p->arr[i]);
    #####: 1763:	xfree(p->arr);
        -: 1764:
    #####: 1765:	for (i = 0; i < p->ntab; i++)
    #####: 1766:		xfree_tab(p->tab[i]);
    #####: 1767:	xfree(p->tab);
        -: 1768:
    #####: 1769:	xfree(p);
        -: 1770:}
        -: 1771:
    #####: 1772:void toml_free(toml_table_t* tab) { xfree_tab(tab); }
        -: 1773:
    #####: 1774:static void set_token(context_t* ctx, tokentype_t tok, int lineno, char* ptr,
        -: 1775:		      int len)
        -: 1776:{
        -: 1777:	token_t t;
    #####: 1778:	t.tok = tok;
    #####: 1779:	t.lineno = lineno;
    #####: 1780:	t.ptr = ptr;
    #####: 1781:	t.len = len;
    #####: 1782:	t.eof = 0;
    #####: 1783:	ctx->tok = t;
    #####: 1784:}
        -: 1785:
    #####: 1786:static void set_eof(context_t* ctx, int lineno)
        -: 1787:{
    #####: 1788:	set_token(ctx, NEWLINE, lineno, ctx->stop, 0);
    #####: 1789:	ctx->tok.eof = 1;
    #####: 1790:}
        -: 1791:
        -: 1792:/* Scan p for n digits compositing entirely of [0-9] */
    #####: 1793:static int scan_digits(const char* p, int n)
        -: 1794:{
    #####: 1795:	int ret = 0;
    #####: 1796:	for (; n > 0 && isdigit(*p); n--, p++)
        -: 1797:	{
    #####: 1798:		ret = 10 * ret + (*p - '0');
        -: 1799:	}
    #####: 1800:	return n ? -1 : ret;
        -: 1801:}
        -: 1802:
    #####: 1803:static int scan_date(const char* p, int* YY, int* MM, int* DD)
        -: 1804:{
        -: 1805:	int year, month, day;
    #####: 1806:	year = scan_digits(p, 4);
    #####: 1807:	month = (year >= 0 && p[4] == '-') ? scan_digits(p + 5, 2) : -1;
    #####: 1808:	day = (month >= 0 && p[7] == '-') ? scan_digits(p + 8, 2) : -1;
    #####: 1809:	if (YY)
    #####: 1810:		*YY = year;
    #####: 1811:	if (MM)
    #####: 1812:		*MM = month;
    #####: 1813:	if (DD)
    #####: 1814:		*DD = day;
    #####: 1815:	return (year >= 0 && month >= 0 && day >= 0) ? 0 : -1;
        -: 1816:}
        -: 1817:
    #####: 1818:static int scan_time(const char* p, int* hh, int* mm, int* ss)
        -: 1819:{
        -: 1820:	int hour, minute, second;
    #####: 1821:	hour = scan_digits(p, 2);
    #####: 1822:	minute = (hour >= 0 && p[2] == ':') ? scan_digits(p + 3, 2) : -1;
    #####: 1823:	second = (minute >= 0 && p[5] == ':') ? scan_digits(p + 6, 2) : -1;
    #####: 1824:	if (hh)
    #####: 1825:		*hh = hour;
    #####: 1826:	if (mm)
    #####: 1827:		*mm = minute;
    #####: 1828:	if (ss)
    #####: 1829:		*ss = second;
    #####: 1830:	return (hour >= 0 && minute >= 0 && second >= 0) ? 0 : -1;
        -: 1831:}
        -: 1832:
    #####: 1833:static int scan_string(context_t* ctx, char* p, int lineno, int dotisspecial)
        -: 1834:{
    #####: 1835:	char* orig = p;
    #####: 1836:	if (0 == strncmp(p, "'''", 3))
        -: 1837:	{
    #####: 1838:		char* q = p + 3;
        -: 1839:
        -: 1840:		while (1)
        -: 1841:		{
    #####: 1842:			q = strstr(q, "'''");
    #####: 1843:			if (0 == q)
        -: 1844:			{
    #####: 1845:				return e_syntax(ctx, lineno,
        -: 1846:						"unterminated triple-s-quote");
        -: 1847:			}
    #####: 1848:			while (q[3] == '\'')
    #####: 1849:				q++;
    #####: 1850:			break;
        -: 1851:		}
        -: 1852:
    #####: 1853:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1854:		return 0;
        -: 1855:	}
        -: 1856:
    #####: 1857:	if (0 == strncmp(p, "\"\"\"", 3))
        -: 1858:	{
    #####: 1859:		char* q = p + 3;
        -: 1860:
        -: 1861:		while (1)
        -: 1862:		{
    #####: 1863:			q = strstr(q, "\"\"\"");
    #####: 1864:			if (0 == q)
        -: 1865:			{
    #####: 1866:				return e_syntax(ctx, lineno,
        -: 1867:						"unterminated triple-d-quote");
        -: 1868:			}
    #####: 1869:			if (q[-1] == '\\')
        -: 1870:			{
    #####: 1871:				q++;
    #####: 1872:				continue;
        -: 1873:			}
    #####: 1874:			while (q[3] == '\"')
    #####: 1875:				q++;
    #####: 1876:			break;
        -: 1877:		}
        -: 1878:
        -: 1879:		// the string is [p+3, q-1]
        -: 1880:
    #####: 1881:		int hexreq = 0; /* #hex required */
    #####: 1882:		int escape = 0;
    #####: 1883:		for (p += 3; p < q; p++)
        -: 1884:		{
    #####: 1885:			if (escape)
        -: 1886:			{
    #####: 1887:				escape = 0;
    #####: 1888:				if (strchr("btnfr\"\\", *p))
    #####: 1889:					continue;
    #####: 1890:				if (*p == 'u')
        -: 1891:				{
    #####: 1892:					hexreq = 4;
    #####: 1893:					continue;
        -: 1894:				}
    #####: 1895:				if (*p == 'U')
        -: 1896:				{
    #####: 1897:					hexreq = 8;
    #####: 1898:					continue;
        -: 1899:				}
    #####: 1900:				if (p[strspn(p, " \t\r")] == '\n')
    #####: 1901:					continue; /* allow for line ending
        -: 1902:						     backslash */
    #####: 1903:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1904:			}
    #####: 1905:			if (hexreq)
        -: 1906:			{
    #####: 1907:				hexreq--;
    #####: 1908:				if (strchr("0123456789ABCDEF", *p))
    #####: 1909:					continue;
    #####: 1910:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1911:			}
    #####: 1912:			if (*p == '\\')
        -: 1913:			{
    #####: 1914:				escape = 1;
    #####: 1915:				continue;
        -: 1916:			}
        -: 1917:		}
    #####: 1918:		if (escape)
    #####: 1919:			return e_syntax(ctx, lineno, "expect an escape char");
    #####: 1920:		if (hexreq)
    #####: 1921:			return e_syntax(ctx, lineno, "expected more hex char");
        -: 1922:
    #####: 1923:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1924:		return 0;
        -: 1925:	}
        -: 1926:
    #####: 1927:	if ('\'' == *p)
        -: 1928:	{
    #####: 1929:		for (p++; *p && *p != '\n' && *p != '\''; p++)
        -: 1930:			;
    #####: 1931:		if (*p != '\'')
        -: 1932:		{
    #####: 1933:			return e_syntax(ctx, lineno, "unterminated s-quote");
        -: 1934:		}
        -: 1935:
    #####: 1936:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1937:		return 0;
        -: 1938:	}
        -: 1939:
    #####: 1940:	if ('\"' == *p)
        -: 1941:	{
    #####: 1942:		int hexreq = 0; /* #hex required */
    #####: 1943:		int escape = 0;
    #####: 1944:		for (p++; *p; p++)
        -: 1945:		{
    #####: 1946:			if (escape)
        -: 1947:			{
    #####: 1948:				escape = 0;
    #####: 1949:				if (strchr("btnfr\"\\", *p))
    #####: 1950:					continue;
    #####: 1951:				if (*p == 'u')
        -: 1952:				{
    #####: 1953:					hexreq = 4;
    #####: 1954:					continue;
        -: 1955:				}
    #####: 1956:				if (*p == 'U')
        -: 1957:				{
    #####: 1958:					hexreq = 8;
    #####: 1959:					continue;
        -: 1960:				}
    #####: 1961:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1962:			}
    #####: 1963:			if (hexreq)
        -: 1964:			{
    #####: 1965:				hexreq--;
    #####: 1966:				if (strchr("0123456789ABCDEF", *p))
    #####: 1967:					continue;
    #####: 1968:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1969:			}
    #####: 1970:			if (*p == '\\')
        -: 1971:			{
    #####: 1972:				escape = 1;
    #####: 1973:				continue;
        -: 1974:			}
    #####: 1975:			if (*p == '\'')
        -: 1976:			{
    #####: 1977:				if (p[1] == '\'' && p[2] == '\'')
        -: 1978:				{
    #####: 1979:					return e_syntax(
        -: 1980:					    ctx, lineno,
        -: 1981:					    "triple-s-quote inside string lit");
        -: 1982:				}
    #####: 1983:				continue;
        -: 1984:			}
    #####: 1985:			if (*p == '\n')
    #####: 1986:				break;
    #####: 1987:			if (*p == '"')
    #####: 1988:				break;
        -: 1989:		}
    #####: 1990:		if (*p != '"')
        -: 1991:		{
    #####: 1992:			return e_syntax(ctx, lineno, "unterminated quote");
        -: 1993:		}
        -: 1994:
    #####: 1995:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1996:		return 0;
        -: 1997:	}
        -: 1998:
        -: 1999:	/* check for timestamp without quotes */
    #####: 2000:	if (0 == scan_date(p, 0, 0, 0) || 0 == scan_time(p, 0, 0, 0))
        -: 2001:	{
        -: 2002:		// forward thru the timestamp
    #####: 2003:		p += strspn(p, "0123456789.:+-Tt Zz");
        -: 2004:		// squeeze out any spaces at end of string
    #####: 2005:		for (; p[-1] == ' '; p--)
        -: 2006:			;
        -: 2007:		// tokenize
    #####: 2008:		set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 2009:		return 0;
        -: 2010:	}
        -: 2011:
        -: 2012:	/* literals */
    #####: 2013:	for (; *p && *p != '\n'; p++)
        -: 2014:	{
    #####: 2015:		int ch = *p;
    #####: 2016:		if (ch == '.' && dotisspecial)
    #####: 2017:			break;
    #####: 2018:		if ('A' <= ch && ch <= 'Z')
    #####: 2019:			continue;
    #####: 2020:		if ('a' <= ch && ch <= 'z')
    #####: 2021:			continue;
    #####: 2022:		if (strchr("0123456789+-_.", ch))
    #####: 2023:			continue;
    #####: 2024:		break;
        -: 2025:	}
        -: 2026:
    #####: 2027:	set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 2028:	return 0;
        -: 2029:}
        -: 2030:
    #####: 2031:static int next_token(context_t* ctx, int dotisspecial)
        -: 2032:{
    #####: 2033:	int lineno = ctx->tok.lineno;
    #####: 2034:	char* p = ctx->tok.ptr;
        -: 2035:	int i;
        -: 2036:
        -: 2037:	/* eat this tok */
    #####: 2038:	for (i = 0; i < ctx->tok.len; i++)
        -: 2039:	{
    #####: 2040:		if (*p++ == '\n')
    #####: 2041:			lineno++;
        -: 2042:	}
        -: 2043:
        -: 2044:	/* make next tok */
    #####: 2045:	while (p < ctx->stop)
        -: 2046:	{
        -: 2047:		/* skip comment. stop just before the \n. */
    #####: 2048:		if (*p == '#')
        -: 2049:		{
    #####: 2050:			for (p++; p < ctx->stop && *p != '\n'; p++)
        -: 2051:				;
    #####: 2052:			continue;
        -: 2053:		}
        -: 2054:
    #####: 2055:		if (dotisspecial && *p == '.')
        -: 2056:		{
    #####: 2057:			set_token(ctx, DOT, lineno, p, 1);
    #####: 2058:			return 0;
        -: 2059:		}
        -: 2060:
    #####: 2061:		switch (*p)
        -: 2062:		{
    #####: 2063:		case ',':
    #####: 2064:			set_token(ctx, COMMA, lineno, p, 1);
    #####: 2065:			return 0;
    #####: 2066:		case '=':
    #####: 2067:			set_token(ctx, EQUAL, lineno, p, 1);
    #####: 2068:			return 0;
    #####: 2069:		case '{':
    #####: 2070:			set_token(ctx, LBRACE, lineno, p, 1);
    #####: 2071:			return 0;
    #####: 2072:		case '}':
    #####: 2073:			set_token(ctx, RBRACE, lineno, p, 1);
    #####: 2074:			return 0;
    #####: 2075:		case '[':
    #####: 2076:			set_token(ctx, LBRACKET, lineno, p, 1);
    #####: 2077:			return 0;
    #####: 2078:		case ']':
    #####: 2079:			set_token(ctx, RBRACKET, lineno, p, 1);
    #####: 2080:			return 0;
    #####: 2081:		case '\n':
    #####: 2082:			set_token(ctx, NEWLINE, lineno, p, 1);
    #####: 2083:			return 0;
    #####: 2084:		case '\r':
        -: 2085:		case ' ':
        -: 2086:		case '\t':
        -: 2087:			/* ignore white spaces */
    #####: 2088:			p++;
    #####: 2089:			continue;
        -: 2090:		}
        -: 2091:
    #####: 2092:		return scan_string(ctx, p, lineno, dotisspecial);
        -: 2093:	}
        -: 2094:
    #####: 2095:	set_eof(ctx, lineno);
    #####: 2096:	return 0;
        -: 2097:}
        -: 2098:
    #####: 2099:const char* toml_key_in(const toml_table_t* tab, int keyidx)
        -: 2100:{
    #####: 2101:	if (keyidx < tab->nkval)
    #####: 2102:		return tab->kval[keyidx]->key;
        -: 2103:
    #####: 2104:	keyidx -= tab->nkval;
    #####: 2105:	if (keyidx < tab->narr)
    #####: 2106:		return tab->arr[keyidx]->key;
        -: 2107:
    #####: 2108:	keyidx -= tab->narr;
    #####: 2109:	if (keyidx < tab->ntab)
    #####: 2110:		return tab->tab[keyidx]->key;
        -: 2111:
    #####: 2112:	return 0;
        -: 2113:}
        -: 2114:
    #####: 2115:int toml_key_exists(const toml_table_t* tab, const char* key)
        -: 2116:{
        -: 2117:	int i;
    #####: 2118:	for (i = 0; i < tab->nkval; i++)
        -: 2119:	{
    #####: 2120:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 2121:			return 1;
        -: 2122:	}
    #####: 2123:	for (i = 0; i < tab->narr; i++)
        -: 2124:	{
    #####: 2125:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 2126:			return 1;
        -: 2127:	}
    #####: 2128:	for (i = 0; i < tab->ntab; i++)
        -: 2129:	{
    #####: 2130:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 2131:			return 1;
        -: 2132:	}
    #####: 2133:	return 0;
        -: 2134:}
        -: 2135:
    #####: 2136:toml_raw_t toml_raw_in(const toml_table_t* tab, const char* key)
        -: 2137:{
        -: 2138:	int i;
    #####: 2139:	for (i = 0; i < tab->nkval; i++)
        -: 2140:	{
    #####: 2141:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 2142:			return tab->kval[i]->val;
        -: 2143:	}
    #####: 2144:	return 0;
        -: 2145:}
        -: 2146:
    #####: 2147:toml_array_t* toml_array_in(const toml_table_t* tab, const char* key)
        -: 2148:{
        -: 2149:	int i;
    #####: 2150:	for (i = 0; i < tab->narr; i++)
        -: 2151:	{
    #####: 2152:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 2153:			return tab->arr[i];
        -: 2154:	}
    #####: 2155:	return 0;
        -: 2156:}
        -: 2157:
    #####: 2158:toml_table_t* toml_table_in(const toml_table_t* tab, const char* key)
        -: 2159:{
        -: 2160:	int i;
    #####: 2161:	for (i = 0; i < tab->ntab; i++)
        -: 2162:	{
    #####: 2163:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 2164:			return tab->tab[i];
        -: 2165:	}
    #####: 2166:	return 0;
        -: 2167:}
        -: 2168:
    #####: 2169:toml_raw_t toml_raw_at(const toml_array_t* arr, int idx)
        -: 2170:{
    #####: 2171:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].val : 0;
        -: 2172:}
        -: 2173:
    #####: 2174:char toml_array_kind(const toml_array_t* arr) { return arr->kind; }
        -: 2175:
    #####: 2176:char toml_array_type(const toml_array_t* arr)
        -: 2177:{
    #####: 2178:	if (arr->kind != 'v')
    #####: 2179:		return 0;
        -: 2180:
    #####: 2181:	if (arr->nitem == 0)
    #####: 2182:		return 0;
        -: 2183:
    #####: 2184:	return arr->type;
        -: 2185:}
        -: 2186:
    #####: 2187:int toml_array_nelem(const toml_array_t* arr) { return arr->nitem; }
        -: 2188:
    #####: 2189:const char* toml_array_key(const toml_array_t* arr)
        -: 2190:{
    #####: 2191:	return arr ? arr->key : (const char*)NULL;
        -: 2192:}
        -: 2193:
    #####: 2194:int toml_table_nkval(const toml_table_t* tab) { return tab->nkval; }
        -: 2195:
    #####: 2196:int toml_table_narr(const toml_table_t* tab) { return tab->narr; }
        -: 2197:
    #####: 2198:int toml_table_ntab(const toml_table_t* tab) { return tab->ntab; }
        -: 2199:
    #####: 2200:const char* toml_table_key(const toml_table_t* tab)
        -: 2201:{
    #####: 2202:	return tab ? tab->key : (const char*)NULL;
        -: 2203:}
        -: 2204:
    #####: 2205:toml_array_t* toml_array_at(const toml_array_t* arr, int idx)
        -: 2206:{
    #####: 2207:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].arr : 0;
        -: 2208:}
        -: 2209:
    #####: 2210:toml_table_t* toml_table_at(const toml_array_t* arr, int idx)
        -: 2211:{
    #####: 2212:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].tab : 0;
        -: 2213:}
        -: 2214:
        -: 2215:static int parse_millisec(const char* p, const char** endp);
        -: 2216:
    #####: 2217:int toml_rtots(toml_raw_t src_, toml_timestamp_t* ret)
        -: 2218:{
    #####: 2219:	if (!src_)
    #####: 2220:		return -1;
        -: 2221:
    #####: 2222:	const char* p = src_;
    #####: 2223:	int must_parse_time = 0;
        -: 2224:
    #####: 2225:	memset(ret, 0, sizeof(*ret));
        -: 2226:
    #####: 2227:	int* year = &ret->__buffer.year;
    #####: 2228:	int* month = &ret->__buffer.month;
    #####: 2229:	int* day = &ret->__buffer.day;
    #####: 2230:	int* hour = &ret->__buffer.hour;
    #####: 2231:	int* minute = &ret->__buffer.minute;
    #####: 2232:	int* second = &ret->__buffer.second;
    #####: 2233:	int* millisec = &ret->__buffer.millisec;
        -: 2234:
        -: 2235:	/* parse date YYYY-MM-DD */
    #####: 2236:	if (0 == scan_date(p, year, month, day))
        -: 2237:	{
    #####: 2238:		ret->year = year;
    #####: 2239:		ret->month = month;
    #####: 2240:		ret->day = day;
        -: 2241:
    #####: 2242:		p += 10;
    #####: 2243:		if (*p)
        -: 2244:		{
        -: 2245:			// parse the T or space separator
    #####: 2246:			if (*p != 'T' && *p != 't' && *p != ' ')
    #####: 2247:				return -1;
    #####: 2248:			must_parse_time = 1;
    #####: 2249:			p++;
        -: 2250:		}
        -: 2251:	}
        -: 2252:
        -: 2253:	/* parse time HH:MM:SS */
    #####: 2254:	if (0 == scan_time(p, hour, minute, second))
        -: 2255:	{
    #####: 2256:		ret->hour = hour;
    #####: 2257:		ret->minute = minute;
    #####: 2258:		ret->second = second;
        -: 2259:
        -: 2260:		/* optionally, parse millisec */
    #####: 2261:		p += 8;
    #####: 2262:		if (*p == '.')
        -: 2263:		{
    #####: 2264:			p++; /* skip '.' */
        -: 2265:			const char* qq;
    #####: 2266:			*millisec = parse_millisec(p, &qq);
    #####: 2267:			ret->millisec = millisec;
    #####: 2268:			p = qq;
        -: 2269:		}
        -: 2270:
    #####: 2271:		if (*p)
        -: 2272:		{
        -: 2273:			/* parse and copy Z */
    #####: 2274:			char* z = ret->__buffer.z;
    #####: 2275:			ret->z = z;
    #####: 2276:			if (*p == 'Z' || *p == 'z')
        -: 2277:			{
    #####: 2278:				*z++ = 'Z';
    #####: 2279:				p++;
    #####: 2280:				*z = 0;
        -: 2281:			}
    #####: 2282:			else if (*p == '+' || *p == '-')
        -: 2283:			{
    #####: 2284:				*z++ = *p++;
        -: 2285:
    #####: 2286:				if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2287:					return -1;
    #####: 2288:				*z++ = *p++;
    #####: 2289:				*z++ = *p++;
        -: 2290:
    #####: 2291:				if (*p == ':')
        -: 2292:				{
    #####: 2293:					*z++ = *p++;
        -: 2294:
    #####: 2295:					if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2296:						return -1;
    #####: 2297:					*z++ = *p++;
    #####: 2298:					*z++ = *p++;
        -: 2299:				}
        -: 2300:
    #####: 2301:				*z = 0;
        -: 2302:			}
        -: 2303:		}
        -: 2304:	}
    #####: 2305:	if (*p != 0)
    #####: 2306:		return -1;
        -: 2307:
    #####: 2308:	if (must_parse_time && !ret->hour)
    #####: 2309:		return -1;
        -: 2310:
    #####: 2311:	return 0;
        -: 2312:}
        -: 2313:
        -: 2314:/* Raw to boolean */
    #####: 2315:int toml_rtob(toml_raw_t src, int* ret_)
        -: 2316:{
    #####: 2317:	if (!src)
    #####: 2318:		return -1;
        -: 2319:	int dummy;
    #####: 2320:	int* ret = ret_ ? ret_ : &dummy;
        -: 2321:
    #####: 2322:	if (0 == strcmp(src, "true"))
        -: 2323:	{
    #####: 2324:		*ret = 1;
    #####: 2325:		return 0;
        -: 2326:	}
    #####: 2327:	if (0 == strcmp(src, "false"))
        -: 2328:	{
    #####: 2329:		*ret = 0;
    #####: 2330:		return 0;
        -: 2331:	}
    #####: 2332:	return -1;
        -: 2333:}
        -: 2334:
        -: 2335:/* Raw to integer */
    #####: 2336:int toml_rtoi(toml_raw_t src, int64_t* ret_)
        -: 2337:{
    #####: 2338:	if (!src)
    #####: 2339:		return -1;
        -: 2340:
        -: 2341:	char buf[100];
    #####: 2342:	char* p = buf;
    #####: 2343:	char* q = p + sizeof(buf);
    #####: 2344:	const char* s = src;
    #####: 2345:	int base = 0;
        -: 2346:	int64_t dummy;
    #####: 2347:	int64_t* ret = ret_ ? ret_ : &dummy;
        -: 2348:
        -: 2349:	/* allow +/- */
    #####: 2350:	if (s[0] == '+' || s[0] == '-')
    #####: 2351:		*p++ = *s++;
        -: 2352:
        -: 2353:	/* disallow +_100 */
    #####: 2354:	if (s[0] == '_')
    #####: 2355:		return -1;
        -: 2356:
        -: 2357:	/* if 0* ... */
    #####: 2358:	if ('0' == s[0])
        -: 2359:	{
    #####: 2360:		switch (s[1])
        -: 2361:		{
    #####: 2362:		case 'x':
    #####: 2363:			base = 16;
    #####: 2364:			s += 2;
    #####: 2365:			break;
    #####: 2366:		case 'o':
    #####: 2367:			base = 8;
    #####: 2368:			s += 2;
    #####: 2369:			break;
    #####: 2370:		case 'b':
    #####: 2371:			base = 2;
    #####: 2372:			s += 2;
    #####: 2373:			break;
    #####: 2374:		case '\0':
    #####: 2375:			return *ret = 0, 0;
    #####: 2376:		default:
        -: 2377:			/* ensure no other digits after it */
    #####: 2378:			if (s[1])
    #####: 2379:				return -1;
        -: 2380:		}
        -: 2381:	}
        -: 2382:
        -: 2383:	/* just strip underscores and pass to strtoll */
    #####: 2384:	while (*s && p < q)
        -: 2385:	{
    #####: 2386:		int ch = *s++;
    #####: 2387:		if (ch == '_')
        -: 2388:		{
        -: 2389:			// disallow '__'
    #####: 2390:			if (s[0] == '_')
    #####: 2391:				return -1;
        -: 2392:			// numbers cannot end with '_'
    #####: 2393:			if (s[0] == '\0')
    #####: 2394:				return -1;
    #####: 2395:			continue; /* skip _ */
        -: 2396:		}
    #####: 2397:		*p++ = ch;
        -: 2398:	}
        -: 2399:
        -: 2400:	// if not at end-of-string or we ran out of buffer ...
    #####: 2401:	if (*s || p == q)
    #####: 2402:		return -1;
        -: 2403:
        -: 2404:	/* cap with NUL */
    #####: 2405:	*p = 0;
        -: 2406:
        -: 2407:	/* Run strtoll on buf to get the integer */
        -: 2408:	char* endp;
    #####: 2409:	errno = 0;
    #####: 2410:	*ret = strtoll(buf, &endp, base);
    #####: 2411:	return (errno || *endp) ? -1 : 0;
        -: 2412:}
        -: 2413:
    #####: 2414:int toml_rtod_ex(toml_raw_t src, double* ret_, char* buf, int buflen)
        -: 2415:{
    #####: 2416:	if (!src)
    #####: 2417:		return -1;
        -: 2418:
    #####: 2419:	char* p = buf;
    #####: 2420:	char* q = p + buflen;
    #####: 2421:	const char* s = src;
        -: 2422:	double dummy;
    #####: 2423:	double* ret = ret_ ? ret_ : &dummy;
        -: 2424:
        -: 2425:	/* allow +/- */
    #####: 2426:	if (s[0] == '+' || s[0] == '-')
    #####: 2427:		*p++ = *s++;
        -: 2428:
        -: 2429:	/* disallow +_1.00 */
    #####: 2430:	if (s[0] == '_')
    #####: 2431:		return -1;
        -: 2432:
        -: 2433:	/* decimal point, if used, must be surrounded by at least one digit on
        -: 2434:	 * each side */
        -: 2435:	{
    #####: 2436:		char* dot = strchr(s, '.');
    #####: 2437:		if (dot)
        -: 2438:		{
    #####: 2439:			if (dot == s || !isdigit(dot[-1]) || !isdigit(dot[1]))
    #####: 2440:				return -1;
        -: 2441:		}
        -: 2442:	}
        -: 2443:
        -: 2444:	/* zero must be followed by . or 'e', or NUL */
    #####: 2445:	if (s[0] == '0' && s[1] && !strchr("eE.", s[1]))
    #####: 2446:		return -1;
        -: 2447:
        -: 2448:	/* just strip underscores and pass to strtod */
    #####: 2449:	while (*s && p < q)
        -: 2450:	{
    #####: 2451:		int ch = *s++;
    #####: 2452:		if (ch == '_')
        -: 2453:		{
        -: 2454:			// disallow '__'
    #####: 2455:			if (s[0] == '_')
    #####: 2456:				return -1;
        -: 2457:			// disallow last char '_'
    #####: 2458:			if (s[0] == 0)
    #####: 2459:				return -1;
    #####: 2460:			continue; /* skip _ */
        -: 2461:		}
    #####: 2462:		*p++ = ch;
        -: 2463:	}
    #####: 2464:	if (*s || p == q)
    #####: 2465:		return -1; /* reached end of string or buffer is full? */
        -: 2466:
        -: 2467:	/* cap with NUL */
    #####: 2468:	*p = 0;
        -: 2469:
        -: 2470:	/* Run strtod on buf to get the value */
        -: 2471:	char* endp;
    #####: 2472:	errno = 0;
    #####: 2473:	*ret = strtod(buf, &endp);
    #####: 2474:	return (errno || *endp) ? -1 : 0;
        -: 2475:}
        -: 2476:
    #####: 2477:int toml_rtod(toml_raw_t src, double* ret_)
        -: 2478:{
        -: 2479:	char buf[100];
    #####: 2480:	return toml_rtod_ex(src, ret_, buf, sizeof(buf));
        -: 2481:}
        -: 2482:
    #####: 2483:int toml_rtos(toml_raw_t src, char** ret)
        -: 2484:{
    #####: 2485:	int multiline = 0;
        -: 2486:	const char* sp;
        -: 2487:	const char* sq;
        -: 2488:
    #####: 2489:	*ret = 0;
    #####: 2490:	if (!src)
    #####: 2491:		return -1;
        -: 2492:
        -: 2493:	// for strings, first char must be a s-quote or d-quote
    #####: 2494:	int qchar = src[0];
    #####: 2495:	int srclen = strlen(src);
    #####: 2496:	if (!(qchar == '\'' || qchar == '"'))
        -: 2497:	{
    #####: 2498:		return -1;
        -: 2499:	}
        -: 2500:
        -: 2501:	// triple quotes?
    #####: 2502:	if (qchar == src[1] && qchar == src[2])
        -: 2503:	{
    #####: 2504:		multiline = 1;	       // triple-quote implies multiline
    #####: 2505:		sp = src + 3;	       // first char after quote
    #####: 2506:		sq = src + srclen - 3; // first char of ending quote
        -: 2507:
    #####: 2508:		if (!(sp <= sq && sq[0] == qchar && sq[1] == qchar && sq[2] == qchar))
        -: 2509:		{
        -: 2510:			// last 3 chars in src must be qchar
    #####: 2511:			return -1;
        -: 2512:		}
        -: 2513:
        -: 2514:		/* skip new line immediate after qchar */
    #####: 2515:		if (sp[0] == '\n')
    #####: 2516:			sp++;
    #####: 2517:		else if (sp[0] == '\r' && sp[1] == '\n')
    #####: 2518:			sp += 2;
        -: 2519:	}
        -: 2520:	else
        -: 2521:	{
    #####: 2522:		sp = src + 1;	       // first char after quote
    #####: 2523:		sq = src + srclen - 1; // ending quote
    #####: 2524:		if (!(sp <= sq && *sq == qchar))
        -: 2525:		{
        -: 2526:			/* last char in src must be qchar */
    #####: 2527:			return -1;
        -: 2528:		}
        -: 2529:	}
        -: 2530:
        -: 2531:	// at this point:
        -: 2532:	//     sp points to first valid char after quote.
        -: 2533:	//     sq points to one char beyond last valid char.
        -: 2534:	//     string len is (sq - sp).
    #####: 2535:	if (qchar == '\'')
        -: 2536:	{
    #####: 2537:		*ret = norm_lit_str(sp, sq - sp, multiline, 0, 0);
        -: 2538:	}
        -: 2539:	else
        -: 2540:	{
    #####: 2541:		*ret = norm_basic_str(sp, sq - sp, multiline, 0, 0);
        -: 2542:	}
        -: 2543:
    #####: 2544:	return *ret ? 0 : -1;
        -: 2545:}
        -: 2546:
    #####: 2547:toml_datum_t toml_string_at(const toml_array_t* arr, int idx)
        -: 2548:{
        -: 2549:	toml_datum_t ret;
    #####: 2550:	memset(&ret, 0, sizeof(ret));
    #####: 2551:	ret.ok = (0 == toml_rtos(toml_raw_at(arr, idx), &ret.u.s));
    #####: 2552:	return ret;
        -: 2553:}
        -: 2554:
    #####: 2555:toml_datum_t toml_bool_at(const toml_array_t* arr, int idx)
        -: 2556:{
        -: 2557:	toml_datum_t ret;
    #####: 2558:	memset(&ret, 0, sizeof(ret));
    #####: 2559:	ret.ok = (0 == toml_rtob(toml_raw_at(arr, idx), &ret.u.b));
    #####: 2560:	return ret;
        -: 2561:}
        -: 2562:
    #####: 2563:toml_datum_t toml_int_at(const toml_array_t* arr, int idx)
        -: 2564:{
        -: 2565:	toml_datum_t ret;
    #####: 2566:	memset(&ret, 0, sizeof(ret));
    #####: 2567:	ret.ok = (0 == toml_rtoi(toml_raw_at(arr, idx), &ret.u.i));
    #####: 2568:	return ret;
        -: 2569:}
        -: 2570:
    #####: 2571:toml_datum_t toml_double_at(const toml_array_t* arr, int idx)
        -: 2572:{
        -: 2573:	toml_datum_t ret;
    #####: 2574:	memset(&ret, 0, sizeof(ret));
    #####: 2575:	ret.ok = (0 == toml_rtod(toml_raw_at(arr, idx), &ret.u.d));
    #####: 2576:	return ret;
        -: 2577:}
        -: 2578:
    #####: 2579:toml_datum_t toml_timestamp_at(const toml_array_t* arr, int idx)
        -: 2580:{
        -: 2581:	toml_timestamp_t ts;
        -: 2582:	toml_datum_t ret;
    #####: 2583:	memset(&ret, 0, sizeof(ret));
    #####: 2584:	ret.ok = (0 == toml_rtots(toml_raw_at(arr, idx), &ts));
    #####: 2585:	if (ret.ok)
        -: 2586:	{
    #####: 2587:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2588:		if (ret.ok)
        -: 2589:		{
    #####: 2590:			*ret.u.ts = ts;
    #####: 2591:			if (ret.u.ts->year)
    #####: 2592:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2593:			if (ret.u.ts->month)
    #####: 2594:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2595:			if (ret.u.ts->day)
    #####: 2596:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2597:			if (ret.u.ts->hour)
    #####: 2598:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2599:			if (ret.u.ts->minute)
    #####: 2600:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2601:			if (ret.u.ts->second)
    #####: 2602:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2603:			if (ret.u.ts->millisec)
    #####: 2604:				ret.u.ts->millisec =
    #####: 2605:				    &ret.u.ts->__buffer.millisec;
    #####: 2606:			if (ret.u.ts->z)
    #####: 2607:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2608:		}
        -: 2609:	}
    #####: 2610:	return ret;
        -: 2611:}
        -: 2612:
    #####: 2613:toml_datum_t toml_string_in(const toml_table_t* arr, const char* key)
        -: 2614:{
        -: 2615:	toml_datum_t ret;
    #####: 2616:	memset(&ret, 0, sizeof(ret));
    #####: 2617:	toml_raw_t raw = toml_raw_in(arr, key);
    #####: 2618:	if (raw)
        -: 2619:	{
    #####: 2620:		ret.ok = (0 == toml_rtos(raw, &ret.u.s));
        -: 2621:	}
    #####: 2622:	return ret;
        -: 2623:}
        -: 2624:
    #####: 2625:toml_datum_t toml_bool_in(const toml_table_t* arr, const char* key)
        -: 2626:{
        -: 2627:	toml_datum_t ret;
    #####: 2628:	memset(&ret, 0, sizeof(ret));
    #####: 2629:	ret.ok = (0 == toml_rtob(toml_raw_in(arr, key), &ret.u.b));
    #####: 2630:	return ret;
        -: 2631:}
        -: 2632:
    #####: 2633:toml_datum_t toml_int_in(const toml_table_t* arr, const char* key)
        -: 2634:{
        -: 2635:	toml_datum_t ret;
    #####: 2636:	memset(&ret, 0, sizeof(ret));
    #####: 2637:	ret.ok = (0 == toml_rtoi(toml_raw_in(arr, key), &ret.u.i));
    #####: 2638:	return ret;
        -: 2639:}
        -: 2640:
    #####: 2641:toml_datum_t toml_double_in(const toml_table_t* arr, const char* key)
        -: 2642:{
        -: 2643:	toml_datum_t ret;
    #####: 2644:	memset(&ret, 0, sizeof(ret));
    #####: 2645:	ret.ok = (0 == toml_rtod(toml_raw_in(arr, key), &ret.u.d));
    #####: 2646:	return ret;
        -: 2647:}
        -: 2648:
    #####: 2649:toml_datum_t toml_timestamp_in(const toml_table_t* arr, const char* key)
        -: 2650:{
        -: 2651:	toml_timestamp_t ts;
        -: 2652:	toml_datum_t ret;
    #####: 2653:	memset(&ret, 0, sizeof(ret));
    #####: 2654:	ret.ok = (0 == toml_rtots(toml_raw_in(arr, key), &ts));
    #####: 2655:	if (ret.ok)
        -: 2656:	{
    #####: 2657:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2658:		if (ret.ok)
        -: 2659:		{
    #####: 2660:			*ret.u.ts = ts;
    #####: 2661:			if (ret.u.ts->year)
    #####: 2662:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2663:			if (ret.u.ts->month)
    #####: 2664:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2665:			if (ret.u.ts->day)
    #####: 2666:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2667:			if (ret.u.ts->hour)
    #####: 2668:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2669:			if (ret.u.ts->minute)
    #####: 2670:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2671:			if (ret.u.ts->second)
    #####: 2672:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2673:			if (ret.u.ts->millisec)
    #####: 2674:				ret.u.ts->millisec =
    #####: 2675:				    &ret.u.ts->__buffer.millisec;
    #####: 2676:			if (ret.u.ts->z)
    #####: 2677:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2678:		}
        -: 2679:	}
    #####: 2680:	return ret;
        -: 2681:}
        -: 2682:
    #####: 2683:static int parse_millisec(const char* p, const char** endp)
        -: 2684:{
    #####: 2685:	int ret = 0;
    #####: 2686:	int unit = 100; /* unit in millisec */
    #####: 2687:	for (; '0' <= *p && *p <= '9'; p++, unit /= 10)
        -: 2688:	{
    #####: 2689:		ret += (*p - '0') * unit;
        -: 2690:	}
    #####: 2691:	*endp = p;
    #####: 2692:	return ret;
        -: 2693:}
        -:    0:Source:prim.c
        -:    0:Graph:prim.gcno
        -:    0:Data:prim.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/prim.h>
        -:   16:
        -:   17:#define DEFINE_PRIM(lower, upper, bits)                               \
        -:   18:	Type(upper##bits, Field(lower##bits, value));                 \
        -:   19:	void upper##bits##_build(const upper##bits##Config* config)   \
        -:   20:	{                                                             \
        -:   21:		$Var(value) = config->value;                          \
        -:   22:	}                                                             \
        -:   23:	void upper##bits##_value_of(void* buf)                        \
        -:   24:	{                                                             \
        -:   25:		*(lower##bits*)buf = $(value);                        \
        -:   26:	}                                                             \
        -:   27:	bool upper##bits##_equal(const Obj* rhs)                      \
        -:   28:	{                                                             \
        -:   29:		return $(value) == $Context(rhs, upper##bits, value); \
        -:   30:	}
        -:   31:
        -:   32:#define IMPL U8
      51*:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_equal:
    #####:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_value_of:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_build:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
__add_impls_U8_vtable:
       39:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_drop_internal:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_build_internal:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_size:
        4:   33:DEFINE_PRIM(u, U, 8);
------------------
        -:   34:#undef IMPL
        -:   35:
        -:   36:#define IMPL U16
      51*:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_equal:
    #####:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_value_of:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_build:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
__add_impls_U16_vtable:
       39:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_drop_internal:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_build_internal:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_size:
        4:   37:DEFINE_PRIM(u, U, 16);
------------------
        -:   38:#undef IMPL
        -:   39:
        -:   40:#define IMPL U32
      69*:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_equal:
    #####:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_value_of:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_build:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
__add_impls_U32_vtable:
       39:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_drop_internal:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_build_internal:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_size:
       10:   41:DEFINE_PRIM(u, U, 32);
------------------
        -:   42:#undef IMPL
        -:   43:
        -:   44:#define IMPL U64
       81:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_equal:
        2:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_value_of:
        4:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_build:
        8:   45:DEFINE_PRIM(u, U, 64);
------------------
__add_impls_U64_vtable:
       39:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_drop_internal:
        4:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_build_internal:
        8:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_size:
       16:   45:DEFINE_PRIM(u, U, 64);
------------------
        -:   46:#undef IMPL
        -:   47:
        -:   48:#define IMPL U128
      51*:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_equal:
    #####:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_value_of:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_build:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
__add_impls_U128_vtable:
       39:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_drop_internal:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_build_internal:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_size:
        4:   49:DEFINE_PRIM(u, U, 128);
------------------
        -:   50:#undef IMPL
        -:   51:
        -:   52:#define IMPL I8
      51*:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_equal:
    #####:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_value_of:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_build:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
__add_impls_I8_vtable:
       39:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_drop_internal:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_build_internal:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_size:
        4:   53:DEFINE_PRIM(i, I, 8);
------------------
        -:   54:#undef IMPL
        -:   55:
        -:   56:#define IMPL I16
      51*:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_equal:
    #####:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_value_of:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_build:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
__add_impls_I16_vtable:
       39:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_drop_internal:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_build_internal:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_size:
        4:   57:DEFINE_PRIM(i, I, 16);
------------------
        -:   58:#undef IMPL
        -:   59:
        -:   60:#define IMPL I32
       88:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_equal:
        4:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_value_of:
        3:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_build:
        9:   61:DEFINE_PRIM(i, I, 32);
------------------
__add_impls_I32_vtable:
       39:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_drop_internal:
        6:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_build_internal:
        9:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_size:
       18:   61:DEFINE_PRIM(i, I, 32);
------------------
        -:   62:#undef IMPL
        -:   63:
        -:   64:#define IMPL I64
      51*:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_equal:
    #####:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_value_of:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_build:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
__add_impls_I64_vtable:
       39:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_drop_internal:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_build_internal:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_size:
        4:   65:DEFINE_PRIM(i, I, 64);
------------------
        -:   66:#undef IMPL
        -:   67:
        -:   68:#define IMPL I128
      51*:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_equal:
    #####:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_value_of:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_build:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
__add_impls_I128_vtable:
       39:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_drop_internal:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_build_internal:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_size:
        4:   69:DEFINE_PRIM(i, I, 128);
------------------
        -:   70:#undef IMPL
        -:   71:
        -:   72:#define IMPL F32
      51*:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_equal:
    #####:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_value_of:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_build:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
__add_impls_F32_vtable:
       39:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_drop_internal:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_build_internal:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_size:
        4:   73:DEFINE_PRIM(f, F, 32);
------------------
        -:   74:#undef IMPL
        -:   75:
        -:   76:#define IMPL F64
      51*:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_equal:
    #####:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_value_of:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_build:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
__add_impls_F64_vtable:
       39:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_drop_internal:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_build_internal:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_size:
        4:   77:DEFINE_PRIM(f, F, 64);
------------------
        -:   78:#undef IMPL
        -:   79:
        -:   80:#define IMPL Bool
       71:   81:Type(Bool, Field(bool, value));
------------------
__add_impls_Bool_vtable:
       39:   81:Type(Bool, Field(bool, value));
------------------
Bool_drop_internal:
        8:   81:Type(Bool, Field(bool, value));
------------------
Bool_build_internal:
        8:   81:Type(Bool, Field(bool, value));
------------------
Bool_size:
       16:   81:Type(Bool, Field(bool, value));
------------------
        8:   82:void Bool_build(const BoolConfig* config)
        -:   83:{
        8:   84:	$Var(value) = config->value;
        8:   85:}
        8:   86:void Bool_value_of(void* buf)
        -:   87:{
        8:   88:	*(bool*)buf = $(value);
        8:   89:}
    #####:   90:bool Bool_equal(const Obj* rhs)
        -:   91:{
    #####:   92:	return $(value) == $Context(rhs, Bool, value);
        -:   93:}
        -:   94:#undef IMPL
        -:    0:Source:rc.c
        -:    0:Graph:rc.gcno
        -:    0:Data:rc.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/prim.h>
        -:   16:#include <core/rc.h>
        -:   17:
        -:   18:// Rc has two 'FatPtr's The first is a counter and the second is holds the value. The value
        -:   19:// can be any object (Obj).
      151:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
__add_impls_Rc_vtable:
       39:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_drop_internal:
       16:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_build_internal:
       32:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_size:
       64:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
        -:   21:
        -:   22:#define IMPL Rc
        -:   23:// Build an Rc.
       32:   24:void Rc_build(const RcConfig* config)
        -:   25:{
        -:   26:	// Allocate memory for both the counter and the value. The value is an Obj regardless of
        -:   27:	// what type. It's data is held in the Object's own FatPtr.
       32:   28:	chain_malloc(&($Var(value)), sizeof(Obj));
       32:   29:	if ($(value).data == NULL)
    #####:   30:		panic("Could not allocate sufficient memory");
       32:   31:	chain_malloc(&($Var(counter)), sizeof(u64));
       32:   32:	if ($(counter).data == NULL)
        -:   33:	{
    #####:   34:		chain_free(&($Var(value)));
    #####:   35:		panic("Could not allocate sufficient memory");
        -:   36:	}
        -:   37:	// pointer to the internal data location
       32:   38:	Obj* obj = $Var(value).data;
        -:   39:	// initialize the object
       32:   40:	*obj = OBJECT_INIT;
        -:   41:	// if a value is passed in (which will be the case generally if the user is calling new,
        -:   42:	// we move the Object into the shared memory location.
       32:   43:	if (config->value)
      14*:   44:		Move(obj, config->value);
        -:   45:	// Initialize the counter to 1.
       32:   46:	*(u64*)$Var(counter).data = 1;
       32:   47:}
        -:   48:// Drop an Rc.
       32:   49:void Rc_drop()
        -:   50:{
        -:   51:	// When an instance of Rc is dropped, we decrement our counter and check if it is 0
        -:   52:	// indicating that no more references remain.
       32:   53:	(*(u64*)$Var(counter).data)--;
       32:   54:	if ((*(u64*)$Var(counter).data) == 0)
        -:   55:	{
        -:   56:		// No other references remain.
       14:   57:		Obj* value = $(value).data;
        -:   58:		// If the Object is not yet consumed, drop it.
       14:   59:		if ((value->flags & OBJECT_FLAGS_CONSUMED) == 0)
       13:   60:			drop(value);
        -:   61:		// Free the allocated memory for this Rc.
       14:   62:		if (chain_free(&($Var(counter))))
    #####:   63:			panic("Unexpected return from a chain_free!");
       14:   64:		if (chain_free(&($Var(value))))
    #####:   65:			panic("Unexpeted return from a chain_free!");
        -:   66:	}
       32:   67:}
        -:   68:
        -:   69:// Unwrap an Rc.
       16:   70:Obj Rc_unwrap()
        -:   71:{
        -:   72:	Obj ret;
        -:   73:	// If there are additional references, the returned object (acting as a reference to the shared data)
        -:   74:	// should not be cleaned up. We merely copy the data and marked the returned reference as 'no cleanup'.
       16:   75:	if (*(u64*)($(counter).data) > 1)
        -:   76:	{
       15:   77:		ret = *(Obj*)$(value).data;
       15:   78:		ret.flags |= OBJECT_FLAGS_NO_CLEANUP;
        -:   79:	}
        -:   80:	else
        -:   81:	{
        -:   82:		// This is the final reference so we move out the Object
        1:   83:		ret = OBJECT_INIT;
       1*:   84:		Move(&ret, (Obj*)$(value).data);
        -:   85:	}
        -:   86:	// Drop this instance of the Rc
       16:   87:	drop($Var());
        -:   88:	// return the objecct.
       16:   89:	return ret;
        -:   90:}
        -:   91:
        -:   92:// Clone the Rc.
       18:   93:Obj Rc_klone()
        -:   94:{
        -:   95:	// Update the counter by incrementing
       18:   96:	u64* counter = $(counter).data;
       18:   97:	(*counter)++;
        -:   98:
        -:   99:	// Create an Rc without a value
       18:  100:	var ret = new (Rc);
        -:  101:	// Set both the value and the counter to the appropriate values
       18:  102:	$ContextVar((&ret), Rc, value).data = ((Obj*)$(value).data);
       18:  103:	$ContextVar((&ret), Rc, counter).data = counter;
        -:  104:	// Safely return the Object
       18:  105:	ReturnObj(ret);
        -:  106:}
        -:  107:#undef IMPL
        -:    0:Source:test_encapsulation.c
        -:    0:Graph:test_encapsulation.gcno
        -:    0:Data:test_encapsulation.gcda
        -:    0:Runs:38
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/test_encapsulation.h>
        -:   16:#include <core/traits.h>
        -:   17:#include <core/type.h>
        -:   18:
       45:   19:Type(HiddenDrop);
------------------
__add_impls_HiddenDrop_vtable:
       38:   19:Type(HiddenDrop);
------------------
HiddenDrop_drop_internal:
        1:   19:Type(HiddenDrop);
------------------
HiddenDrop_build_internal:
        2:   19:Type(HiddenDrop);
------------------
HiddenDrop_size:
        4:   19:Type(HiddenDrop);
------------------
        -:   20:Builder(HiddenDrop);
       76:   21:Impl(HiddenDrop, Drop);
------------------
vtable_add_trait_impl_HiddenDrop_Drop:
       38:   21:Impl(HiddenDrop, Drop);
------------------
__required_add__HiddenDrop_drop:
       38:   21:Impl(HiddenDrop, Drop);
------------------
        -:   22:
        -:   23:#define IMPL HiddenDrop
        1:   24:void HiddenDrop_drop() {}
        -:   25:#undef IMPL
        -:   26:
     123*:   27:Type(
------------------
__add_impls_Hidden_vtable:
       38:   27:Type(
------------------
Hidden_drop_internal:
        1:   27:Type(
------------------
Hidden_build_internal:
       4*:   27:Type(
------------------
__add_where_Hidden_T_vtable:
       76:   27:Type(
------------------
Hidden_size:
        4:   27:Type(
------------------
        -:   28:    Hidden,
        -:   29:    Where(T, TraitBound(Drop)),
        -:   30:    Field(u64, value),
        -:   31:    Field(HiddenConfig, config),
        -:   32:    Generic(T, v2),
        -:   33:    Object(HiddenDrop, dd));
        -:   34:
        -:   35:#define IMPL Hidden
        2:   36:void Hidden_build(const HiddenConfig* config)
        -:   37:{
        2:   38:	printf("building hidden: capacity = %" PRIu64 "\n", config->capacity);
        2:   39:	$Var(config) = *config;
        2:   40:	let hd = new (HiddenDrop);
       4*:   41:	Move(&$Var(v2), &hd);
        2:   42:}
        -:   43:
        2:   44:void Hidden_drop()
        -:   45:{
        2:   46:	printf("drop value=%" PRIu64 "\n", $(value));
        2:   47:}
        4:   48:u64 Hidden_get_value()
        -:   49:{
        4:   50:	return $(value);
        -:   51:}
        1:   52:u64 Hidden_get_capacity_impl()
        -:   53:{
        1:   54:	return $(config).capacity;
        -:   55:}
        3:   56:void Hidden_set_value(u64 v)
        -:   57:{
        3:   58:	$Var(value) = v;
        3:   59:}
        -:   60:#undef IMPL
        -:   61:
      63*:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_as_ref:
        5:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_variant_id:
        5:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_build:
       3*:   62:EnumImpl(HiddenEnum);
------------------
__add_impls_HiddenEnum_vtable:
       38:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_drop_internal:
        3:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_build_internal:
       3*:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_size:
        6:   62:EnumImpl(HiddenEnum);
------------------
        -:    0:Source:test_server.c
        -:    0:Graph:test_server.gcno
        -:    0:Data:test_server.gcda
        -:    0:Runs:38
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/test_server.h>
        -:   16:
        -:   17:// In this file we implement the HttpServer type along with some other types that are
        -:   18:// used by HttpServer. This is a .c file so the implementation details are hidden
        -:   19:// from the user providing encapsulation of the data within the HttpServer type.
        -:   20:
        -:   21:// We create a type that implements the 'Drop' trait. This is needed to satisfy
        -:   22:// the trait bound of HttpServer in our example. We also call the required macros
        -:   23:// to minimally intialize this type and declare that the Drop trait will be
        -:   24:// implemented.
       42:   25:Type(CanDrop);
------------------
__add_impls_CanDrop_vtable:
       38:   25:Type(CanDrop);
------------------
CanDrop_drop_internal:
        1:   25:Type(CanDrop);
------------------
CanDrop_build_internal:
        1:   25:Type(CanDrop);
------------------
CanDrop_size:
        2:   25:Type(CanDrop);
------------------
        -:   26:Builder(CanDrop);
       76:   27:Impl(CanDrop, Drop);
------------------
vtable_add_trait_impl_CanDrop_Drop:
       38:   27:Impl(CanDrop, Drop);
------------------
__required_add__CanDrop_drop:
       38:   27:Impl(CanDrop, Drop);
------------------
        -:   28:
        -:   29:// Do the drop implementation for this type. By defining 'IMPL', we have access
        -:   30:// to the $() macro which allows for self operations and access to the data types.
        -:   31:#define IMPL CanDrop
        1:   32:void CanDrop_drop() { printf("dropping can drop\n"); }
        -:   33:#undef IMPL
        -:   34:
        -:   35:// Now we declare a second type which will demonstrate concrete types. This type
        -:   36:// also has some data fields which are used and a Builder which allows configuration.
       42:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
__add_impls_HttpServerComponent_vtable:
       38:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_drop_internal:
        1:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_build_internal:
        1:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_size:
        2:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
        -:   38:Builder(HttpServerComponent, Config(u64, state));
        -:   39:
        -:   40:// Implement Drop and Build for this type.
       76:   41:Impl(HttpServerComponent, Drop);
------------------
vtable_add_trait_impl_HttpServerComponent_Drop:
       38:   41:Impl(HttpServerComponent, Drop);
------------------
__required_add__HttpServerComponent_drop:
       38:   41:Impl(HttpServerComponent, Drop);
------------------
       76:   42:Impl(HttpServerComponent, Build);
------------------
vtable_add_trait_impl_HttpServerComponent_Build:
       38:   42:Impl(HttpServerComponent, Build);
------------------
__required_add__HttpServerComponent_build:
       38:   42:Impl(HttpServerComponent, Build);
------------------
        -:   43:
        -:   44:// Here we implement drop and build, the required methods for our traits.
        -:   45:#define IMPL HttpServerComponent
        1:   46:void HttpServerComponent_drop()
        -:   47:{
        -:   48:	// The $() macro allows us to access data fields in our type. In this case
        -:   49:	// We print out $(alloc_mem) and free it.
        1:   50:	printf("dropping http server component. Free %p\n", $(alloc_mem));
        1:   51:	free($(alloc_mem));
        1:   52:}
        1:   53:void HttpServerComponent_build(const HttpServerComponentConfig* config_in)
        -:   54:{
        -:   55:	// In contrast to the drop implementation, here we use the $Var macro.
        -:   56:	// The difference from the $ macro is that the $Var macro is mutable.
        -:   57:	// If the $Var macro is used in an immutable function, a thread panic
        -:   58:	// will occur.
        1:   59:	const HttpServerComponentConfig* config = config_in;
        -:   60:	// Set the 'state' data member of this type using the config.
        1:   61:	$Var(state) = config->state;
        -:   62:	// allocate memory to our void pointer type to demonstrate the usage of build/drop.
        1:   63:	$Var(alloc_mem) = malloc(100);
        1:   64:	printf("building http server component. Alloc %p\n", $(alloc_mem));
        1:   65:}
        -:   66:#undef IMPL
        -:   67:
        -:   68:// Now we define the main type. This type information is hidden from the user as this
        -:   69:// data is defined in our .c file and treated as an opaque pointer.
        -:   70:// The HttpServer type demonstrates the 'Where' clause for defining generics and the usage
        -:   71:// of all three types of data members (Generic, Object, and Field).
     119*:   72:Type(
------------------
__add_impls_HttpServer_vtable:
       38:   72:Type(
------------------
HttpServer_drop_internal:
        1:   72:Type(
------------------
HttpServer_build_internal:
       2*:   72:Type(
------------------
__add_where_HttpServer_T_vtable:
       76:   72:Type(
------------------
HttpServer_size:
        2:   72:Type(
------------------
        -:   73:    HttpServer,
        -:   74:    Where(T, TraitBound(Drop)),
        -:   75:    Field(HttpServerConfig, config),
        -:   76:    Field(bool, is_started),
        -:   77:    Object(HttpServerComponent, hsc),
        -:   78:    Generic(T, droppable));
        -:   79:
        -:   80:// Finally, we implement the HttpServer type.
        -:   81:#define IMPL HttpServer
        -:   82:// This function is not defined by any traits. It serves as a private method within our type.
        -:   83:// Since it is within the IMPL block, we can access both the $Var and $ variables and mutability
        -:   84:// is maintained based on what function calls this function.
        1:   85:void HttpServer_validate_input(const HttpServerConfig* config)
        -:   86:{
        -:   87:	// First set the config to the passed in configuration.
        1:   88:	$Var(config) = *config;
        -:   89:	// check threads and panic if they are not configured. memset is called on all
        -:   90:	// data of the type so everything will be set to 0 initially including this parameter. So,
        -:   91:	// here we effectively force the user to configure threads or a thread panic will occur.
        1:   92:	if ($(config).threads == 0)
    #####:   93:		panic("Threads must be greater than 0. Halting!");
        -:   94:
        -:   95:	// For port and host, we set default values keeping in mind the fact that everything is
        -:   96:	// initialized to 0.
        1:   97:	if ($(config).port == 0)
        1:   98:		$Var(config).port = 8080;
        1:   99:	if ($(config).host == NULL)
        1:  100:		$Var(config).host = "127.0.0.1";
        1:  101:}
        1:  102:void HttpServer_build(const HttpServerConfig* config)
        -:  103:{
        -:  104:	// The build function is automatically called by the system when an Object is instantiated.
        1:  105:	HttpServer_validate_input(config);
        -:  106:	// set is_started to false.
        1:  107:	$Var(is_started) = false;
        -:  108:	// create a 'CanDrop' object which will fulfil the trait bounds of 'droppable'.
        2:  109:	let can_drop = new (CanDrop);
        -:  110:	// Always use Move to move Objects as it will enforce all trait bounds and set the cleanup
        -:  111:	// and other flags appropriately for all types.
       2*:  112:	Move(&$Var(droppable), &can_drop);
        -:  113:	// create an immutable HttpServerComponent instance with state initialized to 1.
        1:  114:	let hsc = new (HttpServerComponent, With(state, 1));
        -:  115:	// Once again use the Move macro to move the instance into the proper memory location.
       1*:  116:	Move(&$Var(hsc), &hsc);
        1:  117:}
        -:  118:// Implement a drop method which just prints out the message below.
        1:  119:void HttpServer_drop() { printf("dropping http server\n"); }
        -:  120:// Return the is_started status of the server using the immutable self macro '$'.
        2:  121:bool HttpServer_is_started() { return $(is_started); }
        -:  122:// Implement the start_server Required function.
        2:  123:bool HttpServer_start_server()
        -:  124:{
        -:  125:	// Do error checking.
        2:  126:	if ($(is_started))
        1:  127:		return false;
        -:  128:	// Set is_started to appropriate value.
        1:  129:	$Var(is_started) = true;
        -:  130:	// Print the configuration
        1:  131:	printf(
        -:  132:	    "Server started on %s:%" PRIu16 " with %" PRIu32 " threads\n",
        1:  133:	    $(config).host, $(config).port, $(config).threads);
        -:  134:	// Call the format_print_stats function. This function will execute the provided format_print_stats
        -:  135:	// function. Note that we use the $() which refers to the pointer whose context we are currently in.
        -:  136:	// This can be used to call any trait member functions.
        1:  137:	format_print_stats($());
        1:  138:	return true;
        -:  139:}
        -:  140:// Implement a basic printing of the stats.
        1:  141:void HttpServer_print_stats()
        -:  142:{
        1:  143:	printf("Current stats: is_started: %i\n", $(is_started));
        1:  144:}
    #####:  145:void HttpServer_blorp(u64 v) {}
        -:  146:#undef IMPL
        -:  147:
        -:  148:// This is the default implementation for the format_print_stats function. Note that we can still access
        -:  149:// the $ and $Var macros as a sort of a self operator, but since this is not part of any implementation,
        -:  150:// fields cannot be specified.
        1:  151:void format_print_stats_impl()
        -:  152:{
        1:  153:	printf("-----------------------------------------------------\n");
        1:  154:	print_stats($());
        1:  155:	printf("-----------------------------------------------------\n");
        1:  156:}
        -:    0:Source:thread.c
        -:    0:Graph:thread.gcno
        -:    0:Data:thread.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <base/chain_allocator.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <core/thread.h>
        -:   19:#include <errno.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:int PANIC_TRUE = 1;
        -:   24:int PANIC_FALSE = 0;
        -:   25:
        -:   26:typedef struct ThreadArgsWrapper {
        -:   27:	void (*start_routine)(void *);
        -:   28:	void *args;
        -:   29:	FatPtr self;
        -:   30:} ThreadArgsWrapper;
        -:   31:
        -:   32:typedef struct ThreadImpl {
        -:   33:	pthread_t pth;
        -:   34:	u64 tid;
        -:   35:	FatPtr self;
        -:   36:} ThreadImpl;
        -:   37:
        4:   38:void Thread_cleanup(Thread *ptr) {
        4:   39:	if (chain_free(&ptr->impl))
    #####:   40:		panic("Could not free Thread");
        4:   41:}
        -:   42:
        4:   43:void *Thread_proc_start(void *arg) {
        -:   44:	// set jmp return point for panics
        4:   45:	if (PANIC_RETURN()) {
        1:   46:		pthread_exit(&PANIC_TRUE);
        -:   47:	}
        -:   48:
        4:   49:	ThreadArgsWrapper *taw = arg;
        4:   50:	(taw->start_routine)(taw->args);
        -:   51:
       3*:   52:	ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        3:   53:	if (chain_free(&taw->self))
    #####:   54:		panic("Could not free ThreadArgsWrapper");
        -:   55:
        3:   56:	if (__default_tl_heap_allocator != NULL) {
    #####:   57:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   58:	}
        -:   59:
        3:   60:	pthread_exit(&PANIC_FALSE);
        -:   61:}
        -:   62:
        4:   63:int Thread_start(Thread *th, void (*start_routine)(void *), void *args) {
        4:   64:	int ret = 0;
        4:   65:	ret = chain_malloc(&th->impl, sizeof(ThreadImpl));
        -:   66:
        4:   67:	if (!ret) {
        -:   68:
        8:   69:		ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        4:   70:		ThreadImpl *ti = th->impl.data;
        -:   71:
        -:   72:		FatPtr tawptr;
        4:   73:		ret = chain_malloc(&tawptr, sizeof(ThreadArgsWrapper));
        -:   74:
        4:   75:		if (!ret) {
        4:   76:			ThreadArgsWrapper *data = tawptr.data;
        4:   77:			data->start_routine = start_routine;
        4:   78:			data->args = args;
        4:   79:			data->self = tawptr;
        -:   80:
        4:   81:			ret = pthread_create(&ti->pth, NULL, Thread_proc_start, data);
        -:   82:		}
        -:   83:	}
        4:   84:	return ret;
        -:   85:}
        -:   86:
        4:   87:JoinResult Thread_join(Thread *ptr) {
        4:   88:	int result = -1;
        4:   89:	int *status = &PANIC_FALSE;
        -:   90:
        4:   91:	if (ptr == NULL)
    #####:   92:		errno = EINVAL;
        -:   93:	else {
        4:   94:		ThreadImpl *ti = ptr->impl.data;
        4:   95:		result = pthread_join(ti->pth, (void *)&status);
        -:   96:	}
        4:   97:	JoinResult jr = {*status == PANIC_TRUE, result != 0};
        4:   98:	return jr;
        -:   99:}
        -:  100:
        4:  101:bool JoinResult_is_panic(JoinResult *jr) {
        4:  102:	return jr->is_panic;
        -:  103:}
        -:  104:
        4:  105:bool JoinResult_is_error(JoinResult *jr) {
        4:  106:	return jr->is_error;
        -:  107:}
        -:    0:Source:traits.c
        -:    0:Graph:traits.gcno
        -:    0:Data:traits.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/traits.h>
        -:   16:
    #####:   17:u64 size(const Obj* self)
        -:   18:{
    #####:   19:	if (self->flags & OBJECT_FLAGS_CONSUMED)
    #####:   20:		panic("Runtime error: Obj [%s@%" PRIu64
        -:   21:		      "] has already been consumed!",
    #####:   22:		      self->vtable->name, self->ptr.id);
    #####:   23:	u64 (*impl)() = find_fn(self, "size");
    #####:   24:	if (!impl)
    #####:   25:		panic("Runtime error: Trait bound violation! "
        -:   26:		      "Type "
        -:   27:		      "'%s' does "
        -:   28:		      "not implement the "
        -:   29:		      "required function [%s]",
    #####:   30:		      TypeName((*self)), "size");
    #####:   31:	SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};
    #####:   32:	__thread_local_self_Const = self;
    #####:   33:	__thread_local_self_Var = NULL;
        -:   34:
    #####:   35:	return impl();
        -:   36:}
        -:   37:
       30:   38:void drop(Obj* self)
        -:   39:{
       30:   40:	if (self->flags & OBJECT_FLAGS_CONSUMED)
    #####:   41:		panic("Runtime error: Obj [%s@%" PRIu64
        -:   42:		      "] has already been consumed!",
    #####:   43:		      self->vtable->name, self->ptr.id);
       30:   44:	void (*impl)() = find_fn(self, "drop");
       30:   45:	SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};
       30:   46:	__thread_local_self_Const = self;
       30:   47:	__thread_local_self_Var = self;
        -:   48:
        -:   49:	// custom code here (set no cleanup since we're already done and consume
        -:   50:	// the object):
       30:   51:	self->flags |= OBJECT_FLAGS_NO_CLEANUP | OBJECT_FLAGS_CONSUMED;
        -:   52:	// free the pointer here as well since cleanup will not be called
       30:   53:	if (fat_ptr_data(&self->ptr))
        -:   54:	{
       30:   55:		chain_free(&self->ptr);
        -:   56:	}
        -:   57:	// in the case of no drop existing we just return
       30:   58:	if (impl)
       20:   59:		impl();
       30:   60:}
        -:   61:
        -:   62:// default implementation of clone_from
        1:   63:void clone_from_impl(Obj* to_clone)
        -:   64:{
        -:   65:	// call the type specific 'klone' required method.
        1:   66:	let v = klone(to_clone);
        -:   67:	// move the result to $Var() internal self reference.
        -:   68:	// cleanup handled by Move.
       1*:   69:	Move($Var(), &v);
        1:   70:}
        -:    0:Source:type.c
        -:    0:Graph:type.gcno
        -:    0:Data:type.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/panic.h>
        -:   16:#include <core/type.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        -:   20:_Thread_local const Obj *__thread_local_self_Const = NULL;
        -:   21:_Thread_local Obj *__thread_local_self_Var = NULL;
        -:   22:
        -:   23:atomic_ullong __global_counter__;
       39:   24:void __attribute__((constructor)) init_global_counter() {
       39:   25:	atomic_init(&__global_counter__, 1);
       39:   26:}
        -:   27:
    #####:   28:u64 unique_id() {
    #####:   29:	u64 ret = atomic_fetch_add(&__global_counter__, 1);
    #####:   30:	return ret;
        -:   31:}
        -:   32:
      152:   33:FatPtr build_fat_ptr(u64 size) {
        -:   34:	FatPtr ret;
      152:   35:	if (chain_malloc(&ret, size)) {
        -:   36:		// if chain_malloc is an error we set data to NULL and caller to
        -:   37:		// handle
    #####:   38:		ret.data = NULL;
        -:   39:	}
      152:   40:	return ret;
        -:   41:}
        -:   42:
   111991:   43:int compare_vtable_entry(const void *ent1, const void *ent2) {
   111991:   44:	const VtableEntry *vtent1 = ent1;
   111991:   45:	const VtableEntry *vtent2 = ent2;
   111991:   46:	return strcmp(vtent1->name, vtent2->name);
        -:   47:}
        -:   48:
    14264:   49:void sort_vtable(Vtable *table) {
    14264:   50:	qsort(table->entries, table->len, sizeof(VtableEntry), compare_vtable_entry);
    14264:   51:}
        -:   52:
    14264:   53:void vtable_add_entry(Vtable *table, VtableEntry entry) {
    14264:   54:	if (table->entries == NULL) {
     1725:   55:		table->entries = malloc(sizeof(VtableEntry) * (table->len + 1));
     1725:   56:		if (table->entries == NULL)
    #####:   57:			panic("Couldn't allocate memory for vtable");
        -:   58:	} else {
    12539:   59:		void *tmp = realloc(table->entries, sizeof(VtableEntry) * (table->len + 1));
    12539:   60:		if (tmp == NULL)
    #####:   61:			panic("Couldn't allocate memory for vtable");
    12539:   62:		table->entries = tmp;
        -:   63:	}
        -:   64:
    14264:   65:	memcpy(&table->entries[table->len], &entry, sizeof(VtableEntry));
    14264:   66:	table->len += 1;
    14264:   67:	sort_vtable(table);
    14264:   68:}
        -:   69:
       38:   70:void vtable_override(Vtable *table, VtableEntry entry) {
      228:   71:	for (int i = 0; i < table->len; i++) {
      190:   72:		if (!strcmp(entry.name, table->entries[i].name)) {
       38:   73:			table->entries[i].fn_ptr = entry.fn_ptr;
        -:   74:		}
        -:   75:	}
       38:   76:}
        -:   77:
      304:   78:bool vtable_check_impl_trait(const Vtable *table, const char *trait) {
      304:   79:	bool ret = false;
        -:   80:
      494:   81:	for (u64 i = 0; i < table->trait_len; i++) {
      494:   82:		if (!strcmp(table->trait_entries[i].trait_name, trait)) {
      304:   83:			ret = true;
      304:   84:			break;
        -:   85:		}
        -:   86:	}
        -:   87:
      304:   88:	return ret;
        -:   89:}
        -:   90:
     8252:   91:void vtable_add_trait(Vtable *table, char *trait) {
     8252:   92:	if (table->trait_entries == NULL) {
     1724:   93:		table->trait_entries = malloc(sizeof(VtableTraitEntry) * (table->trait_len + 1));
     1724:   94:		if (table->trait_entries == NULL)
    #####:   95:			panic("Couldn't allocate memory for vtable");
        -:   96:	} else {
        -:   97:		void *tmp =
     6528:   98:			realloc(table->trait_entries, sizeof(VtableTraitEntry) * (table->trait_len + 1));
     6528:   99:		if (tmp == NULL)
    #####:  100:			panic("Couldn't allocate memory for vtable");
     6528:  101:		table->trait_entries = tmp;
        -:  102:	}
        -:  103:
        -:  104:	VtableTraitEntry entry;
     8252:  105:	if (strlen(trait) >= MAX_TRAIT_NAME_LEN)
    #####:  106:		panic("trait name [%s] is too long. MAX_TRAIT_NAME_LEN = %i\n", trait,
        -:  107:			  MAX_TRAIT_NAME_LEN - 1);
     8252:  108:	strcpy(entry.trait_name, trait);
        -:  109:
     8252:  110:	memcpy(&table->trait_entries[table->trait_len], &entry, sizeof(VtableTraitEntry));
     8252:  111:	table->trait_len += 1;
     8252:  112:}
        -:  113:
      795:  114:void *find_fn(const Obj *obj, const char *name) {
      795:  115:	int left = 0;
      795:  116:	int right = obj->vtable->len - 1;
     2138:  117:	while (left <= right) {
     2048:  118:		int mid = left + (right - left) / 2;
     2048:  119:		int cmp = strcmp(name, obj->vtable->entries[mid].name);
        -:  120:
     2048:  121:		if (cmp == 0) {
      705:  122:			return obj->vtable->entries[mid].fn_ptr;
     1343:  123:		} else if (cmp < 0) {
      643:  124:			right = mid - 1;
        -:  125:		} else {
      700:  126:			left = mid + 1;
        -:  127:		}
        -:  128:	}
       90:  129:	return NULL;
        -:  130:}
        -:  131:
      247:  132:void SelfCleanupImpl_update(SelfCleanupImpl *ptr) {
      247:  133:	__thread_local_self_Const = ptr->prev_tl_self_Const;
      247:  134:	__thread_local_self_Var = ptr->prev_tl_self_Var;
      247:  135:}
        -:  136:
       69:  137:void Obj_check_param(const Obj *obj) {
       69:  138:	if (obj && (obj->flags & OBJECT_FLAGS_CONSUMED) != 0)
    #####:  139:		panic("Passing a consumed object as a function "
        -:  140:			  "parameter!");
       69:  141:}
        -:  142:
       17:  143:bool Obj_is_type(const Obj *ptr, char *ref) {
       17:  144:	if (!strcmp(TypeName((*ptr)), ref))
       17:  145:		return true;
    #####:  146:	return false;
        -:  147:}
        -:  148:
      152:  149:void Obj_build_int(Obj *ptr) {
        -:  150:	// call internal build handler
      152:  151:	void (*build_int)(Obj *ptr) = find_fn(ptr, "build_internal");
      152:  152:	if (!build_int)
    #####:  153:		panic("no internal build handler found");
      152:  154:	build_int(ptr);
      152:  155:}
        -:  156:
      152:  157:void Obj_build(Obj *ptr, const void *config) {
      152:  158:	void (*do_build)(const void *config) = find_fn(ptr, "build");
      152:  159:	if (do_build) {
        -:  160:		// setup self references
      148:  161:		Obj *tmp_Var = __thread_local_self_Var;
      148:  162:		const Obj *tmp_Const = __thread_local_self_Const;
      148:  163:		__thread_local_self_Const = ptr;
      148:  164:		__thread_local_self_Var = ptr;
      148:  165:		do_build(config);
        -:  166:		// revert
      148:  167:		__thread_local_self_Var = tmp_Var;
      148:  168:		__thread_local_self_Const = tmp_Const;
        -:  169:	}
      152:  170:}
        -:  171:
        -:  172:#if defined(__clang__)
        -:  173:// Clang-specific pragma
        -:  174:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  175:#elif defined(__GNUC__) && !defined(__clang__)
        -:  176:// GCC-specific pragma
        -:  177:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  178:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  179:#else
        -:  180:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  181:#endif
      236:  182:void Obj_cleanup(const Obj *ptr) {
      236:  183:	Obj *unconst = ptr;
      236:  184:	if ((unconst->flags & OBJECT_FLAGS_NO_CLEANUP) == 0) {
        -:  185:		// call internal drop handler
      122:  186:		void (*drop_int)(Obj *ptr) = find_fn(ptr, "drop_internal");
      122:  187:		if (!drop_int)
    #####:  188:			panic("no internal drop handler found");
      122:  189:		drop_int(unconst);
        -:  190:
        -:  191:		// call defined drop handler
      122:  192:		void (*drop)(Obj *ptr) = find_fn(ptr, "drop");
      122:  193:		if (drop) {
        -:  194:			// setup self references
       46:  195:			Obj *tmp_Var = __thread_local_self_Var;
       46:  196:			Obj *tmp_Const = __thread_local_self_Const;
       46:  197:			__thread_local_self_Const = unconst;
       46:  198:			__thread_local_self_Var = unconst;
       46:  199:			drop(ptr);
        -:  200:			// revert
       46:  201:			__thread_local_self_Var = tmp_Var;
       46:  202:			__thread_local_self_Const = tmp_Const;
        -:  203:		}
      122:  204:		if (fat_ptr_data(&unconst->ptr)) {
      122:  205:			chain_free(&unconst->ptr);
        -:  206:		}
        -:  207:	}
      236:  208:}
        -:  209:
        -:  210:#if defined(__clang__)
        -:  211:// Clang-specific pragma
        -:  212:#pragma GCC diagnostic push
        -:  213:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  214:#elif defined(__GNUC__) && !defined(__clang__)
        -:  215:// GCC-specific pragma
        -:  216:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  217:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  218:#else
        -:  219:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  220:#endif
       45:  221:void Obj_mark_consumed(const Obj *ptr) {
       45:  222:	Obj *unconst = ptr;
       45:  223:	unconst->flags |= OBJECT_FLAGS_NO_CLEANUP | OBJECT_FLAGS_CONSUMED;
       45:  224:}
        -:  225:#pragma GCC diagnostic pop
        -:    0:Source:unit.c
        -:    0:Graph:unit.gcno
        -:    0:Data:unit.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/unit.h>
        -:   16:
      39*:   17:Type(Unit);
------------------
__add_impls_Unit_vtable:
       39:   17:Type(Unit);
------------------
Unit_drop_internal:
    #####:   17:Type(Unit);
------------------
Unit_build_internal:
    #####:   17:Type(Unit);
------------------
Unit_size:
    #####:   17:Type(Unit);
------------------
        -:    0:Source:chain_allocator.c
        -:    0:Graph:chain_allocator.gcno
        -:    0:Data:chain_allocator.gcda
        -:    0:Runs:55
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <errno.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:
        -:   22:// the default heap allocator for the current thread
        -:   23:_Thread_local HeapAllocator *__default_tl_heap_allocator = NULL;
        -:   24:
        -:   25:// the global heap allocator (used when the memory will potentially be
        -:   26:// deallocated in a different thread than it was created in
        -:   27:HeapAllocator *__global_sync_allocator = NULL;
        -:   28:// lock for the global heap allocator
        -:   29:Lock *__global_sync_allocator_lock = NULL;
        -:   30:
        -:   31:// default heap allocator config (no_malloc and zeroed are disabled)
        -:   32:HeapAllocatorConfig __default_hconfig_ = { false, false };
        -:   33:
        -:   34:// create default slab sizes for the heap allocator with alignment in mind
        -:   35:#define HD_CFG(size) { size, 10, 0, UINT32_MAX }
        -:   36:HeapDataParamsConfig __default_hdpc_arr_value[] = { HD_CFG(8), HD_CFG(16), HD_CFG(32), HD_CFG(48),
        -:   37:	HD_CFG(64), HD_CFG(80), HD_CFG(96), HD_CFG(112), HD_CFG(128), HD_CFG(144), HD_CFG(160),
        -:   38:	HD_CFG(176), HD_CFG(192), HD_CFG(208), HD_CFG(224), HD_CFG(240), HD_CFG(256), HD_CFG(272),
        -:   39:	HD_CFG(288), HD_CFG(304), HD_CFG(320), HD_CFG(336), HD_CFG(352), HD_CFG(368), HD_CFG(384),
        -:   40:	HD_CFG(400), HD_CFG(416), HD_CFG(432), HD_CFG(448), HD_CFG(464), HD_CFG(480), HD_CFG(496),
        -:   41:	HD_CFG(512), HD_CFG(1024), HD_CFG(2048), HD_CFG(4096), HD_CFG(8192),
        -:   42:	{ 16384, 5, 0, UINT32_MAX }, { 32768, 5, 0, UINT32_MAX }, { 65536, 2, 0, UINT32_MAX } };
        -:   43:
        -:   44:// heap allocator config
        -:   45:HeapDataParamsConfig *__default_hdpc_arr_ = __default_hdpc_arr_value;
        -:   46:
        -:   47:// the size of the default array
        -:   48:u64 __default_hdpc_arr_size
        -:   49:	= sizeof(__default_hdpc_arr_value) / sizeof(__default_hdpc_arr_value[0]);
        -:   50:
        -:   51:// allows for overwriting the hconfig
    #####:   52:void set_default_hconfig(HeapAllocatorConfig *hconfig)
        -:   53:{
    #####:   54:	__default_hconfig_ = *hconfig;
    #####:   55:}
        -:   56:
        -:   57:// allows for overwriting of the default hdpc array
        2:   58:void set_default_hdpc_arr(HeapDataParamsConfig arr[], u64 size)
        -:   59:{
        2:   60:	__default_hdpc_arr_ = arr;
        2:   61:	__default_hdpc_arr_size = size;
        2:   62:}
        -:   63:
        -:   64:// build the using the default heap allocator config
       40:   65:int build_default_heap_allocator(HeapAllocator *ptr)
        -:   66:{
       40:   67:	return heap_allocator_build_arr(
        -:   68:		ptr, &__default_hconfig_, __default_hdpc_arr_, __default_hdpc_arr_size);
        -:   69:}
        -:   70:
        -:   71:// init the global sync allocator
        4:   72:void global_sync_allocator_init()
        -:   73:{
        -:   74:	// allocate for the data structure
        4:   75:	__global_sync_allocator = mymalloc(sizeof(HeapAllocator));
        4:   76:	__global_sync_allocator_lock = mymalloc(sizeof(Lock));
        -:   77:
        -:   78:	// check for failures
        4:   79:	if (__global_sync_allocator_lock == NULL || __global_sync_allocator == NULL) {
        -:   80:		// deallocate and panic
    #####:   81:		if (__global_sync_allocator_lock != NULL)
    #####:   82:			myfree(__global_sync_allocator_lock);
    #####:   83:		if (__global_sync_allocator != NULL)
    #####:   84:			myfree(__global_sync_allocator);
    #####:   85:		panic("Could not initialize the global sync HeapAllocator");
        -:   86:	}
        -:   87:
        -:   88:	// setup the lock
        4:   89:	*__global_sync_allocator_lock = LOCK();
        -:   90:
        -:   91:	// build with the default configurations
        4:   92:	if (build_default_heap_allocator(__global_sync_allocator)) {
    #####:   93:		myfree(__global_sync_allocator);
    #####:   94:		panic("Could not initialize the global sync HeapAllocator");
        -:   95:	}
        4:   96:}
        -:   97:
        -:   98:// Entry for the chain allocator stack.
        -:   99:typedef struct ChainGuardEntry {
        -:  100:	HeapAllocator *ha;
        -:  101:	bool is_sync;
        -:  102:	Lock *lock;
        -:  103:} ChainGuardEntry;
        -:  104:
        -:  105:// stack for chain allocators
        -:  106:_Thread_local ChainGuardEntry __thread_local_chain_allocator[MAX_CHAIN_ALLOCATOR_DEPTH];
        -:  107:_Thread_local u64 __thread_local_chain_allocator_index = 0;
        -:  108:
        -:  109:// cleanup the local thread allocator (used when threads terminate)
        1:  110:void thread_local_allocator_cleanup()
        -:  111:{
        1:  112:	if (__thread_local_chain_allocator_index > 0)
        1:  113:		heap_allocator_cleanup(
        -:  114:			__thread_local_chain_allocator[__thread_local_chain_allocator_index].ha);
        1:  115:}
        -:  116:
        1:  117:void global_sync_allocator_cleanup()
        -:  118:{
        1:  119:	if (__global_sync_allocator != NULL)
        1:  120:		heap_allocator_cleanup(__global_sync_allocator);
        1:  121:}
        -:  122:
       18:  123:void chain_guard_cleanup(ChainGuard *ptr)
        -:  124:{
       18:  125:	__thread_local_chain_allocator_index--;
       18:  126:}
        -:  127:
       21:  128:ChainGuard chain_guard(ChainConfig *config)
        -:  129:{
       21:  130:	if (__thread_local_chain_allocator_index >= MAX_CHAIN_ALLOCATOR_DEPTH)
    #####:  131:		panic("too many chain allocators");
        -:  132:
       21:  133:	ChainGuardPtr ret
       21:  134:		= { __thread_local_chain_allocator_index, config->ha, config->is_sync, config->lock };
        -:  135:
       21:  136:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].ha = config->ha;
       21:  137:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].is_sync = config->is_sync;
       21:  138:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].lock = config->lock;
        -:  139:
       21:  140:	__thread_local_chain_allocator_index++;
       21:  141:	return ret;
        -:  142:}
        -:  143:
      262:  144:int chain_malloc(FatPtr *ptr, u64 size)
        -:  145:{
      262:  146:	if (__thread_local_chain_allocator_index == 0) {
        -:  147:		// thread local allocator has not been initialized. Create it
        -:  148:		// now.
       25:  149:		HeapAllocator *ha = mymalloc(sizeof(HeapAllocator));
       25:  150:		if (!ha)
    #####:  151:			return -1;
        -:  152:
       25:  153:		if (build_default_heap_allocator(ha)) {
    #####:  154:			myfree(ha);
    #####:  155:			return -1;
        -:  156:		};
        -:  157:
       25:  158:		__default_tl_heap_allocator = ha;
       25:  159:		__thread_local_chain_allocator[0].ha = ha;
       25:  160:		__thread_local_chain_allocator[0].is_sync = false;
       25:  161:		__thread_local_chain_allocator_index++;
        -:  162:	}
      262:  163:	if (size == 0)
    #####:  164:		return -1;
        -:  165:
      262:  166:	u64 index = __thread_local_chain_allocator_index - 1;
      262:  167:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  168:
        -:  169:	int ret;
        -:  170:	{
      262:  171:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
      262:  172:		if (is_sync)
        5:  173:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  174:
      262:  175:		ret = heap_allocator_allocate(__thread_local_chain_allocator[index].ha, size, ptr);
        -:  176:	}
        -:  177:
      262:  178:	return ret;
        -:  179:}
       19:  180:int chain_realloc(FatPtr *dst, FatPtr *src, u64 size)
        -:  181:{
       19:  182:	if (__thread_local_chain_allocator_index == 0) {
    #####:  183:		return -1;
        -:  184:	}
       19:  185:	if (size == 0) {
    #####:  186:		errno = EINVAL;
    #####:  187:		return -1;
        -:  188:	}
       19:  189:	u64 index = __thread_local_chain_allocator_index - 1;
       19:  190:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  191:
        -:  192:	int ret;
        -:  193:	{
       19:  194:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
       19:  195:		if (is_sync)
    #####:  196:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  197:
       19:  198:		ret = heap_allocator_allocate(__thread_local_chain_allocator[index].ha, size, dst);
       19:  199:		if (!ret) {
       19:  200:			void *src_data = fat_ptr_data(src);
       19:  201:			void *dst_data = fat_ptr_data(dst);
       19:  202:			u64 len = fat_ptr_len(src);
       19:  203:			memcpy(dst_data, src_data, len);
       19:  204:			ret = chain_free(src);
        -:  205:		}
        -:  206:	}
        -:  207:
       19:  208:	return ret;
        -:  209:}
      244:  210:int chain_free(FatPtr *ptr)
        -:  211:{
      244:  212:	if (__thread_local_chain_allocator_index == 0) {
    #####:  213:		errno = ERANGE;
    #####:  214:		return -1;
        -:  215:	}
      244:  216:	u64 index = __thread_local_chain_allocator_index - 1;
      244:  217:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  218:
        -:  219:	int ret;
        -:  220:	{
      244:  221:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
      244:  222:		if (is_sync)
        4:  223:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  224:
      244:  225:		ret = heap_allocator_free(__thread_local_chain_allocator[index].ha, ptr);
        -:  226:	}
      244:  227:	return ret;
        -:  228:}
        -:    0:Source:heap.c
        -:    0:Graph:heap.gcno
        -:    0:Data:heap.gcda
        -:    0:Runs:55
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/heap.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        -:   20:// internal representation of the HeapDataParamsConfig with the required
        -:   21:// free_list_head value.
        -:   22:typedef struct HeapDataParams {
        -:   23:	HeapDataParamsConfig config;
        -:   24:	u32 free_list_head; // The next slab that is free
        -:   25:} HeapDataParams;
        -:   26:
        -:   27:// The data associated with each slab_size.
        -:   28:typedef struct HeapData {
        -:   29:	void **data; // pointers to each chunk of data
        -:   30:	u32 *free_list; // the pointers for free slabs.
        -:   31:	u32 count; // the number of chunks currently allocated
        -:   32:	u32 cur_slabs; // the number of slabs currently allocated
        -:   33:	u32 cur_slabs_allocated; // the number of slabs currently allocated;
        -:   34:	HeapDataParams hdp; // The heap data params for this HeapData
        -:   35:} HeapData;
        -:   36:
        -:   37:// The opaque pointer type which is stored in the HeapAllocator data structure
        -:   38:// which is used to access a HeapAllocator.
        -:   39:typedef struct HeapAllocatorImpl {
        -:   40:	u32 hd_size; // number of sizes available
        -:   41:	HeapAllocatorConfig config; // the configuration
        -:   42:	HeapData *hd_arr; // The array of heap data.
        -:   43:	u32 cur_malloc_slabs_allocated; // the number of slabs currently allocated directly via malloc
        -:   44:} HeapAllocatorImpl;
        -:   45:
        -:   46:// debugging options/counters
        -:   47:u64 __malloc_count = 0;
        -:   48:u64 __free_count = 0;
        -:   49:bool __debug_build_allocator_malloc_fail1 = false;
        -:   50:bool __debug_build_allocator_malloc_fail2 = false;
        -:   51:bool __debug_build_allocator_malloc_fail3 = false;
        -:   52:bool __debug_build_allocator_malloc_fail4 = false;
        -:   53:bool __debug_build_allocator_malloc_fail5 = false;
        -:   54:bool __debug_build_allocator_malloc_fail6 = false;
        -:   55:bool __debug_build_allocator_malloc_fail7 = false;
        -:   56:bool __debug_build_allocator_malloc_fail8 = false;
        -:   57:
      453:   58:void *do_malloc(size_t size)
        -:   59:{
      453:   60:	__malloc_count += 1;
      453:   61:	void *ret = malloc(size);
        -:   62:	// printf("malloc %zu [%p (%llu)]\n", size, ret, __malloc_count);
      453:   63:	return ret;
        -:   64:}
        -:   65:
      261:   66:void do_free(void *ptr)
        -:   67:{
      261:   68:	__free_count += 1;
        -:   69:	// printf("free %p (%llu)\n", ptr, __free_count);
      261:   70:	free(ptr);
      261:   71:}
        -:   72:
       35:   73:void *do_realloc(void *ptr, size_t size)
        -:   74:{
       35:   75:	void *ret = realloc(ptr, size);
        -:   76:	// printf("realloc %zu [old=%p,new=%p]\n", size, ptr, ret);
       35:   77:	return ret;
        -:   78:}
        -:   79:
      198:   80:void *fat_ptr_data(const FatPtr *ptr)
        -:   81:{
      198:   82:	return ptr->data;
        -:   83:}
        -:   84:
       31:   85:u64 fat_ptr_len(const FatPtr *ptr)
        -:   86:{
       31:   87:	return ptr->len;
        -:   88:}
        -:   89:
        5:   90:u64 fat_ptr_id(const FatPtr *ptr)
        -:   91:{
        5:   92:	return ptr->id;
        -:   93:}
        -:   94:
      118:   95:int heap_allocator_init_free_list(HeapData *hd, u64 index, u32 slabs, bool last_is_uint_max)
        -:   96:{
      118:   97:	hd->data[index] = NULL; // set to NULL for cleanup consistency
        -:   98:
        -:   99:	// allocate memory for slabs
      118:  100:	if (!__debug_build_allocator_malloc_fail4)
      116:  101:		hd->data[index] = do_malloc(hd->hdp.config.slab_size * slabs);
      118:  102:	if (hd->data[index] == NULL)
        2:  103:		return -1;
        -:  104:
      116:  105:	void *tmp = NULL;
        -:  106:
        -:  107:	// allocate / or reallocate the freelist
      116:  108:	if (!__debug_build_allocator_malloc_fail5) {
      114:  109:		if (index == 0)
       97:  110:			tmp = do_malloc(sizeof(u32) * slabs);
        -:  111:		else {
       17:  112:			tmp = do_realloc(hd->free_list, sizeof(u32) * (hd->cur_slabs + slabs));
        -:  113:		}
        -:  114:	}
        -:  115:
      116:  116:	if (!tmp) {
        2:  117:		do_free(hd->data[index]);
        2:  118:		return -1;
        -:  119:	}
        -:  120:
      114:  121:	hd->free_list = tmp;
        -:  122:
        -:  123:	// initialize the values of the free list.
      114:  124:	u32 offset = index * hd->hdp.config.slabs_per_resize;
     1367:  125:	for (u64 i = 0; i < slabs; i++) {
     1253:  126:		if ((i == (slabs - 1)) && last_is_uint_max)
      113:  127:			hd->free_list[i + offset] = UINT32_MAX;
        -:  128:		else
     1140:  129:			hd->free_list[i + offset] = offset + i + 1;
        -:  130:	}
        -:  131:
      114:  132:	return 0;
        -:  133:}
        -:  134:
        -:  135:// compare function used for sorting.
     3815:  136:int heap_data_compare(const void *p1, const void *p2)
        -:  137:{
     3815:  138:	int ret = 0;
        -:  139:
     3815:  140:	HeapData d1 = *(HeapData *)p1;
     3815:  141:	HeapData d2 = *(HeapData *)p2;
        -:  142:
     3815:  143:	if (d1.hdp.config.slab_size > d2.hdp.config.slab_size)
        1:  144:		ret = 1;
     3814:  145:	else if (d1.hdp.config.slab_size < d2.hdp.config.slab_size)
     3813:  146:		ret = -1;
        -:  147:
     3815:  148:	return ret;
        -:  149:}
        -:  150:
        -:  151:// initialize the heap data params
     1555:  152:int heap_allocator_init_hdp(HeapAllocator *ptr, HeapDataParamsConfig *hdp, u64 index)
        -:  153:{
        -:  154:
        -:  155:	// set some value in case of a failure below such that cleanup can
        -:  156:	// succeed
     1555:  157:	int ret = 0;
     1555:  158:	ptr->impl->hd_arr[index].hdp.config = *hdp;
     1555:  159:	ptr->impl->hd_arr[index].hdp.free_list_head = 0;
     1555:  160:	ptr->impl->hd_arr[index].cur_slabs = 0;
     1555:  161:	ptr->impl->hd_arr[index].cur_slabs_allocated = 0;
     1555:  162:	ptr->impl->hd_arr[index].count = ptr->impl->hd_arr[index].hdp.config.initial_chunks;
        -:  163:
        -:  164:	// if we have initial chunks, initialize them
     1555:  165:	if (ptr->impl->hd_arr[index].hdp.config.initial_chunks) {
       23:  166:		ptr->impl->hd_arr[index].data = NULL;
        -:  167:
        -:  168:		// try to allocate space for the data for this size
       23:  169:		if (!__debug_build_allocator_malloc_fail8)
       22:  170:			ptr->impl->hd_arr[index].data
       22:  171:				= do_malloc(ptr->impl->hd_arr[index].hdp.config.initial_chunks * sizeof(void *));
        -:  172:
        -:  173:		// if NULL return error
       23:  174:		if (ptr->impl->hd_arr[index].data == NULL)
        1:  175:			return -1;
        -:  176:
        -:  177:		// set cur_slabs value
       22:  178:		ptr->impl->hd_arr[index].cur_slabs = ptr->impl->hd_arr[index].hdp.config.initial_chunks
       22:  179:			* ptr->impl->hd_arr[index].hdp.config.slabs_per_resize;
        -:  180:
        -:  181:		// initialize the initial_chunks of the free list
       22:  182:		bool last_is_uint_max = false;
       22:  183:		ptr->impl->hd_arr[index].free_list = NULL;
       45:  184:		for (u64 i = 0; i < ptr->impl->hd_arr[index].hdp.config.initial_chunks; i++) {
        -:  185:
       23:  186:			if (i == ptr->impl->hd_arr[index].hdp.config.initial_chunks - 1)
       22:  187:				last_is_uint_max = true;
       23:  188:			if (heap_allocator_init_free_list(&ptr->impl->hd_arr[index], i,
       23:  189:					ptr->impl->hd_arr[index].hdp.config.slabs_per_resize, last_is_uint_max))
        2:  190:				ret = -1;
        -:  191:		}
        -:  192:	} else
     1532:  193:		ptr->impl->hd_arr[index].data = NULL;
     1554:  194:	return ret;
        -:  195:}
        -:  196:
       66:  197:int heap_allocator_build_arr(HeapAllocator *ptr, HeapAllocatorConfig *config,
        -:  198:	HeapDataParamsConfig arr[], u64 heap_data_params_count)
        -:  199:{
        -:  200:	// check inputs
       66:  201:	if (ptr == NULL || config == NULL || heap_data_params_count >= 256) {
        1:  202:		errno = EINVAL;
        1:  203:		return -1;
        -:  204:	}
        -:  205:
        -:  206:	// allocate the HeapAllocatorImpl
       65:  207:	if (!__debug_build_allocator_malloc_fail1)
       64:  208:		ptr->impl = do_malloc(sizeof(HeapAllocatorImpl));
       65:  209:	if (ptr->impl == NULL || __debug_build_allocator_malloc_fail1)
        1:  210:		return -1;
        -:  211:
       64:  212:	ptr->impl->cur_malloc_slabs_allocated = 0;
       64:  213:	ptr->impl->hd_size = 0;
        -:  214:
        -:  215:	// copy the config
       64:  216:	ptr->impl->config = *config;
        -:  217:
        -:  218:	// allocate heap data array
       64:  219:	ptr->impl->hd_arr = NULL;
       64:  220:	if (!__debug_build_allocator_malloc_fail2)
       63:  221:		ptr->impl->hd_arr = do_malloc(sizeof(HeapData) * heap_data_params_count);
       64:  222:	if (ptr->impl->hd_arr == NULL || __debug_build_allocator_malloc_fail2) {
        1:  223:		heap_allocator_cleanup(ptr);
        1:  224:		return -1;
        -:  225:	}
       63:  226:	ptr->impl->hd_size = heap_data_params_count;
        -:  227:
        -:  228:	// iterate through specified heap data params
     1615:  229:	for (u64 i = 0; i < heap_data_params_count; i++) {
     1556:  230:		HeapDataParamsConfig hdp = arr[i];
     1556:  231:		ptr->impl->hd_arr[i].count = 0; // init to 0 for safe cleanup
     1556:  232:		ptr->impl->hd_arr[i].data = NULL;
     1556:  233:		if ((__debug_build_allocator_malloc_fail3 && i > 0)
     1555:  234:			|| heap_allocator_init_hdp(ptr, &hdp, i)) {
        4:  235:			ptr->impl->hd_size = i; // update for cleanup, others
        -:  236:									// did not get allocated
        4:  237:			if (ptr->impl->hd_arr[i].data) {
        2:  238:				do_free(ptr->impl->hd_arr[i].data);
        -:  239:			}
        4:  240:			heap_allocator_cleanup(ptr);
        4:  241:			return -1;
        -:  242:		}
        -:  243:	}
        -:  244:
       59:  245:	if (heap_data_params_count) {
       57:  246:		qsort(ptr->impl->hd_arr, heap_data_params_count, sizeof(HeapData), heap_data_compare);
        -:  247:	}
        -:  248:
        -:  249:	// check invalid configurations
       59:  250:	u64 last_size = 0;
     1608:  251:	for (u64 i = 0; i < heap_data_params_count; i++) {
     1551:  252:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == 0) {
        -:  253:			// no 0 sized slabs allowed
        1:  254:			errno = EINVAL;
        1:  255:			heap_allocator_cleanup(ptr);
        1:  256:			return -1;
        -:  257:		}
        -:  258:		// note: logic correct because array is sorted.
     1550:  259:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == last_size) {
        -:  260:			// Duplicate slab_size
        1:  261:			errno = EEXIST;
        1:  262:			heap_allocator_cleanup(ptr);
        1:  263:			return -1;
        -:  264:		}
     1549:  265:		last_size = ptr->impl->hd_arr[i].hdp.config.slab_size;
        -:  266:	}
        -:  267:
       57:  268:	return 0;
        -:  269:}
        -:  270:
       26:  271:int heap_allocator_build(
        -:  272:	HeapAllocator *ptr, HeapAllocatorConfig *config, int heap_data_params_count, ...)
       26:  273:{
       26:  274:	int arr_size = heap_data_params_count;
        -:  275:
        -:  276:	// 0 size is allowed, so we update to address sanitizer warning.
       26:  277:	if (arr_size <= 0) {
        5:  278:		arr_size = 1;
        -:  279:	}
       26:  280:	HeapDataParamsConfig arr[arr_size];
        -:  281:	va_list hdps;
       26:  282:	va_start(hdps, heap_data_params_count);
        -:  283:	// build the array to pass to heap_allocator_build_arr
       55:  284:	for (u64 i = 0; i < heap_data_params_count; i++) {
       29:  285:		HeapDataParamsConfig hdp = va_arg(hdps, HeapDataParamsConfig);
       29:  286:		arr[i] = hdp;
        -:  287:	}
        -:  288:
       26:  289:	va_end(hdps);
        -:  290:	// call the array version of the function
       26:  291:	return heap_allocator_build_arr(ptr, config, arr, heap_data_params_count);
        -:  292:}
        -:  293:
        -:  294:// binary search for the correct slab size
      671:  295:int heap_allocator_index(HeapAllocator *ptr, u64 size)
        -:  296:{
      671:  297:	int ret = -1;
      671:  298:	if (ptr->impl->hd_size == 0)
        2:  299:		return ret;
        -:  300:
      669:  301:	int left = 0;
      669:  302:	int right = ptr->impl->hd_size - 1;
        -:  303:
     2085:  304:	while (left <= right) {
     1906:  305:		int mid = left + (right - left) / 2;
     1906:  306:		u64 slab_size = ptr->impl->hd_arr[mid].hdp.config.slab_size;
     1906:  307:		if (slab_size == size) {
      490:  308:			ret = mid;
      490:  309:			break;
     1416:  310:		} else if (slab_size > size)
     1073:  311:			right = mid - 1;
        -:  312:		else
      343:  313:			left = mid + 1;
        -:  314:	}
        -:  315:
      669:  316:	if (ret == -1 && right + 1 <= ptr->impl->hd_size - 1) {
      167:  317:		return right + 1;
        -:  318:	}
        -:  319:
      502:  320:	return ret;
        -:  321:}
        -:  322:
      103:  323:int heap_data_resize(u64 index, HeapData *hd)
        -:  324:{
        -:  325:	// check that we can resize this hdp
      103:  326:	if (hd->cur_slabs < hd->hdp.config.max_slabs) {
        -:  327:		// calculate the new slabs
       96:  328:		u32 nslabs_count = hd->hdp.config.slabs_per_resize + hd->cur_slabs;
       96:  329:		if (nslabs_count > hd->hdp.config.max_slabs)
        2:  330:			nslabs_count = hd->hdp.config.max_slabs;
        -:  331:
        -:  332:		// determine slabs to allocate
       96:  333:		u32 slabs_to_alloc = nslabs_count - hd->cur_slabs;
        -:  334:
        -:  335:		// attempt to allocate
       96:  336:		void *tmp = NULL;
       96:  337:		if (!__debug_build_allocator_malloc_fail7) {
       95:  338:			if (hd->data)
       18:  339:				tmp = do_realloc(hd->data, (hd->count + 1) * sizeof(void *));
        -:  340:			else
       77:  341:				tmp = do_malloc((hd->count + 1) * sizeof(void **));
        -:  342:		}
        -:  343:
       96:  344:		if (tmp == NULL)
        1:  345:			return -1;
       95:  346:		hd->data = tmp;
        -:  347:
        -:  348:		// initialize the new part of the free list
       95:  349:		if (heap_allocator_init_free_list(hd, hd->count, slabs_to_alloc, true))
        2:  350:			return -1;
       93:  351:		hd->hdp.free_list_head = hd->cur_slabs;
       93:  352:		hd->cur_slabs = nslabs_count;
       93:  353:		hd->count += 1;
       93:  354:		return 0;
        -:  355:	}
        7:  356:	return -1;
        -:  357:}
        -:  358:
      673:  359:int heap_data_allocate(u64 index, HeapData *hd, FatPtr *fptr)
        -:  360:{
      673:  361:	if (hd->cur_slabs == 0) {
        -:  362:		// this hd initially had 0 slabs
        -:  363:		// resize it
       78:  364:		if (heap_data_resize(index, hd))
        1:  365:			return -1;
        -:  366:	}
        -:  367:
        -:  368:	// no more slabs, return error
      672:  369:	if (hd->hdp.free_list_head == UINT32_MAX)
       24:  370:		return -1;
        -:  371:
        -:  372:	// get next free slab
      648:  373:	u64 id = hd->hdp.free_list_head;
        -:  374:
        -:  375:	// update free list head
      648:  376:	hd->hdp.free_list_head = hd->free_list[id];
        -:  377:
        -:  378:	// update with the specific index (differing slab sizes)
      648:  379:	fptr->id = id | (index << 56);
      648:  380:	fptr->len = hd->hdp.config.slab_size;
        -:  381:
      648:  382:	u64 heap_data_index = id / hd->hdp.config.slabs_per_resize;
      648:  383:	u64 offset_mod = id % hd->hdp.config.slabs_per_resize;
        -:  384:
        -:  385:	// set the data of the fptr
      648:  386:	fptr->data = hd->data[heap_data_index] + offset_mod * hd->hdp.config.slab_size;
      648:  387:	hd->cur_slabs_allocated++;
        -:  388:
      648:  389:	return 0;
        -:  390:}
        -:  391:
        -:  392:// free data in this HeapData
      361:  393:int heap_data_free(u64 index, HeapData *hd, FatPtr *fptr)
        -:  394:{
      361:  395:	u64 rel = fptr->id & 0x00FFFFFFFFFFFFFF; // Extract the relative ID
        -:  396:
        -:  397:	// if this is invalid return an error
      361:  398:	if (rel >= hd->cur_slabs)
        1:  399:		return -1;
        -:  400:
        -:  401:	// update head and rest of the list
      360:  402:	u64 head = hd->hdp.free_list_head;
      360:  403:	hd->hdp.free_list_head = rel;
      360:  404:	hd->free_list[rel] = head;
        -:  405:
      360:  406:	hd->cur_slabs_allocated--;
        -:  407:
      360:  408:	return 0;
        -:  409:}
        -:  410:
       11:  411:u64 heap_allocator_cur_slabs_allocated(HeapAllocator *ptr)
        -:  412:{
       11:  413:	u64 ret = ptr->impl->cur_malloc_slabs_allocated;
      451:  414:	for (int i = 0; i < ptr->impl->hd_size; i++) {
      440:  415:		ret += ptr->impl->hd_arr[i].cur_slabs_allocated;
        -:  416:	}
       11:  417:	return ret;
        -:  418:}
        -:  419:
        -:  420:// main allocation function
      671:  421:int heap_allocator_allocate(HeapAllocator *ptr, u64 size, FatPtr *fptr)
        -:  422:{
      671:  423:	int ret = -1;
        -:  424:	// determine the index via binary search
      671:  425:	int index = heap_allocator_index(ptr, size);
        -:  426:
        -:  427:	// if this index is not found (too big) fall back to malloc
      671:  428:	if (index < 0) {
       14:  429:		if (!ptr->impl->config.no_malloc) {
       12:  430:			fptr->data = NULL;
       12:  431:			if (!__debug_build_allocator_malloc_fail6) {
       11:  432:				ptr->impl->cur_malloc_slabs_allocated++;
       11:  433:				fptr->data = do_malloc(size);
        -:  434:			}
       12:  435:			if (fptr->data == NULL) {
        1:  436:				fptr->len = 0;
        1:  437:				ret = -1;
        -:  438:			} else {
       11:  439:				fptr->len = size;
       11:  440:				fptr->id = UINT64_MAX;
       11:  441:				ret = 0;
        -:  442:			}
        -:  443:		}
        -:  444:	} else {
      657:  445:		HeapData *hd = &ptr->impl->hd_arr[index];
      657:  446:		ret = heap_data_allocate(index, hd, fptr);
      657:  447:		if (ret) {
        -:  448:			// there are no more slabs. Try to resize
       25:  449:			if (!heap_data_resize(index, hd)) {
        -:  450:				// successful resize, allocate should always
        -:  451:				// succeed here
       16:  452:				ret = heap_data_allocate(index, hd, fptr);
        9:  453:			} else if (!ptr->impl->config.no_malloc) {
        -:  454:				// could not allocate, so we fall back to malloc
        -:  455:				// if configured
        4:  456:				fptr->data = NULL;
        4:  457:				if (!__debug_build_allocator_malloc_fail6)
        3:  458:					fptr->data = do_malloc(size);
        4:  459:				if (fptr->data == NULL) {
        1:  460:					fptr->len = 0;
        1:  461:					ret = -1;
        -:  462:				} else {
        3:  463:					fptr->len = size;
        3:  464:					fptr->id = UINT64_MAX;
        3:  465:					ret = 0;
        -:  466:				}
        -:  467:			}
        -:  468:		}
        -:  469:	}
        -:  470:
        -:  471:	// if zeroed is configured set all memory of allocated slabs to 0.
      671:  472:	if (!ret && ptr->impl->config.zeroed) {
       44:  473:		memset(fptr->data, 0, fptr->len);
        -:  474:	}
        -:  475:
      671:  476:	return ret;
        -:  477:}
        -:  478:
      376:  479:int heap_allocator_free(HeapAllocator *ptr, FatPtr *fptr)
        -:  480:{
      376:  481:	int ret = 0;
      376:  482:	if (fptr->id == UINT64_MAX) {
        -:  483:		// malloc allocated
        -:  484:
       14:  485:		if (fptr->data) {
       14:  486:			ptr->impl->cur_malloc_slabs_allocated--;
       14:  487:			do_free(fptr->data);
       14:  488:			fptr->data = NULL;
        -:  489:		}
        -:  490:
       14:  491:		ret = 0;
        -:  492:	} else {
        -:  493:
      362:  494:		u64 index = (fptr->id >> 56) & 0xFF; // Extract the index
        -:  495:
      362:  496:		if (index >= ptr->impl->hd_size) {
        1:  497:			errno = EINVAL;
        1:  498:			ret = -1; // invalid index
        -:  499:		} else {
      361:  500:			HeapData *hd = &ptr->impl->hd_arr[index];
      361:  501:			ret = heap_data_free(index, hd, fptr);
        -:  502:		}
        -:  503:	}
        -:  504:
      376:  505:	if (!ret && ptr->impl->config.zeroed) {
        1:  506:		memset(fptr->data, 0, fptr->len);
        -:  507:	}
        -:  508:
      376:  509:	return ret;
        -:  510:}
        -:  511:
       40:  512:int heap_allocator_cleanup(HeapAllocator *ptr)
        -:  513:{
        -:  514:	// check for impl and deallocate
       40:  515:	if (ptr->impl) {
      504:  516:		for (u32 i = 0; i < ptr->impl->hd_size; i++) {
      468:  517:			if (ptr->impl->hd_arr[i].count) {
        -:  518:				// check that it's not an unallocated heap data
       54:  519:				if (ptr->impl->hd_arr[i].free_list) {
       54:  520:					do_free(ptr->impl->hd_arr[i].free_list);
       54:  521:					ptr->impl->hd_arr[i].free_list = NULL;
        -:  522:				}
      118:  523:				for (u64 j = 0; j < ptr->impl->hd_arr[i].count; j++) {
       64:  524:					do_free(ptr->impl->hd_arr[i].data[j]);
        -:  525:				}
       54:  526:				if (ptr->impl->hd_arr[i].data) {
       54:  527:					do_free(ptr->impl->hd_arr[i].data);
       54:  528:					ptr->impl->hd_arr[i].data = NULL;
        -:  529:				}
        -:  530:			}
        -:  531:		}
        -:  532:
       36:  533:		if (ptr->impl->hd_arr) {
       35:  534:			do_free(ptr->impl->hd_arr);
       35:  535:			ptr->impl->hd_arr = NULL;
        -:  536:		}
       36:  537:		do_free(ptr->impl);
       36:  538:		ptr->impl = NULL;
        -:  539:	}
       40:  540:	return 0;
        -:  541:}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:55
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/lock.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <stdio.h>
        -:   18:#include <unistd.h>
        -:   19:
        -:   20:#define MAX_LOCKS 100
        -:   21:_Thread_local Lock *__active_locks_[MAX_LOCKS];
        -:   22:_Thread_local u64 __active_lock_count_ = 0;
        -:   23:
       15:   24:void insert_active_lock(Lock *ptr) {
       15:   25:	if (__active_lock_count_ >= MAX_LOCKS)
    #####:   26:		panic("too many locks!");
       15:   27:	__active_locks_[__active_lock_count_] = ptr;
       15:   28:	__active_lock_count_++;
       15:   29:}
       14:   30:void delete_active_lock(Lock *ptr) {
        -:   31:	// note: locks are removed in reverse order
        -:   32:	// It's possible that cleanup occurs in slightly different order
        -:   33:	// but the effect is the same each lock would be invalidated at the end
        -:   34:	// of a scope. For simplicity we just decrement here.
       14:   35:	if (__active_lock_count_ == 0)
    #####:   36:		panic("active lock stack underflow. Unexpected error!");
       14:   37:	__active_lock_count_--;
       14:   38:}
        -:   39:
        8:   40:Lock Lock_build() {
        -:   41:	LockPtr ret;
        8:   42:	pthread_mutex_init(&ret.lock, NULL);
        8:   43:	pthread_cond_init(&ret.cond, NULL);
        8:   44:	atomic_init(&ret.poison, false);
        8:   45:	atomic_init(&ret.is_locked, false);
        8:   46:	atomic_init(&ret.tid, 0);
        8:   47:	return ret;
        -:   48:}
        -:   49:
        4:   50:void Lock_cleanup(LockPtr *ptr) {
        4:   51:	pthread_mutex_destroy(&ptr->lock);
        4:   52:	pthread_cond_destroy(&ptr->cond);
        4:   53:}
        -:   54:
        1:   55:void Lock_set_poison(Lock *ptr) {
        1:   56:	atomic_exchange(&ptr->poison, true);
        1:   57:}
        1:   58:bool Lock_is_poisoned(Lock *ptr) {
        1:   59:	return atomic_load(&ptr->poison);
        -:   60:}
    #####:   61:void Lock_clear_poison(Lock *ptr) {
    #####:   62:	atomic_exchange(&ptr->poison, false);
    #####:   63:}
       15:   64:u64 Lock_get_tid() {
        -:   65:	u64 tid;
        -:   66:#ifdef __APPLE__
        -:   67:	pthread_threadid_np(NULL, &tid);
        -:   68:#else
       15:   69:	tid = gettid();
        -:   70:#endif // tid code
       15:   71:	return tid;
        -:   72:}
        -:   73:
       15:   74:LockGuard lock(Lock *ptr) {
       15:   75:	if (atomic_load(&ptr->poison))
    #####:   76:		panic("Lock %p: poisoned!", ptr);
        -:   77:
       15:   78:	u64 tid = Lock_get_tid();
        -:   79:
        -:   80:	// check if this would be a deadlock
      15*:   81:	if (atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid)
    #####:   82:		panic("Lock %p: attempt to lock would deadlock!", lock);
        -:   83:
        -:   84:	// obtain lock
       15:   85:	pthread_mutex_lock(&ptr->lock);
       15:   86:	if (atomic_load(&ptr->poison))
    #####:   87:		panic("Lock %p: poisoned!", ptr);
        -:   88:
       15:   89:	insert_active_lock(ptr);
        -:   90:
        -:   91:	// set tid/is_locked and return
       15:   92:	atomic_exchange(&ptr->tid, tid);
       15:   93:	atomic_exchange(&ptr->is_locked, true);
       15:   94:	LockGuardPtr ret = {ptr};
       15:   95:	return ret;
        -:   96:}
        -:   97:
      530:   98:void Lockguard_cleanup(LockGuardPtr *ptr) {
      530:   99:	if (ptr && ptr->ref) {
       14:  100:		atomic_exchange(&ptr->ref->is_locked, false);
       14:  101:		pthread_mutex_unlock(&ptr->ref->lock);
       14:  102:		delete_active_lock(ptr->ref);
        -:  103:	}
      530:  104:}
        -:  105:
        3:  106:void Lock_mark_poisoned() {
        3:  107:	if (__active_lock_count_) {
        1:  108:		u64 i = __active_lock_count_ - 1;
        -:  109:		while (true) {
        1:  110:			Lock_set_poison(__active_locks_[i]);
        1:  111:			atomic_exchange(&__active_locks_[i]->is_locked, false);
        1:  112:			pthread_mutex_unlock(&__active_locks_[i]->lock);
        1:  113:			if (i == 0)
        1:  114:				break;
    #####:  115:			i--;
        -:  116:		}
        -:  117:	}
        3:  118:}
        -:  119:
    #####:  120:void Lock_wait(Lock *ptr, u64 nanoseconds) {
    #####:  121:	u64 tid = Lock_get_tid();
    #####:  122:	if (!(atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid))
    #####:  123:		panic("Attempt to wait on lock %p without first obtaining the "
        -:  124:			  "lock!",
        -:  125:			  ptr);
    #####:  126:	if (nanoseconds == 0) {
    #####:  127:		pthread_cond_wait(&ptr->cond, &ptr->lock);
        -:  128:	} else {
        -:  129:		struct timespec ts;
    #####:  130:		clock_gettime(CLOCK_REALTIME, &ts);
        -:  131:
        -:  132:		// Convert the wait time into seconds and nanoseconds
    #####:  133:		ts.tv_sec += nanoseconds / 1000000000;
    #####:  134:		ts.tv_nsec += nanoseconds % 1000000000;
        -:  135:
        -:  136:		// Normalize the timespec structure in case of overflow in
        -:  137:		// nanoseconds
    #####:  138:		if (ts.tv_nsec >= 1000000000) {
    #####:  139:			ts.tv_sec += ts.tv_nsec / 1000000000;
    #####:  140:			ts.tv_nsec %= 1000000000;
        -:  141:		}
    #####:  142:		pthread_cond_timedwait(&ptr->cond, &ptr->lock, &ts);
        -:  143:	}
    #####:  144:}
        -:  145:
        2:  146:void Lock_notify(Lock *ptr) {
        2:  147:	pthread_cond_signal(&ptr->cond);
        2:  148:}
        -:  149:
    #####:  150:void Lock_notify_all(Lock *ptr) {
    #####:  151:	pthread_cond_broadcast(&ptr->cond);
    #####:  152:}
        -:    0:Source:misc.c
        -:    0:Graph:misc.gcno
        -:    0:Data:misc.gcda
        -:    0:Runs:55
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <dirent.h>
        -:   17:#include <limits.h>
        -:   18:#include <stdio.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:#include <sys/stat.h>
        -:   22:#include <unistd.h>
        -:   23:
        3:   24:const char *rstrstr(const char *s1, const char *s2)
        -:   25:{
        3:   26:	size_t s1len = strlen(s1);
        3:   27:	size_t s2len = strlen(s2);
        -:   28:	const char *s;
        -:   29:
        3:   30:	if (s2len > s1len)
    #####:   31:		return NULL;
       25:   32:	for (s = s1 + s1len - s2len; s >= s1; --s)
       25:   33:		if (strncmp(s, s2, s2len) == 0)
        3:   34:			return s;
    #####:   35:	return NULL;
        -:   36:}
        -:   37:
        1:   38:size_t read_all(void *buffer, size_t size, size_t count, FILE *stream)
        -:   39:{
        1:   40:	size_t total_read = 0;
        1:   41:	size_t bytes_to_read = size * count;
        -:   42:	size_t bytes_read;
        -:   43:
        2:   44:	while (total_read < bytes_to_read) {
        1:   45:		bytes_read = fread((char *)buffer + total_read, 1, bytes_to_read - total_read, stream);
        1:   46:		if (bytes_read == 0) {
        -:   47:			// Check for EOF or error
    #####:   48:			if (feof(stream)) {
    #####:   49:				break; // End of file reached
    #####:   50:			} else if (ferror(stream)) {
    #####:   51:				perror("Read error");
    #####:   52:				break; // Error occurred
        -:   53:			}
        -:   54:		}
        1:   55:		total_read += bytes_read;
        -:   56:	}
        -:   57:
        1:   58:	return total_read;
        -:   59:}
        -:   60:
    #####:   61:int copy_file(const char *dst, const char *src)
    #####:   62:{
        -:   63:	FILE *source_file, *dest_file;
        -:   64:	size_t bytes;
        -:   65:
        -:   66:	// Open the source file in binary read mode
    #####:   67:	source_file = myfopen(src, "rb");
    #####:   68:	if (source_file == NULL) {
    #####:   69:		perror("Error opening source file");
    #####:   70:		return -1;
        -:   71:	}
        -:   72:
        -:   73:	// Determine the file size
    #####:   74:	fseek(source_file, 0, SEEK_END);
    #####:   75:	long file_size = ftell(source_file);
    #####:   76:	fseek(source_file, 0, SEEK_SET);
    #####:   77:	char buffer[file_size];
        -:   78:
        -:   79:	// Open the destination file in binary write mode
    #####:   80:	dest_file = myfopen(dst, "wb");
    #####:   81:	if (dest_file == NULL) {
    #####:   82:		perror("Error opening destination file");
    #####:   83:		fclose(source_file);
    #####:   84:		return -1;
        -:   85:	}
        -:   86:
        -:   87:	// Copy the file content
    #####:   88:	while ((bytes = fread(buffer, 1, file_size, source_file)) > 0) {
    #####:   89:		if (fwrite(buffer, 1, bytes, dest_file) != bytes) {
    #####:   90:			perror("Error writing to destination file");
    #####:   91:			fclose(source_file);
    #####:   92:			fclose(dest_file);
    #####:   93:			return -1;
        -:   94:		}
        -:   95:	}
        -:   96:
        -:   97:	// Close both files
    #####:   98:	myfclose(source_file);
    #####:   99:	myfclose(dest_file);
        -:  100:
    #####:  101:	return 0;
        -:  102:}
        -:  103:
        -:  104:// Function to recursively remove a directory and its contents
       22:  105:int remove_directory(const char *path)
        -:  106:{
        -:  107:	struct dirent *entry;
       22:  108:	DIR *dir = opendir(path);
        -:  109:
       22:  110:	if (dir == NULL) {
       11:  111:		return -1;
        -:  112:	}
        -:  113:
       34:  114:	while ((entry = readdir(dir)) != NULL) {
        -:  115:		char full_path[PATH_MAX];
        -:  116:
        -:  117:		// Skip the special entries "." and ".."
       23:  118:		if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
       22:  119:			continue;
        -:  120:		}
        -:  121:
        -:  122:		// Construct the full path to the file/directory
        1:  123:		snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        -:  124:
        -:  125:		struct stat statbuf;
        1:  126:		if (stat(full_path, &statbuf) == -1) {
    #####:  127:			perror("stat");
    #####:  128:			closedir(dir);
    #####:  129:			return -1;
        -:  130:		}
        -:  131:
        1:  132:		if (S_ISDIR(statbuf.st_mode)) {
        -:  133:			// It's a directory, recurse into it
    #####:  134:			if (remove_directory(full_path) == -1) {
    #####:  135:				closedir(dir);
    #####:  136:				return -1;
        -:  137:			}
        -:  138:		} else {
        -:  139:			// It's a file, unlink (delete) it
        1:  140:			if (unlink(full_path) == -1) {
    #####:  141:				perror("unlink");
    #####:  142:				closedir(dir);
    #####:  143:				return -1;
        -:  144:			}
        -:  145:		}
        -:  146:	}
        -:  147:
       11:  148:	closedir(dir);
        -:  149:
        -:  150:	// Now the directory is empty, so we can remove it
       11:  151:	if (rmdir(path) == -1) {
    #####:  152:		perror("rmdir");
    #####:  153:		return -1;
        -:  154:	}
        -:  155:
       11:  156:	return 0;
        -:  157:}
        -:    0:Source:panic.c
        -:    0:Graph:panic.gcno
        -:    0:Data:panic.gcda
        -:    0:Runs:55
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <base/lock.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <setjmp.h>
        -:   19:#include <stdarg.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <stdnoreturn.h>
        -:   23:
        -:   24:_Thread_local jmp_buf return_jmp;
        -:   25:_Thread_local bool jmp_return_set = false;
        -:   26:
        3:   27:void panic(const char *fmt, ...) {
        -:   28:	va_list args;
        -:   29:
        3:   30:	fprintf(stderr, "thread panicked: ");
        3:   31:	va_start(args, fmt);
        3:   32:	vfprintf(stderr, fmt, args);
        3:   33:	va_end(args);
        3:   34:	fprintf(stderr, "\n");
        -:   35:
        3:   36:	Lock_mark_poisoned();
        -:   37:
        3:   38:	if (__default_tl_heap_allocator != NULL) {
    #####:   39:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   40:	}
        -:   41:
        -:   42:	// If jump return has not been set, we resort to an exit with an error
        -:   43:	// status.
        3:   44:	if (!jmp_return_set)
    #####:   45:		exit(-1);
        3:   46:	longjmp(return_jmp, THREAD_PANIC);
        -:   47:}
        -:    0:Source:path.c
        -:    0:Graph:path.gcno
        -:    0:Data:path.gcda
        -:    0:Runs:55
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <errno.h>
        -:   18:#include <limits.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:#include <sys/stat.h>
        -:   22:
        -:   23:#define PATH_SEPARATOR "/"
        -:   24:#define PATH_SEPARATOR_CHAR '/'
        -:   25:
       19:   26:void path_cleanup(PathImpl *ptr)
        -:   27:{
       19:   28:	chain_free(&ptr->ptr);
       19:   29:}
        -:   30:
       19:   31:int path_for(Path *p, const char *path)
        -:   32:{
       19:   33:	if (path == NULL) {
    #####:   34:		errno = EINVAL;
    #####:   35:		return -1;
        -:   36:	}
       19:   37:	int len = strlen(path);
       19:   38:	if (len == 0) {
    #####:   39:		errno = EINVAL;
    #####:   40:		return -1;
        -:   41:	}
       19:   42:	if (chain_malloc(&p->ptr, len + 1))
    #####:   43:		return -1;
       19:   44:	strcpy(p->ptr.data, path);
       19:   45:	return 0;
        -:   46:}
        -:   47:
       18:   48:int path_replace_home(Path *p)
        -:   49:{
       18:   50:	const char *home_dir = getenv("HOME");
       18:   51:	if (home_dir == NULL) {
    #####:   52:		errno = EINVAL;
    #####:   53:		return -1;
        -:   54:	}
       18:   55:	if (((char *)(p->ptr.data))[0] == '~') {
    #####:   56:		int nlen = strlen(home_dir) + strlen(PATH_SEPARATOR) + strlen(p->ptr.data);
    #####:   57:		if (nlen >= PATH_MAX) {
    #####:   58:			errno = E2BIG;
    #####:   59:			return -1;
        -:   60:		}
    #####:   61:		if (nlen >= p->ptr.len) {
        -:   62:			FatPtr nptr;
    #####:   63:			if (chain_realloc(&nptr, &p->ptr, nlen + 1))
    #####:   64:				return -1;
    #####:   65:			p->ptr = nptr;
        -:   66:		}
        -:   67:		char buf[PATH_MAX + 1];
    #####:   68:		snprintf(buf, PATH_MAX, "%s%s%s", home_dir, PATH_SEPARATOR, (char *)(p->ptr.data + 1));
    #####:   69:		strcpy(p->ptr.data, buf);
        -:   70:	}
       18:   71:	return 0;
        -:   72:}
        -:   73:
       18:   74:int path_canonicalize(Path *p)
        -:   75:{
       18:   76:	if (path_replace_home(p))
    #####:   77:		return -1;
        -:   78:	char buf[PATH_MAX];
       18:   79:	errno = 0;
       18:   80:	if (realpath(p->ptr.data, buf) == NULL) {
        2:   81:		return -1;
        -:   82:	}
       16:   83:	int nlen = strlen(buf);
       16:   84:	if (nlen == 0) {
    #####:   85:		errno = EFAULT;
    #####:   86:		return -1;
        -:   87:	}
       16:   88:	if (nlen >= p->ptr.len) {
        -:   89:		FatPtr nptr;
       15:   90:		if (chain_realloc(&nptr, &p->ptr, nlen + 1))
    #####:   91:			return -1;
       15:   92:		p->ptr = nptr;
        -:   93:	}
       16:   94:	strcpy(p->ptr.data, buf);
       16:   95:	return 0;
        -:   96:}
        5:   97:int path_push(Path *p, const char *next)
        -:   98:{
        5:   99:	if (next == NULL) {
    #####:  100:		errno = EINVAL;
    #####:  101:		return -1;
        -:  102:	}
        5:  103:	int slen = strlen(p->ptr.data);
        5:  104:	if (slen <= 0) {
    #####:  105:		errno = EFAULT;
    #####:  106:		return -1;
        -:  107:	}
        5:  108:	bool need_sep = false;
        5:  109:	if (((char *)p->ptr.data)[slen - 1] != PATH_SEPARATOR_CHAR) {
        4:  110:		need_sep = true;
        -:  111:	}
        -:  112:
        5:  113:	int nlen = slen + strlen(next);
        5:  114:	if (need_sep)
        4:  115:		nlen += strlen(PATH_SEPARATOR);
        -:  116:
        5:  117:	if (nlen >= p->ptr.len) {
        -:  118:		FatPtr nptr;
        3:  119:		if (chain_realloc(&nptr, &p->ptr, nlen + 1))
    #####:  120:			return -1;
        3:  121:		p->ptr = nptr;
        -:  122:	}
        -:  123:
        5:  124:	if (need_sep)
        4:  125:		strcat(p->ptr.data, PATH_SEPARATOR);
        5:  126:	strcat(p->ptr.data, next);
        5:  127:	return 0;
        -:  128:}
        2:  129:int path_pop(Path *p)
        -:  130:{
        2:  131:	char *res = rstrstr(p->ptr.data, PATH_SEPARATOR);
        2:  132:	if (res) {
        2:  133:		int index = res - (char *)p->ptr.data;
        2:  134:		((char *)(p->ptr.data))[index] = 0;
        -:  135:	}
        2:  136:	return 0;
        -:  137:}
        -:  138:
        8:  139:char *path_to_string(Path *p)
        -:  140:{
        8:  141:	return p->ptr.data;
        -:  142:}
        -:  143:
    #####:  144:char *path_file_name(Path *p)
        -:  145:{
    #####:  146:	return rstrstr(p->ptr.data, PATH_SEPARATOR);
        -:  147:}
        -:  148:
    #####:  149:bool path_exists(Path *p)
        -:  150:{
    #####:  151:	if (p->ptr.data == NULL && p->ptr.len == 0) {
    #####:  152:		errno = EINVAL;
    #####:  153:		return false;
        -:  154:	}
    #####:  155:	return access(p->ptr.data, F_OK) == 0;
        -:  156:}
    #####:  157:bool path_is_dir(Path *p)
        -:  158:{
    #####:  159:	if (p->ptr.data == NULL && p->ptr.len == 0) {
    #####:  160:		errno = EINVAL;
    #####:  161:		return false;
        -:  162:	}
        -:  163:	struct stat s;
    #####:  164:	if (stat(p->ptr.data, &s) == 0) {
    #####:  165:		return s.st_mode & S_IFDIR;
        -:  166:	}
    #####:  167:	return false;
        -:  168:}
        -:  169:
    #####:  170:bool path_mkdir(Path *p, mode_t mode)
        -:  171:{
    #####:  172:	if (p->ptr.data == NULL && p->ptr.len == 0) {
    #####:  173:		errno = EINVAL;
    #####:  174:		return false;
        -:  175:	}
    #####:  176:	return mkdir(p->ptr.data, 0700) != 0;
        -:  177:}
        -:    0:Source:rand.c
        -:    0:Graph:rand.gcno
        -:    0:Data:rand.gcda
        -:    0:Runs:55
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <base/types.h>
        -:   17:#include <sys/random.h>
        -:   18:
    #####:   19:int rand_i8(i8 *v) {
    #####:   20:	return getentropy(v, sizeof(i8));
        -:   21:}
        -:   22:
    #####:   23:int rand_u8(u8 *v) {
    #####:   24:	return getentropy(v, sizeof(u8));
        -:   25:}
        -:   26:
    #####:   27:int rand_i16(i16 *v) {
    #####:   28:	return getentropy(v, sizeof(i16));
        -:   29:}
        -:   30:
    32350:   31:int rand_u16(u16 *v) {
    32350:   32:	return getentropy(v, sizeof(u16));
        -:   33:}
        -:   34:
    #####:   35:int rand_i32(i32 *v) {
    #####:   36:	return getentropy(v, sizeof(i32));
        -:   37:}
        -:   38:
    #####:   39:int rand_u32(u32 *v) {
    #####:   40:	return getentropy(v, sizeof(u32));
        -:   41:}
        -:   42:
    #####:   43:int rand_i64(i64 *v) {
    #####:   44:	return getentropy(v, sizeof(i64));
        -:   45:}
        -:   46:
    #####:   47:int rand_u64(u64 *v) {
    #####:   48:	return getentropy(v, sizeof(u64));
        -:   49:}
        -:   50:
    #####:   51:int rand_i128(i128 *v) {
    #####:   52:	return getentropy(v, sizeof(i128));
        -:   53:}
        -:   54:
    #####:   55:int rand_u128(u128 *v) {
    #####:   56:	return getentropy(v, sizeof(u128));
        -:   57:}
        -:   58:
    #####:   59:int rand_bytes(void *buf, u64 length) {
    #####:   60:	return getentropy(buf, length);
        -:   61:}
        -:    0:Source:resources.c
        -:    0:Graph:resources.gcno
        -:    0:Data:resources.gcda
        -:    0:Runs:55
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = { 0, 0, 0, 0, 0 };
        -:   19:
    62464:   20:void *mymalloc(usize size)
        -:   21:{
        -:   22:	void *ret;
    62464:   23:	ret = malloc(size);
        -:   24:
    62464:   25:	if (ret) {
    62464:   26:		THREAD_LOCAL_RESOURCE_STATS.malloc_sum += 1;
        -:   27:	}
    62464:   28:	return ret;
        -:   29:}
    62349:   30:void *myrealloc(void *ptr, usize size)
        -:   31:{
        -:   32:	void *ret;
    62349:   33:	ret = realloc(ptr, size);
        -:   34:
    62349:   35:	if (ret) {
    62349:   36:		THREAD_LOCAL_RESOURCE_STATS.realloc_sum += 1;
        -:   37:	}
    62349:   38:	return ret;
        -:   39:}
    62431:   40:void myfree(void *ptr)
        -:   41:{
    62431:   42:	THREAD_LOCAL_RESOURCE_STATS.free_sum += 1;
    62431:   43:	free(ptr);
    62431:   44:}
        4:   45:FILE *myfopen(const char *path, const char *mode)
        -:   46:{
        4:   47:	FILE *ret = fopen(path, mode);
        -:   48:
        4:   49:	if (ret) {
        4:   50:		THREAD_LOCAL_RESOURCE_STATS.fopen_sum += 1;
        -:   51:	}
        4:   52:	return ret;
        -:   53:}
        4:   54:void myfclose(FILE *ptr)
        -:   55:{
        4:   56:	THREAD_LOCAL_RESOURCE_STATS.fclose_sum += 1;
        4:   57:	fclose(ptr);
        4:   58:}
       25:   59:u64 mymalloc_sum()
        -:   60:{
       25:   61:	return THREAD_LOCAL_RESOURCE_STATS.malloc_sum;
        -:   62:}
    #####:   63:u64 myrealloc_sum()
        -:   64:{
    #####:   65:	return THREAD_LOCAL_RESOURCE_STATS.realloc_sum;
        -:   66:}
       25:   67:u64 myfree_sum()
        -:   68:{
       25:   69:	return THREAD_LOCAL_RESOURCE_STATS.free_sum;
        -:   70:}
       33:   71:u64 myfopen_sum()
        -:   72:{
       33:   73:	return THREAD_LOCAL_RESOURCE_STATS.fopen_sum;
        -:   74:}
       33:   75:u64 myfclose_sum()
        -:   76:{
       33:   77:	return THREAD_LOCAL_RESOURCE_STATS.fclose_sum;
        -:   78:}
        -:    0:Source:sha256.c
        -:    0:Graph:sha256.gcno
        -:    0:Data:sha256.gcda
        -:    0:Runs:55
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:
        -:    5:#define uchar unsigned char
        -:    6:#define uint unsigned int
        -:    7:
        -:    8:#define DBL_INT_ADD(a, b, c)                                                                       \
        -:    9:	if (a > 0xffffffff - (c))                                                                      \
        -:   10:		++b;                                                                                       \
        -:   11:	a += c;
        -:   12:#define ROTLEFT(a, b) (((a) << (b)) | ((a) >> (32 - (b))))
        -:   13:#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
        -:   14:
        -:   15:#define CH(x, y, z) (((x) & (y)) ^ (~(x) & (z)))
        -:   16:#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
        -:   17:#define EP0(x) (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
        -:   18:#define EP1(x) (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
        -:   19:#define SIG0(x) (ROTRIGHT(x, 7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
        -:   20:#define SIG1(x) (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))
        -:   21:
        -:   22:typedef struct {
        -:   23:	uchar data[64];
        -:   24:	uint datalen;
        -:   25:	uint bitlen[2];
        -:   26:	uint state[8];
        -:   27:} SHA256_CTX;
        -:   28:
        -:   29:uint k[64] = {
        -:   30:	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        -:   31:	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        -:   32:	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        -:   33:	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        -:   34:	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        -:   35:	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        -:   36:	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        -:   37:	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
        -:   38:
   144820:   39:void SHA256Transform(SHA256_CTX *ctx, uchar data[]) {
        -:   40:	uint a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
        -:   41:
  2461940:   42:	for (i = 0, j = 0; i < 16; ++i, j += 4)
  2317120:   43:		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
  7096180:   44:	for (; i < 64; ++i)
  6951360:   45:		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
        -:   46:
   144820:   47:	a = ctx->state[0];
   144820:   48:	b = ctx->state[1];
   144820:   49:	c = ctx->state[2];
   144820:   50:	d = ctx->state[3];
   144820:   51:	e = ctx->state[4];
   144820:   52:	f = ctx->state[5];
   144820:   53:	g = ctx->state[6];
   144820:   54:	h = ctx->state[7];
        -:   55:
  9413300:   56:	for (i = 0; i < 64; ++i) {
  9268480:   57:		t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
  9268480:   58:		t2 = EP0(a) + MAJ(a, b, c);
  9268480:   59:		h = g;
  9268480:   60:		g = f;
  9268480:   61:		f = e;
  9268480:   62:		e = d + t1;
  9268480:   63:		d = c;
  9268480:   64:		c = b;
  9268480:   65:		b = a;
  9268480:   66:		a = t1 + t2;
        -:   67:	}
        -:   68:
   144820:   69:	ctx->state[0] += a;
   144820:   70:	ctx->state[1] += b;
   144820:   71:	ctx->state[2] += c;
   144820:   72:	ctx->state[3] += d;
   144820:   73:	ctx->state[4] += e;
   144820:   74:	ctx->state[5] += f;
   144820:   75:	ctx->state[6] += g;
   144820:   76:	ctx->state[7] += h;
   144820:   77:}
        -:   78:
        2:   79:void SHA256Init(SHA256_CTX *ctx) {
        2:   80:	ctx->datalen = 0;
        2:   81:	ctx->bitlen[0] = 0;
        2:   82:	ctx->bitlen[1] = 0;
        2:   83:	ctx->state[0] = 0x6a09e667;
        2:   84:	ctx->state[1] = 0xbb67ae85;
        2:   85:	ctx->state[2] = 0x3c6ef372;
        2:   86:	ctx->state[3] = 0xa54ff53a;
        2:   87:	ctx->state[4] = 0x510e527f;
        2:   88:	ctx->state[5] = 0x9b05688c;
        2:   89:	ctx->state[6] = 0x1f83d9ab;
        2:   90:	ctx->state[7] = 0x5be0cd19;
        2:   91:}
        -:   92:
        2:   93:void SHA256Update(SHA256_CTX *ctx, uchar data[], uint len) {
  9268460:   94:	for (uint i = 0; i < len; ++i) {
  9268458:   95:		ctx->data[ctx->datalen] = data[i];
  9268458:   96:		ctx->datalen++;
  9268458:   97:		if (ctx->datalen == 64) {
   144818:   98:			SHA256Transform(ctx, ctx->data);
  144818*:   99:			DBL_INT_ADD(ctx->bitlen[0], ctx->bitlen[1], 512);
   144818:  100:			ctx->datalen = 0;
        -:  101:		}
        -:  102:	}
        2:  103:}
        -:  104:
        2:  105:void SHA256Final(SHA256_CTX *ctx, uchar hash[]) {
        2:  106:	uint i = ctx->datalen;
        -:  107:
        2:  108:	if (ctx->datalen < 56) {
        2:  109:		ctx->data[i++] = 0x80;
        6:  110:		while (i < 56)
        4:  111:			ctx->data[i++] = 0x00;
        -:  112:	} else {
    #####:  113:		ctx->data[i++] = 0x80;
    #####:  114:		while (i < 64)
    #####:  115:			ctx->data[i++] = 0x00;
    #####:  116:		SHA256Transform(ctx, ctx->data);
    #####:  117:		memset(ctx->data, 0, 56);
        -:  118:	}
        -:  119:
       2*:  120:	DBL_INT_ADD(ctx->bitlen[0], ctx->bitlen[1], ctx->datalen * 8);
        2:  121:	ctx->data[63] = ctx->bitlen[0];
        2:  122:	ctx->data[62] = ctx->bitlen[0] >> 8;
        2:  123:	ctx->data[61] = ctx->bitlen[0] >> 16;
        2:  124:	ctx->data[60] = ctx->bitlen[0] >> 24;
        2:  125:	ctx->data[59] = ctx->bitlen[1];
        2:  126:	ctx->data[58] = ctx->bitlen[1] >> 8;
        2:  127:	ctx->data[57] = ctx->bitlen[1] >> 16;
        2:  128:	ctx->data[56] = ctx->bitlen[1] >> 24;
        2:  129:	SHA256Transform(ctx, ctx->data);
        -:  130:
       10:  131:	for (i = 0; i < 4; ++i) {
        8:  132:		hash[i] = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
        8:  133:		hash[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
        8:  134:		hash[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
        8:  135:		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
        8:  136:		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
        8:  137:		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
        8:  138:		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
        8:  139:		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
        -:  140:	}
        2:  141:}
        -:  142:
        2:  143:int SHA256(unsigned char *data, char hashStr[65]) {
        2:  144:	if (hashStr == NULL || data == NULL)
    #####:  145:		return -1;
        2:  146:	int strLen = strlen((const char *)data);
        -:  147:	SHA256_CTX ctx;
        -:  148:	unsigned char hash[32];
        2:  149:	strcpy(hashStr, "");
        -:  150:
        2:  151:	SHA256Init(&ctx);
        2:  152:	SHA256Update(&ctx, data, strLen);
        2:  153:	SHA256Final(&ctx, hash);
        -:  154:
        -:  155:	char s[3];
       66:  156:	for (int i = 0; i < 32; i++) {
       64:  157:		snprintf(s, 3, "%02x", hash[i]);
       64:  158:		strcat(hashStr, s);
        -:  159:	}
        -:  160:
        2:  161:	return 0;
        -:  162:}
        -:    0:Source:build.c
        -:    0:Graph:build.gcno
        -:    0:Data:build.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <base/version.h>
        -:   18:#include <stdio.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:#include <util/replace.h>
        -:   22:
    #####:   23:int proc_build_init(const char *proj_name, const char *proj_path, char authors[11][1024],
        -:   24:	int author_count, bool lib, char *description)
    #####:   25:{
    #####:   26:	int author_len = 0;
    #####:   27:	for (int i = 0; i < author_count; i++) {
    #####:   28:		author_len += strlen(authors[i]) + 10;
        -:   29:	}
    #####:   30:	char author_replace[author_len];
    #####:   31:	strcpy(author_replace, "");
    #####:   32:	for (int i = 0; i < author_count; i++) {
    #####:   33:		strcat(author_replace, "\"");
    #####:   34:		strcat(author_replace, authors[i]);
    #####:   35:		if (i == author_count - 1)
    #####:   36:			strcat(author_replace, "\"");
        -:   37:		else
    #####:   38:			strcat(author_replace, "\", ");
        -:   39:	}
    #####:   40:	Path path;
    #####:   41:	path_for(&path, proj_path);
    #####:   42:	if (path_exists(&path)) {
    #####:   43:		path_canonicalize(&path);
    #####:   44:		fprintf(stderr, "Path: '%s' already exists!\n", path_to_string(&path));
    #####:   45:		exit(-1);
        -:   46:	}
    #####:   47:	if (path_mkdir(&path, 0700)) {
    #####:   48:		perror("Error: could not create directory for project");
    #####:   49:		exit(-1);
        -:   50:	}
        -:   51:
    #####:   52:	path_push(&path, "fam.toml");
    #####:   53:	Path template;
    #####:   54:	if (lib)
    #####:   55:		path_for(&template, "~/.fam/resources/fam.lib.toml");
        -:   56:	else
    #####:   57:		path_for(&template, "~/.fam/resources/fam.toml");
    #####:   58:	path_canonicalize(&template);
    #####:   59:	if (copy_file(path_to_string(&path), path_to_string(&template)) != 0) {
    #####:   60:		perror("Error: copying file");
    #####:   61:		exit(-1);
        -:   62:	}
        -:   63:
    #####:   64:	const char *patterns_in[]
        -:   65:		= { "REPLACE_FAM_VERSION", "REPLACE_NAME", "REPLACE_AUTHORS", "REPLACE_DESCRIPTION" };
    #####:   66:	const bool is_case_sensitive[] = { true, true, true };
        -:   67:	char desc[1024];
    #####:   68:	if (strlen(description) > 0)
    #####:   69:		strcpy(desc, description);
        -:   70:	else
    #####:   71:		strcpy(desc, proj_name);
    #####:   72:	const char *replace[] = { FAM_VERSION, proj_name, author_replace, desc };
    #####:   73:	replace_file(&path, &path, patterns_in, is_case_sensitive, replace, 4);
        -:   74:
    #####:   75:	Path proj_dir;
    #####:   76:	path_for(&proj_dir, proj_path);
    #####:   77:	path_canonicalize(&proj_dir);
    #####:   78:	printf("Project successfully created in '%s'.\n", path_to_string(&proj_dir));
        -:   79:
    #####:   80:	return 0;
        -:   81:}
        -:    0:Source:args.c
        -:    0:Graph:args.gcno
        -:    0:Data:args.gcda
        -:    0:Runs:4
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        8:   20:int args_param_build(ArgsParam *ap, char *name, char *help, char *short_name, bool takes_value,
        -:   21:	bool multiple, char *default_value)
        -:   22:{
        8:   23:	if (ap == NULL || name == NULL || help == NULL || short_name == NULL) {
    #####:   24:		errno = EINVAL;
    #####:   25:		return -1;
        -:   26:	}
        -:   27:
        8:   28:	if (strlen(short_name) > strlen(name)) {
    #####:   29:		fprintf(stderr, "short_name cannot be longer than name\n");
    #####:   30:		return -1;
        -:   31:	}
        -:   32:
        8:   33:	ap->name = NULL;
        8:   34:	ap->help = NULL;
        8:   35:	ap->short_name = NULL;
        8:   36:	ap->default_value = NULL;
        -:   37:
        8:   38:	ap->name = mymalloc((1 + strlen(name)) * sizeof(char));
        8:   39:	if (ap->name == NULL) {
    #####:   40:		return -1;
        -:   41:	}
        8:   42:	strcpy(ap->name, name);
        -:   43:
        8:   44:	ap->help = mymalloc((1 + strlen(help)) * sizeof(char));
        8:   45:	if (ap->help == NULL) {
    #####:   46:		args_param_cleanup(ap);
    #####:   47:		return -1;
        -:   48:	}
        8:   49:	strcpy(ap->help, help);
        -:   50:
        8:   51:	ap->short_name = mymalloc((1 + strlen(short_name)) * sizeof(char));
        8:   52:	if (ap->short_name == NULL) {
    #####:   53:		args_param_cleanup(ap);
    #####:   54:		return -1;
        -:   55:	}
        8:   56:	strcpy(ap->short_name, short_name);
        -:   57:
        8:   58:	ap->takes_value = takes_value;
        8:   59:	ap->multiple = multiple;
        -:   60:
        8:   61:	if (default_value) {
        5:   62:		ap->default_value = mymalloc((1 + strlen(default_value)) * sizeof(char));
        5:   63:		if (ap->default_value == NULL) {
    #####:   64:			args_param_cleanup(ap);
    #####:   65:			return -1;
        -:   66:		}
        5:   67:		strcpy(ap->default_value, default_value);
        -:   68:	} else
        3:   69:		ap->default_value = NULL;
        -:   70:
        8:   71:	return 0;
        -:   72:}
       15:   73:void args_param_cleanup(ArgsParam *ap)
        -:   74:{
       15:   75:	if (ap->name) {
       15:   76:		myfree(ap->name);
       15:   77:		ap->name = NULL;
        -:   78:	}
       15:   79:	if (ap->short_name) {
       15:   80:		myfree(ap->short_name);
       15:   81:		ap->short_name = NULL;
        -:   82:	}
       15:   83:	if (ap->help) {
       15:   84:		myfree(ap->help);
       15:   85:		ap->help = NULL;
        -:   86:	}
       15:   87:	if (ap->default_value) {
       10:   88:		myfree(ap->default_value);
       10:   89:		ap->default_value = NULL;
        -:   90:	}
       15:   91:}
        7:   92:int sub_command_build(
        -:   93:	SubCommand *sc, char *name, char *help, u32 min_args, u32 max_args, char *arg_doc)
        -:   94:{
        7:   95:	if (name == NULL || help == NULL || min_args > max_args || arg_doc == NULL) {
        2:   96:		errno = EINVAL;
        2:   97:		return -1;
        -:   98:	}
        -:   99:
        5:  100:	sc->name = NULL;
        5:  101:	sc->help = NULL;
        5:  102:	sc->arg_doc = NULL;
        5:  103:	sc->params_count = 0;
        -:  104:
        5:  105:	sc->name = mymalloc((1 + strlen(name)) * sizeof(char));
        5:  106:	if (sc->name == NULL) {
    #####:  107:		sub_command_cleanup(sc);
    #####:  108:		return -1;
        -:  109:	}
        5:  110:	strcpy(sc->name, name);
        -:  111:
        5:  112:	sc->help = mymalloc((1 + strlen(help)) * sizeof(char));
        5:  113:	if (sc->help == NULL) {
    #####:  114:		sub_command_cleanup(sc);
    #####:  115:		return -1;
        -:  116:	}
        5:  117:	strcpy(sc->help, help);
        -:  118:
        5:  119:	sc->arg_doc = mymalloc((1 + strlen(arg_doc)) * sizeof(char));
        5:  120:	if (sc->arg_doc == NULL) {
    #####:  121:		sub_command_cleanup(sc);
    #####:  122:		return -1;
        -:  123:	}
        5:  124:	strcpy(sc->arg_doc, arg_doc);
        -:  125:
        5:  126:	sc->min_args = min_args;
        5:  127:	sc->max_args = max_args;
        5:  128:	return 0;
        -:  129:}
        5:  130:void sub_command_cleanup(SubCommand *sc)
        -:  131:{
        5:  132:	if (sc->name) {
        5:  133:		myfree(sc->name);
        5:  134:		sc->name = NULL;
        -:  135:	}
        -:  136:
        5:  137:	if (sc->help) {
        5:  138:		myfree(sc->help);
        5:  139:		sc->help = NULL;
        -:  140:	}
        -:  141:
        5:  142:	if (sc->arg_doc) {
        5:  143:		myfree(sc->arg_doc);
        5:  144:		sc->arg_doc = NULL;
        -:  145:	}
        -:  146:
        5:  147:	if (sc->params_count != 0) {
       11:  148:		for (u64 i = 0; i < sc->params_count; i++) {
        7:  149:			args_param_cleanup(&sc->params[i]);
        -:  150:		}
        -:  151:
        4:  152:		myfree(sc->params);
        4:  153:		myfree(sc->params_state);
        4:  154:		sc->params = NULL;
        4:  155:		sc->params_state = NULL;
        4:  156:		sc->params_count = 0;
        -:  157:	}
        5:  158:}
        7:  159:int sub_command_add_param(SubCommand *sc, ArgsParam *ap)
        -:  160:{
        7:  161:	if (ap->name == NULL || ap->help == NULL || ap->short_name == NULL) {
    #####:  162:		errno = EINVAL;
    #####:  163:		return -1;
        -:  164:	}
        7:  165:	if (sc->params_count == 0) {
        4:  166:		sc->params = mymalloc(sizeof(ArgsParam));
        4:  167:		sc->params_state = mymalloc(sizeof(ArgsParamState));
        -:  168:
        4:  169:		if (sc->params == NULL || sc->params_state == NULL) {
        -:  170:
    #####:  171:			sub_command_cleanup(sc);
    #####:  172:			return -1;
        -:  173:		}
        4:  174:		sc->params_count = 1;
        -:  175:	} else {
        3:  176:		sc->params_count += 1;
        3:  177:		void *tmp1 = myrealloc(sc->params, sizeof(ArgsParam) * sc->params_count);
        3:  178:		void *tmp2 = myrealloc(sc->params_state, sizeof(ArgsParamState) * sc->params_count);
        -:  179:
        3:  180:		sc->params = tmp1;
        3:  181:		sc->params_state = tmp2;
        -:  182:	}
        7:  183:	u64 index = sc->params_count - 1;
        -:  184:
        7:  185:	sc->params[index].name = mymalloc((strlen(ap->name) + 1) * sizeof(char));
        7:  186:	strcpy(sc->params[index].name, ap->name);
        -:  187:
        7:  188:	sc->params[index].help = mymalloc((strlen(ap->help) + 1) * sizeof(char));
        7:  189:	strcpy(sc->params[index].help, ap->help);
        -:  190:
        7:  191:	sc->params[index].short_name = mymalloc((strlen(ap->short_name) + 1) * sizeof(char));
        7:  192:	strcpy(sc->params[index].short_name, ap->short_name);
        -:  193:
        7:  194:	sc->params[index].takes_value = ap->takes_value;
        7:  195:	sc->params[index].multiple = ap->multiple;
        -:  196:
        7:  197:	if (ap->default_value) {
        5:  198:		sc->params[index].default_value = mymalloc((strlen(ap->default_value) + 1) * sizeof(char));
        5:  199:		if (sc->params[index].default_value == NULL) {
    #####:  200:			sub_command_cleanup(sc);
    #####:  201:			return -1;
        -:  202:		}
        5:  203:		strcpy(sc->params[index].default_value, ap->default_value);
        -:  204:	} else {
        2:  205:		sc->params[index].default_value = NULL;
        -:  206:	}
        -:  207:
        7:  208:	sc->params_state[index].specified = false;
        -:  209:
        7:  210:	if (sc->params[index].name == NULL || sc->params[index].help == NULL
        7:  211:		|| sc->params[index].short_name == NULL) {
    #####:  212:		sub_command_cleanup(sc);
    #####:  213:		return -1;
        -:  214:	}
        -:  215:
        7:  216:	return 0;
        -:  217:}
        -:  218:
        1:  219:int args_build(Args *args, char *prog, char *version, char *author, u32 min_args, u32 max_args,
        -:  220:	u64 debug_flags)
        -:  221:{
       1*:  222:	if (prog == NULL && version == NULL && author == NULL) {
    #####:  223:		errno = EINVAL;
    #####:  224:		return -1;
        -:  225:	}
        1:  226:	args->subs_count = 0;
        1:  227:	args->argc = 0;
        1:  228:	args->debug_flags = debug_flags;
        -:  229:
        1:  230:	args->prog = mymalloc(sizeof(char) * (1 + strlen(prog)));
        1:  231:	args->version = mymalloc(sizeof(char) * (1 + strlen(version)));
        1:  232:	args->author = mymalloc(sizeof(char) * (1 + strlen(author)));
        -:  233:
        1:  234:	if (args->prog == NULL || args->version == NULL || args->author == NULL) {
    #####:  235:		args_cleanup(args);
    #####:  236:		return -1;
        -:  237:	}
        1:  238:	strcpy(args->prog, prog);
        1:  239:	strcpy(args->version, version);
        1:  240:	strcpy(args->author, author);
        -:  241:
        -:  242:	// first subcommand is our params
        -:  243:	SubCommand sc;
        1:  244:	sub_command_build(&sc, "", "", min_args, max_args, "");
        1:  245:	args_add_sub_command(args, &sc);
        1:  246:	sub_command_cleanup(&sc);
        -:  247:
        1:  248:	return 0;
        -:  249:}
        -:  250:
        1:  251:void args_cleanup(Args *args)
        -:  252:{
        1:  253:	if (args->argc) {
        3:  254:		for (u64 i = 0; i < args->argc; i++) {
        2:  255:			myfree(args->argv[i]);
        -:  256:		}
        1:  257:		myfree(args->argv);
        1:  258:		args->argc = 0;
        -:  259:	}
        -:  260:
        1:  261:	if (args->prog) {
        1:  262:		myfree(args->prog);
        1:  263:		args->prog = NULL;
        -:  264:	}
        -:  265:
        1:  266:	if (args->author) {
        1:  267:		myfree(args->author);
        1:  268:		args->author = NULL;
        -:  269:	}
        -:  270:
        1:  271:	if (args->version) {
        1:  272:		myfree(args->version);
        1:  273:		args->version = NULL;
        -:  274:	}
        -:  275:
        1:  276:	if (args->subs_count) {
        3:  277:		for (u64 i = 0; i < args->subs_count; i++) {
        2:  278:			sub_command_cleanup(args->subs[i]);
        2:  279:			myfree(args->subs[i]);
        -:  280:		}
        -:  281:
        1:  282:		myfree(args->subs);
        -:  283:	}
        1:  284:}
        2:  285:int args_add_param(Args *args, ArgsParam *ap)
        -:  286:{
        2:  287:	return sub_command_add_param(args->subs[0], ap);
        -:  288:}
        -:  289:
        2:  290:int args_add_sub_command(Args *args, SubCommand *sc)
        -:  291:{
        2:  292:	if (args->subs_count == 0) {
        1:  293:		args->subs = mymalloc(sizeof(SubCommand *));
        1:  294:		if (args->subs == NULL) {
    #####:  295:			fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  296:			return -1;
        -:  297:		}
        -:  298:	} else {
        1:  299:		SubCommand **tmp = myrealloc(args->subs, sizeof(SubCommand *) * (1 + args->subs_count));
        -:  300:
        1:  301:		if (tmp == NULL) {
    #####:  302:			fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  303:			return -1;
        -:  304:		}
        -:  305:
        1:  306:		args->subs = tmp;
        -:  307:	}
        -:  308:
        2:  309:	args->subs[args->subs_count] = mymalloc(sizeof(SubCommand));
        2:  310:	if (args->subs[args->subs_count] == NULL) {
    #####:  311:		fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  312:		return -1;
        -:  313:	}
        -:  314:
        2:  315:	if (sub_command_build(args->subs[args->subs_count], sc->name, sc->help, sc->min_args,
        -:  316:			sc->max_args, sc->arg_doc)) {
    #####:  317:		fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  318:		myfree(args->subs[args->subs_count]);
    #####:  319:		return -1;
        -:  320:	}
        3:  321:	for (u64 i = 0; i < sc->params_count; i++) {
        1:  322:		if (sub_command_add_param(args->subs[args->subs_count], &sc->params[i])) {
    #####:  323:			fprintf(stderr, "add param [%s] subcommand %s failed!\n", sc->params[i].name, sc->name);
        -:  324:		}
        -:  325:	}
        -:  326:
        2:  327:	args->subs_count += 1;
        2:  328:	return 0;
        -:  329:}
        -:  330:
    #####:  331:bool args_sub_takes_value(Args *args, u64 subi, char *name, bool is_short)
        -:  332:{
    #####:  333:	for (u64 i = 0; i < args->subs[subi]->params_count; i++) {
    #####:  334:		if (is_short && !strcmp(name, args->subs[subi]->params[i].short_name)) {
    #####:  335:			if (args->subs[subi]->params[i].takes_value) {
    #####:  336:				return true;
        -:  337:			} else
    #####:  338:				break;
    #####:  339:		} else if (!strcmp(name, args->subs[subi]->params[i].name)) {
    #####:  340:			if (args->subs[subi]->params[i].takes_value) {
    #####:  341:				return true;
        -:  342:			} else
    #####:  343:				break;
        -:  344:		}
        -:  345:	}
    #####:  346:	return false;
        -:  347:}
        -:  348:
    #####:  349:void args_exit_error(Args *args, char *format, ...)
        -:  350:{
        -:  351:	va_list va_args;
    #####:  352:	va_start(va_args, format);
    #####:  353:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
    #####:  354:	vfprintf(stderr, format, va_args);
    #####:  355:	fprintf(stderr, "\n\n");
    #####:  356:	fprintf(stderr,
        -:  357:		"%sUSAGE%s:\n    %s%s%s [%sOPTIONS%s]\n\nFor more information "
        -:  358:		"try %s--help%s\n",
        -:  359:		DIMMED, RESET, BRIGHT_RED, args->prog, RESET, DIMMED, RESET, GREEN, RESET);
    #####:  360:	va_end(va_args);
    #####:  361:	u64 debug_flags = args->debug_flags;
    #####:  362:	if (!(debug_flags & DEBUG_INIT_NO_EXIT))
    #####:  363:		exit(-1);
    #####:  364:}
        -:  365:
    #####:  366:u64 args_subi_for(Args *args, char *sub)
        -:  367:{
    #####:  368:	u64 subi = 0;
    #####:  369:	for (u64 i = 1; i < args->subs_count; i++) {
    #####:  370:		if (!strcmp(sub, args->subs[i]->name)) {
    #####:  371:			subi = i;
        -:  372:		}
        -:  373:	}
    #####:  374:	return subi;
        -:  375:}
        -:  376:
    #####:  377:bool args_check_option(Args *args, u64 subi, char *name, bool is_short, char *argv)
        -:  378:{
    #####:  379:	bool found = false;
    #####:  380:	for (u64 j = 0; j < args->subs[subi]->params_count; j++) {
    #####:  381:		bool multi = args->subs[subi]->params[j].multiple;
    #####:  382:		if (is_short && !strcmp(args->subs[subi]->params[j].short_name, name)) {
    #####:  383:			found = true;
    #####:  384:			if (args->subs[subi]->params_state[j].specified && !multi)
    #####:  385:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
    #####:  386:			args->subs[subi]->params_state[j].specified = true;
    #####:  387:			break;
    #####:  388:		} else if (!is_short && !strcmp(args->subs[subi]->params[j].name, name)) {
    #####:  389:			found = true;
    #####:  390:			if (args->subs[subi]->params_state[j].specified && !multi)
    #####:  391:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
    #####:  392:			args->subs[subi]->params_state[j].specified = true;
    #####:  393:			break;
        -:  394:		}
        -:  395:	}
    #####:  396:	return found;
        -:  397:}
        -:  398:
        1:  399:void args_check_validity(Args *args, int argc, char **argv)
        -:  400:{
        -:  401:	// check if there's a sub command and check arg count
        1:  402:	char *sub = NULL;
        1:  403:	u32 arg_count = 0;
        1:  404:	u64 subi = 0;
        1:  405:	u64 sub_arg = ULONG_MAX;
        2:  406:	for (u64 i = 1; i < argc; i++) {
        1:  407:		u64 len = strlen(argv[i]);
       1*:  408:		if (len > 0 && argv[i][0] == '-') {
    #####:  409:			char name[len];
        -:  410:			bool is_short;
    #####:  411:			bool found = false;
    #####:  412:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  413:				strcpy(name, args->argv[i] + 2);
    #####:  414:				is_short = false;
        -:  415:			} else {
    #####:  416:				strcpy(name, args->argv[i] + 1);
    #####:  417:				is_short = true;
        -:  418:			}
    #####:  419:			if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  420:				i += 1;
        -:  421:			}
        -:  422:		} else {
        1:  423:			if (!sub && args->subs_count > 1) {
    #####:  424:				sub = argv[i];
    #####:  425:				sub_arg = i;
    #####:  426:				subi = args_subi_for(args, sub);
        -:  427:			} else
        1:  428:				arg_count += 1;
        -:  429:		}
        -:  430:	}
        -:  431:
        1:  432:	u64 sub_index = 0;
        -:  433:
        1:  434:	if (sub) {
        -:  435:		// there's a sub so validate it
    #####:  436:		bool valid = false;
    #####:  437:		for (u64 i = 1; i < args->subs_count; i++) {
    #####:  438:			if (!strcmp(sub, args->subs[i]->name)) {
    #####:  439:				valid = true;
    #####:  440:				if (arg_count > args->subs[i]->max_args || arg_count < args->subs[i]->min_args) {
    #####:  441:					args_exit_error(args,
        -:  442:						"Incorrect number of "
        -:  443:						"arguments for sub command '%s' "
        -:  444:						"(%i specified). "
        -:  445:						"Number of arguments must be "
        -:  446:						"between %i and %i.",
    #####:  447:						args->subs[i]->name, arg_count, args->subs[i]->min_args,
    #####:  448:						args->subs[i]->max_args);
        -:  449:				}
    #####:  450:				sub_index = i;
        -:  451:
    #####:  452:				break;
        -:  453:			}
        -:  454:		}
    #####:  455:		if (!valid) {
    #####:  456:			args_exit_error(args, "Unknown SubCommand \"%s\"", sub);
        -:  457:		}
        1:  458:	} else if (args->subs_count > 1) {
    #####:  459:		args_usage(args, NULL);
        -:  460:	} else {
        -:  461:		// check number of args
        1:  462:		if (arg_count > args->subs[0]->max_args || arg_count < args->subs[0]->min_args) {
    #####:  463:			args_exit_error(args,
        -:  464:				"Incorrect number of arguments "
        -:  465:				"(%i specified). "
        -:  466:				"Number of arguments must be "
        -:  467:				"between %i and %i.",
    #####:  468:				arg_count, args->subs[0]->min_args, args->subs[0]->max_args);
        -:  469:		}
        -:  470:	}
        -:  471:
        -:  472:	// check options
        2:  473:	for (u64 i = 1; i < argc; i++) {
        -:  474:		u64 subi;
        1:  475:		if (i <= sub_arg) {
        1:  476:			subi = 0;
        -:  477:		} else {
    #####:  478:			subi = sub_index;
        -:  479:		}
        -:  480:
        1:  481:		u64 len = strlen(argv[i]);
       1*:  482:		if (len > 0 && argv[i][0] == '-') {
        -:  483:			// option to check
    #####:  484:			char name[len];
        -:  485:			bool is_short;
    #####:  486:			bool found = false;
    #####:  487:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  488:				strcpy(name, args->argv[i] + 2);
    #####:  489:				is_short = false;
        -:  490:			} else {
    #####:  491:				strcpy(name, args->argv[i] + 1);
    #####:  492:				is_short = true;
        -:  493:			}
        -:  494:
    #####:  495:			found = args_check_option(args, subi, name, is_short, argv[i]);
    #####:  496:			if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  497:				i += 1;
        -:  498:			}
    #####:  499:			if (!found) {
    #####:  500:				if (subi == 0) {
    #####:  501:					args_exit_error(args, "Unknown option: %s", argv[i]);
        -:  502:				} else {
    #####:  503:					args_exit_error(args,
        -:  504:						"Unknown option: %s. Not valid for "
        -:  505:						"SubCommand \"%s\".",
    #####:  506:						argv[i], args->subs[subi]->name);
        -:  507:				}
        -:  508:			}
        -:  509:		}
        -:  510:	}
        1:  511:}
        -:  512:
        1:  513:int args_init(Args *args, int argc, char **argv)
        -:  514:{
        1:  515:	args->argc = argc;
        1:  516:	args->argv = mymalloc(sizeof(char *) * argc);
        -:  517:
        1:  518:	if (args->argv == NULL) {
    #####:  519:		args->argc = 0;
    #####:  520:		return -1;
        -:  521:	}
        -:  522:
        3:  523:	for (u64 i = 0; i < argc; i++) {
        2:  524:		args->argv[i] = mymalloc(sizeof(char) * (strlen(argv[i]) + 1));
        2:  525:		if (args->argv[i]) {
        2:  526:			strcpy(args->argv[i], argv[i]);
        -:  527:		} else {
    #####:  528:			for (u64 j = i - 1; j >= 0; j--) {
    #####:  529:				myfree(args->argv[j]);
        -:  530:			}
        -:  531:			myfree(args->argv);
        -:  532:			args->argc = 0;
        -:  533:			return -1;
        -:  534:		}
        -:  535:	}
        -:  536:
        2:  537:	for (u64 i = 1; i < argc; i++) {
        1:  538:		if (!strcmp(argv[i], "--version") || !strcmp(argv[i], "-V")) {
    #####:  539:			args_print_version(args);
        -:  540:		}
        1:  541:		if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
    #####:  542:			char *sub = NULL;
    #####:  543:			for (u64 j = 1; j < i; j++) {
    #####:  544:				u64 len = strlen(argv[j]);
    #####:  545:				if (len > 0) {
    #####:  546:					if (argv[j][0] != '-') {
    #####:  547:						sub = argv[j];
    #####:  548:						break;
    #####:  549:					} else {
    #####:  550:						char name[len];
        -:  551:						bool is_short;
    #####:  552:						if (len > 1 && args->argv[j][1] == '-') {
    #####:  553:							strcpy(name, args->argv[j] + 2);
    #####:  554:							is_short = false;
        -:  555:						} else {
    #####:  556:							strcpy(name, args->argv[j] + 1);
    #####:  557:							is_short = true;
        -:  558:						}
        -:  559:
    #####:  560:						u64 subi = 0;
    #####:  561:						if (sub)
    #####:  562:							subi = args_subi_for(args, sub);
        -:  563:
    #####:  564:						if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  565:							j += 1;
        -:  566:						}
        -:  567:					}
        -:  568:				}
        -:  569:			}
    #####:  570:			args_usage(args, sub);
        -:  571:		}
        -:  572:	}
        -:  573:
        1:  574:	args_check_validity(args, argc, argv);
        -:  575:
        1:  576:	return 0;
        -:  577:}
        -:  578:
    #####:  579:int args_value_of(Args *args, char *param_name, char *value_buf, u64 max_value_len, u64 index)
    #####:  580:{
    #####:  581:	if (args == NULL || param_name == NULL) {
    #####:  582:		errno = EINVAL;
    #####:  583:		return -1;
        -:  584:	}
        -:  585:
    #####:  586:	char param_name_buf[strlen(param_name) + 3];
    #####:  587:	strcpy(param_name_buf, "--");
    #####:  588:	strcat(param_name_buf, param_name);
        -:  589:
    #####:  590:	char short_name_buf[strlen(param_name) + 3];
    #####:  591:	strcpy(short_name_buf, "-");
    #####:  592:	bool found = false;
    #####:  593:	char *default_value = NULL;
    #####:  594:	bool takes_value = false;
    #####:  595:	for (u64 i = 0; i < args->subs_count; i++) {
    #####:  596:		for (u64 j = 0; j < args->subs[i]->params_count; j++) {
    #####:  597:			if (!strcmp(args->subs[i]->params[j].name, param_name)) {
    #####:  598:				found = true;
    #####:  599:				strcat(short_name_buf, args->subs[i]->params[j].short_name);
    #####:  600:				default_value = args->subs[i]->params[j].default_value;
    #####:  601:				takes_value = args->subs[i]->params[j].takes_value;
        -:  602:			}
        -:  603:		}
        -:  604:	}
        -:  605:
    #####:  606:	if (!found) {
    #####:  607:		errno = ENOENT;
    #####:  608:		return -1;
        -:  609:	}
    #####:  610:	u64 itt_index = 0;
    #####:  611:	for (u64 i = 1; i < args->argc; i++) {
    #####:  612:		if (!strcmp(args->argv[i], param_name_buf) || !strcmp(args->argv[i], short_name_buf)) {
    #####:  613:			if (itt_index == index) {
    #####:  614:				if (takes_value && i + 1 < args->argc) {
    #####:  615:					return snprintf(value_buf, max_value_len, "%s", args->argv[i + 1]);
    #####:  616:				} else if (takes_value && max_value_len > 1) {
    #####:  617:					strcpy(value_buf, "");
    #####:  618:					return 0;
        -:  619:				} else {
    #####:  620:					return 0;
        -:  621:				}
        -:  622:			} else {
    #####:  623:				itt_index += 1;
        -:  624:			}
        -:  625:		}
        -:  626:	}
        -:  627:
    #####:  628:	if (default_value != NULL && index == 0) {
    #####:  629:		return snprintf(value_buf, max_value_len, "%s", default_value);
        -:  630:	}
        -:  631:
    #####:  632:	errno = ENOENT;
    #####:  633:	return -1;
        -:  634:}
    #####:  635:int args_get_argument(Args *args, u64 index, char *value_buf, u64 max_value_len)
        -:  636:{
    #####:  637:	u64 index_itt = 0;
    #####:  638:	for (u64 i = 1; i < args->argc; i++) {
    #####:  639:		i32 len = strlen(args->argv[i]);
    #####:  640:		if (len > 1 && args->argv[i][0] == '-') {
    #####:  641:			char name[len];
        -:  642:			bool is_short;
    #####:  643:			bool found = false;
    #####:  644:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  645:				strcpy(name, args->argv[i] + 2);
    #####:  646:				is_short = false;
        -:  647:			} else {
    #####:  648:				strcpy(name, args->argv[i] + 1);
    #####:  649:				is_short = true;
        -:  650:			}
        -:  651:
    #####:  652:			for (u64 k = 0; k < args->subs_count; k++) {
    #####:  653:				for (u64 j = 0; j < args->subs[k]->params_count; j++) {
    #####:  654:					if (is_short && !strcmp(name, args->subs[k]->params[j].short_name)) {
    #####:  655:						if (args->subs[k]->params[j].takes_value) {
    #####:  656:							i += 1;
    #####:  657:							found = true;
    #####:  658:							break;
        -:  659:						}
    #####:  660:					} else if (!strcmp(name, args->subs[k]->params[j].name)) {
    #####:  661:						if (args->subs[k]->params[j].takes_value) {
    #####:  662:							i += 1;
    #####:  663:							found = true;
    #####:  664:							break;
        -:  665:						}
        -:  666:					}
        -:  667:				}
        -:  668:			}
        -:  669:		} else {
    #####:  670:			if (index_itt == index) {
    #####:  671:				snprintf(value_buf, max_value_len, "%s", args->argv[i]);
    #####:  672:				return 1;
        -:  673:			}
    #####:  674:			index_itt += 1;
        -:  675:		}
        -:  676:	}
    #####:  677:	return 0;
        -:  678:}
        -:  679:
    #####:  680:void args_print_version(Args *args)
        -:  681:{
    #####:  682:	char *prog = args->prog;
    #####:  683:	char *version = args->version;
    #####:  684:	fprintf(stderr, "%s%s%s %s%s%s\n", BRIGHT_RED, prog, RESET, CYAN, version, RESET);
    #####:  685:	exit(0);
        -:  686:}
        -:  687:
    #####:  688:void args_usage(Args *args, char *sub_command)
    #####:  689:{
    #####:  690:	bool found = false;
    #####:  691:	u64 subs_count = args->subs_count;
    #####:  692:	u64 sub_index = 0;
        -:  693:
    #####:  694:	if (sub_command) {
    #####:  695:		for (u64 i = 1; i < subs_count; i++) {
    #####:  696:			char *name = args->subs[i]->name;
    #####:  697:			if (!strcmp(name, sub_command)) {
    #####:  698:				sub_index = i;
    #####:  699:				found = true;
        -:  700:			}
        -:  701:		}
        -:  702:	} else // general help displayed
    #####:  703:		found = true;
        -:  704:
    #####:  705:	if (!found) {
    #####:  706:		args_exit_error(args, "Unknown SubCommand \"%s\"", sub_command);
        -:  707:	}
        -:  708:
    #####:  709:	SubCommand **subs = args->subs;
    #####:  710:	ArgsParam *params = args->subs[0]->params;
    #####:  711:	u64 count = args->subs[0]->params_count;
    #####:  712:	u64 max_len = 0;
    #####:  713:	for (u64 i = 0; i < count; i++) {
    #####:  714:		bool takes_value = args->subs[0]->params[i].takes_value;
    #####:  715:		bool multi = args->subs[0]->params[i].multiple;
    #####:  716:		char *name = args->subs[0]->params[i].name;
    #####:  717:		char *short_name = args->subs[0]->params[i].short_name;
        -:  718:		u64 len;
    #####:  719:		if (!takes_value)
    #####:  720:			len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
    #####:  721:		else if (multi)
    #####:  722:			len = snprintf(NULL, 0, "    -%s, --%s (<%s>, ...)", short_name, name, name);
        -:  723:		else
    #####:  724:			len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
    #####:  725:		if (len > max_len)
    #####:  726:			max_len = len;
        -:  727:	}
        -:  728:
    #####:  729:	max_len += 4;
        -:  730:
    #####:  731:	if (max_len < 17)
    #####:  732:		max_len = 17;
        -:  733:
    #####:  734:	char *prog = args->prog;
    #####:  735:	char *author = args->author;
    #####:  736:	char *version = args->version;
        -:  737:	char buffer[1025];
        -:  738:	char buffer2[1025];
        -:  739:	u64 i;
    #####:  740:	for (i = 0; i < max_len - 13 && i < 1024; i++)
    #####:  741:		buffer[i] = ' ';
    #####:  742:	buffer[i] = 0;
        -:  743:
    #####:  744:	for (i = 0; i < max_len - 16 && i < 1024; i++)
    #####:  745:		buffer2[i] = ' ';
    #####:  746:	buffer2[i] = 0;
        -:  747:	u64 sub_command_str_len;
    #####:  748:	if (sub_command)
    #####:  749:		sub_command_str_len = strlen(sub_command);
        -:  750:	else
    #####:  751:		sub_command_str_len = 0;
    #####:  752:	char sub_command_str[sub_command_str_len + 30];
    #####:  753:	char *sub_arg_doc_str = "";
    #####:  754:	if (sub_command) {
    #####:  755:		snprintf(
        -:  756:			sub_command_str, sub_command_str_len + 30, "%s%s%s", BRIGHT_RED, sub_command, RESET);
    #####:  757:		sub_arg_doc_str = args->subs[sub_index]->arg_doc;
        -:  758:	} else {
    #####:  759:		snprintf(sub_command_str, sub_command_str_len + 30, "[%sSUB_COMMAND%s]", DIMMED, RESET);
        -:  760:	}
        -:  761:
    #####:  762:	fprintf(stderr,
        -:  763:		"%s%s%s %s%s%s\n%s%s%s\n\n%sUSAGE%s:\n    %s%s%s "
        -:  764:		"[%sCORE_OPTIONS%s] %s [%sSUB_OPTIONS%s] %s\n\n"
        -:  765:		"%sCORE_FLAGS%s:\n"
        -:  766:		"    %s-h%s, %s--help%s%sPrints help information\n"
        -:  767:		"    %s-V%s, %s--version%s%sPrints version "
        -:  768:		"information\n",
        -:  769:		CYAN, prog, RESET, YELLOW, version, RESET, GREEN, author, RESET, DIMMED, RESET, BRIGHT_RED,
        -:  770:		prog, RESET, DIMMED, RESET, sub_command_str, DIMMED, RESET, sub_arg_doc_str, DIMMED, RESET,
        -:  771:		CYAN, RESET, YELLOW, RESET, buffer, CYAN, RESET, YELLOW, RESET, buffer2);
        -:  772:
    #####:  773:	for (u64 i = 0; i < count; i++) {
    #####:  774:		bool takes_value = params[i].takes_value;
    #####:  775:		if (!takes_value) {
    #####:  776:			char *name = params[i].name;
    #####:  777:			char *short_name = params[i].short_name;
    #####:  778:			char *help = params[i].help;
    #####:  779:			u64 len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
    #####:  780:			if (len > max_len)
    #####:  781:				len = max_len;
        -:  782:			u64 i;
    #####:  783:			for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  784:				buffer[i] = ' ';
    #####:  785:			buffer[i] = 0;
    #####:  786:			fprintf(stderr, "    %s-%s%s, %s--%s%s %s%s\n", CYAN, short_name, RESET, YELLOW, name,
        -:  787:				RESET, buffer, help);
        -:  788:		}
        -:  789:	}
        -:  790:
    #####:  791:	if (count) {
    #####:  792:		fprintf(stderr, "\n%sCORE_OPTIONS%s:\n", DIMMED, RESET);
        -:  793:
    #####:  794:		for (u64 i = 0; i < count; i++) {
    #####:  795:			bool takes_value = params[i].takes_value;
    #####:  796:			if (takes_value) {
    #####:  797:				char *name = params[i].name;
    #####:  798:				char *short_name = params[i].short_name;
    #####:  799:				char *help = params[i].help;
    #####:  800:				bool multi = params[i].multiple;
    #####:  801:				char *default_value = params[i].default_value;
        -:  802:				u64 default_value_str_len;
    #####:  803:				if (default_value == NULL) {
    #####:  804:					default_value_str_len = 1;
        -:  805:				} else {
    #####:  806:					default_value_str_len = strlen(default_value) + 100;
        -:  807:				}
    #####:  808:				char default_value_str[default_value_str_len];
    #####:  809:				if (default_value == NULL)
    #####:  810:					strcpy(default_value_str, "");
        -:  811:				else
    #####:  812:					snprintf(default_value_str, default_value_str_len, " (default value: '%s')",
        -:  813:						default_value);
        -:  814:
    #####:  815:				if (multi) {
    #####:  816:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>, ...", short_name, name, name);
    #####:  817:					if (len > max_len)
    #####:  818:						len = max_len;
        -:  819:					u64 i;
    #####:  820:					for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  821:						buffer[i] = ' ';
    #####:  822:					buffer[i] = 0;
    #####:  823:					fprintf(stderr,
        -:  824:						"    %s-%s%s, %s--%s%s "
        -:  825:						"<%s>, "
        -:  826:						"... %s%s%s\n",
        -:  827:						CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  828:						default_value_str);
        -:  829:				} else {
        -:  830:
    #####:  831:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
    #####:  832:					if (len > max_len)
    #####:  833:						len = max_len;
        -:  834:					u64 i;
    #####:  835:					for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  836:						buffer[i] = ' ';
    #####:  837:					buffer[i] = 0;
        -:  838:
    #####:  839:					fprintf(stderr,
        -:  840:						"    %s-%s%s, %s--%s%s "
        -:  841:						"<%s> "
        -:  842:						"%s%s%s\n",
        -:  843:						CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  844:						default_value_str);
        -:  845:				}
        -:  846:			}
        -:  847:		}
        -:  848:	}
        -:  849:
    #####:  850:	if (subs_count > 1 && sub_command == NULL) {
    #####:  851:		fprintf(stderr, "\n%sSUB_COMMANDS%s:\n", DIMMED, RESET);
    #####:  852:		for (u64 i = 1; i < subs_count; i++) {
        -:  853:
    #####:  854:			char *name = args->subs[i]->name;
    #####:  855:			char *help = args->subs[i]->help;
    #####:  856:			char *arg_doc = args->subs[i]->arg_doc;
        -:  857:
    #####:  858:			u64 len = strlen(name) + strlen(arg_doc) + 4;
    #####:  859:			if (len > max_len)
    #####:  860:				len = max_len;
        -:  861:			char buffer[1025];
        -:  862:			u64 j;
    #####:  863:			for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  864:				buffer[j] = ' ';
    #####:  865:			buffer[j] = 0;
        -:  866:
    #####:  867:			fprintf(stderr, "    %s%s%s %s%s%s\n", CYAN, name, RESET, arg_doc, buffer, help);
        -:  868:		}
        -:  869:	}
        -:  870:
    #####:  871:	if (sub_command) {
    #####:  872:		u64 param_index = 0;
    #####:  873:		for (u64 i = 1; i < subs_count; i++) {
    #####:  874:			char *name = args->subs[i]->name;
    #####:  875:			if (!strcmp(name, sub_command)) {
    #####:  876:				param_index = i;
        -:  877:			}
        -:  878:		}
        -:  879:
    #####:  880:		if (param_index > 0) {
    #####:  881:			params = args->subs[param_index]->params;
        -:  882:
    #####:  883:			count = args->subs[param_index]->params_count;
    #####:  884:			fprintf(stderr, "\n%sSUB_FLAGS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -:  885:				RESET);
        -:  886:
    #####:  887:			for (u64 i = 0; i < count; i++) {
    #####:  888:				char *name = params[i].name;
    #####:  889:				char *short_name = params[i].short_name;
    #####:  890:				bool takes_value = params[i].takes_value;
    #####:  891:				char *help = params[i].help;
        -:  892:
    #####:  893:				if (!takes_value) {
    #####:  894:					u64 len = strlen(name) + 10;
    #####:  895:					if (len > max_len)
    #####:  896:						len = max_len;
        -:  897:					char buffer[1025];
        -:  898:					u64 j;
    #####:  899:					for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  900:						buffer[j] = ' ';
    #####:  901:					buffer[j] = 0;
    #####:  902:					fprintf(stderr,
        -:  903:						"    %s-%s%s, "
        -:  904:						"%s--%s%s%s %s\n",
        -:  905:						CYAN, short_name, RESET, YELLOW, name, RESET, buffer, help);
        -:  906:				}
        -:  907:			}
    #####:  908:			fprintf(stderr, "\n%sSUB_OPTIONS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -:  909:				RESET);
    #####:  910:			for (u64 i = 0; i < count; i++) {
    #####:  911:				char *name = params[i].name;
    #####:  912:				char *short_name = params[i].short_name;
    #####:  913:				bool takes_value = params[i].takes_value;
    #####:  914:				char *help = params[i].help;
    #####:  915:				bool multiple = params[i].multiple;
        -:  916:
    #####:  917:				char *default_value = params[i].default_value;
        -:  918:				u64 default_value_str_len;
    #####:  919:				if (default_value == NULL) {
    #####:  920:					default_value_str_len = 1;
        -:  921:				} else {
    #####:  922:					default_value_str_len = strlen(default_value) + 100;
        -:  923:				}
    #####:  924:				char default_value_str[default_value_str_len];
    #####:  925:				if (default_value == NULL)
    #####:  926:					strcpy(default_value_str, "");
        -:  927:				else
    #####:  928:					snprintf(default_value_str, default_value_str_len, " (default value: %s)",
        -:  929:						default_value);
        -:  930:
    #####:  931:				if (takes_value) {
    #####:  932:					if (multiple) {
    #####:  933:						u64 len = 2 * strlen(name) + 19;
        -:  934:						char buffer[1025];
        -:  935:						u64 j;
    #####:  936:						if (len > max_len)
    #####:  937:							len = max_len;
    #####:  938:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  939:							buffer[j] = ' ';
    #####:  940:						buffer[j] = ' ';
    #####:  941:						buffer[j + 1] = 0;
    #####:  942:						fprintf(stderr,
        -:  943:							"    %s-%s%s, "
        -:  944:							"%s--%s%s "
        -:  945:							"<%s>, ...%s %s"
        -:  946:							"%s\n",
        -:  947:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  948:							default_value_str);
        -:  949:					} else {
    #####:  950:						u64 len = 2 * strlen(name) + 13;
        -:  951:						char buffer[1025];
        -:  952:						u64 j;
    #####:  953:						if (len > max_len)
    #####:  954:							len = max_len;
    #####:  955:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  956:							buffer[j] = ' ';
    #####:  957:						buffer[j] = 0;
    #####:  958:						fprintf(stderr,
        -:  959:							"    %s-%s%s, "
        -:  960:							"%s--%s%s "
        -:  961:							"<%s>%s "
        -:  962:							"%s%s\n",
        -:  963:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  964:							default_value_str);
        -:  965:					}
        -:  966:				}
        -:  967:			}
        -:  968:		}
        -:  969:	}
        -:  970:
    #####:  971:	exit(0);
        -:  972:}
        -:    0:Source:bible.c
        -:    0:Graph:bible.gcno
        -:    0:Data:bible.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <bible/bible.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:
        2:   21:int bible_checksum(char *data) {
        -:   22:	char sha[65];
        2:   23:	SHA256(data, sha);
        -:   24:
        -:   25:	// sha 256 checksum of the akjv bible from
        -:   26:	// https://github.com/bible-hub/Bibles/blob/master/English__American_King_James_Version__akjv__LTR.txt
        2:   27:	if (strcmp(sha, "9fac349223681483dd1d225cd04a298cef93f3efeb21b562469a1a"
        -:   28:					"8efa7069ff")) {
    #####:   29:		errno = EPERM;
    #####:   30:		return -1;
        -:   31:	}
        2:   32:	return 0;
        -:   33:}
        -:   34:
    62204:   35:int bible_parse_verse(Bible *bible, u64 index, char *buf) {
    62204:   36:	const char *strstr_res = strstr(buf, "|");
    62204:   37:	if (strstr_res == NULL) {
    #####:   38:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   39:		errno = EINVAL;
    #####:   40:		return -1;
        -:   41:	}
    62204:   42:	int end_book = strstr_res - buf;
    62204:   43:	if (end_book < 0) {
    #####:   44:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   45:		errno = EINVAL;
    #####:   46:		return -1;
        -:   47:	}
    62204:   48:	char bookname[end_book + 1];
    62204:   49:	memcpy(bookname, buf, end_book);
    62204:   50:	bookname[end_book] = 0;
        -:   51:
    62204:   52:	int start_chapter = end_book + 2;
    62204:   53:	const char *end_chapter_str = strstr(buf + start_chapter, "|");
    62204:   54:	if (end_chapter_str == NULL) {
    #####:   55:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   56:		errno = EINVAL;
    #####:   57:		return -1;
        -:   58:	}
    62204:   59:	int end_chapter = end_chapter_str - buf;
    62204:   60:	if (end_chapter < start_chapter) {
    #####:   61:		fprintf(stderr, "invalid line %s, index=%" PRIu64 ", end_chapter=%i,start_chap=%i\n", buf,
        -:   62:				index, end_chapter, start_chapter);
    #####:   63:		errno = EINVAL;
    #####:   64:		return -1;
        -:   65:	}
        -:   66:
    62204:   67:	char chapter[(end_chapter - start_chapter) + 1];
    62204:   68:	memcpy(chapter, buf + start_chapter, end_chapter - start_chapter);
    62204:   69:	chapter[end_chapter - start_chapter] = 0;
        -:   70:
    62204:   71:	int start_verse = end_chapter + 2;
    62204:   72:	const char *end_verse_str = strstr(buf + start_verse, "|");
    62204:   73:	if (end_verse_str == NULL) {
    #####:   74:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   75:		errno = EINVAL;
    #####:   76:		return -1;
        -:   77:	}
    62204:   78:	int end_verse = end_verse_str - buf;
        -:   79:
    62204:   80:	if (end_verse < start_verse) {
    #####:   81:		fprintf(stderr, "invalid line %s, index=%" PRIu64 ", end_chapter=%i,start_chap=%i\n", buf,
        -:   82:				index, end_verse, start_verse);
    #####:   83:		errno = EINVAL;
    #####:   84:		return -1;
        -:   85:	}
        -:   86:
    62204:   87:	char verse[(end_verse - start_verse) + 1];
    62204:   88:	memcpy(verse, buf + start_verse, end_verse - start_verse);
    62204:   89:	verse[end_verse - start_verse] = 0;
        -:   90:
    62204:   91:	int start_text = end_verse + 2;
        -:   92:
        -:   93:	int end_text;
    62204:   94:	const char *end_text_res = strstr(buf, "\n");
    62204:   95:	if (end_text_res == NULL) {
        -:   96:		// last line has no newline so just use entire line here
        2:   97:		end_text = strlen(buf);
        -:   98:	} else
    62202:   99:		end_text = end_text_res - buf;
        -:  100:
    62204:  101:	char text[(end_text - start_text) + 1];
    62204:  102:	memcpy(text, buf + start_text, end_text - start_text);
    62204:  103:	text[end_text - start_text] = 0;
        -:  104:
    62204:  105:	bible->verses[index].text = mymalloc(sizeof(char) * (end_text - start_text) + 1);
    62204:  106:	strcpy(bible->verses[index].text, text);
    62204:  107:	bible->verses[index].chapter_id = strtol(chapter, NULL, 10);
    62204:  108:	bible->verses[index].verse_id = strtol(verse, NULL, 10);
        -:  109:
        -:  110:	// find book
    62204:  111:	if (bible->book_id_count == 0) {
        -:  112:		// first book
        2:  113:		bible->book_ids = mymalloc(sizeof(BibleBookIdMap));
        2:  114:		bible->book_ids[0].book_id = 0;
        2:  115:		bible->book_ids[0].name = mymalloc(sizeof(char) * (strlen(bookname) + 1));
        2:  116:		strcpy(bible->book_ids[0].name, bookname);
        2:  117:		bible->book_id_count += 1;
        2:  118:		bible->verses[index].book_id = 0;
        -:  119:	} else {
    62202:  120:		char *cur_book = bible->book_ids[bible->book_id_count - 1].name;
        -:  121:		// check for new book
    62202:  122:		if (!strcmp(cur_book, bookname)) {
        -:  123:			// we're still in the same book
    62072:  124:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count - 1].book_id;
        -:  125:		} else {
        -:  126:			// new book, update book ids
      130:  127:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count - 1].book_id + 1;
        -:  128:			void *tmp =
      130:  129:				myrealloc(bible->book_ids, sizeof(BibleBookIdMap) * (bible->book_id_count + 1));
      130:  130:			if (!tmp)
    #####:  131:				return -1;
      130:  132:			bible->book_ids = tmp;
        -:  133:			// next higher book id
      130:  134:			bible->book_ids[bible->book_id_count].book_id =
      130:  135:				bible->book_ids[bible->book_id_count - 1].book_id + 1;
      260:  136:			bible->book_ids[bible->book_id_count].name =
      130:  137:				mymalloc(sizeof(char) * (strlen(bookname) + 1));
      130:  138:			strcpy(bible->book_ids[bible->book_id_count].name, bookname);
      130:  139:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count].book_id;
      130:  140:			bible->book_id_count += 1;
        -:  141:		}
        -:  142:	}
        -:  143:
    62204:  144:	return 0;
        -:  145:}
        -:  146:
      620:  147:int bible_book_id_map_compare(const void *a, const void *b) {
      620:  148:	return strcmp(((BibleBookIdMap *)a)->name, ((BibleBookIdMap *)b)->name);
        -:  149:}
        -:  150:
        2:  151:int bible_build(Bible *bible, char *path) {
        2:  152:	FILE *fp = myfopen(path, "r");
        2:  153:	if (fp == NULL) {
    #####:  154:		return -1;
        -:  155:	}
        -:  156:
        -:  157:	char bible_check[BIBLE_CHECKSUM_SCAN_BUF_SIZE];
        2:  158:	int len = fread(bible_check, sizeof(*bible_check), BIBLE_CHECKSUM_SCAN_BUF_SIZE, fp);
        2:  159:	bible_check[len] = 0;
        -:  160:
        2:  161:	if (bible_checksum(bible_check))
    #####:  162:		return -1;
        -:  163:
        2:  164:	fseek(fp, 0, SEEK_SET);
        -:  165:
        -:  166:	char buf[VERSE_BUF_LEN];
        -:  167:
        2:  168:	bible->verses = NULL;
        2:  169:	bible->verse_count = 0;
        2:  170:	bible->book_ids = NULL;
        2:  171:	bible->book_id_count = 0;
        -:  172:
        2:  173:	int max_len = 0;
    62216:  174:	while (fgets(buf, VERSE_BUF_LEN, fp)) {
    62214:  175:		if (strlen(buf) > max_len)
       36:  176:			max_len = strlen(buf);
    62214:  177:		if (bible->verse_count == 0) {
        2:  178:			bible->verses = mymalloc(sizeof(BibleVerse));
        2:  179:			if (bible->verses == NULL)
    #####:  180:				return -1;
        -:  181:		} else {
    62212:  182:			void *tmp = myrealloc(bible->verses, sizeof(BibleVerse) * (bible->verse_count + 1));
    62212:  183:			if (tmp == NULL)
    #####:  184:				return -1;
    62212:  185:			bible->verses = tmp;
        -:  186:		}
    62214:  187:		const char *strstr_res = strstr(buf, "|");
    62214:  188:		if (strstr_res == NULL) {
        -:  189:			// there is an empty line in the file. Skip it.
       10:  190:			continue;
        -:  191:		}
    62204:  192:		int end_book = strstr_res - buf;
    62204:  193:		if (bible_parse_verse(bible, bible->verse_count, buf))
    #####:  194:			return -1;
    62204:  195:		bible->verse_count += 1;
        -:  196:	}
        -:  197:
        -:  198:	// sort the books for quicker lookups
        2:  199:	bible->book_ids_sorted = mymalloc(sizeof(BibleVerse) * (bible->verse_count));
        2:  200:	if (bible->book_ids_sorted == NULL)
    #####:  201:		return -1;
        2:  202:	memcpy(bible->book_ids_sorted, bible->book_ids, bible->book_id_count * sizeof(BibleBookIdMap));
        2:  203:	qsort(bible->book_ids_sorted, bible->book_id_count, sizeof(BibleBookIdMap),
        -:  204:		  bible_book_id_map_compare);
        -:  205:
        2:  206:	myfclose(fp);
        2:  207:	return 0;
        -:  208:}
        -:  209:
        2:  210:void bible_cleanup(Bible *bible) {
    62206:  211:	for (int i = 0; i < bible->verse_count; i++)
    62204:  212:		myfree(bible->verses[i].text);
      134:  213:	for (int i = 0; i < bible->book_id_count; i++)
      132:  214:		myfree(bible->book_ids[i].name);
        2:  215:	myfree(bible->verses);
        2:  216:	myfree(bible->book_ids);
        2:  217:	myfree(bible->book_ids_sorted);
        2:  218:}
        -:  219:
    31102:  220:int format_verse(Bible *bible, int index, char *buf, int buf_len, bool colors) {
        -:  221:
    31102:  222:	if (colors)
    #####:  223:		return snprintf(buf, buf_len, "[%s%s%s:%s%i:%i%s] %s%s%s", GREEN,
    #####:  224:						bible->book_ids[bible->verses[index].book_id].name, RESET, CYAN,
    #####:  225:						bible->verses[index].chapter_id, bible->verses[index].verse_id, RESET,
    #####:  226:						YELLOW, bible->verses[index].text, RESET);
        -:  227:	else
    31102:  228:		return snprintf(buf, buf_len, "[%s:%i:%i] %s",
    31102:  229:						bible->book_ids[bible->verses[index].book_id].name,
    31102:  230:						bible->verses[index].chapter_id, bible->verses[index].verse_id,
    31102:  231:						bible->verses[index].text);
        -:  232:}
        -:  233:
    32350:  234:int bible_book_index(Bible *bible, char *book) {
        -:  235:	// use binary search to find the book
        -:  236:	int index;
    32350:  237:	int min = 0;
    32350:  238:	int max = bible->book_id_count - 1;
        -:  239:	int book_id;
   132081:  240:	while (true) {
   164431:  241:		if (max < min) {
    #####:  242:			errno = EINVAL;
    #####:  243:			return -1;
        -:  244:		}
   164431:  245:		index = min + ((max - min) / 2);
   164431:  246:		int strcmp_res = strcmp(book, bible->book_ids_sorted[index].name);
   164431:  247:		if (strcmp_res == 0) {
    32350:  248:			book_id = bible->book_ids_sorted[index].book_id;
    32350:  249:			break;
   132081:  250:		} else if (strcmp_res < 0) {
    65983:  251:			max = index - 1;
        -:  252:		} else {
    66098:  253:			min = index + 1;
        -:  254:		}
        -:  255:	}
    32350:  256:	return book_id;
        -:  257:}
        -:  258:
    32351:  259:int bible_verse_to_string(Bible *bible, char *book, u8 chapter, u8 verse, char *buf, int buf_len,
        -:  260:						  bool colors) {
    32351:  261:	if (book == NULL || strlen(book) == 0) {
        1:  262:		errno = EINVAL;
        1:  263:		return -1;
        -:  264:	}
    32350:  265:	return bible_random_verse_to_string(bible, buf, buf_len, colors, book, &chapter, &verse);
        -:  266:}
        -:  267:
    32350:  268:int bible_random_verse_to_string(Bible *bible, char *buf, int buf_len, bool colors,
        -:  269:								 char *optional_book, u8 *optional_chapter, u8 *optional_verse) {
        -:  270:	u16 r;
    32350:  271:	if (rand_u16(&r))
    #####:  272:		return -1;
        -:  273:
    32350:  274:	if (optional_book && strlen(optional_book) > 0) {
    32350:  275:		int book_id = bible_book_index(bible, optional_book);
    32350:  276:		if (book_id < 0)
    #####:  277:			return -1;
        -:  278:
        -:  279:		int index;
    32350:  280:		int min = 0;
    32350:  281:		int max = bible->verse_count;
        -:  282:
        -:  283:		// use binary search to find the verse
        -:  284:
        -:  285:		while (true) {
   140658:  286:			if (max < min) {
    #####:  287:				errno = EINVAL;
    #####:  288:				return -1;
        -:  289:			}
   140658:  290:			index = min + ((max - min) / 2);
   140658:  291:			if (book_id == bible->verses[index].book_id) {
    32350:  292:				min = index;
    32350:  293:				max = index;
 15912881:  294:				while (min - 1 >= 0 && bible->verses[min - 1].book_id == book_id)
 15880531:  295:					min--;
 16589666:  296:				while (max + 1 < bible->verse_count && bible->verses[max + 1].book_id == book_id)
 16557316:  297:					max++;
    32350:  298:				break;
   108308:  299:			} else if (book_id < bible->verses[index].book_id) {
    54604:  300:				max = index - 1;
        -:  301:			} else {
    53704:  302:				min = index + 1;
        -:  303:			}
        -:  304:		}
        -:  305:
    32350:  306:		if (optional_chapter) {
    32350:  307:			u8 target_chapter = *optional_chapter;
        -:  308:			while (true) {
   133500:  309:				if (max < min) {
       65:  310:					errno = EINVAL;
       65:  311:					return -1;
        -:  312:				}
   133435:  313:				index = min + ((max - min) / 2);
   133435:  314:				if (target_chapter == bible->verses[index].chapter_id) {
    32285:  315:					min = index;
    32285:  316:					max = index;
   527723:  317:					while (min - 1 >= 0 && bible->verses[min - 1].chapter_id == target_chapter &&
   495531:  318:						   bible->verses[min - 1].book_id == book_id)
   495438:  319:						min--;
    32285:  320:					while (max + 1 < bible->verse_count &&
   564609:  321:						   bible->verses[max + 1].chapter_id == target_chapter &&
   532422:  322:						   bible->verses[max + 1].book_id == book_id)
   532324:  323:						max++;
        -:  324:
    32285:  325:					if (optional_verse) {
    32285:  326:						u8 target_verse = *optional_verse;
    32285:  327:						if (target_verse > (1 + max) - min) {
     1183:  328:							errno = EINVAL;
     1183:  329:							return -1;
        -:  330:						}
    31102:  331:						min += target_verse - 1;
    31102:  332:						max = min + 2;
        -:  333:					}
    31102:  334:					break;
   101150:  335:				} else if (target_chapter < bible->verses[index].chapter_id) {
    50430:  336:					max = index - 1;
        -:  337:				} else {
    50720:  338:					min = index + 1;
        -:  339:				}
        -:  340:			}
        -:  341:		}
        -:  342:
    31102:  343:		r %= ((max - 1) - min);
    31102:  344:		r += (min);
        -:  345:	} else
    #####:  346:		r %= bible->verse_count;
    31102:  347:	return format_verse(bible, r, buf, buf_len, colors);
        -:  348:}
        -:    0:Source:replace.c
        -:    0:Graph:replace.gcno
        -:    0:Data:replace.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <stdio.h>
        -:   17:#include <util/replace.h>
        -:   18:#include <util/trie.h>
        -:   19:
        1:   20:int replace_file(Path *in_path, Path *out_path, const char *patterns_in[],
        -:   21:	const bool is_case_sensisitive[], const char *replace[], int count)
        1:   22:{
        1:   23:	FILE *file = myfopen(path_to_string(in_path), "rb"); // Open the file in binary mode
        1:   24:	if (!file) {
    #####:   25:		perror("File opening failed");
    #####:   26:		return -1;
        -:   27:	}
        -:   28:
        -:   29:	// Move the file pointer to the end of the file to get its size
        1:   30:	fseek(file, 0, SEEK_END);
        1:   31:	long file_size = ftell(file); // Get the size of the file
        1:   32:	fseek(file, 0, SEEK_SET); // Move file pointer back to the beginning
        -:   33:
        -:   34:	// Allocate memory to store the contents (+1 for null terminator)
        1:   35:	char buffer[file_size + 1];
        -:   36:
        -:   37:	// Read the contents of the file into the buffer
        1:   38:	if (fread(buffer, 1, file_size, file) < file_size) {
    #####:   39:		perror("fread");
    #####:   40:		myfclose(file);
    #####:   41:		return -1;
        -:   42:	}
        1:   43:	buffer[file_size] = '\0'; // Null-terminate the buffer
        -:   44:
        1:   45:	myfclose(file); // Close the file
        -:   46:
        1:   47:	TrieMatch tm[count];
        1:   48:	Trie t;
        1:   49:	trie_build(&t, patterns_in, is_case_sensisitive, count);
        1:   50:	int matches = trie_match(&t, buffer, tm, count);
        -:   51:
        1:   52:	file = myfopen(path_to_string(out_path), "wb"); // Open file for writing
        1:   53:	if (!file) {
    #####:   54:		perror("File opening failed");
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        1:   58:	int itt = 0;
        -:   59:
        4:   60:	for (int i = 0; i < matches; i++) {
        3:   61:		if (tm[i].offset > itt) {
        3:   62:			int v = fwrite(buffer + itt, sizeof(char), tm[i].offset - itt, file);
        3:   63:			if (v < tm[i].offset - itt) {
    #####:   64:				perror("fwrite");
    #####:   65:				myfclose(file);
    #####:   66:				return -1;
        -:   67:			}
        3:   68:			itt = tm[i].offset;
        -:   69:		}
        3:   70:		fprintf(file, "%s", replace[tm[i].pattern_id]);
        3:   71:		itt += tm[i].len;
        -:   72:	}
        1:   73:	if (itt < file_size) {
        1:   74:		if (fwrite(buffer + itt, sizeof(char), file_size - itt, file) < file_size - itt) {
    #####:   75:			perror("fwrite");
    #####:   76:			myfclose(file);
    #####:   77:			return -1;
        -:   78:		}
        -:   79:	}
        -:   80:
        1:   81:	myfclose(file);
        -:   82:
        1:   83:	return 0;
        -:   84:}
        -:    0:Source:suffix_tree.c
        -:    0:Graph:suffix_tree.gcno
        -:    0:Data:suffix_tree.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/base.h>
        -:   16:#include <errno.h>
        -:   17:#include <string.h>
        -:   18:#include <util/suffix_tree.h>
        -:   19:
        -:   20:// The suffix pair represents the index and it's corresponding suffix. This is used to calcualte the
        -:   21:// suffix tree efficiently.
        -:   22:typedef struct SuffixPair {
        -:   23:	u64 index; // index (where does this suffix start within the text)
        -:   24:	const char *suffix; // the actual suffix
        -:   25:} SuffixPair;
        -:   26:
        -:   27:// The opaque SuffixTreeImpl
        -:   28:typedef struct SuffixTreeImpl {
        -:   29:	FatPtr suffix_array; // The array of u64 offsets
        -:   30:	FatPtr lcp_array; // The array of least common prefixes
        -:   31:	char *text; // The text for this suffix tree
        -:   32:	u64 suffix_array_len; // The length of the suffix array
        -:   33:} SuffixTreeImpl;
        -:   34:
        -:   35:// Deallocate all memory associated with the suffix tree
        1:   36:void suffix_tree_cleanup(SuffixTree *ptr)
        -:   37:{
        1:   38:	if (ptr->impl.data) {
        1:   39:		SuffixTreeImpl *si = ptr->impl.data;
        1:   40:		if (si->suffix_array.data) {
        1:   41:			chain_free(&si->suffix_array);
        -:   42:		}
        1:   43:		if (si->lcp_array.data) {
        1:   44:			chain_free(&si->lcp_array);
        -:   45:		}
        1:   46:		if (si->text) {
        1:   47:			myfree(si->text);
        1:   48:			si->text = NULL;
        -:   49:		}
        1:   50:		chain_free(&ptr->impl);
        -:   51:	}
        1:   52:}
        -:   53:
        -:   54:// Compare suffix pairs (for qsort)
      142:   55:int suffix_pair_compare(const void *p1, const void *p2)
        -:   56:{
      142:   57:	const SuffixPair *sp1 = p1;
      142:   58:	const SuffixPair *sp2 = p2;
      142:   59:	return strcmp(sp1->suffix, sp2->suffix);
        -:   60:}
        -:   61:
        -:   62:// Compare suffix matches (for qsort)
       15:   63:int suffix_match_compare(const void *s1, const void *s2)
        -:   64:{
       15:   65:	const SuffixTreeMatch *sm1 = s1;
       15:   66:	const SuffixTreeMatch *sm2 = s2;
       15:   67:	if (sm1->offset < sm2->offset)
        7:   68:		return -1;
        8:   69:	else if (sm1->offset > sm2->offset)
        8:   70:		return 1;
    #####:   71:	return 0;
        -:   72:}
        -:   73:
        -:   74:// build a suffix tree
        1:   75:int suffix_tree_build(SuffixTree *ptr, const char *text)
        1:   76:{
        -:   77:	// validate input
        1:   78:	if (text == NULL) {
    #####:   79:		errno = EINVAL;
    #####:   80:		return -1;
        -:   81:	}
        1:   82:	int text_len = strlen(text);
        1:   83:	if (text_len == 0) {
    #####:   84:		errno = EINVAL;
    #####:   85:		return -1;
        -:   86:	}
        -:   87:
        -:   88:	// allocate the needed memory for the SuffixTreeImpl
        1:   89:	if (chain_malloc(&ptr->impl, sizeof(SuffixTreeImpl))) {
    #####:   90:		return -1;
        -:   91:	}
        -:   92:
        -:   93:	// Pointer to our suffix tree impl
        1:   94:	SuffixTreeImpl *si = ptr->impl.data;
        -:   95:
        -:   96:	// allocate the suffix array
        1:   97:	if (chain_malloc(&si->suffix_array, sizeof(u64) * text_len)) {
    #####:   98:		chain_free(&ptr->impl);
    #####:   99:		return -1;
        -:  100:	}
        -:  101:
        -:  102:	// allocate the lcp array
        1:  103:	if (chain_malloc(&si->lcp_array, sizeof(u64) * text_len)) {
    #####:  104:		chain_free(&si->suffix_array);
    #####:  105:		chain_free(&ptr->impl);
    #####:  106:		return -1;
        -:  107:	}
        -:  108:
        -:  109:	// allocate the text
        1:  110:	si->text = mymalloc(sizeof(char) * text_len + 1);
        1:  111:	if (si->text == NULL) {
    #####:  112:		chain_free(&si->suffix_array);
    #####:  113:		chain_free(&si->lcp_array);
    #####:  114:		chain_free(&ptr->impl);
    #####:  115:		return -1;
        -:  116:	}
        -:  117:
        -:  118:	// create a suffix array to build our suffixes.
        1:  119:	SuffixPair arr[text_len];
        1:  120:	u64 rank[text_len];
        1:  121:	u64 *lcp_arr = si->lcp_array.data;
        -:  122:
        -:  123:	// initialize the values of the suffix array.
       37:  124:	for (u64 i = 0; i < text_len; i++) {
       36:  125:		arr[i].index = i;
       36:  126:		arr[i].suffix = (char *)(text + i);
        -:  127:	}
        -:  128:
        -:  129:	// sort them
        1:  130:	qsort(arr, text_len, sizeof(SuffixPair), suffix_pair_compare);
        -:  131:
        -:  132:	// initialize rank and lcp to 0
        1:  133:	memset(rank, 0, sizeof(u64) * text_len);
        1:  134:	memset(lcp_arr, 0, sizeof(u64) * text_len);
        -:  135:
        -:  136:	// update the data in our array and initialize 'rank' for LCP calc.
        1:  137:	u64 *suffix_arr = si->suffix_array.data;
       37:  138:	for (u64 i = 0; i < text_len; i++) {
       36:  139:		suffix_arr[i] = arr[i].index;
       36:  140:		rank[arr[i].index] = i;
        -:  141:	}
        -:  142:
        -:  143:	// calculate the LCP
        1:  144:	u64 h = 0; // Length of the common prefix
       37:  145:	for (u64 i = 0; i < text_len; i++) {
       36:  146:		u64 r = rank[i];
       36:  147:		if (r > 0) {
        -:  148:			// Previous suffix in sorted order
       35:  149:			u64 j = suffix_arr[r - 1];
        -:  150:
        -:  151:			// Compare characters
       60:  152:			while (i + h < text_len && j + h < text_len && text[i + h] == text[j + h]) {
       25:  153:				h++;
        -:  154:			}
       35:  155:			lcp_arr[r] = h; // Set LCP value
       35:  156:			if (h > 0) {
       25:  157:				h--; // Decrease h for the next suffix
        -:  158:			}
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	// copy the text and set the suffix_array_len
        1:  163:	strcpy(si->text, text);
        1:  164:	si->suffix_array_len = text_len;
        -:  165:
        1:  166:	return 0;
        -:  167:}
        -:  168:
        -:  169:// search our suffix tree for the specified pattern. Return up to limit entries in the
        -:  170:// SuffixTreeMatch.
        3:  171:int suffix_tree_search(SuffixTree *ptr, const char *pattern, SuffixTreeMatch *ret, u64 limit)
        -:  172:{
        -:  173:	// validate input
        3:  174:	if (pattern == NULL) {
    #####:  175:		errno = EINVAL;
    #####:  176:		return -1;
        -:  177:	}
        -:  178:
        3:  179:	SuffixTreeImpl *si = ptr->impl.data;
        3:  180:	if (si->suffix_array_len == 0) {
    #####:  181:		errno = EINVAL;
    #####:  182:		return -1;
        -:  183:	}
        -:  184:
        3:  185:	u64 pattern_len = strlen(pattern);
        3:  186:	if (pattern_len == 0 || limit == 0) {
    #####:  187:		errno = EINVAL;
    #####:  188:		return -1;
        -:  189:	}
        -:  190:
        -:  191:	// init other variables
        3:  192:	u64 *suffix_arr = si->suffix_array.data;
        3:  193:	u64 *lcp_arr = si->lcp_array.data;
        3:  194:	i32 min = 0;
        3:  195:	i32 max = si->suffix_array_len - 1;
        3:  196:	u64 match_index = UINT64_MAX;
        -:  197:
        -:  198:	// do a binary search to find a match
        -:  199:	loop
        7:  200:	{
        -:  201:		// take midpoint
       10:  202:		i64 mid = min + ((max - min) / 2);
        -:  203:		// compare
       10:  204:		int cmp = strncmp(pattern, si->text + suffix_arr[mid], pattern_len);
       10:  205:		if (cmp < 0) {
        -:  206:			// it's less so max must be lower
        3:  207:			max = mid - 1;
        7:  208:		} else if (cmp > 0) {
        -:  209:			// it's greater so min must be higher
        5:  210:			min = mid + 1;
        -:  211:		} else {
        -:  212:			// match found
        2:  213:			match_index = mid;
        2:  214:			break;
        -:  215:		}
        -:  216:		// can't go any further
        8:  217:		if (max < min)
        1:  218:			break;
        -:  219:	}
        -:  220:
        3:  221:	int count = 0;
        -:  222:	// If we have a match, iterate through up to limit times and set the ret[i].offset
        -:  223:	// appropriately.
        3:  224:	if (match_index != UINT64_MAX) {
        -:  225:		// populate first entry of the return array
        2:  226:		count++;
        2:  227:		ret[0].offset = suffix_arr[match_index];
        -:  228:
        -:  229:		// set direction to iterate up
        2:  230:		bool up = true;
        -:  231:		// initialize the match iterator
        2:  232:		u64 match_itt = match_index;
        -:  233:
        -:  234:		loop
        -:  235:		{
        -:  236:			// if count exceeds our limit break
       11:  237:			if (count >= limit)
    #####:  238:				break;
        -:  239:
       11:  240:			if (up) {
        -:  241:				// we are going up check lcp array upwards if it's lcp is greater than or equal to
        -:  242:				// pattern_len we know it's also a match.
        7:  243:				if (match_itt + 1 < si->suffix_array_len && lcp_arr[match_itt + 1] >= pattern_len) {
        -:  244:					// update the return array with this value
        5:  245:					ret[count].offset = suffix_arr[match_itt + 1];
        5:  246:					count++;
        5:  247:					match_itt++;
        -:  248:				} else {
        -:  249:					// it's not a match switch to downward direction and reset match index to our
        -:  250:					// original match
        2:  251:					up = false;
        2:  252:					match_itt = match_index;
        -:  253:				}
        -:  254:			} else {
        -:  255:				// we are now oriented downward check if the lcp for our current entry is greater
        -:  256:				// than pattern_len. If so we know the previous value must be a match.
        4:  257:				if (match_itt - 1 >= 0 && lcp_arr[match_itt] >= pattern_len) {
        -:  258:					// update the return array with this value
        2:  259:					ret[count].offset = suffix_arr[match_itt - 1];
        2:  260:					count++;
        2:  261:					match_itt--;
        -:  262:				} else {
        -:  263:					// it's not a match. break - no more matches.
        2:  264:					break;
        -:  265:				}
        -:  266:			}
        -:  267:		}
        -:  268:	}
        -:  269:	// return count
        3:  270:	return count;
        -:  271:}
        -:  272:
        -:  273:// sort the suffix tree using qsort
        2:  274:void suffix_tree_sort_results(SuffixTreeMatch *ret, u64 count)
        -:  275:{
        2:  276:	qsort(ret, count, sizeof(SuffixTreeMatch), suffix_match_compare);
        2:  277:}
        -:    0:Source:trie.c
        -:    0:Graph:trie.gcno
        -:    0:Data:trie.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <string.h>
        -:   17:#include <util/trie.h>
        -:   18:
        -:   19:typedef struct TrieNode {
        -:   20:	u32 children[256];
        -:   21:	u32 pattern_id;
        -:   22:} TrieNode;
        -:   23:
        -:   24:typedef struct TrieImpl {
        -:   25:	FatPtr memory_block;
        -:   26:	TrieNode *root;
        -:   27:	u32 cur;
        -:   28:} TrieImpl;
        -:   29:
        3:   30:void trie_cleanup(TrieNc *ptr)
        -:   31:{
        3:   32:	if (ptr->impl.data) {
        3:   33:		TrieImpl *ti = ptr->impl.data;
        3:   34:		if (ti)
        3:   35:			chain_free(&ti->memory_block);
        3:   36:		chain_free(&ptr->impl);
        -:   37:	}
        3:   38:}
        -:   39:
       34:   40:int trie_init_node(TrieNode *ptr)
        -:   41:{
       34:   42:	ptr->pattern_id = UINT32_MAX;
     8738:   43:	for (int i = 0; i < 256; i++)
     8704:   44:		ptr->children[i] = UINT32_MAX;
       34:   45:	return 0;
        -:   46:}
        -:   47:
        8:   48:int trie_insert(Trie *ptr, const char *str, bool is_case_sensitive, int pattern_id)
        -:   49:{
        8:   50:	TrieImpl *ti = ptr->impl.data;
        8:   51:	int slen = strlen(str);
        8:   52:	TrieNode *itt = ti->root;
       57:   53:	for (int i = 0; i < slen; i++) {
       49:   54:		char next = str[i];
       49:   55:		if (!is_case_sensitive) {
        5:   56:			if (next >= 'A' && next <= 'Z')
        3:   57:				next += 32;
        -:   58:		}
       49:   59:		u32 offset = itt->children[next];
       49:   60:		if (offset == UINT32_MAX) {
        -:   61:			// new node needed
       31:   62:			itt->children[next] = ti->cur;
       31:   63:			trie_init_node((TrieNode *)(ti->memory_block.data + ti->cur * sizeof(TrieNode)));
       31:   64:			offset = ti->cur;
       31:   65:			ti->cur++;
        -:   66:
        -:   67:		} else {
        -:   68:			// node exists follow it
        -:   69:		}
       49:   70:		itt = (TrieNode *)(ti->memory_block.data + offset * sizeof(TrieNode));
        -:   71:	}
        -:   72:
        8:   73:	itt->pattern_id = pattern_id;
        -:   74:
        8:   75:	return 0;
        -:   76:}
        -:   77:
        3:   78:int trie_build(Trie *ptr, const char *search_strings[], const bool is_case_sensitive[], int count)
        -:   79:{
        3:   80:	int m = 1; // 1 for root
       11:   81:	for (int i = 0; i < count; i++) {
        8:   82:		m += strlen(search_strings[i]);
        -:   83:	}
        3:   84:	if (chain_malloc(&ptr->impl, sizeof(TrieImpl)))
    #####:   85:		return -1;
        -:   86:
        3:   87:	TrieImpl *ti = ptr->impl.data;
        3:   88:	ti->cur = 1;
        -:   89:
        3:   90:	if (chain_malloc(&ti->memory_block, m * sizeof(TrieNode))) {
    #####:   91:		chain_free(&ptr->impl);
    #####:   92:		return -1;
        -:   93:	}
        3:   94:	ti->root = ti->memory_block.data;
        3:   95:	trie_init_node(ti->root);
        -:   96:
       11:   97:	for (int i = 0; i < count; i++) {
        8:   98:		if (trie_insert(ptr, search_strings[i], is_case_sensitive[i], i)) {
    #####:   99:			trie_cleanup(ptr);
    #####:  100:			return -1;
        -:  101:		}
        -:  102:	}
        -:  103:
        3:  104:	return 0;
        -:  105:}
        -:  106:
        1:  107:int trie_compare(const void *m1, const void *m2)
        -:  108:{
        1:  109:	const TrieMatch *tm1 = m1;
        1:  110:	const TrieMatch *tm2 = m2;
        1:  111:	if (tm1->offset < tm2->offset)
    #####:  112:		return -1;
        1:  113:	else if (tm1->offset > tm2->offset)
        1:  114:		return 1;
    #####:  115:	return 0;
        -:  116:}
        -:  117:
        3:  118:int trie_sort(TrieMatch ret[], int count)
        -:  119:{
        3:  120:	return qsort(ret, count, sizeof(TrieMatch), trie_compare);
        -:  121:}
        -:  122:
        8:  123:int trie_match(Trie *ptr, const char *text, TrieMatch ret[], u64 limit)
        8:  124:{
        8:  125:	TrieMatch ci_matches[limit];
        8:  126:	int ci_match_count = 0;
        8:  127:	int match_count = 0;
        8:  128:	int tlen = strlen(text);
        8:  129:	TrieImpl *ti = ptr->impl.data;
        8:  130:	TrieNode *itt = ti->root;
        8:  131:	int match_len = 0;
      220:  132:	for (int i = 0; i < tlen; i++) {
      214:  133:		char next = text[i];
      214:  134:		u32 offset = itt->children[next];
      214:  135:		if (offset != UINT32_MAX) {
        -:  136:			// found the node
       66:  137:			itt = (TrieNode *)(ti->memory_block.data + offset * sizeof(TrieNode));
       66:  138:			if (itt->pattern_id != UINT32_MAX) {
        9:  139:				ret[match_count].pattern_id = itt->pattern_id;
        9:  140:				ret[match_count].offset = i - match_len;
        9:  141:				ret[match_count].len = match_len + 1;
        9:  142:				ci_matches[ci_match_count].pattern_id = itt->pattern_id;
        9:  143:				ci_matches[ci_match_count].offset = i - match_len;
        9:  144:				ci_match_count++;
        9:  145:				match_count++;
        -:  146:			}
       66:  147:			match_len++;
       66:  148:			if (match_count == limit)
        2:  149:				break;
        -:  150:		} else {
        -:  151:			// not found, return to root
      148:  152:			itt = ti->root;
      148:  153:			match_len = 0;
        -:  154:		}
        -:  155:	}
        -:  156:
        8:  157:	bool has_case_sensitive = false;
        8:  158:	if (match_count < limit) {
      165:  159:		for (int i = 0; i < tlen; i++) {
      159:  160:			char next = text[i];
      159:  161:			if (next >= 'A' && next <= 'Z')
       28:  162:				next += 32;
      159:  163:			u32 offset = itt->children[next];
      159:  164:			if (offset != UINT32_MAX) {
        -:  165:				// found the node
       40:  166:				itt = (TrieNode *)(ti->memory_block.data + offset * sizeof(TrieNode));
       40:  167:				if (itt->pattern_id != UINT32_MAX) {
        -:  168:
        6:  169:					bool duplicate = false;
       12:  170:					for (int j = 0; j < ci_match_count; j++) {
        6:  171:						if (ci_matches[j].pattern_id == itt->pattern_id
        3:  172:							&& ci_matches[j].offset == i - match_len) {
        3:  173:							duplicate = true;
        -:  174:						}
        -:  175:					}
        -:  176:
        6:  177:					if (!duplicate) {
        3:  178:						has_case_sensitive = true;
        3:  179:						ret[match_count].pattern_id = itt->pattern_id;
        3:  180:						ret[match_count].offset = i - match_len;
        3:  181:						ret[match_count].len = match_len + 1;
        3:  182:						match_count++;
        -:  183:					}
        -:  184:				}
       40:  185:				match_len++;
       40:  186:				if (match_count == limit)
    #####:  187:					break;
        -:  188:			} else {
        -:  189:				// not found, return to root
      119:  190:				itt = ti->root;
      119:  191:				match_len = 0;
        -:  192:			}
        -:  193:		}
        -:  194:	}
        -:  195:
        8:  196:	if (has_case_sensitive)
        3:  197:		trie_sort(ret, match_count);
        8:  198:	return match_count;
        -:  199:}
