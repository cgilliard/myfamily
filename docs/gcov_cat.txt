        -:    0:Source:backtrace.c
        -:    0:Graph:backtrace.gcno
        -:    0:Data:backtrace.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/backtrace.h>
        -:   16:#include <base/colors.h>
        -:   17:#include <base/fam_err.h>
        -:   18:#include <base/resources.h>
        -:   19:#include <base/types.h>
        -:   20:#include <dlfcn.h>
        -:   21:#include <execinfo.h>
        -:   22:#include <inttypes.h>
        -:   23:#include <stdio.h>
        -:   24:#include <stdlib.h>
        -:   25:#include <string.h>
        -:   26:
       10:   27:int get_file_line(char *bin, char *addr, char *line_num, char *fn_name, int max_len) {
        -:   28:	pid_t process_id;
       10:   29:	int cmd_max_len = strlen(bin) + strlen(addr) + 100;
       10:   30:	char cmd[cmd_max_len];
        -:   31:
        -:   32:	// hack to get line numbers on linux in criterion
       10:   33:	if (!strcmp(bin, "boxfort-worker")) {
        5:   34:		strcpy(bin, "./bin/test");
        -:   35:	}
        -:   36:
        -:   37:#ifdef __APPLE__
        -:   38:	snprintf(cmd, cmd_max_len, "atos --fullPath -o %s %s", bin, addr);
        -:   39:#else  // LINUX/WIN for now
       10:   40:	snprintf(cmd, cmd_max_len, "addr2line -f -e %s %s", bin, addr);
        -:   41:#endif // OS Specific code
        -:   42:
       10:   43:	char buffer[MAX_ENTRY_SIZE] = {0};
        -:   44:	FILE *fp;
        -:   45:
       10:   46:	if ((fp = popen(cmd, "r")) == NULL) {
    #####:   47:		return -1;
        -:   48:	}
        -:   49:
       10:   50:	int counter = 0;
       30:   51:	while (fgets(buffer, MAX_ENTRY_SIZE, fp) != NULL) {
        -:   52:#ifdef __APPLE__
        -:   53:		bool found_first_paren = false;
        -:   54:		bool found_second_paren = false;
        -:   55:		u64 len = strlen(buffer);
        -:   56:		int line_num_itt = 0;
        -:   57:		for (int i = 0; i < len; i++) {
        -:   58:			if (!found_first_paren && buffer[i] == '(') {
        -:   59:				found_first_paren = true;
        -:   60:			} else if (!found_second_paren && buffer[i] == '(') {
        -:   61:				found_second_paren = true;
        -:   62:			} else if (found_second_paren && found_first_paren) {
        -:   63:				if (buffer[i] == ')') {
        -:   64:					break;
        -:   65:				}
        -:   66:				line_num[line_num_itt] = buffer[i];
        -:   67:				line_num_itt++;
        -:   68:				if (line_num_itt == max_len)
        -:   69:					break;
        -:   70:			}
        -:   71:		}
        -:   72:		line_num[line_num_itt] = 0;
        -:   73:#else  // Linux
       20:   74:		if (counter == 0) {
       10:   75:			int len = strlen(buffer);
      167:   76:			for (int i = 0; i < len; i++) {
      157:   77:				if (buffer[i] == '\n')
       10:   78:					buffer[i] = 0;
        -:   79:			}
       10:   80:			buffer[max_len - 1] = 0;
       10:   81:			strcpy(fn_name, buffer);
       10:   82:		} else if (counter == 1) {
       10:   83:			int len = strlen(buffer);
       64:   84:			for (int i = 0; i < len; i++) {
       54:   85:				if (buffer[i] == '\n')
       10:   86:					buffer[i] = 0;
        -:   87:			}
       10:   88:			buffer[max_len - 1] = 0;
       10:   89:			strcpy(line_num, buffer);
        -:   90:		}
       20:   91:		counter++;
        -:   92:#endif // OS specific code
        -:   93:	}
        -:   94:
       10:   95:	if (pclose(fp)) {
    #####:   96:		return -1;
        -:   97:	}
        -:   98:
       10:   99:	return 0;
        -:  100:}
        -:  101:
       10:  102:void backtrace_set_entry_values(BacktraceEntry *ptr, const char *name, const char *bin_name,
        -:  103:								const char *address, const char *file_path) {
       10:  104:	u64 offset = 0;
       10:  105:	ptr->start_bin = MAX_ENTRY_SIZE;
       10:  106:	ptr->start_addr = MAX_ENTRY_SIZE;
       10:  107:	ptr->start_file_path = MAX_ENTRY_SIZE;
    10260:  108:	for (int i = 0; i <= MAX_ENTRY_SIZE; i++)
    10250:  109:		ptr->data[i] = 0;
        -:  110:
       10:  111:	strncpy((char *)(ptr->data + offset), name, MAX_ENTRY_SIZE - offset);
       10:  112:	offset += strlen(name) + 1;
        -:  113:
       10:  114:	if (offset >= MAX_ENTRY_SIZE)
    #####:  115:		return;
        -:  116:
       10:  117:	ptr->start_bin = offset;
       10:  118:	strncpy((char *)(ptr->data + offset), bin_name, MAX_ENTRY_SIZE - offset);
       10:  119:	offset += strlen(bin_name) + 1;
        -:  120:
       10:  121:	if (offset >= MAX_ENTRY_SIZE)
    #####:  122:		return;
        -:  123:
       10:  124:	ptr->start_addr = offset;
       10:  125:	strncpy((char *)(ptr->data + offset), address, MAX_ENTRY_SIZE - offset);
       10:  126:	offset += strlen(address) + 1;
        -:  127:
       10:  128:	if (offset >= MAX_ENTRY_SIZE)
    #####:  129:		return;
        -:  130:
       10:  131:	ptr->start_file_path = offset;
       10:  132:	strncpy((char *)(ptr->data + offset), file_path, MAX_ENTRY_SIZE - offset);
       10:  133:	offset += strlen(address) + 1;
        -:  134:}
        -:  135:
       10:  136:bool backtrace_add_entry(Backtrace *ptr, const char *name, const char *bin_name,
        -:  137:						 const char *address, const char *file_path) {
       10:  138:	u64 count = ptr->cur_entries;
       10:  139:	if (count >= MAX_ENTRIES)
    #####:  140:		return false;
       10:  141:	backtrace_set_entry_values(&ptr->entries[count], name, bin_name, address, file_path);
       10:  142:	ptr->cur_entries++;
       10:  143:	return true;
        -:  144:}
        -:  145:
        1:  146:int backtrace_generate(Backtrace *ptr) {
        1:  147:	if (ptr == NULL) {
    #####:  148:		SetErr(IllegalArgument);
    #####:  149:		return -1;
        -:  150:	}
        -:  151:
        1:  152:	ptr->cur_entries = 0;
        -:  153:	void *array[MAX_ENTRIES];
        1:  154:	int size = backtrace(array, MAX_ENTRIES);
        1:  155:	if (size < 0) {
    #####:  156:		SetErr(BackTraceErr);
    #####:  157:		return -1;
        -:  158:	}
        1:  159:	char **strings = backtrace_symbols(array, size);
        -:  160:
        1:  161:	if (strings == NULL)
    #####:  162:		size = 0;
        -:  163:
       11:  164:	for (int i = 0; i < size; i++) {
        -:  165:#ifdef __APPLE__
        -:  166:		char address[30];
        -:  167:		Dl_info info;
        -:  168:		dladdr(array[i], &info);
        -:  169:		u64 addr = 0x0000000100000000 + info.dli_saddr - info.dli_fbase;
        -:  170:		snprintf(address, 30, "0x%" PRIx64 "", addr);
        -:  171:		char function_name[strlen(info.dli_sname) + 1];
        -:  172:		char bin_name[strlen(info.dli_fname) + 1];
        -:  173:		strcpy(function_name, info.dli_sname);
        -:  174:		strcpy(bin_name, info.dli_fname);
        -:  175:
        -:  176:		char file_path[513];
        -:  177:		char fn_name[513];
        -:  178:		strcpy(file_path, "");
        -:  179:		get_file_line(bin_name, address, file_path, fn_name, 512);
        -:  180:		if (!strcmp(file_path, "")) {
        -:  181:			strcpy(file_path, "Unknown");
        -:  182:		}
        -:  183:		if (!backtrace_add_entry(ptr, function_name, bin_name, address, file_path))
        -:  184:			break;
        -:  185:#else  // LINUX
        -:  186:		char buffer[2050];
        -:  187:		char address[101];
       10:  188:		int len = strlen(strings[i]);
       10:  189:		bool in_bin_name = true;
       10:  190:		bool in_address = false;
       10:  191:		int buffer_itt = 0;
       10:  192:		int address_itt = 0;
      568:  193:		for (int j = 0; j < len; j++) {
      558:  194:			if (in_bin_name && strings[i][j] == '(') {
       10:  195:				in_bin_name = false;
       10:  196:				in_address = true;
      548:  197:			} else if (in_address && strings[i][j] == ')') {
       10:  198:				in_address = false;
       10:  199:				if (address_itt < 100) {
       10:  200:					address[address_itt] = 0;
        -:  201:				}
      538:  202:			} else if (in_bin_name) {
      249:  203:				if (buffer_itt < 2048) {
      249:  204:					buffer[buffer_itt] = strings[i][j];
      249:  205:					buffer_itt++;
    #####:  206:				} else if (buffer_itt == 2048) {
    #####:  207:					buffer[buffer_itt] = 0;
    #####:  208:					buffer_itt = 0;
        -:  209:				}
      289:  210:			} else if (in_address) {
      119:  211:				if (address_itt < 100) {
      119:  212:					address[address_itt] = strings[i][j];
      119:  213:					address_itt++;
        -:  214:				} else {
    #####:  215:					address[100] = 0;
        -:  216:				}
        -:  217:			}
        -:  218:		}
        -:  219:
       10:  220:		if (address_itt < 100) {
       10:  221:			address[address_itt] = 0;
        -:  222:		}
       10:  223:		if (buffer_itt < 2048) {
       10:  224:			buffer[buffer_itt] = 0;
        -:  225:		}
        -:  226:
        -:  227:		char file_path[513];
        -:  228:		char fn_name[513];
       10:  229:		strcpy(file_path, "");
       10:  230:		get_file_line(buffer, address, file_path, fn_name, 512);
       10:  231:		if (!strcmp(file_path, "")) {
    #####:  232:			strcpy(file_path, "Unknown");
        -:  233:		}
       10:  234:		if (!strcmp(file_path, "") || file_path[0] == 63 || file_path[0] == -107) {
        9:  235:			strcpy(file_path, "Unknown");
        -:  236:		}
       10:  237:		if (fn_name[0] == 63 || fn_name[0] == -107)
        2:  238:			strcpy(fn_name, "Unknown");
       10:  239:		if (!backtrace_add_entry(ptr, fn_name, buffer, address, file_path))
    #####:  240:			break;
        -:  241:#endif // OS Specific code
        -:  242:	}
        -:  243:
        1:  244:	if (strings)
        1:  245:		free(strings);
        -:  246:
        1:  247:	return 0;
        -:  248:}
        -:  249:
        1:  250:void backtrace_print(const Backtrace *ptr) {
        1:  251:	const BacktraceEntry *rows = ptr->entries;
        1:  252:	u64 count = ptr->cur_entries;
        1:  253:	if (count == 0) {
    #####:  254:		printf("-------------Backtrace not available-------------\n");
        -:  255:	} else {
        1:  256:		printf("Backtrace:\n");
       11:  257:		for (int i = 0; i < count; i++) {
       10:  258:			const u8 *function_name = rows[i].data;
        -:  259:			const u8 *bin_name;
       10:  260:			if (rows[i].start_bin < MAX_ENTRY_SIZE)
       10:  261:				bin_name = rows[i].data + rows[i].start_bin;
        -:  262:			else
    #####:  263:				bin_name = (u8 *)"";
        -:  264:			const u8 *address;
       10:  265:			if (rows[i].start_bin < MAX_ENTRY_SIZE)
       10:  266:				address = rows[i].data + rows[i].start_addr;
        -:  267:			else
    #####:  268:				address = (u8 *)"";
        -:  269:
        -:  270:			const u8 *file_path;
       10:  271:			if (rows[i].start_file_path < MAX_ENTRY_SIZE)
       10:  272:				file_path = rows[i].data + rows[i].start_file_path;
        -:  273:			else
    #####:  274:				file_path = (u8 *)"";
       10:  275:			printf("#%i:\n\
        -:  276:        [%sfn=%s%s%s%s']\n\
        -:  277:        [%sbinary=%s'%s%s%s'] [%saddress=%s%s]\n\
        -:  278:        [%scode=%s'%s%s%s']\n",
        -:  279:				   i, DIMMED, RESET, GREEN, function_name, RESET, DIMMED, RESET, MAGENTA, bin_name,
        -:  280:				   RESET, DIMMED, RESET, address, DIMMED, RESET, CYAN, file_path, RESET);
        -:  281:		}
        -:  282:	}
        1:  283:}
        -:    0:Source:bitflags.c
        -:    0:Graph:bitflags.gcno
        -:    0:Data:bitflags.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/bitflags.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <string.h>
        -:   18:
    66333:   19:int bitflags_set(BitFlags *ptr, u32 index, bool value) {
    66333:   20:	u32 offset = index >> 3;
        -:   21:
        -:   22:	// Out of range check
    66333:   23:	if (offset >= ptr->capacity) {
        1:   24:		fam_err = IndexOutOfBounds;
        1:   25:		return -1;
        -:   26:	}
        -:   27:
        -:   28:	// Calculate mask directly
    66332:   29:	u32 mask = 1 << (index & 0x7);
        -:   30:
    66332:   31:	if (value) {
    26258:   32:		ptr->flags[offset] |= mask;
        -:   33:	} else {
    40074:   34:		ptr->flags[offset] &= ~mask;
        -:   35:	}
        -:   36:
    66332:   37:	return 0;
        -:   38:}
        -:   39:
118954932:   40:bool bitflags_check(const BitFlags *ptr, u32 index) {
118954932:   41:	u32 offset = index >> 3;
        -:   42:
        -:   43:	// Out of range check
118954932:   44:	if (offset >= ptr->capacity) {
        1:   45:		return false;
        -:   46:	}
        -:   47:
        -:   48:	// Calculate mask directly
118954931:   49:	u32 mask = 1 << (index & 0x7);
        -:   50:
118954931:   51:	return ptr->flags[offset] & mask;
        -:   52:}
        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:#ifdef __linux__
        -:   19:#define getenv(x) secure_getenv(x)
        -:   20:#endif // __linux__
        -:   21:
      156:   22:char *get_dimmed() {
      156:   23:	if (getenv("NO_COLOR") != NULL) {
        1:   24:		return "";
        -:   25:	} else {
      155:   26:		return "\x1b[2m";
        -:   27:	}
        -:   28:}
        -:   29:
        2:   30:char *get_red() {
        2:   31:	if (getenv("NO_COLOR") != NULL) {
        1:   32:		return "";
        -:   33:	} else {
        1:   34:		return "\x1b[31m";
        -:   35:	}
        -:   36:}
        -:   37:
      109:   38:char *get_bright_red() {
      109:   39:	if (getenv("NO_COLOR") != NULL) {
        1:   40:		return "";
        -:   41:	} else {
      108:   42:		return "\x1b[91m";
        -:   43:	}
        -:   44:}
        -:   45:
       48:   46:char *get_green() {
       48:   47:	if (getenv("NO_COLOR") != NULL) {
        1:   48:		return "";
        -:   49:	} else {
       47:   50:		return "\x1b[32m";
        -:   51:	}
        -:   52:}
        -:   53:
       49:   54:char *get_yellow() {
       49:   55:	if (getenv("NO_COLOR") != NULL) {
        1:   56:		return "";
        -:   57:	} else {
       48:   58:		return "\x1b[33m";
        -:   59:	}
        -:   60:}
        -:   61:
       62:   62:char *get_cyan() {
       62:   63:	if (getenv("NO_COLOR") != NULL) {
        1:   64:		return "";
        -:   65:	} else {
       61:   66:		return "\x1b[36m";
        -:   67:	}
        -:   68:}
        -:   69:
       12:   70:char *get_magenta() {
       12:   71:	if (getenv("NO_COLOR") != NULL) {
        1:   72:		return "";
        -:   73:	} else {
       11:   74:		return "\x1b[35m";
        -:   75:	}
        -:   76:}
        -:   77:
        2:   78:char *get_blue() {
        2:   79:	if (getenv("NO_COLOR") != NULL) {
        1:   80:		return "";
        -:   81:	} else {
        1:   82:		return "\x1b[34m";
        -:   83:	}
        -:   84:}
        -:   85:
      426:   86:char *get_reset() {
      426:   87:	if (getenv("NO_COLOR") != NULL) {
        1:   88:		return "";
        -:   89:	} else {
      425:   90:		return "\x1b[0m";
        -:   91:	}
        -:   92:}
        -:    0:Source:fam_alloc.c
        -:    0:Graph:fam_alloc.gcno
        -:    0:Data:fam_alloc.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <base/resources.h>
        -:   19:#include <base/slabs.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdio.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:SlabAllocator *global_allocator = NULL;
        -:   25:_Thread_local SlabAllocator *thread_local_slab_allocator = NULL;
        -:   26:
        -:   27:#define MAX_FAM_GUARDS 255
        -:   28:
        -:   29:pthread_mutex_t global_allocator_lock;
        -:   30:
        -:   31:typedef struct FamGuardEntry {
        -:   32:	bool send;
        -:   33:} FamGuardEntry;
        -:   34:
        -:   35:_Thread_local static FamGuardEntry fam_guard_entries[MAX_FAM_GUARDS];
        -:   36:_Thread_local static u8 fam_guard_sp = 0;
        -:   37:_Thread_local static bool fam_guard_is_init = false;
        -:   38:
       57:   39:SlabAllocator *initialize_default_slab_allocator(bool global) {
       57:   40:	SlabAllocatorNc *sa = mymalloc(sizeof(SlabAllocator));
       57:   41:	if (sa == NULL)
    #####:   42:		return NULL;
       57:   43:	SlabAllocatorConfig sac;
        -:   44:	// default slab allocator zeroed = false
       57:   45:	if (slab_allocator_config_build(&sac, false, global)) {
    #####:   46:		myfree(sa);
    #####:   47:		return NULL;
        -:   48:	}
       57:   49:	u32 max_slabs = MAX_SLABS;
     7353:   50:	for (i32 i = 0; i < 128; i++) {
     7296:   51:		SlabType st = {.slab_size = (i + 3) * 8,
        -:   52:					   .slabs_per_resize = 100,
        -:   53:					   .initial_chunks = 0,
        -:   54:					   .max_slabs = max_slabs};
     7296:   55:		if (slab_allocator_config_add_type(&sac, &st)) {
    #####:   56:			myfree(sa);
    #####:   57:			return NULL;
        -:   58:		}
        -:   59:	}
     7353:   60:	for (i32 i = 0; i < 128; i++) {
     7296:   61:		SlabType st = {.slab_size = (128 + 3) * 8 + (i + 1) * 1024,
        -:   62:					   .slabs_per_resize = 100,
        -:   63:					   .initial_chunks = 0,
        -:   64:					   .max_slabs = max_slabs};
     7296:   65:		if (slab_allocator_config_add_type(&sac, &st)) {
    #####:   66:			myfree(sa);
    #####:   67:			return NULL;
        -:   68:		}
        -:   69:	}
       57:   70:	if (slab_allocator_build(sa, &sac)) {
    #####:   71:		myfree(sa);
    #####:   72:		return NULL;
        -:   73:	}
        -:   74:
       57:   75:	return sa;
        -:   76:}
        -:   77:
    60947:   78:void init_fam_guards() {
    60947:   79:	if (!fam_guard_is_init) {
       29:   80:		fam_guard_is_init = true;
       29:   81:		fam_guard_entries[0].send = false;
       29:   82:		if (thread_local_slab_allocator == NULL)
       29:   83:			thread_local_slab_allocator = initialize_default_slab_allocator(false);
       29:   84:		if (thread_local_slab_allocator == NULL)
    #####:   85:			panic("Could not initialize the default slab allocator");
       29:   86:		if (global_allocator == NULL)
       28:   87:			global_allocator = initialize_default_slab_allocator(true);
       29:   88:		if (global_allocator == NULL)
    #####:   89:			panic("Could not initialize the global slab allocator");
       29:   90:		if (pthread_mutex_init(&global_allocator_lock, NULL))
    #####:   91:			panic("Could not init pthread_mutex");
        -:   92:	}
    60947:   93:}
        -:   94:
    24582:   95:void send_guard_cleanup(SendStateGuardNc *ptr) {
    24582:   96:	fam_guard_sp--;
    24582:   97:}
        -:   98:
    18183:   99:int fam_alloc(FatPtr *ptr, u64 size) {
    18183:  100:	init_fam_guards();
    18183:  101:	bool send = fam_guard_entries[fam_guard_sp].send;
        -:  102:
        -:  103:	SlabAllocatorNc *sa;
        -:  104:
    18183:  105:	if (send)
       58:  106:		sa = global_allocator;
        -:  107:	else {
    18125:  108:		sa = thread_local_slab_allocator;
        -:  109:	}
        -:  110:
        -:  111:	int ret;
    18183:  112:	if (send)
       58:  113:		pthread_mutex_lock(&global_allocator_lock);
    18183:  114:	ret = slab_allocator_allocate(sa, size, ptr);
    18183:  115:	if (send)
       58:  116:		pthread_mutex_unlock(&global_allocator_lock);
        -:  117:
    18183:  118:	if (ret) { // try malloc
        3:  119:		ret = fat_ptr_mallocate(ptr, size);
        -:  120:	}
        -:  121:
    18183:  122:	return ret;
        -:  123:}
        3:  124:int fam_realloc(FatPtr *ptr, u64 size) {
        3:  125:	if ($is_pin(*ptr)) {
        1:  126:		fam_err = IllegalState;
        1:  127:		return -1;
        -:  128:	}
        2:  129:	init_fam_guards();
        2:  130:	int ret = 0;
        2:  131:	bool send = fam_guard_entries[fam_guard_sp].send;
        -:  132:
        2:  133:	FatPtr tmp = null;
        -:  134:
        2:  135:	if (send)
    #####:  136:		pthread_mutex_lock(&global_allocator_lock);
        -:  137:
        2:  138:	ret = fam_alloc(&tmp, size);
        2:  139:	if (ret || nil(tmp)) {
    #####:  140:		fam_err = AllocErr;
    #####:  141:		ret = -1;
        -:  142:	} else {
        2:  143:		u64 len = $size(*ptr);
        2:  144:		u64 nlen = $size(tmp);
        2:  145:		if (nlen < len) {
        1:  146:			len = nlen;
        -:  147:		}
        -:  148:
        2:  149:		memcpy(fat_ptr_data(&tmp), fat_ptr_data(ptr), len);
        -:  150:
        2:  151:		fam_free(ptr);
        2:  152:		*ptr = tmp;
        -:  153:	}
        2:  154:	if (send)
    #####:  155:		pthread_mutex_unlock(&global_allocator_lock);
        -:  156:
        2:  157:	return ret;
        -:  158:}
    18181:  159:void fam_free(FatPtr *ptr) {
    18181:  160:	if ($flag(*ptr, FAT_PTR_FLAG_MALLOC)) {
        1:  161:		fat_ptr_malloc_free(ptr);
        -:  162:	} else {
    18180:  163:		init_fam_guards();
        -:  164:
    18180:  165:		bool global = $flag(*ptr, FAT_PTR_FLAG_GLOBAL);
        -:  166:
        -:  167:		SlabAllocatorNc *sa;
        -:  168:
    18180:  169:		if (global)
       58:  170:			sa = global_allocator;
        -:  171:		else
    18122:  172:			sa = thread_local_slab_allocator;
        -:  173:
    18180:  174:		if (global)
       58:  175:			pthread_mutex_lock(&global_allocator_lock);
    18180:  176:		slab_allocator_free(sa, ptr);
    18180:  177:		if (global)
       58:  178:			pthread_mutex_unlock(&global_allocator_lock);
        -:  179:	}
    18181:  180:}
    24582:  181:void fam_alloc_increment_state(bool send) {
    24582:  182:	init_fam_guards();
    24582:  183:	fam_guard_sp++;
    24582:  184:	fam_guard_entries[fam_guard_sp].send = send;
    24582:  185:}
        -:  186:
        -:  187:#ifdef TEST
       69:  188:void fam_alloc_cleanup() {
       69:  189:	if (fam_guard_is_init) {
       28:  190:		slab_allocator_cleanup(thread_local_slab_allocator);
       28:  191:		pthread_mutex_lock(&global_allocator_lock);
       28:  192:		slab_allocator_cleanup(global_allocator);
       28:  193:		pthread_mutex_unlock(&global_allocator_lock);
       28:  194:		myfree(global_allocator);
       28:  195:		myfree(thread_local_slab_allocator);
        -:  196:	}
       69:  197:}
        -:  198:
       69:  199:u64 fam_alloc_count_tl_slab_allocator() {
       69:  200:	if (!fam_guard_is_init)
       41:  201:		return 0;
       28:  202:	return slab_allocator_cur_slabs_allocated(thread_local_slab_allocator);
        -:  203:}
       69:  204:u64 fam_alloc_count_global_allocator() {
       69:  205:	if (!fam_guard_is_init)
       41:  206:		return 0;
       28:  207:	pthread_mutex_lock(&global_allocator_lock);
       28:  208:	u64 ret = slab_allocator_cur_slabs_allocated(global_allocator);
       28:  209:	pthread_mutex_unlock(&global_allocator_lock);
        -:  210:
       28:  211:	return ret;
        -:  212:}
        -:  213:#endif // TEST
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        -:   20:#ifdef __linux__
        -:   21:#define getenv(x) secure_getenv(x)
        -:   22:#endif // __linux__
        -:   23:
        -:   24:char *FamErrText[FamErrCount] = {"NoErrors",
        -:   25:								 "IllegalArgument",
        -:   26:								 "AllocError",
        -:   27:								 "InitErr",
        -:   28:								 "AlreadyInitialized",
        -:   29:								 "IndexOutOfBounds",
        -:   30:								 "IO",
        -:   31:								 "FileNotFound",
        -:   32:								 "NotADirectory",
        -:   33:								 "IllegalState",
        -:   34:								 "TooBig",
        -:   35:								 "ResourceNotAvailable",
        -:   36:								 "Permission",
        -:   37:								 "BackTraceErr",
        -:   38:								 "ExpectedTypeMismatch"};
        -:   39:
        -:   40:int fam_err = NoErrors;
        -:   41:_Thread_local char fam_err_last[ERR_LEN] = {""};
        -:   42:_Thread_local Backtrace thread_local_bt__;
        -:   43:
    #####:   44:const char *get_err() {
    #####:   45:	strcpy(fam_err_last, FamErrText[fam_err]);
    #####:   46:	return fam_err_last;
        -:   47:}
        -:   48:
       15:   49:void print_err(const char *text) {
       15:   50:	fprintf(stderr, "%s: %s\n", FamErrText[fam_err], text);
       15:   51:	if (getenv("CBACKTRACE") != NULL) {
    #####:   52:		backtrace_print(&thread_local_bt__);
        -:   53:	} else {
       15:   54:		printf("Backtrace currently disabled set env variable CBACKTRACE to enable\n");
        -:   55:	}
       15:   56:}
        -:   57:
       93:   58:void do_backtrace_generate(Backtrace *bt) {
       93:   59:	if (getenv("CBACKTRACE") != NULL) {
    #####:   60:		backtrace_generate(bt);
        -:   61:	}
       93:   62:}
        -:    0:Source:misc.c
        -:    0:Graph:misc.gcno
        -:    0:Data:misc.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/macro_utils.h>
        -:   18:#include <base/misc.h>
        -:   19:#include <base/resources.h>
        -:   20:#include <base/types.h>
        -:   21:#include <ctype.h>
        -:   22:#include <dirent.h>
        -:   23:#include <limits.h>
        -:   24:#include <stdarg.h>
        -:   25:#include <stdio.h>
        -:   26:#include <stdlib.h>
        -:   27:#include <string.h>
        -:   28:#include <sys/stat.h>
        -:   29:#include <unistd.h>
        -:   30:
        -:   31:bool __is_debug_misc_ferror = false;
        -:   32:bool __is_debug_misc_fwrite = false;
        -:   33:bool __is_debug_misc_stat = false;
        -:   34:bool __is_debug_misc_remove_dir = false;
        -:   35:bool __is_debug_misc_unlink = false;
        -:   36:bool __is_debug_misc_no_exit = false;
        -:   37:bool __is_debug_misc_preserve = false;
        -:   38:
    #####:   39:char *myfgets(char *str, int n, MYFILE *stream) {
    #####:   40:	return fgets(str, n, (FILE *)stream);
        -:   41:}
        -:   42:
       17:   43:u64 myfread(void *buffer, u64 size, u64 count, MYFILE *stream) {
       17:   44:	return fread(buffer, size, count, (FILE *)stream);
        -:   45:}
        -:   46:
       18:   47:u64 myfwrite(const void *buffer, u64 size, u64 count, MYFILE *stream) {
       18:   48:	return fwrite(buffer, size, count, (FILE *)stream);
        -:   49:}
        -:   50:
       11:   51:int myfeof(MYFILE *stream) {
       11:   52:	return feof((FILE *)stream);
        -:   53:}
        -:   54:
        6:   55:int myferror(MYFILE *stream) {
        6:   56:	return ferror((FILE *)stream);
        -:   57:}
        -:   58:
       11:   59:long myftell(MYFILE *stream) {
       11:   60:	return ftell((FILE *)stream);
        -:   61:}
        -:   62:
       15:   63:int myfseek(MYFILE *stream, long pos, int type) {
       15:   64:	return fseek((FILE *)stream, pos, type);
        -:   65:}
        -:   66:
       11:   67:u64 mystrlen(const char *s) {
       11:   68:	int ret = 0;
        -:   69:	loop {
      231:   70:		if (s[ret] == 0)
       11:   71:			return ret;
      220:   72:		ret++;
        -:   73:	}
        -:   74:}
        -:   75:
        6:   76:int myfprintf(MYFILE *fptr, const char *str, ...) {
        -:   77:	va_list args;
        6:   78:	va_start(args, str);
        6:   79:	int ret = vfprintf((FILE *)fptr, str, args);
        6:   80:	va_end(args);
        6:   81:	return ret;
        -:   82:}
        -:   83:
      137:   84:const char *rstrstr(const char *s1, const char *s2) {
      137:   85:	size_t s1len = strlen(s1);
      137:   86:	size_t s2len = strlen(s2);
        -:   87:	const char *s;
        -:   88:
      137:   89:	if (s2len > s1len)
        1:   90:		return NULL;
      753:   91:	for (s = s1 + s1len - s2len; s >= s1; --s)
      750:   92:		if (strncmp(s, s2, s2len) == 0)
      133:   93:			return s;
        3:   94:	return NULL;
        -:   95:}
        -:   96:
       12:   97:u64 read_all(void *buffer, u64 size, u64 count, MYFILE *stream) {
       12:   98:	size_t total_read = 0;
       12:   99:	size_t bytes_to_read = size * count;
        -:  100:	size_t bytes_read;
        -:  101:
       17:  102:	while (total_read < bytes_to_read || __is_debug_misc_ferror) {
       12:  103:		bytes_read = myfread((char *)buffer + total_read, 1, bytes_to_read - total_read, stream);
       12:  104:		if (bytes_read == 0 || __is_debug_misc_ferror) {
        -:  105:			// Check for EOF or error
        2:  106:			if (myferror(stream) || __is_debug_misc_ferror) {
        1:  107:				SetErr(IO);
        1:  108:				break; // Error occurred
        -:  109:			}
        -:  110:		}
       11:  111:		total_read += bytes_read;
       11:  112:		if (myfeof(stream))
        6:  113:			break;
        -:  114:	}
        -:  115:
       12:  116:	return total_read;
        -:  117:}
        -:  118:
        6:  119:int copy_file(const Path *dst_path, const Path *src_path) {
        6:  120:	if (dst_path == NULL || src_path == NULL) {
        1:  121:		SetErr(IllegalArgument);
        1:  122:		return -1;
        -:  123:	}
        -:  124:	MYFILE *source_file, *dest_file;
        -:  125:	size_t bytes;
        -:  126:
        -:  127:	// Open the source file in binary read mode
        5:  128:	source_file = myfopen(src_path, "rb");
        5:  129:	if (source_file == NULL) {
        1:  130:		SetErr(IllegalArgument);
        1:  131:		return -1;
        -:  132:	}
        -:  133:
        -:  134:	// Determine the file size
        4:  135:	myfseek(source_file, 0, SEEK_END);
        4:  136:	long file_size = myftell(source_file);
        4:  137:	myfseek(source_file, 0, SEEK_SET);
        4:  138:	char buffer[file_size];
        -:  139:
        -:  140:	// Open the destination file in binary write mode
        4:  141:	dest_file = myfopen(dst_path, "wb");
        4:  142:	if (dest_file == NULL) {
        1:  143:		SetErr(FileNotFound);
        1:  144:		myfclose(source_file);
        1:  145:		return -1;
        -:  146:	}
        -:  147:
        -:  148:	// Copy the file content
        5:  149:	while ((bytes = myfread(buffer, 1, file_size, source_file)) > 0) {
        3:  150:		if (myferror(source_file) || myfwrite(buffer, 1, bytes, dest_file) != bytes ||
        -:  151:			__is_debug_misc_fwrite) {
        1:  152:			SetErr(IO);
        1:  153:			myfclose(source_file);
        1:  154:			myfclose(dest_file);
        1:  155:			return -1;
        -:  156:		}
        -:  157:	}
        -:  158:
        -:  159:	// Close both files
        2:  160:	myfclose(source_file);
        2:  161:	myfclose(dest_file);
        -:  162:
        2:  163:	return 0;
        -:  164:}
        -:  165:
        -:  166:// Function to recursively remove a directory and its contents
      173:  167:int remove_directory(const Path *p, bool preserve_dir) {
      173:  168:	const char *path = path_to_string(p);
        -:  169:	struct dirent *entry;
      173:  170:	DIR *dir = opendir(path);
        -:  171:
      173:  172:	if (dir == NULL) {
       72:  173:		return -1;
        -:  174:	}
        -:  175:
      339:  176:	while ((entry = readdir(dir)) != NULL) {
        -:  177:		char full_path[PATH_MAX];
        -:  178:
        -:  179:		// Skip the special entries "." and ".."
      243:  180:		if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
      194:  181:			continue;
        -:  182:		}
        -:  183:
        -:  184:		// Construct the full path to the file/directory
       49:  185:		snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        -:  186:
        -:  187:		struct stat statbuf;
       49:  188:		if (stat(full_path, &statbuf) == -1 || __is_debug_misc_stat) {
        1:  189:			SetErr(IO);
        1:  190:			closedir(dir);
        5:  191:			return -1;
        -:  192:		}
        -:  193:
       48:  194:		if (S_ISDIR(statbuf.st_mode)) {
        -:  195:			// It's a directory, recurse into it
       24:  196:			Path full_path_p;
       24:  197:			path_for(&full_path_p, full_path);
       24:  198:			if (remove_directory(&full_path_p, false) == -1 || __is_debug_misc_remove_dir) {
        3:  199:				closedir(dir);
        3:  200:				return -1;
        -:  201:			}
        -:  202:		} else {
        -:  203:			// It's a file, unlink (delete) it
       24:  204:			if (unlink(full_path) == -1 || __is_debug_misc_unlink) {
        1:  205:				SetErr(IO);
        1:  206:				closedir(dir);
        1:  207:				return -1;
        -:  208:			}
        -:  209:		}
        -:  210:	}
        -:  211:
       96:  212:	closedir(dir);
        -:  213:
        -:  214:	// Now the directory is empty, so we can remove it
       96:  215:	if (!preserve_dir) {
       95:  216:		if (rmdir(path) == -1 || __is_debug_misc_preserve) {
        1:  217:			SetErr(IO);
        1:  218:			return -1;
        -:  219:		}
        -:  220:	}
        -:  221:
       95:  222:	return 0;
        -:  223:}
        -:  224:
        5:  225:void exit_error(char *format, ...) {
        -:  226:	va_list va_args;
        5:  227:	va_start(va_args, format);
        5:  228:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
        5:  229:	vfprintf(stderr, format, va_args);
        5:  230:	fprintf(stderr, "\n");
        5:  231:	va_end(va_args);
       5*:  232:	EXIT_ERR_IF_NO_DEBUG(-1);
        5:  233:}
        -:  234:
       23:  235:void print_error(char *format, ...) {
        -:  236:	va_list va_args;
       23:  237:	va_start(va_args, format);
       23:  238:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
       23:  239:	vfprintf(stderr, format, va_args);
       23:  240:	fprintf(stderr, "\n");
       23:  241:	va_end(va_args);
       23:  242:}
        -:  243:
        -:  244:// Helper function to trim leading and trailing whitespace
        7:  245:char *trim_whitespace(char *str) {
        -:  246:	// Trim leading whitespace
       15:  247:	while (isspace((unsigned char)*str))
        8:  248:		str++;
        -:  249:	// Trim trailing whitespace
        7:  250:	char *end = str + strlen(str) - 1;
       15:  251:	while (end > str && isspace((unsigned char)*end))
        8:  252:		end--;
        7:  253:	*(end + 1) = '\0'; // Null-terminate the trimmed string
        7:  254:	return str;		   // Return the trimmed string
        -:  255:}
        -:    0:Source:panic.c
        -:    0:Graph:panic.gcno
        -:    0:Data:panic.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/backtrace.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <setjmp.h>
        -:   18:#include <signal.h>
        -:   19:#include <stdarg.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:void exit(int value);
        -:   25:
        -:   26:#define MAX_PANIC_MSG 1024
        -:   27:
        -:   28:_Thread_local jmp_buf return_jmp;
        -:   29:_Thread_local bool jmp_return_set = false;
        -:   30:_Thread_local char panic_buf[MAX_PANIC_MSG];
        -:   31:
    #####:   32:void panic(const char *fmt, ...) {
        -:   33:	va_list args;
        -:   34:
    #####:   35:	fprintf(stderr, "application panicked: ");
    #####:   36:	va_start(args, fmt);
    #####:   37:	vfprintf(stderr, fmt, args);
    #####:   38:	vsnprintf(panic_buf, MAX_PANIC_MSG, fmt, args);
    #####:   39:	va_end(args);
    #####:   40:	fprintf(stderr, "\n");
        -:   41:
        -:   42:	Backtrace bt;
    #####:   43:	backtrace_generate(&bt);
    #####:   44:	backtrace_print(&bt);
        -:   45:
        -:   46:	// If jump return has not been set, we resort to an exit with an error
        -:   47:	// status.
    #####:   48:	if (!jmp_return_set)
    #####:   49:		exit(-1);
    #####:   50:	longjmp(return_jmp, THREAD_PANIC);
        -:   51:}
        -:   52:
    #####:   53:void signal_handler(int signal) {
        -:   54:	// Handle the signal and call the _on_panic function
    #####:   55:	panic("Caught signal: %d", signal);
    #####:   56:}
        -:   57:
    #####:   58:void set_on_panic(panic_handler_t on_panic) {
        -:   59:	struct sigaction sa;
    #####:   60:	memset(&sa, 0, sizeof(sa));
    #####:   61:	sa.sa_handler = signal_handler;
        -:   62:	// Catching only error signals
    #####:   63:	sigaction(SIGSEGV, &sa, NULL); // Segmentation fault
    #####:   64:	sigaction(SIGABRT, &sa, NULL); // Abort signal
    #####:   65:	sigaction(SIGTRAP, &sa, NULL); // Signal trap
    #####:   66:	sigaction(SIGILL, &sa, NULL);  // Illegal instruction
    #####:   67:	sigaction(SIGFPE, &sa, NULL);  // Arithmetic error
    #####:   68:	sigaction(SIGBUS, &sa, NULL);  // Bus error
        -:   69:
    #####:   70:	jmp_return_set = true;
    #####:   71:	int value = setjmp(return_jmp);
    #####:   72:	if (value)
    #####:   73:		on_panic(panic_buf);
    #####:   74:}
        -:    0:Source:path.c
        -:    0:Graph:path.gcno
        -:    0:Data:path.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/misc.h>
        -:   17:#include <base/path.h>
        -:   18:#include <base/resources.h>
        -:   19:#include <limits.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:#include <sys/stat.h>
        -:   24:#include <unistd.h>
        -:   25:
        -:   26:bool __is_debug_path_homedir_null = false;
        -:   27:
      257:   28:void path_cleanup(PathImpl *ptr) {
      257:   29:	if (ptr->ptr) {
      254:   30:		myfree(ptr->ptr);
      254:   31:		ptr->ptr = NULL;
        -:   32:	}
      257:   33:}
        -:   34:
      265:   35:int path_for(Path *p, const char *path) {
      265:   36:	if (p == NULL) {
        1:   37:		SetErr(IllegalArgument);
        1:   38:		return -1;
        -:   39:	}
      264:   40:	if (path == NULL) {
        1:   41:		SetErr(IllegalArgument);
        1:   42:		p->ptr = NULL;
        1:   43:		return -1;
        -:   44:	}
      263:   45:	int len = strlen(path);
      263:   46:	if (len == 0) {
        1:   47:		SetErr(IllegalArgument);
        1:   48:		p->ptr = NULL;
        1:   49:		return -1;
        -:   50:	}
      262:   51:	p->ptr = mymalloc(len + 1);
      262:   52:	if (!p->ptr)
        2:   53:		return -1;
      260:   54:	p->len = len;
      260:   55:	strcpy(p->ptr, path);
      260:   56:	return 0;
        -:   57:}
        -:   58:
       33:   59:int path_replace_home(Path *p) {
       33:   60:	const char *home_dir = getenv("HOME");
       33:   61:	if (home_dir == NULL || __is_debug_path_homedir_null) {
        1:   62:		SetErr(IllegalArgument);
        1:   63:		return -1;
        -:   64:	}
       32:   65:	if (((char *)(p->ptr))[0] == '~') {
        4:   66:		int nlen = strlen(home_dir) + strlen(PATH_SEPARATOR) + strlen(p->ptr);
        4:   67:		if (nlen >= PATH_MAX) {
        1:   68:			SetErr(TooBig);
        2:   69:			return -1;
        -:   70:		}
        3:   71:		if (nlen >= p->len) {
        3:   72:			void *nptr = myrealloc(p->ptr, nlen + 1);
        3:   73:			if (nptr == NULL)
        1:   74:				return -1;
        2:   75:			p->ptr = nptr;
        2:   76:			p->len = nlen;
        -:   77:		}
        -:   78:		char buf[PATH_MAX + 1];
        2:   79:		if (strlen(p->ptr) > 1 && ((char *)(p->ptr))[1] == PATH_SEPARATOR_CHAR)
        1:   80:			snprintf(buf, PATH_MAX, "%s%s", home_dir, (char *)(p->ptr + 1));
        -:   81:		else
        1:   82:			snprintf(buf, PATH_MAX, "%s%s%s", home_dir, PATH_SEPARATOR, (char *)(p->ptr + 1));
        2:   83:		strcpy(p->ptr, buf);
        -:   84:	}
       30:   85:	return 0;
        -:   86:}
        -:   87:
        8:   88:u64 path_file_size(Path *p) {
        8:   89:	MYFILE *fp = myfopen(p, "r");
        8:   90:	if (!fp) {
        1:   91:		SetErr(IO);
        1:   92:		return 0;
        -:   93:	}
        7:   94:	myfseek(fp, 0L, SEEK_END);
        7:   95:	u64 ret = myftell(fp);
        7:   96:	myfclose(fp);
        7:   97:	return ret;
        -:   98:}
        -:   99:
       33:  100:int path_canonicalize(Path *p) {
        -:  101:	char buf[PATH_MAX];
        -:  102:	int nlen;
       33:  103:	if (path_replace_home(p) || realpath(p->ptr, buf) == NULL || (nlen = strlen(buf)) == 0) {
       19:  104:		SetErr(IllegalArgument);
       19:  105:		return -1;
        -:  106:	}
       14:  107:	SetErr(NoErrors);
       14:  108:	if (nlen >= p->len) {
       12:  109:		void *nptr = myrealloc(p->ptr, nlen + 1);
       12:  110:		if (nptr == NULL)
        1:  111:			return -1;
       11:  112:		p->ptr = nptr;
       11:  113:		p->len = nlen;
        -:  114:	}
       13:  115:	strcpy(p->ptr, buf);
       13:  116:	return 0;
        -:  117:}
      181:  118:int path_push(Path *p, const char *next) {
      181:  119:	if (p == NULL) {
        1:  120:		SetErr(IllegalArgument);
        1:  121:		return -1;
        -:  122:	}
      180:  123:	if (next == NULL) {
        1:  124:		SetErr(IllegalArgument);
        1:  125:		return -1;
        -:  126:	}
      179:  127:	int slen = strlen(p->ptr);
      179:  128:	if (slen <= 0 || strlen(next) == 0) {
        1:  129:		SetErr(IllegalState);
        1:  130:		return -1;
        -:  131:	}
      178:  132:	bool need_sep = false;
      178:  133:	if (((char *)p->ptr)[slen - 1] != PATH_SEPARATOR_CHAR) {
      178:  134:		need_sep = true;
        -:  135:	}
        -:  136:
      178:  137:	int nlen = slen + strlen(next);
      178:  138:	if (need_sep)
      178:  139:		nlen += strlen(PATH_SEPARATOR);
        -:  140:
      178:  141:	if (nlen >= p->len) {
      174:  142:		void *nptr = myrealloc(p->ptr, nlen + 1);
      174:  143:		if (nptr == NULL)
        1:  144:			return -1;
      173:  145:		p->ptr = nptr;
      173:  146:		p->len = nlen;
        -:  147:	}
        -:  148:
      177:  149:	if (need_sep)
      177:  150:		strcat(p->ptr, PATH_SEPARATOR);
      177:  151:	strcat(p->ptr, next);
      177:  152:	return 0;
        -:  153:}
       48:  154:int path_pop(Path *p) {
       48:  155:	const char *res = rstrstr(p->ptr, PATH_SEPARATOR);
       48:  156:	if (res) {
       47:  157:		int index = res - (char *)p->ptr;
       47:  158:		((char *)(p->ptr))[index] = 0;
        -:  159:	} else {
        1:  160:		((char *)(p->ptr))[0] = '.';
        1:  161:		((char *)(p->ptr))[1] = 0;
        -:  162:	}
       48:  163:	return 0;
        -:  164:}
        -:  165:
      300:  166:char *path_to_string(const Path *p) {
      300:  167:	return p->ptr;
        -:  168:}
        -:  169:
       88:  170:const char *path_file_name(const Path *p) {
       88:  171:	const char *ret = rstrstr(p->ptr, PATH_SEPARATOR);
       88:  172:	if (ret != NULL && strlen(ret) > 0)
       86:  173:		return ret + 1;
        -:  174:
        2:  175:	return ret;
        -:  176:}
        -:  177:
       30:  178:bool path_exists(const Path *p) {
       30:  179:	if (p->ptr == NULL || p->len == 0) {
        1:  180:		SetErr(IllegalArgument);
        1:  181:		return false;
        -:  182:	}
       29:  183:	return access(p->ptr, F_OK) == 0;
        -:  184:}
       11:  185:bool path_is_dir(const Path *p) {
       11:  186:	if (p->ptr == NULL || p->len == 0) {
        1:  187:		SetErr(IllegalArgument);
        1:  188:		return false;
        -:  189:	}
        -:  190:	struct stat s;
       10:  191:	if (stat(p->ptr, &s) == 0) {
        7:  192:		return s.st_mode & S_IFDIR;
        -:  193:	}
        3:  194:	return false;
        -:  195:}
        -:  196:
      153:  197:bool path_mkdir(Path *p, u64 mode, bool parent) {
      153:  198:	if (p->ptr == NULL || p->len == 0) {
        1:  199:		SetErr(IllegalArgument);
        1:  200:		return false;
        -:  201:	}
        -:  202:
        -:  203:	struct stat s;
        -:  204:
        -:  205:	// Check if the path exists
      152:  206:	if (stat(p->ptr, &s) == 0) {
        -:  207:		// If the path exists and it's a directory, return success
        8:  208:		if (s.st_mode & S_IFDIR) {
        7:  209:			return true;
        -:  210:		} else {
        -:  211:			// Path exists but it's not a directory
        1:  212:			SetErr(NotADirectory);
        1:  213:			return false;
        -:  214:		}
        -:  215:	}
        -:  216:
        -:  217:	// If parent is false, attempt to create only the target directory
      144:  218:	if (!parent) {
      126:  219:		if (mkdir(p->ptr, mode) != 0) {
       28:  220:			return false;
        -:  221:		}
       98:  222:		return true;
        -:  223:	}
        -:  224:
        -:  225:	// Create the directory structure (parent is true)
       18:  226:	Path temp_path;
       18:  227:	if (path_copy(&temp_path, p) != 0) {
        1:  228:		return false;
        -:  229:	}
        -:  230:
       17:  231:	int i = 0;
        -:  232:	char path_bufs[20][PATH_MAX];
       43:  233:	while (i < 20 && path_file_name(&temp_path) != NULL) {
       41:  234:		if (path_mkdir(&temp_path, mode, false)) {
       15:  235:			bool ret = true;
       21:  236:			for (int j = i - 1; ret && j >= 0; j--) {
        6:  237:				path_push(&temp_path, path_bufs[j]);
        6:  238:				ret = path_mkdir(&temp_path, mode, false);
        -:  239:			}
       15:  240:			return true;
        -:  241:		}
       26:  242:		const char *dir_part = path_file_name(&temp_path);
       26:  243:		path_pop(&temp_path);
       26:  244:		strcpy(path_bufs[i], dir_part);
       26:  245:		i++;
        -:  246:	}
        2:  247:	return false;
        -:  248:}
        -:  249:
       49:  250:int path_copy(Path *dst, const Path *src) {
       49:  251:	return path_for(dst, path_to_string(src));
        -:  252:}
        -:  253:
        2:  254:int path_file_stem(const Path *p, char *buf, u64 limit) {
        -:  255:	// Copy the file name into the buffer, ensuring proper null termination
        2:  256:	strncpy(buf, path_file_name(p), limit - 1);
        2:  257:	buf[limit - 1] = '\0'; // Manually ensure null-termination
        -:  258:
        2:  259:	u64 buflen = strlen(buf); // Compute length once
       12:  260:	for (u64 i = buflen - 1; i > 0; i--) {
       11:  261:		if (buf[i] == '.') {
        1:  262:			buf[i] = '\0'; // Null-terminate at the dot
        1:  263:			break;
        -:  264:		}
        -:  265:	}
        2:  266:	return 0;
        -:  267:}
        -:    0:Source:resources.c
        -:    0:Graph:resources.gcno
        -:    0:Data:resources.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/resources.h>
        -:   17:#include <base/types.h>
        -:   18:#include <stdio.h>
        -:   19:#include <stdlib.h>
        -:   20:
        -:   21:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   22:#ifdef TEST
        -:   23:bool __is_debug_malloc = false;
        -:   24:bool __is_debug_realloc = false;
        -:   25:u64 __is_debug_malloc_counter_ = UINT64_MAX;
        -:   26:u64 __is_debug_realloc_counter_ = UINT64_MAX;
        -:   27:#endif // TEST
        -:   28:
     2764:   29:void *mymalloc(u64 size) {
        -:   30:#ifdef TEST
     2764:   31:	if (__is_debug_malloc || __is_debug_malloc_counter_ == 0) {
       24:   32:		__is_debug_malloc_counter_ = UINT64_MAX;
       24:   33:		return NULL;
        -:   34:	}
     2740:   35:	__is_debug_malloc_counter_--;
        -:   36:#endif // TEST
        -:   37:	void *ret;
     2740:   38:	ret = malloc(size);
        -:   39:
     2740:   40:	if (ret) {
     2740:   41:		THREAD_LOCAL_RESOURCE_STATS.malloc_sum += 1;
        -:   42:	} else
    #####:   43:		SetErr(AllocErr);
     2740:   44:	return ret;
        -:   45:}
    15047:   46:void *myrealloc(void *ptr, u64 size) {
        -:   47:#ifdef TEST
    15047:   48:	if (__is_debug_realloc || __is_debug_realloc_counter_ == 0) {
        7:   49:		__is_debug_realloc_counter_ = UINT64_MAX;
        7:   50:		return NULL;
        -:   51:	}
    15040:   52:	__is_debug_realloc_counter_--;
        -:   53:#endif // TEST
        -:   54:	void *ret;
    15040:   55:	ret = realloc(ptr, size);
        -:   56:
    15040:   57:	if (ret) {
    15040:   58:		THREAD_LOCAL_RESOURCE_STATS.realloc_sum += 1;
        -:   59:	} else
    #####:   60:		SetErr(AllocErr);
    15040:   61:	return ret;
        -:   62:}
     2678:   63:void myfree(void *ptr) {
     2678:   64:	THREAD_LOCAL_RESOURCE_STATS.free_sum += 1;
     2678:   65:	free(ptr);
     2678:   66:}
       53:   67:MYFILE *myfopen(const Path *path, const char *mode) {
       53:   68:	const char *path_str = path_to_string(path);
       53:   69:	FILE *ret = fopen(path_str, mode);
       53:   70:	if (ret) {
       48:   71:		THREAD_LOCAL_RESOURCE_STATS.fopen_sum += 1;
        -:   72:	}
       53:   73:	return (MYFILE *)ret;
        -:   74:}
        -:   75:
    #####:   76:void *mymalloc_no_stat(u64 size) {
    #####:   77:	return malloc(size);
        -:   78:}
        -:   79:
       48:   80:void myfclose(MYFILE *ptr) {
       48:   81:	THREAD_LOCAL_RESOURCE_STATS.fclose_sum += 1;
       48:   82:	fclose((FILE *)ptr);
       48:   83:}
      143:   84:u64 mymalloc_sum() {
      143:   85:	return THREAD_LOCAL_RESOURCE_STATS.malloc_sum;
        -:   86:}
        2:   87:u64 myrealloc_sum() {
        2:   88:	return THREAD_LOCAL_RESOURCE_STATS.realloc_sum;
        -:   89:}
      143:   90:u64 myfree_sum() {
      143:   91:	return THREAD_LOCAL_RESOURCE_STATS.free_sum;
        -:   92:}
      213:   93:u64 myfopen_sum() {
      213:   94:	return THREAD_LOCAL_RESOURCE_STATS.fopen_sum;
        -:   95:}
      213:   96:u64 myfclose_sum() {
      213:   97:	return THREAD_LOCAL_RESOURCE_STATS.fclose_sum;
        -:   98:}
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/bitflags.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/macro_utils.h>
        -:   18:#include <base/panic.h>
        -:   19:#include <base/resources.h>
        -:   20:#include <base/slabs.h>
        -:   21:#include <stdio.h>
        -:   22:#include <stdlib.h>
        -:   23:#include <string.h>
        -:   24:
        -:   25:// 2^24 -1 (3 bytes)
        -:   26:#define MAX_SLAB_SIZE (16777216 - 1)
        -:   27:
        -:   28:#define SIZE_OVERHEAD (2 * sizeof(u32) + sizeof(u64))
        -:   29:#define SIZE_WITH_OVERHEAD(size) (size + SIZE_OVERHEAD)
        -:   30:
        -:   31:typedef struct FatPtr32Impl {
        -:   32:	u32 id;
        -:   33:	u8 size_flags[4];
        -:   34:	void *data;
        -:   35:} FatPtr32Impl;
        -:   36:
    24161:   37:bool fat_ptr_is_nil(const FatPtr *ptr) {
    24161:   38:	bool ret = false;
    24161:   39:	if (ptr && ptr->data) {
    22095:   40:		FatPtr32Impl *fptr = ptr->data;
    22095:   41:		BitFlags bf = {.flags = (fptr->size_flags + 3), .capacity = 1};
    22095:   42:		ret = bitflags_check(&bf, FAT_PTR_FLAG_NIL);
        -:   43:	}
    24161:   44:	return ret;
        -:   45:}
        -:   46:
        3:   47:int fat_ptr_mallocate(FatPtr *ptr, u64 size) {
        3:   48:	void *tmp = mymalloc(SIZE_WITH_OVERHEAD(size));
        3:   49:	if (tmp == NULL)
        2:   50:		return -1;
        -:   51:
        1:   52:	FatPtr32Impl *fptr32 = tmp;
        1:   53:	ptr->data = tmp;
        1:   54:	fptr32->id = 0; // id doesn't matter with mallocate
        1:   55:	memcpy(&fptr32->size_flags, &size, 3);
        1:   56:	fptr32->size_flags[3] = 0;
        1:   57:	BitFlags bf = {.flags = (fptr32->size_flags + 3), .capacity = 1};
        1:   58:	bitflags_set(&bf, FAT_PTR_FLAG_MALLOC, true);
        1:   59:	fptr32->data = tmp + SIZE_OVERHEAD;
        -:   60:
        1:   61:	return 0;
        -:   62:}
        -:   63:
        1:   64:void fat_ptr_malloc_free(FatPtr *ptr) {
        1:   65:	if (ptr->data) {
        1:   66:		myfree(ptr->data);
        1:   67:		ptr->data = NULL;
        -:   68:	}
        1:   69:}
        -:   70:
  2019512:   71:u32 fat_ptr_size(const FatPtr *ptr) {
  2019512:   72:	u32 ret = 0;
  2019512:   73:	if (ptr != NULL) {
  2019512:   74:		FatPtr32Impl *tmp = ptr->data;
  2019512:   75:		if (!nil(*ptr))
  2019510:   76:			memcpy(&ret, tmp->size_flags, 3);
        -:   77:	} else
    #####:   78:		SetErr(IllegalArgument);
  2019512:   79:	return ret;
        -:   80:}
        -:   81:
 67609864:   82:void *fat_ptr_data(const FatPtr *ptr) {
 67609864:   83:	void *ret = NULL;
 67609864:   84:	if (ptr != NULL) {
 67609864:   85:		FatPtr32Impl *tmp = ptr->data;
 67609864:   86:		if (!nil(*ptr) && ptr->data != NULL)
 67609862:   87:			ret = ((FatPtr32Impl *)ptr->data)->data;
        -:   88:	} else
    #####:   89:		SetErr(IllegalArgument);
 67609864:   90:	return ret;
        -:   91:}
        -:   92:
        1:   93:void fat_ptr_flag_set(const FatPtr *ptr, u8 flag, bool value) {
        1:   94:	if (ptr && ptr->data) {
        1:   95:		FatPtr32Impl *fptr = ptr->data;
        1:   96:		BitFlags bf = {.flags = (fptr->size_flags + 3), .capacity = 1};
        1:   97:		bitflags_set(&bf, flag, value);
        -:   98:	}
        1:   99:}
        -:  100:
 70695848:  101:bool fat_ptr_flag_get(const FatPtr *ptr, u8 flag) {
 70695848:  102:	bool ret = false;
 70695848:  103:	if (ptr && ptr->data) {
 70695848:  104:		FatPtr32Impl *fptr = ptr->data;
 70695848:  105:		BitFlags bf = {.flags = (fptr->size_flags + 3), .capacity = 1};
 70695848:  106:		ret = bitflags_check(&bf, flag);
        -:  107:	}
 70695848:  108:	return ret;
        -:  109:}
        -:  110:
       67:  111:void slab_allocator_config_cleanup(SlabAllocatorConfigNc *sc) {
       67:  112:	if (sc->slab_types) {
       67:  113:		myfree(sc->slab_types);
       67:  114:		sc->slab_types = NULL;
        -:  115:	}
       67:  116:}
        -:  117:
       70:  118:int slab_allocator_config_build(SlabAllocatorConfig *sc, bool zeroed, bool global) {
       70:  119:	sc->zeroed = zeroed;
       70:  120:	sc->global = global;
       70:  121:	sc->slab_types_count = 0;
       70:  122:	sc->slab_types = NULL;
       70:  123:	return 0;
        -:  124:}
        -:  125:
    14603:  126:int slab_allocator_config_add_type(SlabAllocatorConfig *sc, const SlabType *st) {
    14603:  127:	if (sc->slab_types) {
    14536:  128:		void *tmp = myrealloc(sc->slab_types, sizeof(SlabType) * (1 + sc->slab_types_count));
    14536:  129:		if (tmp == NULL)
    #####:  130:			return -1;
    14536:  131:		sc->slab_types = tmp;
        -:  132:	} else {
       67:  133:		sc->slab_types = mymalloc(sizeof(SlabType));
       67:  134:		if (sc->slab_types == NULL)
    #####:  135:			return -1;
        -:  136:	}
        -:  137:
    14603:  138:	sc->slab_types[sc->slab_types_count] = *st;
    14603:  139:	sc->slab_types_count++;
        -:  140:
    14603:  141:	return 0;
        -:  142:}
        -:  143:
        -:  144:// Slab Allocator
        -:  145:
        -:  146:typedef struct SlabData {
        -:  147:	SlabType type; // This slab data's type information (slab_size, slabs_per_resize, initial, max)
        -:  148:	void **data;   // Pointers to each chunk
        -:  149:	void *free_list;	// The free list pointers
        -:  150:	u32 cur_chunks;		// number of chunks currently allocated
        -:  151:	u32 cur_slabs;		// number of slabs currently allocated
        -:  152:	u32 free_list_head; // the free list head
        -:  153:} SlabData;
        -:  154:
        -:  155:typedef struct SlabAllocatorImpl {
        -:  156:	u64 sd_size;	  // size of the SlabData array
        -:  157:	SlabData *sd_arr; // slab data array one for each SlabType
        -:  158:	bool zeroed;	  // config zeroed
        -:  159:	bool global;	  // whether this slab allocator is considered 'global'
        -:  160:} SlabAllocatorImpl;
        -:  161:
       65:  162:void slab_allocator_cleanup(SlabAllocatorNc *ptr) {
       65:  163:	if (ptr->impl) {
       65:  164:		SlabAllocatorImpl *impl = ptr->impl;
       65:  165:		if (impl->sd_arr) {
    14410:  166:			for (u64 i = 0; i < impl->sd_size; i++) {
    14576:  167:				for (int j = 0; j < impl->sd_arr[i].cur_chunks; j++) {
      231:  168:					if (impl->sd_arr[i].data[j]) {
      231:  169:						myfree(impl->sd_arr[i].data[j]);
      231:  170:						impl->sd_arr[i].data[j] = NULL;
        -:  171:					}
        -:  172:				}
    14345:  173:				if (impl->sd_arr[i].data) {
       95:  174:					myfree(impl->sd_arr[i].data);
       95:  175:					impl->sd_arr[i].data = NULL;
        -:  176:				}
    14345:  177:				if (impl->sd_arr[i].free_list) {
       95:  178:					myfree(impl->sd_arr[i].free_list);
       95:  179:					impl->sd_arr[i].free_list = NULL;
        -:  180:				}
        -:  181:			}
        -:  182:
       65:  183:			myfree(impl->sd_arr);
       65:  184:			impl->sd_arr = NULL;
        -:  185:		}
       65:  186:		myfree(ptr->impl);
       65:  187:		ptr->impl = NULL;
        -:  188:	}
       65:  189:}
        -:  190:
    14825:  191:int slab_allocator_init_free_list(SlabData *sd, u32 slabs, u32 offset) {
        -:  192:	//  initialize the values of the free list.
  1036845:  193:	for (u32 i = 0; i < slabs; i++) {
  1022020:  194:		if (i == (slabs - 1)) {
      232:  195:			((u32 *)(sd->free_list))[i + offset] = UINT32_MAX;
        -:  196:		} else {
  1021788:  197:			((u32 *)(sd->free_list))[i + offset] = offset + i + 1;
        -:  198:		}
        -:  199:	}
        -:  200:
    14825:  201:	return 0;
        -:  202:}
        -:  203:
    14601:  204:int slab_allocator_init_slab_data(SlabAllocatorImpl *impl, SlabType *st, u64 index) {
    14601:  205:	impl->sd_arr[index].type = *st;
    14601:  206:	impl->sd_arr[index].type.slab_size += SIZE_OVERHEAD;
    14601:  207:	impl->sd_arr[index].cur_slabs = 0;
    14601:  208:	impl->sd_arr[index].cur_chunks = st->initial_chunks;
    14601:  209:	if (st->initial_chunks > 0) {
        8:  210:		impl->sd_arr[index].free_list_head = 0;
        8:  211:		impl->sd_arr[index].data = mymalloc(sizeof(void *) * st->initial_chunks);
        8:  212:		if (impl->sd_arr[index].data == NULL)
    #####:  213:			return -1;
        -:  214:	} else {
    14593:  215:		impl->sd_arr[index].data = NULL;
    14593:  216:		impl->sd_arr[index].free_list_head = UINT32_MAX;
        -:  217:	}
        -:  218:
    14601:  219:	if (st->initial_chunks > 0) {
       16:  220:		impl->sd_arr[index].free_list =
        8:  221:			mymalloc(sizeof(u32) * (u64)st->slabs_per_resize * (u64)st->initial_chunks);
        8:  222:		if (impl->sd_arr[index].free_list == NULL) {
    #####:  223:			myfree(impl->sd_arr[index].data);
    #####:  224:			return -1;
        -:  225:		}
        -:  226:	} else {
    14593:  227:		impl->sd_arr[index].free_list = NULL;
        -:  228:	}
        -:  229:
    14609:  230:	for (u64 i = 0; i < st->initial_chunks; i++) {
       16:  231:		impl->sd_arr[index].data[i] =
        8:  232:			mymalloc((u64)impl->sd_arr[index].type.slab_size * (u64)st->slabs_per_resize);
        -:  233:
        8:  234:		if (impl->sd_arr[index].data[i] == NULL) {
    #####:  235:			for (u64 j = 0; j < i; j++) {
    #####:  236:				myfree(impl->sd_arr[index].data[j]);
        -:  237:			}
    #####:  238:			myfree(impl->sd_arr[index].data);
    #####:  239:			return -1;
        -:  240:		}
        -:  241:	}
        -:  242:
    14601:  243:	slab_allocator_init_free_list(&impl->sd_arr[index], st->initial_chunks * st->slabs_per_resize,
        -:  244:								  0);
    14601:  245:	return 0;
        -:  246:}
        -:  247:
    58368:  248:int compare_sd(const void *a, const void *b) {
    58368:  249:	const SlabData *sda = a;
    58368:  250:	const SlabData *sdb = b;
    58368:  251:	if (sda->type.slab_size < sdb->type.slab_size)
    58368:  252:		return -1;
    #####:  253:	else if (sda->type.slab_size > sdb->type.slab_size)
    #####:  254:		return 1;
    #####:  255:	return 0;
        -:  256:}
        -:  257:
       66:  258:int slab_allocator_sort_slab_data(SlabAllocator *ptr) {
       66:  259:	SlabAllocatorImpl *impl = ptr->impl;
       66:  260:	qsort(impl->sd_arr, impl->sd_size, sizeof(SlabData), compare_sd);
       66:  261:	u32 last_slab_size = 0;
    14666:  262:	for (u64 i = 0; i < impl->sd_size; i++) {
    14601:  263:		if (impl->sd_arr[i].type.slab_size >= MAX_SLAB_SIZE) { // 2^24 - 1
    #####:  264:			SetErr(TooBig);
    #####:  265:			return -1;
        -:  266:		}
        -:  267:
    14601:  268:		if (last_slab_size >= impl->sd_arr[i].type.slab_size) {
    #####:  269:			SetErr(IllegalArgument);
    #####:  270:			return -1;
        -:  271:		}
        -:  272:		// for alignment, must be divisible by 8
    14601:  273:		if (impl->sd_arr[i].type.slab_size % 8 != 0) {
    #####:  274:			SetErr(IllegalArgument);
    #####:  275:			return -1;
        -:  276:		}
        -:  277:		// can't have higher max slabs than initial
    14601:  278:		if (impl->sd_arr[i].type.slabs_per_resize * impl->sd_arr[i].type.initial_chunks >
    14601:  279:			impl->sd_arr[i].type.max_slabs) {
    #####:  280:			SetErr(IllegalArgument);
    #####:  281:			return -1;
        -:  282:		}
        -:  283:		// max slabs
    14601:  284:		if (impl->sd_arr[i].type.max_slabs > MAX_SLABS) {
    #####:  285:			SetErr(IllegalArgument);
    #####:  286:			return -1;
        -:  287:		}
        -:  288:
        -:  289:		// max slabs must be dividisble by slabs_per_resize
    14601:  290:		if (impl->sd_arr[i].type.max_slabs % impl->sd_arr[i].type.slabs_per_resize) {
        1:  291:			SetErr(IllegalArgument);
        1:  292:			return -1;
        -:  293:		}
    14600:  294:		last_slab_size = impl->sd_arr[i].type.slab_size;
        -:  295:	}
       65:  296:	return 0;
        -:  297:}
        -:  298:
       66:  299:int slab_allocator_build(SlabAllocator *ptr, const SlabAllocatorConfig *config) {
       66:  300:	ptr->impl = mymalloc(sizeof(SlabAllocatorImpl));
       66:  301:	if (ptr->impl == NULL)
    #####:  302:		return -1;
       66:  303:	SlabAllocatorImpl *impl = ptr->impl;
       66:  304:	impl->zeroed = config->zeroed;
       66:  305:	impl->global = config->global;
       66:  306:	impl->sd_size = config->slab_types_count;
       66:  307:	impl->sd_arr = mymalloc(sizeof(SlabData) * impl->sd_size);
       66:  308:	if (impl->sd_arr == NULL) {
    #####:  309:		myfree(ptr->impl);
    #####:  310:		return -1;
        -:  311:	}
        -:  312:
    14667:  313:	for (u64 i = 0; i < config->slab_types_count; i++) {
    14601:  314:		if (slab_allocator_init_slab_data(impl, &config->slab_types[i], i)) {
        -:  315:			// cleanup previously allocated slabs
    #####:  316:			impl->sd_size = i;
    #####:  317:			slab_allocator_cleanup(ptr);
    #####:  318:			return -1;
        -:  319:		}
        -:  320:	}
       66:  321:	int ret = slab_allocator_sort_slab_data(ptr);
       66:  322:	if (ret)
        1:  323:		slab_allocator_cleanup(ptr);
       66:  324:	return ret;
        -:  325:}
        -:  326:
  2036596:  327:int slab_allocator_index(const SlabAllocator *ptr, u32 size) {
  2036596:  328:	SlabAllocatorImpl *impl = ptr->impl;
  2036596:  329:	int ret = -1;
  2036596:  330:	if (impl->sd_size > 0) {
        -:  331:
  2036596:  332:		int left = 0;
  2036596:  333:		int right = impl->sd_size - 1;
        -:  334:
  3272659:  335:		while (left <= right) {
  2258530:  336:			int mid = left + (right - left) / 2;
  2258530:  337:			u32 slab_size = impl->sd_arr[mid].type.slab_size;
  2258530:  338:			if (slab_size == size) {
  1022467:  339:				ret = mid;
  1022467:  340:				break;
  1236063:  341:			} else if (slab_size > size)
  1199463:  342:				right = mid - 1;
        -:  343:			else
    36600:  344:				left = mid + 1;
        -:  345:		}
        -:  346:
  2036596:  347:		if (ret == -1 && right + 1 <= impl->sd_size - 1) {
  1014128:  348:			ret = right + 1;
        -:  349:		}
        -:  350:	}
        -:  351:
  2036596:  352:	return ret;
        -:  353:}
        -:  354:
        -:  355:int slab_data_try_resize(SlabData *sd, FatPtr *fptr, bool zeroed, bool global);
        -:  356:
  1018525:  357:int slab_data_allocate(SlabData *sd, FatPtr *fptr, bool zeroed, bool global) {
  1018525:  358:	u32 id = sd->free_list_head;
  1018525:  359:	if (id == UINT32_MAX) {
      230:  360:		return slab_data_try_resize(sd, fptr, zeroed, global);
        -:  361:	}
        -:  362:
  1018295:  363:	sd->free_list_head = ((u32 *)sd->free_list)[id];
        -:  364:
        -:  365:	// set to MAX-1 as a marker that this is allocated
        -:  366:	// if any freed without this value, it's an error
  1018295:  367:	((u32 *)sd->free_list)[id] = (UINT32_MAX - 1);
        -:  368:
  1018295:  369:	u32 len = sd->type.slab_size;
  1018295:  370:	u64 slab_data_index = id / sd->type.slabs_per_resize;
  1018295:  371:	u64 offset_mod = id % sd->type.slabs_per_resize;
        -:  372:
  1018295:  373:	fptr->data = sd->data[slab_data_index] + offset_mod * sd->type.slab_size;
        -:  374:
  1018295:  375:	FatPtr32Impl *fptr32 = fptr->data;
  1018295:  376:	fptr32->id = id;
  1018295:  377:	u64 data_len = len - SIZE_OVERHEAD;
  1018295:  378:	memcpy(&fptr32->size_flags, &data_len, 3);
  1018295:  379:	fptr32->size_flags[3] = 0;
  1018295:  380:	fptr32->data = fptr->data + SIZE_OVERHEAD;
  1018295:  381:	u8 *data_ptr = fptr32->data;
  1018295:  382:	if (global) {
       58:  383:		BitFlags bf = {.flags = (fptr32->size_flags + 3), .capacity = 1};
       58:  384:		bitflags_set(&bf, FAT_PTR_FLAG_GLOBAL, true);
        -:  385:	}
        -:  386:
  1018295:  387:	sd->cur_slabs += 1;
  1018295:  388:	if (zeroed) {
      500:  389:		for (u64 i = 0; i < data_len; i++) {
      480:  390:			data_ptr[i] = 0;
        -:  391:		}
        -:  392:	}
        -:  393:
  1018295:  394:	return 0;
        -:  395:}
        -:  396:
      230:  397:int slab_data_try_resize(SlabData *sd, FatPtr *fptr, bool zeroed, bool global) {
      230:  398:	int ret = -1;
      230:  399:	if (sd->cur_slabs < sd->type.max_slabs) {
        -:  400:		// we can try to resize
        -:  401:		// first try to reallocate the free list
      226:  402:		void *nfree_list = NULL;
      226:  403:		u64 factor = sizeof(u32);
      226:  404:		if (sd->free_list) {
        -:  405:			nfree_list =
      136:  406:				myrealloc(sd->free_list, (1 + sd->cur_chunks) * sd->type.slabs_per_resize * factor);
        -:  407:		} else {
        -:  408:
       90:  409:			nfree_list = mymalloc((u64)sd->type.slabs_per_resize * (u64)factor);
        -:  410:		}
      226:  411:		if (nfree_list != NULL) {
        -:  412:
      224:  413:			sd->free_list = nfree_list;
        -:  414:
        -:  415:			// now try to allocate more slab chunks
        -:  416:			void *ndata;
      224:  417:			if (sd->data == NULL) {
       88:  418:				ndata = mymalloc(sizeof(void *));
        -:  419:			} else {
      136:  420:				ndata = myrealloc(sd->data, sizeof(void *) * (1 + sd->cur_chunks));
        -:  421:			}
      224:  422:			if (ndata != NULL) {
        -:  423:
      224:  424:				sd->data = ndata;
      224:  425:				sd->data[sd->cur_chunks] = mymalloc(sd->type.slab_size * sd->type.slabs_per_resize);
      224:  426:				if (sd->data[sd->cur_chunks] != NULL) {
        -:  427:
        -:  428:					// data was successfully allocated, make updates.
      224:  429:					slab_allocator_init_free_list(sd, sd->type.slabs_per_resize, sd->cur_slabs);
      224:  430:					sd->free_list_head = sd->cur_slabs;
      224:  431:					sd->cur_chunks += 1;
        -:  432:
      224:  433:					return slab_data_allocate(sd, fptr, zeroed, global);
        -:  434:				}
        -:  435:			}
        -:  436:		}
        -:  437:	}
        6:  438:	return ret;
        -:  439:}
        -:  440:
  1018294:  441:void slab_data_free(SlabData *sd, const FatPtr *fptr, bool zeroed) {
  1018294:  442:	u64 data_len = 0;
        -:  443:	u8 *data_ptr;
  1018294:  444:	if (sd->free_list == NULL) {
    #####:  445:		panic("free list not initialized (wrong slab allocator?)");
        -:  446:	}
        -:  447:
  1018294:  448:	FatPtr32Impl *fptr32 = fptr->data;
  1018294:  449:	memcpy(&data_len, &fptr32->size_flags, 3);
  1018294:  450:	data_ptr = fptr32->data;
  1018294:  451:	u32 id = fptr32->id;
  1018294:  452:	if (((u32 *)sd->free_list)[id] != (UINT32_MAX - 1)) {
    #####:  453:		panic("Potential double free. Id = %llu.\n", id);
        -:  454:	}
  1018294:  455:	((u32 *)sd->free_list)[id] = sd->free_list_head;
  1018294:  456:	sd->free_list_head = id;
  1018294:  457:	if (sd->cur_slabs == 0)
    #####:  458:		panic("Potential double free. Id = %llu. Freeing slabs when none are allocated.\n", id);
  1018294:  459:	sd->cur_slabs -= 1;
        -:  460:
  1018294:  461:	if (zeroed) {
      500:  462:		for (u64 i = 0; i < data_len; i++) {
      480:  463:			data_ptr[i] = 0;
        -:  464:		}
        -:  465:	}
  1018294:  466:}
        -:  467:
  1018302:  468:int slab_allocator_allocate(SlabAllocator *ptr, u32 size, FatPtr *fptr) {
  1018302:  469:	if (ptr == NULL || size == 0) {
    #####:  470:		SetErr(IllegalArgument);
    #####:  471:		return -1;
        -:  472:	}
        -:  473:
  1018302:  474:	SlabAllocatorImpl *impl = ((SlabAllocatorImpl *)ptr->impl);
  1018302:  475:	bool zeroed = impl->zeroed;
  1018302:  476:	bool global = impl->global;
  1018302:  477:	u32 needed = size + SIZE_OVERHEAD;
  1018302:  478:	int index = slab_allocator_index(ptr, needed);
  1018302:  479:	int ret = -1;
  1018302:  480:	if (index >= 0) {
  1018301:  481:		SlabData *sd = &impl->sd_arr[index];
  1018301:  482:		ret = slab_data_allocate(sd, fptr, zeroed, global);
        -:  483:	} else
        1:  484:		SetErr(ResourceNotAvailable);
  1018302:  485:	return ret;
        -:  486:}
  1018294:  487:void slab_allocator_free(SlabAllocator *ptr, FatPtr *fptr) {
  1018294:  488:	if (fptr == NULL || nil(*fptr)) {
    #####:  489:		panic("Freeing a slab that's already nil. Double free?");
        -:  490:	}
  1018294:  491:	SlabAllocatorImpl *impl = ptr->impl;
        -:  492:
  1018294:  493:	FatPtr32Impl *fptr32 = fptr->data;
        -:  494:
  1018294:  495:	u32 needed = fat_ptr_size(fptr) + SIZE_OVERHEAD;
  1018294:  496:	int index = slab_allocator_index(ptr, needed);
  1018294:  497:	if (index < 0)
    #####:  498:		panic("Freeing a slab with an unknown slab size %llu.\n", needed);
  1018294:  499:	SlabData *sd = &((SlabAllocatorImpl *)ptr->impl)->sd_arr[index];
  1018294:  500:	if (needed != sd->type.slab_size)
    #####:  501:		panic("Freeing a slab with an unknown slab size %llu.\n", needed);
  1018294:  502:	slab_data_free(sd, fptr, ((SlabAllocatorImpl *)ptr->impl)->zeroed);
  1018294:  503:	*fptr = null;
  1018294:  504:}
       70:  505:u64 slab_allocator_cur_slabs_allocated(const SlabAllocator *ptr) {
       70:  506:	SlabAllocatorImpl *impl = ptr->impl;
       70:  507:	u64 ret = 0;
        -:  508:
    14420:  509:	for (u64 i = 0; i < impl->sd_size; i++) {
    14350:  510:		ret += impl->sd_arr[i].cur_slabs;
        -:  511:	}
       70:  512:	return ret;
        -:  513:}
        -:  514:
        -:  515:// These are test helper functions
        -:  516:#ifdef TEST
      100:  517:u32 fat_ptr_id(const FatPtr *ptr) {
      100:  518:	return ((FatPtr32Impl *)ptr->data)->id;
        -:  519:}
     1100:  520:void fat_ptr_test_obj32(FatPtr *ptr, u32 id, u32 len, bool global, bool pin) {
     1100:  521:	ptr->data = mymalloc(SIZE_OVERHEAD + len);
     1100:  522:	FatPtr32Impl *fptr = ptr->data;
     1100:  523:	fptr->id = id;
     1100:  524:	fptr->size_flags[3] = 0;
     1100:  525:	BitFlags bf = {.flags = (fptr->size_flags + 3), .capacity = 1};
     1100:  526:	bitflags_set(&bf, FAT_PTR_FLAG_GLOBAL, global);
     1100:  527:	bitflags_set(&bf, FAT_PTR_FLAG_PIN, pin);
        -:  528:
     1100:  529:	memcpy(&fptr->size_flags, &len, 3);
     1100:  530:	fptr->data = ptr->data + SIZE_OVERHEAD;
     1100:  531:}
     1100:  532:void fat_ptr_free_test_obj32(FatPtr *ptr) {
     1100:  533:	if (ptr && ptr->data) {
     1100:  534:		myfree(ptr->data);
     1100:  535:		ptr->data = NULL;
        -:  536:	}
     1100:  537:}
        -:  538:#endif // TEST
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:77
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:#include <stdatomic.h>
        -:   17:#include <stddef.h>
        -:   18:#include <stdio.h>
        -:   19:#include <stdlib.h>
        -:   20:
       77:   21:bool __is_little_endian() {
       77:   22:	u16 test = 0x1;
       77:   23:	return (*(u8 *)&test == 0x1);
        -:   24:}
        -:   25:
       77:   26:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   27:	if (sizeof(size_t) != 8) {
        -:   28:		fprintf(stderr, "Error: This program requires a 64-bit architecture to run.\n");
        -:   29:		exit(EXIT_FAILURE);
        -:   30:	}
        -:   31:
        -:   32:	if (sizeof(u8) != 1 || sizeof(u16) != 2 || sizeof(u32) != 4 || sizeof(u64) != 8 ||
        -:   33:		sizeof(u128) != 16 || sizeof(i8) != 1 || sizeof(i16) != 2 || sizeof(i32) != 4 ||
        -:   34:		sizeof(i64) != 8 || sizeof(i128) != 16 || sizeof(f32) != 4 || sizeof(f64) != 8 ||
        -:   35:		sizeof(bool) != 1) {
        -:   36:		fprintf(stderr, "Invalid data type size! Check your c compiler configuration options.\n");
        -:   37:		exit(EXIT_FAILURE);
        -:   38:	}
        -:   39:
       77:   40:	if (!__is_little_endian()) {
    #####:   41:		fprintf(stderr, "Big endian systems not supported");
    #####:   42:		exit(EXIT_FAILURE);
        -:   43:	}
        -:   44:
        -:   45:	if (sizeof(atomic_ullong) != 8) {
        -:   46:		fprintf(
        -:   47:			stderr,
        -:   48:			"Error: Unexpected size for atomic_ullong. Check your compiler and architecture.\n");
        -:   49:		exit(EXIT_FAILURE);
        -:   50:	}
       77:   51:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <assert.h>
        -:   17:#include <base/misc.h>
        -:   18:#include <base/path.h>
        -:   19:#include <crypto/sha3.h>
        -:   20:#include <limits.h>
        -:   21:#include <main/main.h>
        -:   22:#include <stdio.h>
        -:   23:#include <string.h>
        -:   24:
        -:   25:bool __is_debug_real_main_res_mkdir = false;
        -:   26:
       16:   27:void write_to_disk(const char *dir, const char *file_name, const unsigned char *data, u64 size) {
        -:   28:	char path[PATH_MAX + 1];
       16:   29:	snprintf(path, sizeof(path), "%s/%s", dir, file_name);
       16:   30:	Path ensure_parent;
       16:   31:	path_for(&ensure_parent, path);
       16:   32:	const char *pfile_name = path_file_name(&ensure_parent);
        -:   33:	char pfile_name_copy[PATH_MAX + 1];
       16:   34:	strcpy(pfile_name_copy, pfile_name);
       16:   35:	path_pop(&ensure_parent);
       16:   36:	path_canonicalize(&ensure_parent);
       16:   37:	path_mkdir(&ensure_parent, 0700, true);
       16:   38:	path_push(&ensure_parent, pfile_name_copy);
       16:   39:	MYFILE *f = myfopen(&ensure_parent, "wb");
       16:   40:	if (f) {
       15:   41:		myfwrite(data, 1, size, f);
       15:   42:		myfclose(f);
        -:   43:	} else {
        1:   44:		exit_error("Could not open file for writing");
        -:   45:	}
       16:   46:}
        -:   47:
        4:   48:bool check_build_id(const char *config_dir) {
        4:   49:	Path bid_file;
        4:   50:	path_for(&bid_file, config_dir);
        4:   51:	path_push(&bid_file, "build_id");
        4:   52:	path_canonicalize(&bid_file);
        -:   53:	// check build id
        4:   54:	MYFILE *fp = myfopen(&bid_file, "r");
        4:   55:	if (!fp) {
        1:   56:		exit_error("could not open the build file");
        1:   57:		return false;
        -:   58:	}
        -:   59:	char bid_file_contents[1024];
        3:   60:	size_t rlen = read_all(bid_file_contents, 1, 100, fp);
        3:   61:	bid_file_contents[rlen] = 0;
        3:   62:	myfclose(fp);
        3:   63:	return !strcmp(bid_file_contents, get_build_id());
        -:   64:}
        -:   65:
        6:   66:void setup_config_dir(const char *config_dir) {
        6:   67:	Path cd;
        6:   68:	path_for(&cd, config_dir);
        6:   69:	path_canonicalize(&cd);
        6:   70:	if (path_exists(&cd)) {
        2:   71:		if (check_build_id(config_dir))
        1:   72:			return;
        1:   73:		remove_directory(&cd, false);
        -:   74:	}
        5:   75:	fprintf(stderr, "Installing config directory at %s. Build id = %s.\n", config_dir,
        -:   76:			get_build_id());
        -:   77:
        5:   78:	if (!path_mkdir(&cd, 0700, false)) {
        1:   79:		exit_error("Could not create config directory at path [%s].", path_to_string(&cd));
        1:   80:		return;
        -:   81:	}
        -:   82:
        4:   83:	Path rd;
        4:   84:	path_copy(&rd, &cd);
        4:   85:	path_push(&rd, "resources");
        -:   86:
        4:   87:	if (__is_debug_real_main_res_mkdir || !path_mkdir(&rd, 0700, true)) {
        1:   88:		exit_error("Could not create resources directory at path [%s].", path_to_string(&rd));
        1:   89:		return;
        -:   90:	}
        -:   91:
       15:   92:	BUILD_RESOURCE_DIR(path_to_string(&rd), fam);
        3:   93:	WRITE_BUILD_ID(config_dir);
        -:   94:}
        -:   95:
        1:   96:void build_args(Args *args, int argc, char **argv) {
        1:   97:	SubCommand sc1;
       1*:   98:	assert(!sub_command_build(&sc1, "sc1", "sc1 help", 1, 2, "<arg doc>"));
        1:   99:	ArgsParam p1;
       1*:  100:	assert(!args_param_build(&p1, "name", "name help here", "n", false, false, "myname"));
        1:  101:	sub_command_add_param(&sc1, &p1);
        -:  102:
        1:  103:	ArgsParam p2;
        1:  104:	args_param_build(&p2, "name2", "name2 help here", "x", true, false, NULL);
        -:  105:
        1:  106:	args_build(args, "prog", "ver1.0", "me", 2, 3, "Darwin arm64");
        1:  107:	args_add_param(args, &p2);
        1:  108:	args_add_sub_command(args, &sc1);
        1:  109:}
        -:  110:
        1:  111:int real_main(int argc, char **argv) {
        1:  112:	Args args;
        1:  113:	build_args(&args, argc, argv);
        -:  114:
        1:  115:	setup_config_dir(DEFAULT_CONFIG_DIR);
        1:  116:	return 0;
        -:  117:}
        -:    0:Source:aes.c
        -:    0:Graph:aes.gcno
        -:    0:Data:aes.gcda
        -:    0:Runs:34
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stddef.h>
        -:   16:#include <stdint.h>
        -:   17:#include <stdio.h>
        -:   18:
        -:   19:/*
        -:   20:
        -:   21:This is an implementation of the AES algorithm, specifically ECB, CTR and CBC mode.
        -:   22:Block size can be chosen in aes.h - available choices are AES128, AES192, AES256.
        -:   23:
        -:   24:The implementation is verified against the test vectors in:
        -:   25:  National Institute of Standards and Technology Special Publication 800-38A 2001 ED
        -:   26:
        -:   27:ECB-AES128
        -:   28:----------
        -:   29:
        -:   30:  plain-text:
        -:   31:	6bc1bee22e409f96e93d7e117393172a
        -:   32:	ae2d8a571e03ac9c9eb76fac45af8e51
        -:   33:	30c81c46a35ce411e5fbc1191a0a52ef
        -:   34:	f69f2445df4f9b17ad2b417be66c3710
        -:   35:
        -:   36:  key:
        -:   37:	2b7e151628aed2a6abf7158809cf4f3c
        -:   38:
        -:   39:  resulting cipher
        -:   40:	3ad77bb40d7a3660a89ecaf32466ef97
        -:   41:	f5d3d58503b9699de785895a96fdbaaf
        -:   42:	43b1cd7f598ece23881b00e3ed030688
        -:   43:	7b0c785e27e8ad3f8223207104725dd4
        -:   44:
        -:   45:
        -:   46:NOTE:   String length must be evenly divisible by 16byte (str_len % 16 == 0)
        -:   47:		You should pad the end of the string with zeros if this is not the case.
        -:   48:		For AES192/256 the key size is proportionally larger.
        -:   49:
        -:   50:*/
        -:   51:
        -:   52:/*****************************************************************************/
        -:   53:/* Includes:                                                                 */
        -:   54:/*****************************************************************************/
        -:   55:#include "aes.h"
        -:   56:#include <string.h> // CBC mode, for memset
        -:   57:
        -:   58:/*****************************************************************************/
        -:   59:/* Defines:                                                                  */
        -:   60:/*****************************************************************************/
        -:   61:// The number of columns comprising a state in AES. This is a constant in AES. Value=4
        -:   62:#define Nb 4
        -:   63:
        -:   64:#if defined(AES256) && (AES256 == 1)
        -:   65:#define Nk 8
        -:   66:#define Nr 14
        -:   67:#elif defined(AES192) && (AES192 == 1)
        -:   68:#define Nk 6
        -:   69:#define Nr 12
        -:   70:#else
        -:   71:#define Nk 4  // The number of 32 bit words in a key.
        -:   72:#define Nr 10 // The number of rounds in AES Cipher.
        -:   73:#endif
        -:   74:
        -:   75:// jcallan@github points out that declaring Multiply as a function
        -:   76:// reduces code size considerably with the Keil ARM compiler.
        -:   77:// See this link for more information: https://github.com/kokke/tiny-AES-C/pull/3
        -:   78:#ifndef MULTIPLY_AS_A_FUNCTION
        -:   79:#define MULTIPLY_AS_A_FUNCTION 0
        -:   80:#endif
        -:   81:
        -:   82:/*****************************************************************************/
        -:   83:/* Private variables:                                                        */
        -:   84:/*****************************************************************************/
        -:   85:// state - array holding the intermediate results during decryption.
        -:   86:typedef u8 state_t[4][4];
        -:   87:
        -:   88:// The lookup-tables are marked const so they can be placed in read-only storage instead of RAM
        -:   89:// The numbers below can be computed dynamically trading ROM for RAM -
        -:   90:// This can be useful in (embedded) bootloader applications, where ROM is often limited.
        -:   91:static const u8 sbox[256] = {
        -:   92:	// 0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
        -:   93:	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
        -:   94:	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
        -:   95:	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
        -:   96:	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
        -:   97:	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
        -:   98:	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
        -:   99:	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
        -:  100:	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
        -:  101:	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
        -:  102:	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
        -:  103:	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
        -:  104:	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
        -:  105:	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
        -:  106:	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
        -:  107:	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        -:  108:	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};
        -:  109:
        -:  110:#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
        -:  111:static const u8 rsbox[256] = {
        -:  112:	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
        -:  113:	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
        -:  114:	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        -:  115:	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
        -:  116:	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
        -:  117:	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        -:  118:	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
        -:  119:	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
        -:  120:	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        -:  121:	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
        -:  122:	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
        -:  123:	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        -:  124:	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
        -:  125:	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
        -:  126:	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        -:  127:	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};
        -:  128:#endif
        -:  129:
        -:  130:// The round constant word array, Rcon[i], contains the values given by
        -:  131:// x to the power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)
        -:  132:static const u8 Rcon[11] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};
        -:  133:
        -:  134:/*
        -:  135: * Jordan Goulder points out in PR #12 (https://github.com/kokke/tiny-AES-C/pull/12),
        -:  136: * that you can remove most of the elements in the Rcon array, because they are unused.
        -:  137: *
        -:  138: * From Wikipedia's article on the Rijndael key schedule @
        -:  139: * https://en.wikipedia.org/wiki/Rijndael_key_schedule#Rcon
        -:  140: *
        -:  141: * "Only the first some of these constants are actually used  up to rcon[10] for AES-128 (as 11
        -:  142: * round keys are needed), up to rcon[8] for AES-192, up to rcon[7] for AES-256. rcon[0] is not used
        -:  143: * in AES algorithm."
        -:  144: */
        -:  145:
        -:  146:/*****************************************************************************/
        -:  147:/* Private functions:                                                        */
        -:  148:/*****************************************************************************/
        -:  149:/*
        -:  150:static u8 getSBoxValue(u8 num)
        -:  151:{
        -:  152:  return sbox[num];
        -:  153:}
        -:  154:*/
        -:  155:#define getSBoxValue(num) (sbox[(num)])
        -:  156:
        -:  157:// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the
        -:  158:// states.
       39:  159:static void KeyExpansion(u8 *RoundKey, const u8 *Key) {
        -:  160:	unsigned i, j, k;
        -:  161:	u8 tempa[4]; // Used for the column/row operations
        -:  162:
        -:  163:	// The first round key is the key itself.
      351:  164:	for (i = 0; i < Nk; ++i) {
      312:  165:		RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
      312:  166:		RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
      312:  167:		RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
      312:  168:		RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
        -:  169:	}
        -:  170:
        -:  171:	// All other round keys are found from the previous round keys.
     2067:  172:	for (i = Nk; i < Nb * (Nr + 1); ++i) {
        -:  173:		{
     2028:  174:			k = (i - 1) * 4;
     2028:  175:			tempa[0] = RoundKey[k + 0];
     2028:  176:			tempa[1] = RoundKey[k + 1];
     2028:  177:			tempa[2] = RoundKey[k + 2];
     2028:  178:			tempa[3] = RoundKey[k + 3];
        -:  179:		}
        -:  180:
     2028:  181:		if (i % Nk == 0) {
        -:  182:			// This function shifts the 4 bytes in a word to the left once.
        -:  183:			// [a0,a1,a2,a3] becomes [a1,a2,a3,a0]
        -:  184:
        -:  185:			// Function RotWord()
        -:  186:			{
      273:  187:				const u8 u8tmp = tempa[0];
      273:  188:				tempa[0] = tempa[1];
      273:  189:				tempa[1] = tempa[2];
      273:  190:				tempa[2] = tempa[3];
      273:  191:				tempa[3] = u8tmp;
        -:  192:			}
        -:  193:
        -:  194:			// SubWord() is a function that takes a four-byte input word and
        -:  195:			// applies the S-box to each of the four bytes to produce an output word.
        -:  196:
        -:  197:			// Function Subword()
        -:  198:			{
      273:  199:				tempa[0] = getSBoxValue(tempa[0]);
      273:  200:				tempa[1] = getSBoxValue(tempa[1]);
      273:  201:				tempa[2] = getSBoxValue(tempa[2]);
      273:  202:				tempa[3] = getSBoxValue(tempa[3]);
        -:  203:			}
        -:  204:
      273:  205:			tempa[0] = tempa[0] ^ Rcon[i / Nk];
        -:  206:		}
        -:  207:#if defined(AES256) && (AES256 == 1)
     2028:  208:		if (i % Nk == 4) {
        -:  209:			// Function Subword()
        -:  210:			{
      234:  211:				tempa[0] = getSBoxValue(tempa[0]);
      234:  212:				tempa[1] = getSBoxValue(tempa[1]);
      234:  213:				tempa[2] = getSBoxValue(tempa[2]);
      234:  214:				tempa[3] = getSBoxValue(tempa[3]);
        -:  215:			}
        -:  216:		}
        -:  217:#endif
     2028:  218:		j = i * 4;
     2028:  219:		k = (i - Nk) * 4;
     2028:  220:		RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
     2028:  221:		RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
     2028:  222:		RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
     2028:  223:		RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
        -:  224:	}
       39:  225:}
        -:  226:
    #####:  227:void AES_init_ctx(struct AES_ctx *ctx, const u8 *key) {
    #####:  228:	KeyExpansion(ctx->RoundKey, key);
    #####:  229:}
        -:  230:#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
       39:  231:void AES_init_ctx_iv(struct AES_ctx *ctx, const u8 *key, const u8 *iv) {
       39:  232:	KeyExpansion(ctx->RoundKey, key);
       39:  233:	memcpy(ctx->Iv, iv, AES_BLOCKLEN);
       39:  234:}
    #####:  235:void AES_ctx_set_iv(struct AES_ctx *ctx, const u8 *iv) {
    #####:  236:	memcpy(ctx->Iv, iv, AES_BLOCKLEN);
    #####:  237:}
        -:  238:#endif
        -:  239:
        -:  240:// This function adds the round key to state.
        -:  241:// The round key is added to the state by an XOR function.
   326640:  242:static void AddRoundKey(u8 round, state_t *state, const u8 *RoundKey) {
        -:  243:	u8 i, j;
  1633200:  244:	for (i = 0; i < 4; ++i) {
  6532800:  245:		for (j = 0; j < 4; ++j) {
  5226240:  246:			(*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
        -:  247:		}
        -:  248:	}
   326640:  249:}
        -:  250:
        -:  251:// The SubBytes Function Substitutes the values in the
        -:  252:// state matrix with values in an S-box.
   304864:  253:static void SubBytes(state_t *state) {
        -:  254:	u8 i, j;
  1524320:  255:	for (i = 0; i < 4; ++i) {
  6097280:  256:		for (j = 0; j < 4; ++j) {
  4877824:  257:			(*state)[j][i] = getSBoxValue((*state)[j][i]);
        -:  258:		}
        -:  259:	}
   304864:  260:}
        -:  261:
        -:  262:// The ShiftRows() function shifts the rows in the state to the left.
        -:  263:// Each row is shifted with different offset.
        -:  264:// Offset = Row number. So the first row is not shifted.
   304864:  265:static void ShiftRows(state_t *state) {
        -:  266:	u8 temp;
        -:  267:
        -:  268:	// Rotate first row 1 columns to left
   304864:  269:	temp = (*state)[0][1];
   304864:  270:	(*state)[0][1] = (*state)[1][1];
   304864:  271:	(*state)[1][1] = (*state)[2][1];
   304864:  272:	(*state)[2][1] = (*state)[3][1];
   304864:  273:	(*state)[3][1] = temp;
        -:  274:
        -:  275:	// Rotate second row 2 columns to left
   304864:  276:	temp = (*state)[0][2];
   304864:  277:	(*state)[0][2] = (*state)[2][2];
   304864:  278:	(*state)[2][2] = temp;
        -:  279:
   304864:  280:	temp = (*state)[1][2];
   304864:  281:	(*state)[1][2] = (*state)[3][2];
   304864:  282:	(*state)[3][2] = temp;
        -:  283:
        -:  284:	// Rotate third row 3 columns to left
   304864:  285:	temp = (*state)[0][3];
   304864:  286:	(*state)[0][3] = (*state)[3][3];
   304864:  287:	(*state)[3][3] = (*state)[2][3];
   304864:  288:	(*state)[2][3] = (*state)[1][3];
   304864:  289:	(*state)[1][3] = temp;
   304864:  290:}
        -:  291:
  4529408:  292:static u8 xtime(u8 x) {
  4529408:  293:	return ((x << 1) ^ (((x >> 7) & 1) * 0x1b));
        -:  294:}
        -:  295:
        -:  296:// MixColumns function mixes the columns of the state matrix
   283088:  297:static void MixColumns(state_t *state) {
        -:  298:	u8 i;
        -:  299:	u8 Tmp, Tm, t;
  1415440:  300:	for (i = 0; i < 4; ++i) {
  1132352:  301:		t = (*state)[i][0];
  1132352:  302:		Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3];
  1132352:  303:		Tm = (*state)[i][0] ^ (*state)[i][1];
  1132352:  304:		Tm = xtime(Tm);
  1132352:  305:		(*state)[i][0] ^= Tm ^ Tmp;
  1132352:  306:		Tm = (*state)[i][1] ^ (*state)[i][2];
  1132352:  307:		Tm = xtime(Tm);
  1132352:  308:		(*state)[i][1] ^= Tm ^ Tmp;
  1132352:  309:		Tm = (*state)[i][2] ^ (*state)[i][3];
  1132352:  310:		Tm = xtime(Tm);
  1132352:  311:		(*state)[i][2] ^= Tm ^ Tmp;
  1132352:  312:		Tm = (*state)[i][3] ^ t;
  1132352:  313:		Tm = xtime(Tm);
  1132352:  314:		(*state)[i][3] ^= Tm ^ Tmp;
        -:  315:	}
   283088:  316:}
        -:  317:
        -:  318:// Multiply is used to multiply numbers in the field GF(2^8)
        -:  319:// Note: The last call to xtime() is unneeded, but often ends up generating a smaller binary
        -:  320://       The compiler seems to be able to vectorize the operation better this way.
        -:  321://       See https://github.com/kokke/tiny-AES-c/pull/34
        -:  322:#if MULTIPLY_AS_A_FUNCTION
        -:  323:static u8 Multiply(u8 x, u8 y) {
        -:  324:	return (((y & 1) * x) ^ ((y >> 1 & 1) * xtime(x)) ^ ((y >> 2 & 1) * xtime(xtime(x))) ^
        -:  325:			((y >> 3 & 1) * xtime(xtime(xtime(x)))) ^
        -:  326:			((y >> 4 & 1) *
        -:  327:			 xtime(xtime(xtime(xtime(x)))))); /* this last call to xtime() can be omitted */
        -:  328:}
        -:  329:#else
        -:  330:#define Multiply(x, y)                                                                             \
        -:  331:	(((y & 1) * x) ^ ((y >> 1 & 1) * xtime(x)) ^ ((y >> 2 & 1) * xtime(xtime(x))) ^                \
        -:  332:	 ((y >> 3 & 1) * xtime(xtime(xtime(x)))) ^ ((y >> 4 & 1) * xtime(xtime(xtime(xtime(x))))))
        -:  333:
        -:  334:#endif
        -:  335:
        -:  336:#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
        -:  337:/*
        -:  338:static u8 getSBoxInvert(u8 num)
        -:  339:{
        -:  340:  return rsbox[num];
        -:  341:}
        -:  342:*/
        -:  343:#define getSBoxInvert(num) (rsbox[(num)])
        -:  344:
        -:  345:// MixColumns function mixes the columns of the state matrix.
        -:  346:// The method used to multiply may be difficult to understand for the inexperienced.
        -:  347:// Please use the references to gain more information.
    #####:  348:static void InvMixColumns(state_t *state) {
        -:  349:	int i;
        -:  350:	u8 a, b, c, d;
    #####:  351:	for (i = 0; i < 4; ++i) {
    #####:  352:		a = (*state)[i][0];
    #####:  353:		b = (*state)[i][1];
    #####:  354:		c = (*state)[i][2];
    #####:  355:		d = (*state)[i][3];
        -:  356:
    #####:  357:		(*state)[i][0] =
    #####:  358:			Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    #####:  359:		(*state)[i][1] =
    #####:  360:			Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    #####:  361:		(*state)[i][2] =
    #####:  362:			Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    #####:  363:		(*state)[i][3] =
    #####:  364:			Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
        -:  365:	}
    #####:  366:}
        -:  367:
        -:  368:// The SubBytes Function Substitutes the values in the
        -:  369:// state matrix with values in an S-box.
    #####:  370:static void InvSubBytes(state_t *state) {
        -:  371:	u8 i, j;
    #####:  372:	for (i = 0; i < 4; ++i) {
    #####:  373:		for (j = 0; j < 4; ++j) {
    #####:  374:			(*state)[j][i] = getSBoxInvert((*state)[j][i]);
        -:  375:		}
        -:  376:	}
    #####:  377:}
        -:  378:
    #####:  379:static void InvShiftRows(state_t *state) {
        -:  380:	u8 temp;
        -:  381:
        -:  382:	// Rotate first row 1 columns to right
    #####:  383:	temp = (*state)[3][1];
    #####:  384:	(*state)[3][1] = (*state)[2][1];
    #####:  385:	(*state)[2][1] = (*state)[1][1];
    #####:  386:	(*state)[1][1] = (*state)[0][1];
    #####:  387:	(*state)[0][1] = temp;
        -:  388:
        -:  389:	// Rotate second row 2 columns to right
    #####:  390:	temp = (*state)[0][2];
    #####:  391:	(*state)[0][2] = (*state)[2][2];
    #####:  392:	(*state)[2][2] = temp;
        -:  393:
    #####:  394:	temp = (*state)[1][2];
    #####:  395:	(*state)[1][2] = (*state)[3][2];
    #####:  396:	(*state)[3][2] = temp;
        -:  397:
        -:  398:	// Rotate third row 3 columns to right
    #####:  399:	temp = (*state)[0][3];
    #####:  400:	(*state)[0][3] = (*state)[1][3];
    #####:  401:	(*state)[1][3] = (*state)[2][3];
    #####:  402:	(*state)[2][3] = (*state)[3][3];
    #####:  403:	(*state)[3][3] = temp;
    #####:  404:}
        -:  405:#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
        -:  406:
        -:  407:// Cipher is the main function that encrypts the PlainText.
    21776:  408:static void Cipher(state_t *state, const u8 *RoundKey) {
    21776:  409:	u8 round = 0;
        -:  410:
        -:  411:	// Add the First round key to the state before starting the rounds.
    21776:  412:	AddRoundKey(0, state, RoundKey);
        -:  413:
        -:  414:	// There will be Nr rounds.
        -:  415:	// The first Nr-1 rounds are identical.
        -:  416:	// These Nr rounds are executed in the loop below.
        -:  417:	// Last one without MixColumns()
   304864:  418:	for (round = 1;; ++round) {
   304864:  419:		SubBytes(state);
   304864:  420:		ShiftRows(state);
   304864:  421:		if (round == Nr) {
    21776:  422:			break;
        -:  423:		}
   283088:  424:		MixColumns(state);
   283088:  425:		AddRoundKey(round, state, RoundKey);
        -:  426:	}
        -:  427:	// Add round key to last round
    21776:  428:	AddRoundKey(Nr, state, RoundKey);
    21776:  429:}
        -:  430:
        -:  431:#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
    #####:  432:static void InvCipher(state_t *state, const u8 *RoundKey) {
    #####:  433:	u8 round = 0;
        -:  434:
        -:  435:	// Add the First round key to the state before starting the rounds.
    #####:  436:	AddRoundKey(Nr, state, RoundKey);
        -:  437:
        -:  438:	// There will be Nr rounds.
        -:  439:	// The first Nr-1 rounds are identical.
        -:  440:	// These Nr rounds are executed in the loop below.
        -:  441:	// Last one without InvMixColumn()
    #####:  442:	for (round = (Nr - 1);; --round) {
    #####:  443:		InvShiftRows(state);
    #####:  444:		InvSubBytes(state);
    #####:  445:		AddRoundKey(round, state, RoundKey);
    #####:  446:		if (round == 0) {
    #####:  447:			break;
        -:  448:		}
    #####:  449:		InvMixColumns(state);
        -:  450:	}
    #####:  451:}
        -:  452:#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
        -:  453:
        -:  454:/*****************************************************************************/
        -:  455:/* Public functions:                                                         */
        -:  456:/*****************************************************************************/
        -:  457:#if defined(ECB) && (ECB == 1)
        -:  458:
    #####:  459:void AES_ECB_encrypt(const struct AES_ctx *ctx, u8 *buf) {
        -:  460:	// The next function call encrypts the PlainText with the Key using AES algorithm.
    #####:  461:	Cipher((state_t *)buf, ctx->RoundKey);
    #####:  462:}
        -:  463:
    #####:  464:void AES_ECB_decrypt(const struct AES_ctx *ctx, u8 *buf) {
        -:  465:	// The next function call decrypts the PlainText with the Key using AES algorithm.
    #####:  466:	InvCipher((state_t *)buf, ctx->RoundKey);
    #####:  467:}
        -:  468:
        -:  469:#endif // #if defined(ECB) && (ECB == 1)
        -:  470:
        -:  471:#if defined(CBC) && (CBC == 1)
        -:  472:
    #####:  473:static void XorWithIv(u8 *buf, const u8 *Iv) {
        -:  474:	u8 i;
    #####:  475:	for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
        -:  476:	{
    #####:  477:		buf[i] ^= Iv[i];
        -:  478:	}
    #####:  479:}
        -:  480:
    #####:  481:void AES_CBC_encrypt_buffer(struct AES_ctx *ctx, u8 *buf, u64 length) {
        -:  482:	u64 i;
    #####:  483:	u8 *Iv = ctx->Iv;
    #####:  484:	for (i = 0; i < length; i += AES_BLOCKLEN) {
    #####:  485:		XorWithIv(buf, Iv);
    #####:  486:		Cipher((state_t *)buf, ctx->RoundKey);
    #####:  487:		Iv = buf;
    #####:  488:		buf += AES_BLOCKLEN;
        -:  489:	}
        -:  490:	/* store Iv in ctx for next call */
    #####:  491:	memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
    #####:  492:}
        -:  493:
    #####:  494:void AES_CBC_decrypt_buffer(struct AES_ctx *ctx, u8 *buf, u64 length) {
        -:  495:	u64 i;
        -:  496:	u8 storeNextIv[AES_BLOCKLEN];
    #####:  497:	for (i = 0; i < length; i += AES_BLOCKLEN) {
    #####:  498:		memcpy(storeNextIv, buf, AES_BLOCKLEN);
    #####:  499:		InvCipher((state_t *)buf, ctx->RoundKey);
    #####:  500:		XorWithIv(buf, ctx->Iv);
    #####:  501:		memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    #####:  502:		buf += AES_BLOCKLEN;
        -:  503:	}
    #####:  504:}
        -:  505:
        -:  506:#endif // #if defined(CBC) && (CBC == 1)
        -:  507:
        -:  508:#if defined(CTR) && (CTR == 1)
        -:  509:
        -:  510:/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should
        -:  511: * never be reused with the same key */
    21776:  512:void AES_CTR_xcrypt_buffer(struct AES_ctx *ctx, u8 *buf, u64 length) {
        -:  513:	u8 buffer[AES_BLOCKLEN];
        -:  514:
        -:  515:	u64 i;
        -:  516:	int bi;
   125949:  517:	for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi) {
   104173:  518:		if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
        -:  519:		{
        -:  520:
    21776:  521:			memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
    21776:  522:			Cipher((state_t *)buffer, ctx->RoundKey);
        -:  523:
        -:  524:			/* Increment Iv and handle overflow */
    21860:  525:			for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi) {
        -:  526:				/* inc will overflow */
    21860:  527:				if (ctx->Iv[bi] == 255) {
       84:  528:					ctx->Iv[bi] = 0;
       84:  529:					continue;
        -:  530:				}
    21776:  531:				ctx->Iv[bi] += 1;
    21776:  532:				break;
        -:  533:			}
    21776:  534:			bi = 0;
        -:  535:		}
        -:  536:
   104173:  537:		buf[i] = (buf[i] ^ buffer[bi]);
        -:  538:	}
    21776:  539:}
        -:  540:
        -:  541:#endif // #if defined(CTR) && (CTR == 1)
        -:    0:Source:murmurhash.c
        -:    0:Graph:murmurhash.gcno
        -:    0:Data:murmurhash.gcda
        -:    0:Runs:34
        -:    1:/**
        -:    2: * `murmurhash.h' - murmurhash
        -:    3: *
        -:    4: * copyright (c) 2014-2022 joseph werle <joseph.werle@gmail.com>
        -:    5: */
        -:    6:
        -:    7:#include <base/resources.h>
        -:    8:#include <crypto/murmurhash.h>
        -:    9:
   501529:   10:u32 murmurhash(const char *key, u32 len, u32 seed) {
   501529:   11:	u32 c1 = 0xcc9e2d51;
   501529:   12:	u32 c2 = 0x1b873593;
   501529:   13:	u32 r1 = 15;
   501529:   14:	u32 r2 = 13;
   501529:   15:	u32 m = 5;
   501529:   16:	u32 n = 0xe6546b64;
   501529:   17:	u32 h = 0;
   501529:   18:	u32 k = 0;
   501529:   19:	u8 *d = (u8 *)key; // 32 bit extract from `key'
   501529:   20:	const u32 *chunks = NULL;
   501529:   21:	const u8 *tail = NULL; // tail - last 8 bytes
   501529:   22:	int i = 0;
   501529:   23:	int l = len / 4; // chunk length
        -:   24:
   501529:   25:	h = seed;
        -:   26:
   501529:   27:	chunks = (const u32 *)(d + l * 4); // body
   501529:   28:	tail = (const u8 *)(d + l * 4);	   // last 8 byte chunk of `key'
        -:   29:
        -:   30:	// for each 4 byte chunk of `key'
  1512811:   31:	for (i = -l; i != 0; ++i) {
        -:   32:		// next 4 byte chunk of `key'
  1011282:   33:		k = chunks[i];
        -:   34:
        -:   35:		// encode next 4 byte chunk of `key'
  1011282:   36:		k *= c1;
  1011282:   37:		k = (k << r1) | (k >> (32 - r1));
  1011282:   38:		k *= c2;
        -:   39:
        -:   40:		// append to hash
  1011282:   41:		h ^= k;
  1011282:   42:		h = (h << r2) | (h >> (32 - r2));
  1011282:   43:		h = h * m + n;
        -:   44:	}
        -:   45:
   501529:   46:	k = 0;
        -:   47:
        -:   48:	// remainder
   501529:   49:	switch (len & 3) { // `len % 4'
    #####:   50:	case 3:
    #####:   51:		k ^= (tail[2] << 16);
    #####:   52:	case 2:
    #####:   53:		k ^= (tail[1] << 8);
        -:   54:
    #####:   55:	case 1:
    #####:   56:		k ^= tail[0];
    #####:   57:		k *= c1;
    #####:   58:		k = (k << r1) | (k >> (32 - r1));
    #####:   59:		k *= c2;
    #####:   60:		h ^= k;
        -:   61:	}
        -:   62:
   501529:   63:	h ^= len;
        -:   64:
   501529:   65:	h ^= (h >> 16);
   501529:   66:	h *= 0x85ebca6b;
   501529:   67:	h ^= (h >> 13);
   501529:   68:	h *= 0xc2b2ae35;
   501529:   69:	h ^= (h >> 16);
        -:   70:
   501529:   71:	return h;
        -:   72:}
        -:    0:Source:psrng.c
        -:    0:Graph:psrng.gcno
        -:    0:Data:psrng.gcda
        -:    0:Runs:34
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <crypto/aes.h>
        -:   16:#include <crypto/psrng.h>
        -:   17:#include <crypto/rand.h>
        -:   18:#include <stdio.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:
        -:   22:static struct AES_ctx ctx;
        -:   23:
       34:   24:void psrng_reseed() {
        -:   25:	u8 iv[16];
        -:   26:	u8 key[32];
       34:   27:	if (rand_bytes(key, 32)) {
    #####:   28:		perror("Could not generate entropy for AES key generation");
    #####:   29:		exit(-1);
        -:   30:	}
       34:   31:	if (rand_bytes(iv, 16)) {
    #####:   32:		perror("Could not generate entropy for AES iv generation");
    #####:   33:		exit(-1);
        -:   34:	}
        -:   35:
       34:   36:	AES_init_ctx_iv(&ctx, key, iv);
       34:   37:}
        -:   38:
        -:   39:// __attribute__ ((constructor)) guaranteed to be called before main.
        -:   40:// This will either succeed or exit before main is called.
       34:   41:void __attribute__((constructor)) __init_psrng() {
       34:   42:	psrng_reseed();
       34:   43:}
        -:   44:
        -:   45:// note: not thread safe as user must ensure thread safety. This allows for flexible usage
        -:   46:// in a single thread, no locking is needed. In multi-threaded environments, locking may be used.
    10005:   47:void psrng_rand_u8(u8 *v) {
    10005:   48:	AES_CTR_xcrypt_buffer(&ctx, v, sizeof(u8));
    10005:   49:}
        -:   50:
        -:   51:// note: not thread safe as user must ensure thread safety. This allows for flexible usage
        -:   52:// in a single thread, no locking is needed. In multi-threaded environments, locking may be used.
    11771:   53:void psrng_rand_u64(u64 *v) {
    11771:   54:	AES_CTR_xcrypt_buffer(&ctx, (u8 *)v, sizeof(u64));
    11771:   55:}
        -:   56:
        -:   57:// note: not thread safe as user must ensure thread safety. This allows for flexible usage
        -:   58:// in a single thread, no locking is needed. In multi-threaded environments, locking may be used.
    #####:   59:void psrng_rand_u128(u128 *v) {
    #####:   60:	AES_CTR_xcrypt_buffer(&ctx, (u8 *)v, sizeof(u128));
    #####:   61:}
        -:   62:
        -:   63:// note: not thread safe as user must ensure thread safety. This allows for flexible usage
        -:   64:// in a single thread, no locking is needed. In multi-threaded environments, locking may be used.
    #####:   65:void psrng_rand_bytes(void *v, u64 size) {
    #####:   66:	AES_CTR_xcrypt_buffer(&ctx, (u8 *)v, size);
    #####:   67:}
        -:   68:
        -:   69:// only available in test mode for tests. Not used in production environments.
        -:   70:#ifdef TEST
        5:   71:void psrng_test_seed(u8 iv[16], u8 key[32]) {
        5:   72:	AES_init_ctx_iv(&ctx, key, iv);
        5:   73:	u64 v0 = 0;
        5:   74:	psrng_rand_u64(&v0);
        5:   75:}
        -:   76:#endif // TEST
        -:    0:Source:rand.c
        -:    0:Graph:rand.gcno
        -:    0:Data:rand.gcda
        -:    0:Runs:34
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/types.h>
        -:   16:#include <crypto/rand.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <sys/random.h>
        -:   19:
    #####:   20:int rand_i8(i8 *v) {
    #####:   21:	return getentropy(v, sizeof(i8));
        -:   22:}
        -:   23:
    #####:   24:int rand_u8(u8 *v) {
    #####:   25:	return getentropy(v, sizeof(u8));
        -:   26:}
        -:   27:
    #####:   28:int rand_i16(i16 *v) {
    #####:   29:	return getentropy(v, sizeof(i16));
        -:   30:}
        -:   31:
    #####:   32:int rand_u16(u16 *v) {
    #####:   33:	return getentropy(v, sizeof(u16));
        -:   34:}
        -:   35:
    #####:   36:int rand_i32(i32 *v) {
    #####:   37:	return getentropy(v, sizeof(i32));
        -:   38:}
        -:   39:
    #####:   40:int rand_u32(u32 *v) {
    #####:   41:	return getentropy(v, sizeof(u32));
        -:   42:}
        -:   43:
    #####:   44:int rand_i64(i64 *v) {
    #####:   45:	return getentropy(v, sizeof(i64));
        -:   46:}
        -:   47:
    #####:   48:int rand_u64(u64 *v) {
    #####:   49:	return getentropy(v, sizeof(u64));
        -:   50:}
        -:   51:
    #####:   52:int rand_i128(i128 *v) {
    #####:   53:	return getentropy(v, sizeof(i128));
        -:   54:}
        -:   55:
    #####:   56:int rand_u128(u128 *v) {
    #####:   57:	return getentropy(v, sizeof(u128));
        -:   58:}
        -:   59:
       68:   60:int rand_bytes(void *buf, u64 length) {
       68:   61:	return getentropy(buf, length);
        -:   62:}
        -:    0:Source:sha3.c
        -:    0:Graph:sha3.gcno
        -:    0:Data:sha3.gcda
        -:    0:Runs:34
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:/* -------------------------------------------------------------------------
        -:   16: * Works when compiled for either 32-bit or 64-bit targets, optimized for
        -:   17: * 64 bit.
        -:   18: *
        -:   19: * Canonical implementation of Init/Update/Finalize for SHA-3 byte input.
        -:   20: *
        -:   21: * SHA3-256, SHA3-384, SHA-512 are implemented. SHA-224 can easily be added.
        -:   22: *
        -:   23: * Based on code from http://keccak.noekeon.org/ .
        -:   24: *
        -:   25: * I place the code that I wrote into public domain, free to use.
        -:   26: *
        -:   27: * I would appreciate if you give credits to this work if you used it to
        -:   28: * write or test * your code.
        -:   29: *
        -:   30: * Aug 2015. Andrey Jivsov. crypto@brainhub.org
        -:   31: * ---------------------------------------------------------------------- */
        -:   32:
        -:   33:#include <stdint.h>
        -:   34:#include <stdio.h>
        -:   35:#include <string.h>
        -:   36:
        -:   37:#include <crypto/sha3.h>
        -:   38:
        -:   39:#define SHA3_ASSERT(x)
        -:   40:#define SHA3_TRACE(format, ...)
        -:   41:#define SHA3_TRACE_BUF(format, buf, l)
        -:   42:
        -:   43:/*
        -:   44: * This flag is used to configure "pure" Keccak, as opposed to NIST SHA3.
        -:   45: */
        -:   46:#define SHA3_USE_KECCAK_FLAG 0x80000000
        -:   47:#define SHA3_CW(x) ((x) & (~SHA3_USE_KECCAK_FLAG))
        -:   48:
        -:   49:#if defined(_MSC_VER)
        -:   50:#define SHA3_CONST(x) x
        -:   51:#else
        -:   52:#define SHA3_CONST(x) x##L
        -:   53:#endif
        -:   54:
        -:   55:#ifndef SHA3_ROTL64
        -:   56:#define SHA3_ROTL64(x, y) (((x) << (y)) | ((x) >> ((sizeof(u64) * 8) - (y))))
        -:   57:#endif
        -:   58:
        -:   59:static const u64 keccakf_rndc[24] = {
        -:   60:	SHA3_CONST(0x0000000000000001UL), SHA3_CONST(0x0000000000008082UL),
        -:   61:	SHA3_CONST(0x800000000000808aUL), SHA3_CONST(0x8000000080008000UL),
        -:   62:	SHA3_CONST(0x000000000000808bUL), SHA3_CONST(0x0000000080000001UL),
        -:   63:	SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008009UL),
        -:   64:	SHA3_CONST(0x000000000000008aUL), SHA3_CONST(0x0000000000000088UL),
        -:   65:	SHA3_CONST(0x0000000080008009UL), SHA3_CONST(0x000000008000000aUL),
        -:   66:	SHA3_CONST(0x000000008000808bUL), SHA3_CONST(0x800000000000008bUL),
        -:   67:	SHA3_CONST(0x8000000000008089UL), SHA3_CONST(0x8000000000008003UL),
        -:   68:	SHA3_CONST(0x8000000000008002UL), SHA3_CONST(0x8000000000000080UL),
        -:   69:	SHA3_CONST(0x000000000000800aUL), SHA3_CONST(0x800000008000000aUL),
        -:   70:	SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008080UL),
        -:   71:	SHA3_CONST(0x0000000080000001UL), SHA3_CONST(0x8000000080008008UL)};
        -:   72:
        -:   73:static const unsigned keccakf_rotc[24] = {1,  3,  6,  10, 15, 21, 28, 36, 45, 55, 2,  14,
        -:   74:										  27, 41, 56, 8,  25, 43, 62, 18, 39, 61, 20, 44};
        -:   75:
        -:   76:static const unsigned keccakf_piln[24] = {10, 7,  11, 17, 18, 3, 5,	 16, 8,	 21, 24, 4,
        -:   77:										  15, 23, 19, 13, 12, 2, 20, 14, 22, 9,	 6,	 1};
        -:   78:
        -:   79:/* generally called after SHA3_KECCAK_SPONGE_WORDS-ctx->capacityWords words
        -:   80: * are XORed into the state s
        -:   81: */
       11:   82:static void keccakf(u64 s[25]) {
        -:   83:	int i, j, round;
        -:   84:	u64 t, bc[5];
        -:   85:#define KECCAK_ROUNDS 24
        -:   86:
      275:   87:	for (round = 0; round < KECCAK_ROUNDS; round++) {
        -:   88:
        -:   89:		/* Theta */
     1584:   90:		for (i = 0; i < 5; i++)
     1320:   91:			bc[i] = s[i] ^ s[i + 5] ^ s[i + 10] ^ s[i + 15] ^ s[i + 20];
        -:   92:
     1584:   93:		for (i = 0; i < 5; i++) {
     1320:   94:			t = bc[(i + 4) % 5] ^ SHA3_ROTL64(bc[(i + 1) % 5], 1);
     7920:   95:			for (j = 0; j < 25; j += 5)
     6600:   96:				s[j + i] ^= t;
        -:   97:		}
        -:   98:
        -:   99:		/* Rho Pi */
      264:  100:		t = s[1];
     6600:  101:		for (i = 0; i < 24; i++) {
     6336:  102:			j = keccakf_piln[i];
     6336:  103:			bc[0] = s[j];
     6336:  104:			s[j] = SHA3_ROTL64(t, keccakf_rotc[i]);
     6336:  105:			t = bc[0];
        -:  106:		}
        -:  107:
        -:  108:		/* Chi */
     1584:  109:		for (j = 0; j < 25; j += 5) {
     7920:  110:			for (i = 0; i < 5; i++)
     6600:  111:				bc[i] = s[j + i];
     7920:  112:			for (i = 0; i < 5; i++)
     6600:  113:				s[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
        -:  114:		}
        -:  115:
        -:  116:		/* Iota */
      264:  117:		s[0] ^= keccakf_rndc[round];
        -:  118:	}
       11:  119:}
        -:  120:
        -:  121:/* *************************** Public Inteface ************************ */
        -:  122:
        -:  123:/* For Init or Reset call these: */
       11:  124:sha3_return_t sha3_Init(void *priv, unsigned bitSize) {
       11:  125:	sha3_context *ctx = (sha3_context *)priv;
      11*:  126:	if (bitSize != 256 && bitSize != 384 && bitSize != 512)
    #####:  127:		return SHA3_RETURN_BAD_PARAMS;
       11:  128:	memset(ctx, 0, sizeof(*ctx));
       11:  129:	ctx->capacityWords = 2 * bitSize / (8 * sizeof(u64));
       11:  130:	return SHA3_RETURN_OK;
        -:  131:}
        -:  132:
       11:  133:void sha3_Init256(void *priv) {
       11:  134:	sha3_Init(priv, 256);
       11:  135:}
        -:  136:
    #####:  137:void sha3_Init384(void *priv) {
    #####:  138:	sha3_Init(priv, 384);
    #####:  139:}
        -:  140:
    #####:  141:void sha3_Init512(void *priv) {
    #####:  142:	sha3_Init(priv, 512);
    #####:  143:}
        -:  144:
    #####:  145:enum SHA3_FLAGS sha3_SetFlags(void *priv, enum SHA3_FLAGS flags) {
    #####:  146:	sha3_context *ctx = (sha3_context *)priv;
    #####:  147:	flags &= SHA3_FLAGS_KECCAK;
    #####:  148:	ctx->capacityWords |= (flags == SHA3_FLAGS_KECCAK ? SHA3_USE_KECCAK_FLAG : 0);
    #####:  149:	return flags;
        -:  150:}
        -:  151:
       11:  152:void sha3_Update(void *priv, void const *bufIn, u64 len) {
       11:  153:	sha3_context *ctx = (sha3_context *)priv;
        -:  154:
        -:  155:	/* 0...7 -- how much is needed to have a word */
       11:  156:	unsigned old_tail = (8 - ctx->byteIndex) & 7;
        -:  157:
        -:  158:	u64 words;
        -:  159:	unsigned tail;
        -:  160:	u64 i;
        -:  161:
       11:  162:	const u8 *buf = bufIn;
        -:  163:
        -:  164:	SHA3_TRACE_BUF("called to update with:", buf, len);
        -:  165:
        -:  166:	SHA3_ASSERT(ctx->byteIndex < 8);
        -:  167:	SHA3_ASSERT(ctx->wordIndex < sizeof(ctx->u.s) / sizeof(ctx->u.s[0]));
        -:  168:
       11:  169:	if (len < old_tail) { /* have no complete word or haven't started
        -:  170:						   * the word yet */
        -:  171:		SHA3_TRACE("because %d<%d, store it and return", (unsigned)len, (unsigned)old_tail);
        -:  172:		/* endian-independent code follows: */
    #####:  173:		while (len--)
    #####:  174:			ctx->saved |= (u64)(*(buf++)) << ((ctx->byteIndex++) * 8);
        -:  175:		SHA3_ASSERT(ctx->byteIndex < 8);
    #####:  176:		return;
        -:  177:	}
        -:  178:
       11:  179:	if (old_tail) { /* will have one word to process */
        -:  180:		SHA3_TRACE("completing one word with %d bytes", (unsigned)old_tail);
        -:  181:		/* endian-independent code follows: */
    #####:  182:		len -= old_tail;
    #####:  183:		while (old_tail--)
    #####:  184:			ctx->saved |= (u64)(*(buf++)) << ((ctx->byteIndex++) * 8);
        -:  185:
        -:  186:		/* now ready to add saved to the sponge */
    #####:  187:		ctx->u.s[ctx->wordIndex] ^= ctx->saved;
        -:  188:		SHA3_ASSERT(ctx->byteIndex == 8);
    #####:  189:		ctx->byteIndex = 0;
    #####:  190:		ctx->saved = 0;
    #####:  191:		if (++ctx->wordIndex == (SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords))) {
    #####:  192:			keccakf(ctx->u.s);
    #####:  193:			ctx->wordIndex = 0;
        -:  194:		}
        -:  195:	}
        -:  196:
        -:  197:	/* now work in full words directly from input */
        -:  198:
        -:  199:	SHA3_ASSERT(ctx->byteIndex == 0);
        -:  200:
       11:  201:	words = len / sizeof(u64);
       11:  202:	tail = len - words * sizeof(u64);
        -:  203:
        -:  204:	SHA3_TRACE("have %d full words to process", (unsigned)words);
        -:  205:
       33:  206:	for (i = 0; i < words; i++, buf += sizeof(u64)) {
       22:  207:		const u64 t = (u64)(buf[0]) | ((u64)(buf[1]) << 8 * 1) | ((u64)(buf[2]) << 8 * 2) |
       22:  208:					  ((u64)(buf[3]) << 8 * 3) | ((u64)(buf[4]) << 8 * 4) |
       22:  209:					  ((u64)(buf[5]) << 8 * 5) | ((u64)(buf[6]) << 8 * 6) |
       22:  210:					  ((u64)(buf[7]) << 8 * 7);
        -:  211:#if defined(__x86_64__) || defined(__i386__)
        -:  212:		SHA3_ASSERT(memcmp(&t, buf, 8) == 0);
        -:  213:#endif
       22:  214:		ctx->u.s[ctx->wordIndex] ^= t;
       22:  215:		if (++ctx->wordIndex == (SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords))) {
    #####:  216:			keccakf(ctx->u.s);
    #####:  217:			ctx->wordIndex = 0;
        -:  218:		}
        -:  219:	}
        -:  220:
        -:  221:	SHA3_TRACE("have %d bytes left to process, save them", (unsigned)tail);
        -:  222:
        -:  223:	/* finally, save the partial word */
        -:  224:	SHA3_ASSERT(ctx->byteIndex == 0 && tail < 8);
       55:  225:	while (tail--) {
        -:  226:		SHA3_TRACE("Store byte %02x '%c'", *buf, *buf);
       44:  227:		ctx->saved |= (u64)(*(buf++)) << ((ctx->byteIndex++) * 8);
        -:  228:	}
        -:  229:	SHA3_ASSERT(ctx->byteIndex < 8);
        -:  230:	SHA3_TRACE("Have saved=0x%016" PRIx64 " at the end", ctx->saved);
        -:  231:}
        -:  232:
        -:  233:/* This is simply the 'update' with the padding block.
        -:  234: * The padding block is 0x01 || 0x00* || 0x80. First 0x01 and last 0x80
        -:  235: * bytes are always present, but they can be the same byte.
        -:  236: */
       11:  237:void const *sha3_Finalize(void *priv) {
       11:  238:	sha3_context *ctx = (sha3_context *)priv;
        -:  239:
        -:  240:	SHA3_TRACE("called with %d bytes in the buffer", ctx->byteIndex);
        -:  241:
        -:  242:	/* Append 2-bit suffix 01, per SHA-3 spec. Instead of 1 for padding we
        -:  243:	 * use 1<<2 below. The 0x02 below corresponds to the suffix 01.
        -:  244:	 * Overall, we feed 0, then 1, and finally 1 to start padding. Without
        -:  245:	 * M || 01, we would simply use 1 to start padding. */
        -:  246:
        -:  247:	u64 t;
        -:  248:
       11:  249:	if (ctx->capacityWords & SHA3_USE_KECCAK_FLAG) {
        -:  250:		/* Keccak version */
    #####:  251:		t = (u64)(((u64)1) << (ctx->byteIndex * 8));
        -:  252:	} else {
        -:  253:		/* SHA3 version */
       11:  254:		t = (u64)(((u64)(0x02 | (1 << 2))) << ((ctx->byteIndex) * 8));
        -:  255:	}
        -:  256:
       11:  257:	ctx->u.s[ctx->wordIndex] ^= ctx->saved ^ t;
        -:  258:
       11:  259:	ctx->u.s[SHA3_KECCAK_SPONGE_WORDS - SHA3_CW(ctx->capacityWords) - 1] ^=
        -:  260:		SHA3_CONST(0x8000000000000000UL);
       11:  261:	keccakf(ctx->u.s);
        -:  262:
        -:  263:	/* Return first bytes of the ctx->s. This conversion is not needed for
        -:  264:	 * little-endian platforms e.g. wrap with #if !defined(__BYTE_ORDER__)
        -:  265:	 * || !defined(__ORDER_LITTLE_ENDIAN__) || __BYTE_ORDER__!=__ORDER_LITTLE_ENDIAN__
        -:  266:	 *    ... the conversion below ...
        -:  267:	 * #endif */
        -:  268:	{
        -:  269:		unsigned i;
      286:  270:		for (i = 0; i < SHA3_KECCAK_SPONGE_WORDS; i++) {
      275:  271:			const unsigned t1 = (uint32_t)ctx->u.s[i];
      275:  272:			const unsigned t2 = (uint32_t)((ctx->u.s[i] >> 16) >> 16);
      275:  273:			ctx->u.sb[i * 8 + 0] = (uint8_t)(t1);
      275:  274:			ctx->u.sb[i * 8 + 1] = (uint8_t)(t1 >> 8);
      275:  275:			ctx->u.sb[i * 8 + 2] = (uint8_t)(t1 >> 16);
      275:  276:			ctx->u.sb[i * 8 + 3] = (uint8_t)(t1 >> 24);
      275:  277:			ctx->u.sb[i * 8 + 4] = (uint8_t)(t2);
      275:  278:			ctx->u.sb[i * 8 + 5] = (uint8_t)(t2 >> 8);
      275:  279:			ctx->u.sb[i * 8 + 6] = (uint8_t)(t2 >> 16);
      275:  280:			ctx->u.sb[i * 8 + 7] = (uint8_t)(t2 >> 24);
        -:  281:		}
        -:  282:	}
        -:  283:
        -:  284:	SHA3_TRACE_BUF("Hash: (first 32 bytes)", ctx->u.sb, 256 / 8);
        -:  285:
       11:  286:	return (ctx->u.sb);
        -:  287:}
        -:  288:
    #####:  289:sha3_return_t sha3_HashBuffer(unsigned bitSize, enum SHA3_FLAGS flags, const void *in,
        -:  290:							  unsigned inBytes, void *out, unsigned outBytes) {
        -:  291:	sha3_return_t err;
        -:  292:	sha3_context c;
        -:  293:
    #####:  294:	err = sha3_Init(&c, bitSize);
    #####:  295:	if (err != SHA3_RETURN_OK)
    #####:  296:		return err;
    #####:  297:	if (sha3_SetFlags(&c, flags) != flags) {
    #####:  298:		return SHA3_RETURN_BAD_PARAMS;
        -:  299:	}
    #####:  300:	sha3_Update(&c, in, inBytes);
    #####:  301:	const void *h = sha3_Finalize(&c);
        -:  302:
    #####:  303:	if (outBytes > bitSize / 8)
    #####:  304:		outBytes = bitSize / 8;
    #####:  305:	memcpy(out, h, outBytes);
    #####:  306:	return SHA3_RETURN_OK;
        -:  307:}
        -:    0:Source:object.c
        -:    0:Graph:object.gcno
        -:    0:Data:object.gcda
        -:    0:Runs:29
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <base/fam_alloc.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <base/resources.h>
        -:   19:#include <pthread.h>
        -:   20:#include <stdatomic.h>
        -:   21:#include <stdio.h>
        -:   22:#include <string.h>
        -:   23:#include <util/object.h>
        -:   24:#include <util/object_macros.h>
        -:   25:#include <util/orbtree.h>
        -:   26:
        -:   27:#define MAX_CLEANUP_STACK_SIZE 100
        -:   28:
        -:   29:typedef struct ORBContext {
        -:   30:	ORBTreeTray tray;
        -:   31:	ORBTreeTray sequence_tray;
        -:   32:	ORBTree *sequence_tree;
        -:   33:	ORBTree *sorted_tree;
        -:   34:	ORBTreeIterator *itt;
        -:   35:	u64 namespace_next;
        -:   36:	atomic_ullong global_namespace_next;
        -:   37:} ORBContext;
        -:   38:
        -:   39:pthread_rwlock_t global_rbtree_lock = PTHREAD_RWLOCK_INITIALIZER;
        -:   40:_Thread_local ORBContext *tl_orb_context = NULL;
        -:   41:_Thread_local u32 has_global_lock = 0;
        -:   42:ORBContext *global_orb_context = NULL;
        -:   43:
        -:   44:typedef struct ObjectValueNc {
        -:   45:	u64 seqno;
        -:   46:	u64 namespace;
        -:   47:	FatPtr name;
        -:   48:	FatPtr value;
        -:   49:	u32 seqno_precision;
        -:   50:} ObjectValueNc;
        -:   51:
     1142:   52:void object_value_cleanup(ObjectValueNc *ptr) {
     1142:   53:	if (!nil(ptr->name))
     1106:   54:		fam_free(&ptr->name);
     1142:   55:	if (!nil(ptr->value))
    #####:   56:		fam_free(&ptr->value);
     1142:   57:}
        -:   58:
        -:   59:#define INIT_OBJECT_VALUE {.name = null, .value = null}
        -:   60:#define ObjectValue ObjectValueNc __attribute__((warn_unused_result, cleanup(object_value_cleanup)))
        -:   61:_Thread_local ObjectValueNc tl_start_range_value = INIT_OBJECT_VALUE;
        -:   62:_Thread_local ObjectValueNc tl_end_range_value = INIT_OBJECT_VALUE;
        -:   63:
     1044:   64:int init_tl_range_values() {
     1044:   65:	if (nil(tl_start_range_value.name)) {
       10:   66:		if (fam_alloc(&tl_start_range_value.name, 1))
    #####:   67:			return -1;
       10:   68:		strcpy($(tl_start_range_value.name), "");
       10:   69:		tl_start_range_value.seqno = 0;
       10:   70:		tl_start_range_value.seqno_precision = 0;
        -:   71:	}
     1044:   72:	if (nil(tl_end_range_value.name)) {
       10:   73:		if (fam_alloc(&tl_end_range_value.name, 1))
    #####:   74:			return -1;
       10:   75:		strcpy($(tl_end_range_value.name), "");
       10:   76:		tl_end_range_value.seqno = 0;
       10:   77:		tl_end_range_value.seqno_precision = 0;
        -:   78:	}
     1044:   79:	return 0;
        -:   80:}
        -:   81:
        -:   82:u64 obj_name_count = 0;
        -:   83:u64 obj_seq_count = 0;
        -:   84:
    34361:   85:int object_property_name_compare(const void *v1, const void *v2) {
        -:   86:	// printf("(name count) = %llu,  seq count  = %llu\n", ++obj_name_count, obj_seq_count);
    34361:   87:	const ObjectValueNc *k1 = v1;
    34361:   88:	const ObjectValueNc *k2 = v2;
    34361:   89:	if (k1->namespace != k2->namespace) {
      154:   90:		if (k1->namespace < k2->namespace)
       73:   91:			return -1;
        -:   92:		else
       81:   93:			return 1;
        -:   94:	} else {
    34207:   95:		int ret = strcmp($(k1->name), $(k2->name));
    34207:   96:		return ret;
        -:   97:	}
        -:   98:}
        -:   99:
    19800:  100:int object_sequence_compare(const void *v1, const void *v2) {
        -:  101:	// printf(" name count  = %llu, (seq count) = %llu\n", obj_name_count, ++obj_seq_count);
    19800:  102:	const ObjectValueNc *k1 = v1;
    19800:  103:	const ObjectValueNc *k2 = v2;
    19800:  104:	if (k1->namespace != k2->namespace) {
       31:  105:		if (k1->namespace < k2->namespace) {
        7:  106:			return -1;
        -:  107:		} else {
       24:  108:			return 1;
        -:  109:		}
        -:  110:	} else {
    19769:  111:		if (k1->seqno < k2->seqno)
    15058:  112:			return -1;
     4711:  113:		else if (k1->seqno > k2->seqno)
     2654:  114:			return 1;
     2057:  115:		if (k1->seqno_precision < k2->seqno_precision)
    #####:  116:			return -1;
     2057:  117:		else if (k1->seqno_precision > k2->seqno_precision)
    #####:  118:			return 1;
     2057:  119:		return 0;
        -:  120:	}
        -:  121:}
        -:  122:
       10:  123:ORBContext *init_orb_context(bool send) {
       10:  124:	ORBContext *ret = mymalloc(sizeof(ORBContext));
       10:  125:	ORBTreeNc *sequence_tree = mymalloc(sizeof(ORBTree));
       10:  126:	ORBTreeNc *sorted_tree = mymalloc(sizeof(ORBTree));
       10:  127:	ORBTreeIteratorNc *itt = mymalloc(sizeof(ORBTreeIterator));
        -:  128:
       10:  129:	if (ret && sequence_tree && sorted_tree && itt) {
       10:  130:		ret->sequence_tree = sequence_tree;
       10:  131:		ret->sorted_tree = sorted_tree;
       10:  132:		ret->itt = itt;
       10:  133:		if (orbtree_create(sequence_tree, sizeof(ObjectValue), object_sequence_compare)) {
    #####:  134:			if (sequence_tree)
    #####:  135:				myfree(sequence_tree);
    #####:  136:			if (ret)
    #####:  137:				myfree(ret);
    #####:  138:			if (sorted_tree)
    #####:  139:				myfree(sorted_tree);
    #####:  140:			if (itt)
    #####:  141:				myfree(itt);
    #####:  142:			return NULL;
        -:  143:		}
        -:  144:
       10:  145:		if (orbtree_create(sorted_tree, sizeof(ObjectValue), object_property_name_compare)) {
    #####:  146:			if (sequence_tree)
    #####:  147:				myfree(sequence_tree);
    #####:  148:			if (ret)
    #####:  149:				myfree(ret);
    #####:  150:			if (sorted_tree)
    #####:  151:				myfree(sorted_tree);
    #####:  152:			if (itt)
    #####:  153:				myfree(itt);
    #####:  154:			return NULL;
        -:  155:		}
        -:  156:
       10:  157:		if (orbtree_iterator(sorted_tree, itt, NULL, false, NULL, false, send)) {
    #####:  158:			if (sequence_tree)
    #####:  159:				myfree(sequence_tree);
    #####:  160:			if (ret)
    #####:  161:				myfree(ret);
    #####:  162:			if (sorted_tree)
    #####:  163:				myfree(sorted_tree);
    #####:  164:			if (itt)
    #####:  165:				myfree(itt);
    #####:  166:			return NULL;
        -:  167:		}
        -:  168:	} else {
    #####:  169:		if (sequence_tree)
    #####:  170:			myfree(sequence_tree);
    #####:  171:		if (ret)
    #####:  172:			myfree(ret);
    #####:  173:		if (sorted_tree)
    #####:  174:			myfree(sorted_tree);
    #####:  175:		if (itt)
    #####:  176:			myfree(itt);
        -:  177:	}
       10:  178:	ret->namespace_next = 1;
       10:  179:	ret->global_namespace_next = 1;
       10:  180:	return ret;
        -:  181:}
        -:  182:
        8:  183:int object_init_global() {
        8:  184:	if (init_tl_range_values())
    #####:  185:		return -1;
        8:  186:	if (global_orb_context == NULL) {
        2:  187:		if (pthread_rwlock_wrlock(&global_rbtree_lock))
    #####:  188:			panic("rwlock error!");
        2:  189:		if (global_orb_context == NULL) {
        2:  190:			global_orb_context = init_orb_context(true);
        -:  191:		}
        -:  192:
        2:  193:		if (pthread_rwlock_unlock(&global_rbtree_lock))
    #####:  194:			panic("rwlock error!");
        2:  195:		if (global_orb_context == NULL)
    #####:  196:			return -1;
        -:  197:	}
        8:  198:	return 0;
        -:  199:}
        -:  200:
     1036:  201:int object_init_local() {
     1036:  202:	if (init_tl_range_values())
    #####:  203:		return -1;
     1036:  204:	if (tl_orb_context == NULL) {
        8:  205:		tl_orb_context = init_orb_context(false);
        8:  206:		if (tl_orb_context == NULL)
    #####:  207:			return -1;
        -:  208:	}
     1036:  209:	return 0;
        -:  210:}
        -:  211:
        -:  212:typedef struct ObjectValueData {
        -:  213:	ObjectType type;
        -:  214:	u32 pad;
        -:  215:	u8 value[];
        -:  216:} ObjectValueData;
        -:  217:
        -:  218:typedef struct ObjectImpl {
        -:  219:	FatPtr self;
        -:  220:	u64 namespace;
        -:  221:	u64 seqno;
        -:  222:	ObjectType type;
        -:  223:	u32 property_count;
        -:  224:	u64 property_seqno_next;
        -:  225:	bool send;
        -:  226:	u8 data[];
        -:  227:} ObjectImpl;
        -:  228:
     5202:  229:void object_cleanup(const Object *ptr) {
     5202:  230:	if (ptr == NULL || nil(ptr->impl) || ptr->flags & OBJECT_FLAG_NO_CLEANUP)
     3110:  231:		return;
        -:  232:#if defined(__clang__)
        -:  233:// Clang-specific pragma
        -:  234:#pragma GCC diagnostic push
        -:  235:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  236:#elif defined(__GNUC__) && !defined(__clang__)
        -:  237:// GCC-specific pragma
        -:  238:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  239:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  240:#else
        -:  241:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  242:#endif
     2092:  243:	ObjectNc *ptr_mut = ptr;
        -:  244:#pragma GCC diagnostic pop
     2092:  245:	if (nil(ptr_mut->impl)) {
    #####:  246:		return;
        -:  247:	}
        -:  248:
     2092:  249:	ObjectImpl *impl = $(ptr_mut->impl);
     2092:  250:	if (!nil(ptr_mut->impl)) {
     2092:  251:		rc_cleanup(&ptr_mut->impl);
     2092:  252:		ptr_mut->impl.impl = null;
        -:  253:	}
        -:  254:}
        -:  255:
     2132:  256:ORBContext *object_get_context_and_lock(const ObjectImpl *impl) {
    2132*:  257:	assert(impl);
     2132:  258:	bool send = impl->send;
     2132:  259:	if (send) {
       30:  260:		if (!has_global_lock && pthread_rwlock_wrlock(&global_rbtree_lock))
    #####:  261:			panic("rwlock error!");
       30:  262:		has_global_lock++;
       30:  263:		return global_orb_context;
        -:  264:	} else {
     2102:  265:		return tl_orb_context;
        -:  266:	}
        -:  267:}
        -:  268:
     2131:  269:void object_unlock(const ObjectImpl *impl) {
    2131*:  270:	assert(impl);
     2131:  271:	bool send = impl->send;
     2131:  272:	if (send) {
       30:  273:		if (--has_global_lock == 0)
       30:  274:			if (pthread_rwlock_unlock(&global_rbtree_lock))
    #####:  275:				panic("rwlock error!");
        -:  276:	}
     2131:  277:}
        -:  278:
     1044:  279:void object_cleanup_rc(ObjectImpl *impl) {
    1044*:  280:	assert(impl);
     1044:  281:	if (!nil(impl->self)) {
     1044:  282:		fam_free(&impl->self);
     1044:  283:		impl->self = null;
        -:  284:	}
     1044:  285:	if (impl->property_count) {
       22:  286:		u64 size = impl->property_count;
       22:  287:		if (size > MAX_CLEANUP_STACK_SIZE)
        1:  288:			size = 1;
       22:  289:		ObjectNc *to_cleanup_stack[size];
        -:  290:		ObjectNc **to_cleanup;
       22:  291:		if (impl->property_count > MAX_CLEANUP_STACK_SIZE) {
        1:  292:			to_cleanup = mymalloc(impl->property_count * sizeof(Object *));
        1:  293:			if (to_cleanup == NULL)
    #####:  294:				panic("Could not allocate enoough memory to cleanup!");
        -:  295:		} else
       21:  296:			to_cleanup = (ObjectNc **)to_cleanup_stack;
       22:  297:		u64 cleanup_count = 0;
       22:  298:		tl_start_range_value.namespace = impl->namespace;
       22:  299:		tl_end_range_value.namespace = impl->namespace + 1;
        -:  300:
       22:  301:		bool send = impl->send;
        -:  302:
       22:  303:		FatPtr *properties_stack[size];
        -:  304:		FatPtr **properties;
        -:  305:
       22:  306:		if (impl->property_count > MAX_CLEANUP_STACK_SIZE) {
        1:  307:			properties = mymalloc(impl->property_count * sizeof(FatPtr *));
        1:  308:			if (properties == NULL)
    #####:  309:				panic("Could not allocate enoough memory to cleanup!");
        -:  310:		} else
       21:  311:			properties = properties_stack;
        -:  312:
       22:  313:		ORBContext *ctx = object_get_context_and_lock(impl);
       22:  314:		ORBTreeIteratorNc *itt = ctx->itt;
       22:  315:		ORBTreeNc *tree = ctx->sorted_tree;
       22:  316:		ORBTreeNc *sequence_tree = ctx->sequence_tree;
        -:  317:
      22*:  318:		assert(
        -:  319:			!orbtree_iterator_reset(itt, &tl_start_range_value, true, &tl_end_range_value, false));
        -:  320:
       22:  321:		u64 i = 0;
     1059:  322:		while (orbtree_iterator_next(itt, &ctx->tray)) {
     1037:  323:			ObjectValueNc *v = ctx->tray.value;
     1037:  324:			char *nx = $(v->name);
     1037:  325:			u64 seqno = v->seqno;
     1037:  326:			properties[i] = &v->name;
     1037:  327:			i++;
        -:  328:		}
      22*:  329:		assert(i == impl->property_count);
        -:  330:
     1059:  331:		for (i = 0; i < impl->property_count; i++) {
     1037:  332:			ObjectValueNc value = INIT_OBJECT_VALUE;
     1037:  333:			value.namespace = impl->namespace;
     1037:  334:			value.name = *properties[i];
    1037*:  335:			assert(!orbtree_remove(tree, &value, &ctx->tray));
     1037:  336:			ObjectValueNc *rem = ctx->tray.value;
    1037*:  337:			assert(rem);
     1037:  338:			u64 seqno = rem->seqno;
     1037:  339:			u32 precision = rem->seqno_precision;
     1037:  340:			ObjectValueData *obj_data = $(rem->value);
    1037*:  341:			assert(obj_data);
     1037:  342:			if (obj_data->type == ObjectTypeObject) {
     1028:  343:				to_cleanup[cleanup_count++] = (ObjectNc *)obj_data->value;
        -:  344:			}
        -:  345:
     1037:  346:			fam_free(&rem->value);
     1037:  347:			fam_free(&rem->name);
    1037*:  348:			assert(!orbtree_deallocate_tray(tree, &ctx->tray));
        -:  349:
     1037:  350:			value.seqno = seqno;
     1037:  351:			value.seqno_precision = precision;
    1037*:  352:			assert(!orbtree_remove(sequence_tree, &value, &ctx->tray));
     1037:  353:			rem = ctx->tray.value;
     1037:  354:			fam_free(&rem->value);
     1037:  355:			fam_free(&rem->name);
        -:  356:
    1037*:  357:			assert(!orbtree_deallocate_tray(sequence_tree, &ctx->tray));
        -:  358:		}
        -:  359:
       22:  360:		object_unlock(impl);
        -:  361:
     1050:  362:		for (i = 0; i < cleanup_count; i++) {
     1028:  363:			object_cleanup(to_cleanup[i]);
        -:  364:		}
        -:  365:
       22:  366:		if (impl->property_count > MAX_CLEANUP_STACK_SIZE) {
        1:  367:			myfree(to_cleanup);
        1:  368:			myfree(properties);
        -:  369:		}
        -:  370:	}
     1044:  371:}
        -:  372:
     6251:  373:void object_check_consumed(const Object *ptr) {
     6251:  374:	if (ptr == NULL)
    #####:  375:		panic("Object pointer NULL!");
     6251:  376:	u8 flags = ptr->flags;
     6251:  377:	bool consumed = flags & OBJECT_FLAG_CONSUMED;
     6251:  378:	if (consumed)
    #####:  379:		panic("Object has been consumed!");
     6251:  380:	if (nil(ptr->impl))
    #####:  381:		panic("Object is nil!");
     6251:  382:}
        -:  383:
        -:  384:// move the object to a new memory location
     1035:  385:Object object_move(const Object *src) {
     1035:  386:	object_check_consumed(src);
     1035:  387:	ObjectNc dst = {.flags = src->flags, .impl = src->impl};
        -:  388:#if defined(__clang__)
        -:  389:// Clang-specific pragma
        -:  390:#pragma GCC diagnostic push
        -:  391:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  392:#elif defined(__GNUC__) && !defined(__clang__)
        -:  393:// GCC-specific pragma
        -:  394:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  395:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  396:#else
        -:  397:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  398:#endif
     1035:  399:	ObjectNc *src_mut = src;
        -:  400:#pragma GCC diagnostic pop
     1035:  401:	src_mut->flags |= OBJECT_FLAG_NO_CLEANUP | OBJECT_FLAG_CONSUMED;
        -:  402:
     1035:  403:	return dst;
        -:  404:}
        -:  405:
        -:  406:// create a reference counted reference of the object
     1047:  407:Object object_ref(const Object *src) {
     1047:  408:	object_check_consumed(src);
     1047:  409:	ObjectNc dst = {.flags = src->flags, .impl = rc_null};
     1047:  410:	rc_clone(&dst.impl, &src->impl);
     1047:  411:	return dst;
        -:  412:}
        -:  413:
     4232:  414:bool object_is_send(const Object *obj) {
     4232:  415:	return (obj->flags & OBJECT_FLAG_SEND) != 0;
        -:  416:}
        -:  417:
     3164:  418:int object_value_for(ObjectValue *value, const Object *obj, const char *name, u64 seqno,
        -:  419:					 u32 seqno_precision) {
     3164:  420:	const ObjectImpl *impl = $(obj->impl);
     3164:  421:	if (name) {
     3164:  422:		bool send = object_is_send(obj);
        -:  423:		{
     6328:  424:			SendStateGuard _ = SetSend(send);
     3164:  425:			if (fam_alloc(&value->name, sizeof(char) * (1 + strlen(name))))
    #####:  426:				return -1;
        -:  427:		}
        -:  428:
     3164:  429:		strcpy($(value->name), name);
        -:  430:	}
     3164:  431:	value->namespace = impl->namespace;
     3164:  432:	value->seqno = seqno;
     3164:  433:	value->seqno_precision = seqno_precision;
        -:  434:
     3164:  435:	return 0;
        -:  436:}
        -:  437:
     1085:  438:ObjectValueNc *object_get_property_value(ORBContext *ctx, const Object *obj, const char *name,
        -:  439:										 bool remove) {
     1085:  440:	ORBTreeNc *sorted_tree = ctx->sorted_tree;
     1085:  441:	ORBTreeNc *sequence_tree = ctx->sequence_tree;
     1085:  442:	ctx->tray.updated = false;
        -:  443:
     1085:  444:	ObjectImpl *impl = $(obj->impl);
     1085:  445:	if (impl == NULL) {
    #####:  446:		SetErr(IllegalState);
    #####:  447:		return NULL;
        -:  448:	}
        -:  449:
     1085:  450:	ObjectValue objvalue = INIT_OBJECT_VALUE;
     1085:  451:	if (object_value_for(&objvalue, obj, name, -1, 0))
    #####:  452:		return NULL;
        -:  453:	int v;
     1085:  454:	if (remove) {
        3:  455:		v = orbtree_remove(sorted_tree, &objvalue, &ctx->tray);
        3:  456:		if (v == 0 && ctx->tray.updated) {
        2:  457:			ObjectValueNc *rem = ctx->tray.value;
        2:  458:			u64 seqno = rem->seqno;
        2:  459:			u32 precision = rem->seqno_precision;
        2:  460:			ObjectValueData *obj_data = $(rem->value);
       2*:  461:			assert(obj_data);
        2:  462:			fam_free(&rem->name);
       2*:  463:			assert(!orbtree_deallocate_tray(sorted_tree, &ctx->tray));
        2:  464:			objvalue.seqno = seqno;
        2:  465:			objvalue.seqno_precision = precision;
        2:  466:			ctx->sequence_tray.updated = false;
       2*:  467:			assert(!orbtree_remove(sequence_tree, &objvalue, &ctx->sequence_tray));
       2*:  468:			assert(ctx->sequence_tray.updated);
        -:  469:
        2:  470:			ObjectValueNc *sequence_rem = ctx->sequence_tray.value;
        2:  471:			fam_free(&sequence_rem->name);
        2:  472:			fam_free(&sequence_rem->value);
        -:  473:
       2*:  474:			assert(!orbtree_deallocate_tray(sequence_tree, &ctx->sequence_tray));
        -:  475:		}
        -:  476:	} else {
     1082:  477:		v = orbtree_get(sorted_tree, &objvalue, &ctx->tray);
        -:  478:	}
        -:  479:
     1085:  480:	if (v || !ctx->tray.updated)
     1042:  481:		return NULL;
        -:  482:
       43:  483:	ObjectValueNc *valueret = ctx->tray.value;
       43:  484:	return valueret;
        -:  485:}
        -:  486:
     1082:  487:ObjectValueData *object_get_property_data(ORBContext *ctx, const Object *obj, const char *name,
        -:  488:										  bool remove) {
     1082:  489:	ObjectValueNc *valueret = object_get_property_value(ctx, obj, name, remove);
     1082:  490:	if (valueret != NULL) {
       40:  491:		ObjectValueData *valueretdata = $(valueret->value);
       40:  492:		return valueretdata;
        -:  493:	} else
     1042:  494:		return NULL;
        -:  495:}
        -:  496:
     1042:  497:int object_set_property_value(Object *obj, const char *name, const void *value, u64 size,
        -:  498:							  ObjectType type) {
     1042:  499:	Object to_cleanup = NIL;
     1042:  500:	if (obj == NULL || name == NULL || value == NULL) {
    #####:  501:		SetErr(IllegalArgument);
    #####:  502:		return -1;
        -:  503:	}
        -:  504:
     1042:  505:	bool send = object_is_send(obj);
     1042:  506:	ObjectImpl *impl = $(obj->impl);
     1042:  507:	if (impl == NULL) {
    #####:  508:		SetErr(IllegalState);
    #####:  509:		return -1;
        -:  510:	}
        -:  511:
     1042:  512:	int ret = 0;
     1042:  513:	ORBContext *ctx = object_get_context_and_lock(impl);
        -:  514:
        -:  515:	// first check if it is in the object
     1042:  516:	ObjectValueData *vd = object_get_property_data(ctx, obj, name, false);
        -:  517:
     1042:  518:	if (vd) {
        3:  519:		if (vd->type == ObjectTypeObject) {
        3:  520:			to_cleanup = *(Object *)vd->value;
        -:  521:		}
        -:  522:
        3:  523:		ObjectValueNc *valueret = object_get_property_value(ctx, obj, name, false);
        -:  524:
        -:  525:		// it exists, overwrite it
        3:  526:		memcpy(vd->value, value, size);
        -:  527:
        -:  528:	} else {
        -:  529:		// it doesn't exist, insert it
     1039:  530:		int res1 = orbtree_allocate_tray(ctx->sorted_tree, &ctx->tray);
     1039:  531:		int res2 = orbtree_allocate_tray(ctx->sequence_tree, &ctx->sequence_tray);
        -:  532:
     1039:  533:		if (res1 || res2) {
    #####:  534:			orbtree_deallocate_tray(ctx->sorted_tree, &ctx->tray);
    #####:  535:			orbtree_deallocate_tray(ctx->sequence_tree, &ctx->sequence_tray);
        -:  536:		}
        -:  537:
     2078:  538:		if (res1 == 0 && res2 == 0) {
        -:  539:
     1039:  540:			ObjectValueNc val = INIT_OBJECT_VALUE;
     1039:  541:			ObjectValueNc val2 = INIT_OBJECT_VALUE;
     1039:  542:			int res3 = object_value_for(&val, obj, name, impl->property_seqno_next, 0);
     1039:  543:			int res4 = object_value_for(&val2, obj, name, impl->property_seqno_next, 0);
     1039:  544:			impl->property_seqno_next++;
        -:  545:
     1039:  546:			int fres1 = fam_alloc(&val.value, sizeof(ObjectValueData) + size);
     1039:  547:			int fres2 = fam_alloc(&val2.value, sizeof(ObjectValueData) + size);
        -:  548:
     1039:  549:			if (fres1 || fres2) {
    #####:  550:				fam_free(&val.value);
    #####:  551:				fam_free(&val2.value);
    #####:  552:				orbtree_deallocate_tray(ctx->sorted_tree, &ctx->tray);
    #####:  553:				orbtree_deallocate_tray(ctx->sequence_tree, &ctx->sequence_tray);
    #####:  554:				ret = -1;
        -:  555:			} else {
        -:  556:
     1039:  557:				ObjectValueData *objdata = $(val.value);
     1039:  558:				objdata->type = type;
     1039:  559:				ObjectValueData *objdata2 = $(val2.value);
     1039:  560:				objdata2->type = type;
        -:  561:
     1039:  562:				memcpy(objdata->value, value, size);
     1039:  563:				memcpy(objdata2->value, value, size);
        -:  564:
     1039:  565:				if (res3 == 0) {
     1039:  566:					memcpy(ctx->tray.value, &val, sizeof(ObjectValue));
     1039:  567:					memcpy(ctx->sequence_tray.value, &val2, sizeof(ObjectValue));
     1039:  568:					ORBTreeTray retval = {.updated = false};
     1039:  569:					int res5 = orbtree_put(ctx->sorted_tree, &ctx->tray, &retval);
    1039*:  570:					assert(!retval.updated);
    1039*:  571:					assert(!res5);
     1039:  572:					int res6 = orbtree_put(ctx->sequence_tree, &ctx->sequence_tray, &retval);
    1039*:  573:					assert(!retval.updated);
    1039*:  574:					assert(!res6);
     1039:  575:					impl->property_count++;
        -:  576:				} else {
    #####:  577:					ret = -1;
        -:  578:				}
        -:  579:			}
        -:  580:
        -:  581:		} else {
    #####:  582:			ret = -1;
        -:  583:		}
        -:  584:	}
        -:  585:
     1042:  586:	object_unlock(impl);
        -:  587:
     1042:  588:	return ret;
        -:  589:}
        -:  590:
     1044:  591:Object object_create(bool send, ObjectType type, const void *primitive) {
     1044:  592:	if (send) {
        8:  593:		if (object_init_global()) {
    #####:  594:			return NIL;
        -:  595:		}
        -:  596:
        -:  597:	} else {
     1036:  598:		if (object_init_local()) {
    #####:  599:			return NIL;
        -:  600:		}
        -:  601:	}
        -:  602:
     1044:  603:	u64 data_size = 0;
     1044:  604:	if (type == ObjectTypeU64) {
     1021:  605:		data_size = sizeof(u64);
        -:  606:	}
        -:  607:
     1044:  608:	FatPtr ptr = null;
        -:  609:	{
     2088:  610:		SendStateGuard _ = SetSend(send);
     1044:  611:		if (fam_alloc(&ptr, sizeof(ObjectImpl) + data_size)) {
    #####:  612:			return NIL;
        -:  613:		}
        -:  614:	}
        -:  615:
     1044:  616:	ObjectImpl *impl = $(ptr);
     1044:  617:	impl->send = send;
     1044:  618:	impl->self = ptr;
        -:  619:	ORBContext *ctx;
        -:  620:
     1044:  621:	if (send) {
        8:  622:		ctx = global_orb_context;
        8:  623:		impl->namespace = atomic_fetch_add(&ctx->global_namespace_next, 1);
        -:  624:	} else {
     1036:  625:		ctx = tl_orb_context;
     1036:  626:		impl->namespace = ctx->namespace_next;
     1036:  627:		ctx->namespace_next++;
        -:  628:	}
     1044:  629:	ObjectNc obj = {.flags = 0};
     1044:  630:	if (send)
        8:  631:		obj.flags |= OBJECT_FLAG_SEND;
        -:  632:
     1044:  633:	impl->type = type;
     1044:  634:	impl->property_count = 0;
     1044:  635:	impl->property_seqno_next = 0;
        -:  636:
     1044:  637:	if (type == ObjectTypeU64) {
     1021:  638:		memcpy(impl->data, primitive, sizeof(u64));
        -:  639:	}
        -:  640:
     1044:  641:	if (rc_build(&obj.impl, impl, sizeof(ObjectImpl) + data_size, false,
        -:  642:				 (void (*)(void *))object_cleanup_rc)) {
    #####:  643:		fam_free(&ptr);
    #####:  644:		return NIL;
        -:  645:	}
        -:  646:
     1044:  647:	u64 size = 0;
     1044:  648:	if (type == ObjectTypeString) {
        9:  649:		size = sizeof(char) * (1 + strlen((char *)primitive));
        -:  650:	} else if (type == ObjectTypeU64) {
        -:  651:	}
        -:  652:
     1044:  653:	if (size) {
        9:  654:		if (object_set_property_value(&obj, "value", primitive, size, type)) {
    #####:  655:			object_cleanup(&obj);
    #####:  656:			return NIL;
        -:  657:		}
        -:  658:	}
        -:  659:
     1044:  660:	return obj;
        -:  661:}
        -:  662:
    #####:  663:ObjectType object_type(const Object *obj) {
    #####:  664:	object_check_consumed(obj);
    #####:  665:	ObjectImpl *impl = $(obj->impl);
    #####:  666:	return impl->type;
        -:  667:}
        -:  668:
    #####:  669:int object_send(Object *obj, Channel *channel) {
    #####:  670:	return 0;
        -:  671:}
        -:  672:
        6:  673:i64 object_properties(const Object *obj) {
        6:  674:	object_check_consumed(obj);
        6:  675:	ObjectImpl *impl = $(obj->impl);
        6:  676:	return impl->property_count;
        -:  677:}
     1033:  678:Object object_set_property(Object *obj, const char *name, const Object *value) {
     1033:  679:	object_check_consumed(obj);
     1033:  680:	object_check_consumed(value);
     1033:  681:	ObjectNc vmove = object_move(value);
     1033:  682:	if (object_set_property_value(obj, name, &vmove, sizeof(Object), ObjectTypeObject))
    #####:  683:		return NIL;
     1033:  684:	return UNIT;
        -:  685:}
        -:  686:
       23:  687:Object object_get_property(const Object *obj, const char *name) {
       23:  688:	if (obj == NULL || name == NULL) {
    #####:  689:		SetErr(IllegalArgument);
    #####:  690:		return NIL;
        -:  691:	}
       23:  692:	object_check_consumed(obj);
        -:  693:
       23:  694:	bool send = object_is_send(obj);
       23:  695:	ObjectImpl *impl = $(obj->impl);
       23:  696:	if (impl == NULL) {
    #####:  697:		SetErr(IllegalState);
    #####:  698:		return NIL;
        -:  699:	}
        -:  700:
       23:  701:	ORBContext *ctx = object_get_context_and_lock(impl);
       23:  702:	const ObjectValueData *vd = object_get_property_data(ctx, obj, name, false);
       23:  703:	object_unlock(impl);
        -:  704:
       23:  705:	if (vd == NULL)
        2:  706:		return NIL;
       21:  707:	ObjectNc ret = *(Object *)vd->value;
        -:  708:
       21:  709:	return object_ref(&ret);
        -:  710:}
        -:  711:
        3:  712:Object object_remove_property(Object *obj, const char *name) {
        3:  713:	if (obj == NULL || name == NULL) {
    #####:  714:		SetErr(IllegalArgument);
    #####:  715:		return NIL;
        -:  716:	}
        3:  717:	object_check_consumed(obj);
        -:  718:
        3:  719:	bool send = object_is_send(obj);
        3:  720:	ObjectImpl *impl = $(obj->impl);
        3:  721:	if (impl == NULL) {
    #####:  722:		SetErr(IllegalState);
    #####:  723:		return NIL;
        -:  724:	}
        -:  725:
        3:  726:	ORBContext *ctx = object_get_context_and_lock(impl);
        3:  727:	const ObjectValueData *vd = object_get_property_data(ctx, obj, name, true);
        3:  728:	if (vd != NULL) {
        2:  729:		impl->property_count--;
        -:  730:
        2:  731:		ObjectNc *ret = (Object *)vd->value;
        -:  732:
        2:  733:		ObjectNc ref_ret = object_move(ret);
        2:  734:		ObjectValueNc *rem = ctx->tray.value;
        2:  735:		fam_free(&rem->value);
        2:  736:		object_unlock(impl);
        2:  737:		return ref_ret;
        -:  738:	}
        1:  739:	object_unlock(impl);
        -:  740:
        1:  741:	return NIL;
        -:  742:}
        -:  743:
     1028:  744:ObjectValue *object_get_property_index_impl(ORBContext *ctx, const Object *obj, u32 index,
        -:  745:											ObjectIndexType itype) {
     1028:  746:	object_check_consumed(obj);
        -:  747:
     1028:  748:	ObjectImpl *impl = $(obj->impl);
        -:  749:
     1028:  750:	if (impl == NULL) {
    #####:  751:		SetErr(IllegalState);
    #####:  752:		return NULL;
        -:  753:	}
        -:  754:
        -:  755:	ORBTreeNc *tree;
     1028:  756:	if (itype == ObjectIndexTypeSequential)
     1018:  757:		tree = ctx->sequence_tree;
        -:  758:	else
       10:  759:		tree = ctx->sorted_tree;
        -:  760:
     1028:  761:	ctx->tray.updated = false;
     1028:  762:	tl_start_range_value.namespace = impl->namespace;
     1028:  763:	int v = orbtree_get_index_ranged(tree, index, &ctx->tray, &tl_start_range_value, true);
        -:  764:
     1028:  765:	if (v || !ctx->tray.updated) {
        1:  766:		return NULL;
        -:  767:	}
        -:  768:
     1027:  769:	ObjectValueNc *valueret = ctx->tray.value;
        -:  770:
     1027:  771:	if (valueret->namespace != impl->namespace) {
    #####:  772:		return NULL;
        -:  773:	}
     1027:  774:	return valueret;
        -:  775:}
        -:  776:
     1026:  777:Object object_get_property_index(const Object *obj, u32 index, ObjectIndexType itype) {
        -:  778:	ObjectNc ret;
        -:  779:	{
     1026:  780:		ObjectImpl *impl = $(obj->impl);
        -:  781:
     1026:  782:		if (impl == NULL) {
    #####:  783:			SetErr(IllegalState);
    #####:  784:			return NIL;
        -:  785:		}
     1026:  786:		ORBContext *ctx = object_get_context_and_lock(impl);
     1026:  787:		const ObjectValueNc *valueret = object_get_property_index_impl(ctx, obj, index, itype);
     1026:  788:		object_unlock(impl);
     1026:  789:		if (valueret == NULL) {
        1:  790:			return NIL;
        -:  791:		}
     1025:  792:		ObjectValueData *vd = $(valueret->value);
     1025:  793:		ret = *(Object *)vd->value;
     1025:  794:		if (nil(ret)) {
    #####:  795:			return NIL;
        -:  796:		}
        -:  797:	}
     1025:  798:	return object_ref(&ret);
        -:  799:}
        -:  800:
        1:  801:Object object_remove_property_index(Object *obj, u32 index, ObjectIndexType itype) {
        1:  802:	ObjectImpl *impl = $(obj->impl);
        -:  803:
        1:  804:	if (impl == NULL) {
    #####:  805:		SetErr(IllegalState);
    #####:  806:		return NIL;
        -:  807:	}
        -:  808:
        1:  809:	ORBContext *ctx = object_get_context_and_lock(impl);
        -:  810:
        1:  811:	ObjectValueNc *valueret = object_get_property_index_impl(ctx, obj, index, itype);
        1:  812:	ObjectValueData *vd = $(valueret->value);
        1:  813:	if (vd == NULL) {
        -:  814:
    #####:  815:		return NIL;
        -:  816:	}
        -:  817:
        1:  818:	const char *name = $(valueret->name);
        2:  819:	let res = object_remove_property(obj, name);
        1:  820:	if (nil(res)) {
    #####:  821:		return NIL;
        -:  822:	}
        -:  823:
        1:  824:	return object_ref(&res);
        -:  825:}
        -:  826:
        1:  827:Object object_set_property_index(Object *obj, u32 index, const Object *value,
        -:  828:								 ObjectIndexType itype) {
        1:  829:	ObjectImpl *impl = $(obj->impl);
        -:  830:
        1:  831:	if (impl == NULL) {
    #####:  832:		SetErr(IllegalState);
    #####:  833:		return NIL;
        -:  834:	}
        -:  835:
        1:  836:	ORBContext *ctx = object_get_context_and_lock(impl);
        1:  837:	const ObjectValueNc *valueret = object_get_property_index_impl(ctx, obj, index, itype);
        -:  838:
        -:  839:	ObjectValueData *vd;
        2:  840:	if (valueret == NULL || valueret->namespace != impl->namespace ||
        1:  841:		(vd = $(valueret->value)) == NULL) {
    #####:  842:		object_unlock(impl);
    #####:  843:		return NIL;
        -:  844:	}
        -:  845:
        1:  846:	const char *name = $(valueret->name);
        1:  847:	ObjectValueNc *obj_val = ctx->tray.value;
        1:  848:	ObjectValueData *obj_data = $(obj_val->value);
        1:  849:	Object to_cleanup;
        1:  850:	memcpy(&to_cleanup, obj_data->value, sizeof(Object));
        1:  851:	memcpy(obj_data->value, value, sizeof(Object));
        -:  852:
        1:  853:	ctx->tray.updated = false;
        2:  854:	ObjectValue objvalue = INIT_OBJECT_VALUE;
        1:  855:	object_value_for(&objvalue, obj, name, -1, 0);
        -:  856:
        1:  857:	orbtree_get(ctx->sorted_tree, &objvalue, &ctx->tray);
       1*:  858:	assert(ctx->tray.updated);
        1:  859:	obj_val = ctx->tray.value;
        1:  860:	obj_data = $(obj_val->value);
        1:  861:	memcpy(obj_data->value, value, sizeof(Object));
        -:  862:
        1:  863:	object_unlock(impl);
        -:  864:
        1:  865:	return UNIT;
        -:  866:}
        -:  867:
    #####:  868:Object object_insert_property_before_index(Object *obj, u32 index, const char *name,
        -:  869:										   const Object *value, ObjectIndexType itype) {
    #####:  870:	return NIL;
        -:  871:}
        -:  872:
       14:  873:const char *object_as_string(const Object *obj) {
       14:  874:	object_check_consumed(obj);
       14:  875:	ObjectImpl *impl = $(obj->impl);
       14:  876:	ORBContext *ctx = object_get_context_and_lock(impl);
       14:  877:	const ObjectValueData *v = object_get_property_data(ctx, obj, "value", false);
       14:  878:	object_unlock(impl);
       14:  879:	if (v == NULL || v->type != ObjectTypeString) {
    #####:  880:		SetErr(ExpectedTypeMismatch);
    #####:  881:		return NULL;
        -:  882:	}
        -:  883:
       14:  884:	return (char *)v->value;
        -:  885:}
     1029:  886:u64 object_as_u64(const Object *obj) {
     1029:  887:	object_check_consumed(obj);
     1029:  888:	ObjectImpl *impl = $(obj->impl);
        -:  889:	u64 value;
     1029:  890:	memcpy(&value, impl->data, sizeof(u64));
     1029:  891:	return value;
        -:  892:}
        -:  893:
       28:  894:void object_cleanup_thread_local() {
       28:  895:	object_value_cleanup(&tl_start_range_value);
       28:  896:	object_value_cleanup(&tl_end_range_value);
       28:  897:	if (tl_orb_context != NULL) {
        8:  898:		orbtree_iterator_cleanup(tl_orb_context->itt);
        8:  899:		orbtree_cleanup(tl_orb_context->sorted_tree);
        8:  900:		orbtree_cleanup(tl_orb_context->sequence_tree);
        8:  901:		myfree(tl_orb_context->sequence_tree);
        8:  902:		myfree(tl_orb_context->itt);
        8:  903:		myfree(tl_orb_context->sorted_tree);
        8:  904:		myfree(tl_orb_context);
        -:  905:	}
       28:  906:}
        -:  907:
        -:  908:#ifdef TEST
       56:  909:i64 get_thread_local_orbtree_alloc_count() {
       56:  910:	if (tl_orb_context == NULL)
       40:  911:		return 0;
       16:  912:	return orbtree_slabs(tl_orb_context->sorted_tree);
        -:  913:}
       56:  914:i64 get_global_orbtree_alloc_count() {
       56:  915:	if (global_orb_context == NULL)
       52:  916:		return 0;
        4:  917:	return orbtree_slabs(global_orb_context->sorted_tree);
        -:  918:}
       59:  919:u64 get_thread_local_orbtree_size() {
       59:  920:	if (tl_orb_context == NULL)
       40:  921:		return 0;
       19:  922:	return orbtree_size(tl_orb_context->sorted_tree);
        -:  923:}
       59:  924:u64 get_global_orbtree_size() {
       59:  925:	if (global_orb_context == NULL)
       52:  926:		return 0;
        7:  927:	return orbtree_size(global_orb_context->sorted_tree);
        -:  928:}
        -:  929:
       28:  930:i64 get_thread_local_orbtree_seq_alloc_count() {
       28:  931:	if (tl_orb_context == NULL)
       20:  932:		return 0;
        8:  933:	return orbtree_slabs(tl_orb_context->sequence_tree);
        -:  934:}
       28:  935:i64 get_global_orbtree_seq_alloc_count() {
       28:  936:	if (global_orb_context == NULL)
       26:  937:		return 0;
        2:  938:	return orbtree_slabs(global_orb_context->sequence_tree);
        -:  939:}
       28:  940:u64 get_thread_local_orbtree_seq_size() {
       28:  941:	if (tl_orb_context == NULL)
       20:  942:		return 0;
        8:  943:	return orbtree_size(tl_orb_context->sequence_tree);
        -:  944:}
       28:  945:u64 get_global_orbtree_seq_size() {
       28:  946:	if (global_orb_context == NULL)
       26:  947:		return 0;
        2:  948:	return orbtree_size(global_orb_context->sequence_tree);
        -:  949:}
        -:  950:
       28:  951:void object_cleanup_global() {
       28:  952:	if (global_orb_context != NULL) {
        2:  953:		orbtree_iterator_cleanup(global_orb_context->itt);
        2:  954:		orbtree_cleanup(global_orb_context->sorted_tree);
        2:  955:		orbtree_cleanup(global_orb_context->sequence_tree);
        2:  956:		myfree(global_orb_context->sequence_tree);
        2:  957:		myfree(global_orb_context->itt);
        2:  958:		myfree(global_orb_context->sorted_tree);
        2:  959:		myfree(global_orb_context);
        -:  960:	}
       28:  961:}
        -:  962:#endif // TEST
        -:    0:Source:orbtree.c
        -:    0:Graph:orbtree.gcno
        -:    0:Data:orbtree.gcda
        -:    0:Runs:29
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <base/fam_alloc.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <base/resources.h>
        -:   19:#include <crypto/murmurhash.h>
        -:   20:#include <stdio.h>
        -:   21:#include <string.h>
        -:   22:#include <util/orbtree.h>
        -:   23:
        -:   24:#define NODES_PER_CHUNK 1024
        -:   25:#define CHUNKS_PER_RESIZE 64
        -:   26:#define ITERATOR_STACK_SIZE 128
        -:   27:#define CACHE_ENTRIES 128
        -:   28:#define MURMUR_SEED 0xF9
        -:   29:
        -:   30:u64 orbtree_next_node_id = 10;
        -:   31:
        -:   32:#define RED_MASK 0x80000000
        -:   33:
        -:   34:#define SET_RED(impl, id)                                                                          \
        -:   35:	({                                                                                             \
        -:   36:		ORBTreeNode *_orb_node__ = orbtree_node(impl, id);                                         \
        -:   37:		_orb_node__->color |= RED_MASK;                                                            \
        -:   38:	})
        -:   39:#define SET_BLACK(impl, id)                                                                        \
        -:   40:	({                                                                                             \
        -:   41:		ORBTreeNode *_orb_node__ = orbtree_node(impl, id);                                         \
        -:   42:		_orb_node__->color &= ~RED_MASK;                                                           \
        -:   43:	})
        -:   44:#define IS_RED(impl, id)                                                                           \
        -:   45:	({                                                                                             \
        -:   46:		ORBTreeNode *_orb_node__ = orbtree_node(impl, id);                                         \
        -:   47:		_orb_node__ != NULL && (_orb_node__->color & RED_MASK) != 0;                               \
        -:   48:	})
        -:   49:#define IS_BLACK(impl, id)                                                                         \
        -:   50:	({                                                                                             \
        -:   51:		ORBTreeNode *_orb_node__ = orbtree_node(impl, id);                                         \
        -:   52:		_orb_node__ == NULL || (_orb_node__->color & RED_MASK) == 0;                               \
        -:   53:	})
        -:   54:
        -:   55:typedef struct ORBTreeNode {
        -:   56:	u32 color;
        -:   57:	u32 right;
        -:   58:	u32 left;
        -:   59:	u32 parent;
        -:   60:	u32 right_subtree_size;
        -:   61:	u32 left_subtree_size;
        -:   62:#ifdef NODE_ID
        -:   63:	u64 node_id;
        -:   64:#endif // NODE_ID
        -:   65:	char data[];
        -:   66:} ORBTreeNode;
        -:   67:
        -:   68:// Data structure used for searching ORBTrees.
        -:   69:typedef struct ORBTreeNodePair {
        -:   70:	u32 parent;
        -:   71:	u32 self;
        -:   72:	bool is_right;
        -:   73:} ORBTreeNodePair;
        -:   74:
        -:   75:const static u32 NIL = (UINT32_MAX - 2);
        -:   76:
        -:   77:typedef struct ORBAllocator {
        -:   78:	u8 **data_chunks;
        -:   79:	u32 size;	  // current number of slabs allocated for the tree.
        -:   80:	u32 capacity; // current capacity in terms of number of slabs for the tree.
        -:   81:	u32 free_list_head;
        -:   82:	u32 cur_chunks;
        -:   83:	u32 *free_list;
        -:   84:} ORBAllocator;
        -:   85:
        -:   86:// Format for cache data:
        -:   87:// [entry1]
        -:   88:// [entry2]
        -:   89:// ....
        -:   90:// entry = [4 byte murmurhash][4 byte node id]
        -:   91:
        -:   92:typedef struct ORBTreeCacheEntry {
        -:   93:	u32 hash;
        -:   94:	u32 node;
        -:   95:	u32 last;
        -:   96:	u32 index;
        -:   97:	u64 mutation_id;
        -:   98:} ORBTreeCacheEntry;
        -:   99:
        -:  100:// The internal ORBTreeImpl storage data structure
        -:  101:typedef struct ORBTreeImpl {
        -:  102:	u64 value_size; // size of the values
        -:  103:
        -:  104:	// a comparion function (like qsort)
        -:  105:	int (*compare)(const void *, const void *);
        -:  106:	u32 root;	  // offset to the root node.
        -:  107:	u32 elements; // number of elements in the tree.
        -:  108:	ORBAllocator *alloc;
        -:  109:	u64 mutation_id;
        -:  110:	u32 cache_entries;
        -:  111:	ORBTreeCacheEntry cache[];
        -:  112:} ORBTreeImpl;
        -:  113:
        -:  114:// Iterator impl
        -:  115:typedef struct ORBTreeIteratorImpl {
        -:  116:	u32 cur;
        -:  117:	u32 min;
        -:  118:	u32 max;
        -:  119:	u32 stack[ITERATOR_STACK_SIZE];
        -:  120:	u64 value_size;
        -:  121:	u8 stack_pointer;
        -:  122:	ORBTreeImpl *impl;
        -:  123:} ORBTreeIteratorImpl;
        -:  124:
  4766366:  125:ORBTreeNode *orbtree_node(const ORBTreeImpl *impl, u32 node) {
  4766366:  126:	if (node == NIL) {
   135520:  127:		return NULL;
        -:  128:	}
  4630846:  129:	u64 index = node / NODES_PER_CHUNK;
  4630846:  130:	u64 offset = node % NODES_PER_CHUNK;
  4630846:  131:	u64 offset_sum = (offset * (sizeof(ORBTreeNode) + impl->value_size));
  4630846:  132:	return (ORBTreeNode *)(impl->alloc->data_chunks[index] + offset_sum);
        -:  133:}
        -:  134:
   749129:  135:void *orbtree_value(const ORBTreeImpl *impl, u32 node) {
   749129:  136:	return orbtree_node(impl, node)->data;
        -:  137:}
        -:  138:
       11:  139:void orbtree_iterator_cleanup(ORBTreeIteratorNc *ptr) {
       11:  140:	if (!nil(ptr->impl)) {
       11:  141:		fam_free(&ptr->impl);
       11:  142:		ptr->impl = null;
        -:  143:	}
       11:  144:}
        -:  145:
   122460:  146:bool orbtree_iterator_next(ORBTreeIterator *ptr, ORBTreeTray *value) {
   122460:  147:	ORBTreeIteratorImpl *impl = $(ptr->impl);
        -:  148:
        -:  149:	// If the iterator is empty, we're done
   122460:  150:	if (impl->cur == NIL && impl->stack_pointer == 0) {
      423:  151:		return false; // No more nodes to traverse
        -:  152:	}
        -:  153:
   122037:  154:	ORBTreeNode *min = NULL;
   122037:  155:	if (impl->min != NIL)
   121037:  156:		min = orbtree_node(impl->impl, impl->min);
        -:  157:
        -:  158:	// Traverse the tree
   247350:  159:	while (impl->cur != NIL || impl->stack_pointer > 0) {
   247350:  160:		ORBTreeNode *cur = orbtree_node(impl->impl, impl->cur);
        -:  161:		// Traverse left subtree
   247350:  162:		if (impl->cur != NIL) {
        -:  163:			// based on worst case log(n) * 2 + 1 this should not be possible
  125313*:  164:			assert(impl->stack_pointer < 128);
   125313:  165:			int v = 0;
   125313:  166:			if (impl->min != NIL)
   124313:  167:				v = impl->impl->compare(cur->data, min->data);
   125313:  168:			if (v < 0) {
        -:  169:				// we haven't hit the minimum yet
     1797:  170:				impl->cur = cur->right;
        -:  171:			} else {
        -:  172:				// Push the current node pointer onto the stack
   123516:  173:				impl->stack[impl->stack_pointer++] = impl->cur;
        -:  174:
        -:  175:				// Move to the left child
   123516:  176:				impl->cur = cur->left;
        -:  177:			}
        -:  178:		} else {
        -:  179:			// Pop the top node from the stack
   122037:  180:			impl->cur = impl->stack[--impl->stack_pointer];
        -:  181:
        -:  182:			// Store the current node's data to return
   122037:  183:			value->value = orbtree_value(impl->impl, impl->cur);
        -:  184:
        -:  185:			// check if we hit our max node. If so, next will return false.
   122037:  186:			if (impl->cur == impl->max) {
      422:  187:				impl->cur = NIL;
      422:  188:				impl->stack_pointer = 0;
        -:  189:			} else {
        -:  190:				// Move to the right child after visiting this node
   121615:  191:				cur = orbtree_node(impl->impl, impl->cur);
   121615:  192:				impl->cur = cur->right;
        -:  193:			}
        -:  194:
   122037:  195:			break;
        -:  196:		}
        -:  197:	}
   122037:  198:	return true;
        -:  199:}
        -:  200:
       27:  201:void orbtree_cleanup(ORBTreeNc *ptr) {
       27:  202:	if (ptr->impl) {
       27:  203:		ORBTreeImpl *impl = ptr->impl;
       27:  204:		if (impl->alloc->data_chunks != NULL) {
       53:  205:			for (u32 i = 0; i < impl->alloc->capacity; i += NODES_PER_CHUNK) {
       27:  206:				myfree(impl->alloc->data_chunks[i / NODES_PER_CHUNK]);
        -:  207:			}
       26:  208:			myfree(impl->alloc->data_chunks);
       26:  209:			impl->alloc->data_chunks = NULL;
        -:  210:		}
        -:  211:
       27:  212:		if (impl->alloc->free_list) {
       26:  213:			myfree(impl->alloc->free_list);
       26:  214:			impl->alloc->free_list = NULL;
        -:  215:		}
        -:  216:
       27:  217:		if (impl->alloc) {
       27:  218:			myfree(impl->alloc);
       27:  219:			impl->alloc = NULL;
        -:  220:		}
        -:  221:
       27:  222:		myfree(ptr->impl);
       27:  223:		ptr->impl = NULL;
        -:  224:	}
       27:  225:}
        -:  226:
       27:  227:int orbtree_create(ORBTree *ptr, const u64 value_size, int (*compare)(const void *, const void *)) {
        -:  228:	// validate input
       27:  229:	if (ptr == NULL || value_size == 0 || compare == NULL) {
    #####:  230:		SetErr(IllegalArgument);
    #####:  231:		return -1;
        -:  232:	}
        -:  233:
       27:  234:	ptr->impl = mymalloc(sizeof(ORBTreeImpl) + CACHE_ENTRIES * sizeof(ORBTreeCacheEntry));
       27:  235:	if (ptr->impl == NULL) {
    #####:  236:		return -1;
        -:  237:	}
       27:  238:	ORBTreeImpl *impl = ptr->impl;
       27:  239:	impl->value_size = value_size;
       27:  240:	impl->compare = compare;
       27:  241:	impl->root = NIL;
        -:  242:
       27:  243:	impl->alloc = mymalloc(sizeof(ORBAllocator));
        -:  244:
       27:  245:	impl->alloc->size = 0;
       27:  246:	impl->alloc->capacity = 0;
       27:  247:	impl->alloc->free_list_head = UINT32_MAX;
       27:  248:	impl->alloc->data_chunks = NULL;
       27:  249:	impl->alloc->cur_chunks = 0;
       27:  250:	impl->elements = 0;
       27:  251:	impl->alloc->free_list = NULL;
       27:  252:	impl->cache_entries = CACHE_ENTRIES;
       27:  253:	impl->mutation_id = 0;
        -:  254:
       27:  255:	return 0;
        -:  256:}
        -:  257:
    10870:  258:void orbtree_update_heights(const ORBTreeImpl *impl, u32 node) {
    10870:  259:	ORBTreeNode *last = orbtree_node(impl, node);
    10870:  260:	if (last == NULL)
       79:  261:		return;
        -:  262:	ORBTreeNode *parent;
    96890:  263:	while (last->parent != NIL) {
    86099:  264:		parent = orbtree_node(impl, last->parent);
    86099:  265:		if (orbtree_node(impl, parent->right) == last) {
    61194:  266:			parent->right_subtree_size = 1 + last->right_subtree_size + last->left_subtree_size;
        -:  267:		} else {
    24905:  268:			parent->left_subtree_size = 1 + last->right_subtree_size + last->left_subtree_size;
        -:  269:		}
    86099:  270:		last = parent;
        -:  271:	}
        -:  272:}
        -:  273:
        -:  274:// internal search function used by get/insert/delete.
    11311:  275:void orbtree_search(const ORBTreeImpl *impl, const void *value, ORBTreeNodePair *nodes) {
    11311:  276:	nodes->parent = NIL;
    11311:  277:	nodes->self = impl->root;
    11311:  278:	int i = 0;
   121938:  279:	while (nodes->self != NIL) {
   114780:  280:		nodes->parent = nodes->self;
   114780:  281:		int v = impl->compare(orbtree_value(impl, nodes->self), value);
   114780:  282:		if (v == 0) {
     4153:  283:			break;
   110627:  284:		} else if (v < 0) {
    80787:  285:			ORBTreeNode *self = orbtree_node(impl, nodes->self);
    80787:  286:			nodes->self = self->right;
    80787:  287:			nodes->is_right = true;
        -:  288:		} else {
    29840:  289:			ORBTreeNode *self = orbtree_node(impl, nodes->self);
    29840:  290:			nodes->self = self->left;
    29840:  291:			nodes->is_right = false;
        -:  292:		}
        -:  293:	}
    11311:  294:}
        -:  295:
     5219:  296:void orbtree_left_rotate(ORBTreeImpl *impl, u32 x_id) {
     5219:  297:	ORBTreeNode *x = orbtree_node(impl, x_id);
     5219:  298:	u32 y_id = x->right;
     5219:  299:	ORBTreeNode *y = orbtree_node(impl, y_id);
     5219:  300:	u32 y_left_subtree_size = y->left_subtree_size;
        -:  301:
        -:  302:	// Move y's left subtree to x's right subtree
     5219:  303:	x->right = y->left;
     5219:  304:	x->right_subtree_size = y_left_subtree_size;
        -:  305:
     5219:  306:	if (y->left != NIL) {
     2859:  307:		ORBTreeNode *yleft = orbtree_node(impl, y->left);
     2859:  308:		yleft->parent = x_id;
        -:  309:	}
        -:  310:
        -:  311:	// Update y's parent to x's parent
     5219:  312:	y->parent = x->parent;
        -:  313:
        -:  314:	// If x was the root, now y becomes the root
     5219:  315:	ORBTreeNode *xparent = orbtree_node(impl, x->parent);
     5219:  316:	if (x->parent == NIL) {
       77:  317:		impl->root = y_id;
     5142:  318:	} else if (x_id == xparent->left) {
     1643:  319:		xparent->left = y_id;
        -:  320:	} else {
     3499:  321:		xparent->right = y_id;
        -:  322:	}
        -:  323:
        -:  324:	// Place x as y's left child
     5219:  325:	y->left = x_id;
     5219:  326:	y->left_subtree_size = x->right_subtree_size + x->left_subtree_size + 1;
     5219:  327:	x->parent = y_id;
     5219:  328:}
        -:  329:
     1042:  330:void orbtree_right_rotate(ORBTreeImpl *impl, u32 x_id) {
     1042:  331:	ORBTreeNode *x = orbtree_node(impl, x_id);
     1042:  332:	u32 y_id = x->left;
     1042:  333:	ORBTreeNode *y = orbtree_node(impl, y_id);
        -:  334:
     1042:  335:	u32 y_right_subtree_size = y->right_subtree_size;
        -:  336:
        -:  337:	// Move y's right subtree to x's right subtree
     1042:  338:	x->left = y->right;
     1042:  339:	x->left_subtree_size = y_right_subtree_size;
        -:  340:
     1042:  341:	if (y->right != NIL) {
      407:  342:		ORBTreeNode *yright = orbtree_node(impl, y->right);
      407:  343:		yright->parent = x_id;
        -:  344:	}
        -:  345:
        -:  346:	// Update y's parent to x's parent
     1042:  347:	y->parent = x->parent;
        -:  348:
        -:  349:	// If x was the root, now y becomes the root
     1042:  350:	ORBTreeNode *xparent = orbtree_node(impl, x->parent);
     1042:  351:	if (x->parent == NIL) {
       19:  352:		impl->root = y_id;
     1023:  353:	} else if (x_id == xparent->right) {
      699:  354:		xparent->right = y_id;
        -:  355:	} else {
      324:  356:		xparent->left = y_id;
        -:  357:	}
        -:  358:
        -:  359:	// Place x as y's left child
     1042:  360:	y->right = x_id;
     1042:  361:	y->right_subtree_size = x->right_subtree_size + x->left_subtree_size + 1;
     1042:  362:	x->parent = y_id;
     1042:  363:}
        -:  364:
        -:  365:// find the successor node
     1471:  366:u32 orbtree_find_successor(ORBTreeImpl *impl, u32 x_id) {
     1471:  367:	ORBTreeNode *x = orbtree_node(impl, x_id);
     1471:  368:	u32 successor_id = x->right;
     1471:  369:	ORBTreeNode *successor = orbtree_node(impl, x->right);
     4821:  370:	while (successor && successor->left != NIL) {
     3350:  371:		successor_id = successor->left;
     3350:  372:		successor = orbtree_node(impl, successor->left);
        -:  373:	}
     1471:  374:	return successor_id;
        -:  375:}
        -:  376:
        -:  377:// perform transplant operation
     4295:  378:void orbtree_transplant(ORBTreeImpl *impl, u32 dst, u32 src) {
     4295:  379:	ORBTreeNode *dst_node = orbtree_node(impl, dst);
     4295:  380:	ORBTreeNode *dst_parent = orbtree_node(impl, dst_node->parent);
        -:  381:
     4295:  382:	if (dst_node->parent == NIL)
       53:  383:		impl->root = src;
     4242:  384:	else if (dst == dst_parent->left) {
     3458:  385:		dst_parent->left = src;
     3458:  386:		if (src == NIL)
     1459:  387:			dst_parent->left_subtree_size = 0;
        -:  388:		else {
     1999:  389:			ORBTreeNode *src_node = orbtree_node(impl, src);
        -:  390:		}
        -:  391:	} else {
      784:  392:		dst_parent->right = src;
      784:  393:		if (src == NIL)
      197:  394:			dst_parent->right_subtree_size = 0;
        -:  395:		else {
      587:  396:			ORBTreeNode *src_node = orbtree_node(impl, src);
        -:  397:		}
        -:  398:	}
     4295:  399:	if (src != NIL) {
     2616:  400:		ORBTreeNode *src_node = orbtree_node(impl, src);
     2616:  401:		src_node->parent = dst_node->parent;
     2616:  402:		ORBTreeNode *src_node_p = orbtree_node(impl, src_node->parent);
     2616:  403:		if (src_node_p) {
     2586:  404:			if (src_node_p->right == src)
      587:  405:				src_node_p->right_subtree_size =
      587:  406:					1 + src_node->right_subtree_size + src_node->left_subtree_size;
        -:  407:			else
     1999:  408:				src_node_p->left_subtree_size =
     1999:  409:					1 + src_node->right_subtree_size + src_node->left_subtree_size;
        -:  410:		}
        -:  411:	}
        -:  412:
     4295:  413:	orbtree_update_heights(impl, dst_node->parent);
     4295:  414:}
        -:  415:
     5104:  416:void orbtree_put_fixup(ORBTreeImpl *impl, u32 k_id) {
     5104:  417:	ORBTreeNode *k = orbtree_node(impl, k_id);
        -:  418:
    13627:  419:	while (k_id != impl->root && IS_RED(impl, k->parent)) {
     8523:  420:		k = orbtree_node(impl, k_id);
     8523:  421:		ORBTreeNode *parent = orbtree_node(impl, k->parent);
     8523:  422:		ORBTreeNode *gparent = orbtree_node(impl, parent->parent);
        -:  423:
     8523:  424:		if (k->parent == gparent->left) {
        -:  425:			// Case 1: Uncle is on the right
      911:  426:			ORBTreeNode *u = orbtree_node(impl, gparent->right);
      911:  427:			u32 u_id = gparent->right;
      911:  428:			if (IS_RED(impl, u_id)) {
        -:  429:				// Case 1a: Uncle is red
        -:  430:				// Recolor the parent and uncle to black
      276:  431:				SET_BLACK(impl, k->parent);
      276:  432:				SET_BLACK(impl, u_id);
        -:  433:				// Recolor the grandparent to red
      276:  434:				SET_RED(impl, parent->parent);
        -:  435:
        -:  436:				// Move up the tree
      276:  437:				k_id = parent->parent;
      276:  438:				k = orbtree_node(impl, k_id);
        -:  439:			} else {
        -:  440:				// Case 1b: Uncle is black
      635:  441:				if (k_id == parent->right) {
        -:  442:					// Case 1b1: Node is a right child
        -:  443:					// Rotate left to make the node the left child
      520:  444:					k_id = k->parent;
      520:  445:					k = orbtree_node(impl, k_id);
      520:  446:					orbtree_left_rotate(impl, k_id);
        -:  447:				}
        -:  448:				// Recolor and rotate
      635:  449:				ORBTreeNode *kparent = orbtree_node(impl, k->parent);
      635:  450:				SET_BLACK(impl, k->parent);
      635:  451:				SET_RED(impl, kparent->parent);
        -:  452:
      635:  453:				orbtree_right_rotate(impl, kparent->parent);
        -:  454:			}
        -:  455:		} else {
        -:  456:			// Case 2: Uncle is on the left
     7612:  457:			ORBTreeNode *u = orbtree_node(impl, gparent->left);
     7612:  458:			u32 u_id = gparent->left;
     7612:  459:			if (IS_RED(impl, u_id)) {
        -:  460:				// Case 2a: Uncle is red
        -:  461:				// Recolor the parent and uncle to black
     4017:  462:				SET_BLACK(impl, k->parent);
     4017:  463:				SET_BLACK(impl, u_id);
        -:  464:				// Recolor the grandparent to red
     4017:  465:				SET_RED(impl, parent->parent);
        -:  466:
        -:  467:				// Move up the tree
     4017:  468:				k_id = parent->parent;
     4017:  469:				k = orbtree_node(impl, k_id);
        -:  470:			} else {
        -:  471:				// Case 2b: Uncle is black
     3595:  472:				if (k_id == parent->left) {
        -:  473:					// Case 2b1: Node is a right child
        -:  474:					// Rotate left to make the node the left child
      110:  475:					k_id = k->parent;
      110:  476:					k = orbtree_node(impl, k_id);
      110:  477:					orbtree_right_rotate(impl, k_id);
        -:  478:				}
        -:  479:				// Recolor and rotate
     3595:  480:				SET_BLACK(impl, k->parent);
     3595:  481:				ORBTreeNode *kparent = orbtree_node(impl, k->parent);
     3595:  482:				SET_RED(impl, kparent->parent);
     3595:  483:				orbtree_left_rotate(impl, kparent->parent);
        -:  484:			}
        -:  485:		}
        -:  486:	}
        -:  487:	// Ensure the root is always black
     5104:  488:	SET_BLACK(impl, impl->root);
     5104:  489:}
        -:  490:
     5105:  491:int orbtree_put(ORBTree *ptr, const ORBTreeTray *value, ORBTreeTray *replaced) {
        -:  492:	// validate input
     5105:  493:	if (ptr == NULL || value == NULL || replaced == NULL) {
    #####:  494:		SetErr(IllegalArgument);
    #####:  495:		return -1;
        -:  496:	}
        -:  497:
        -:  498:	// obtain the impl from the ptr
     5105:  499:	ORBTreeImpl *impl = ptr->impl;
        -:  500:	// this pair is used to search
        -:  501:	ORBTreeNodePair pair;
        -:  502:
     5105:  503:	if (impl == NULL) {
    #####:  504:		SetErr(IllegalState);
    #####:  505:		return -1;
        -:  506:	}
        -:  507:
        -:  508:	// we are assured a mutation at this point
     5105:  509:	impl->mutation_id++;
        -:  510:
        -:  511:	// perform search for the key
     5105:  512:	orbtree_search(impl, value->value, &pair);
     5105:  513:	if (pair.self != NIL) {
        1:  514:		void *val = orbtree_value(impl, pair.self);
        1:  515:		memcpy(replaced->value, val, impl->value_size);
        1:  516:		replaced->updated = true;
        1:  517:		replaced->id = pair.self;
        1:  518:		memcpy(val, value->value, impl->value_size);
        1:  519:		return 0;
        -:  520:	}
        -:  521:
     5104:  522:	if (impl->root == NIL) {
       26:  523:		impl->root = value->id;
     5078:  524:	} else if (pair.is_right) {
     4278:  525:		ORBTreeNode *parent = orbtree_node(impl, pair.parent);
     4278:  526:		parent->right_subtree_size++;
     4278:  527:		parent->right = value->id;
        -:  528:	} else {
      800:  529:		ORBTreeNode *parent = orbtree_node(impl, pair.parent);
      800:  530:		parent->left_subtree_size++;
      800:  531:		parent->left = value->id;
        -:  532:	}
        -:  533:
     5104:  534:	orbtree_update_heights(impl, pair.parent);
        -:  535:
     5104:  536:	ORBTreeNode *node = orbtree_node(impl, value->id);
     5104:  537:	node->right = NIL;
     5104:  538:	node->left = NIL;
     5104:  539:	node->right_subtree_size = 0;
     5104:  540:	node->left_subtree_size = 0;
     5104:  541:	node->parent = pair.parent;
        -:  542:
        -:  543:#ifdef NODE_ID
        -:  544:	node->node_id = orbtree_next_node_id++;
        -:  545:#endif // NODE_ID
        -:  546:
     5104:  547:	SET_RED(impl, value->id);
     5104:  548:	impl->elements++;
        -:  549:
     5104:  550:	orbtree_put_fixup(impl, value->id);
        -:  551:
     5104:  552:	return 0;
        -:  553:}
        -:  554:
   501529:  555:int orbtree_get_index_ranged(const ORBTree *ptr, u32 index, ORBTreeTray *tray,
        -:  556:							 const void *start_value, bool start_inclusive) {
   501529:  557:	u32 index_orig = index;
   501529:  558:	if (ptr == NULL || tray == NULL || start_value == NULL) {
    #####:  559:		SetErr(IllegalArgument);
    #####:  560:		return -1;
        -:  561:	}
        -:  562:
   501529:  563:	ORBTreeImpl *impl = ptr->impl;
   501529:  564:	if (impl == NULL) {
    #####:  565:		SetErr(IllegalState);
    #####:  566:		return -1;
        -:  567:	}
        -:  568:
   501529:  569:	u32 cur = NIL;
   501529:  570:	u32 itt = impl->root;
        -:  571:	u32 hash;
        -:  572:	u32 offset;
        -:  573:
        -:  574:	if (CACHE_ENTRIES) {
   501529:  575:		hash = murmurhash(start_value, impl->value_size, MURMUR_SEED);
   501529:  576:		offset = hash % CACHE_ENTRIES;
   501529:  577:		if (impl->cache[offset].hash == hash) {
   500515:  578:			ORBTreeNode *node = orbtree_node(impl, impl->cache[offset].node);
   500515:  579:			if (node && impl->compare(node->data, start_value) == 0) {
   500515:  580:				itt = NIL;
   500515:  581:				cur = impl->cache[offset].node;
   500515:  582:				ORBTreeNode *last = orbtree_node(impl, impl->cache[offset].last);
   500515:  583:				if (impl->cache[offset].mutation_id == impl->mutation_id) {
   500514:  584:					if (index >= impl->cache[offset].index) {
   500511:  585:						index -= impl->cache[offset].index;
   500511:  586:						cur = impl->cache[offset].last;
        -:  587:					}
        -:  588:				}
        -:  589:			}
        -:  590:		}
        -:  591:	}
        -:  592:
   510003:  593:	while (itt != NIL) {
     9478:  594:		ORBTreeNode *node = orbtree_node(impl, itt);
     9478:  595:		int v = impl->compare(node->data, start_value);
     9478:  596:		if (v == 0) {
        -:  597:			// exact match
     1004:  598:			if (start_inclusive) {
     1004:  599:				cur = itt;
        -:  600:				if (CACHE_ENTRIES) {
        -:  601:					// update cache
     1004:  602:					impl->cache[offset].hash = hash;
     1004:  603:					impl->cache[offset].node = itt;
        -:  604:				}
     1004:  605:				break;
        -:  606:			} else {
    #####:  607:				if (node->right != NIL)
    #####:  608:					cur = node->right;
    #####:  609:				itt = node->right;
        -:  610:			}
     8474:  611:		} else if (v < 0) {
        -:  612:			// continue down the
        -:  613:			// chain to look for
        -:  614:			// more
     4877:  615:			itt = node->right;
        -:  616:		} else {
        -:  617:			// higher value
        -:  618:			// found update cur
     3597:  619:			cur = itt;
     3597:  620:			itt = node->left;
        -:  621:		}
        -:  622:	}
        -:  623:
  1002082:  624:	while (cur != NIL) {
  1002082:  625:		ORBTreeNode *cur_node = orbtree_node(impl, cur);
        -:  626:		//  index found
  1002082:  627:		if (index == 0) {
   501527:  628:			tray->value = orbtree_value(impl, cur);
   501527:  629:			tray->updated = true;
        -:  630:			if (CACHE_ENTRIES) {
        -:  631:				// update cache
   501527:  632:				impl->cache[offset].last = cur;
   501527:  633:				impl->cache[offset].index = index_orig;
   501527:  634:				impl->cache[offset].mutation_id = impl->mutation_id;
        -:  635:			}
        -:  636:
   501527:  637:			return 0;
        -:  638:		}
   500555:  639:		if (cur_node->right_subtree_size < index && cur_node->parent == NIL) {
        -:  640:			// not enough remaining nodes
        -:  641:			break;
   500554:  642:		} else if (cur_node->right_subtree_size < index) {
   249543:  643:			index -= cur_node->right_subtree_size + 1;
   249543:  644:			u32 last = cur;
   489404:  645:			while (cur_node->parent != NIL) {
   489404:  646:				cur = cur_node->parent;
   489404:  647:				cur_node = orbtree_node(impl, cur);
        -:  648:
   489404:  649:				if (cur_node->left == last)
   249542:  650:					break;
   239862:  651:				last = cur;
        -:  652:
   239862:  653:				if (cur_node->parent == NIL) {
        -:  654:					// no more nodes to look at, not found
        1:  655:					return -1;
        -:  656:				}
        -:  657:			}
        -:  658:
        -:  659:		} else {
   251011:  660:			index -= 1;
   251011:  661:			cur = cur_node->right;
   251011:  662:			cur_node = orbtree_node(impl, cur);
        -:  663:
   496977:  664:			while (cur_node->left != NIL) {
   245966:  665:				if (cur_node->left_subtree_size < index) {
        1:  666:					index -= cur_node->left_subtree_size + 1;
        1:  667:					cur = cur_node->right;
        1:  668:					cur_node = orbtree_node(impl, cur);
        -:  669:				} else {
   245965:  670:					cur = cur_node->left;
   245965:  671:					cur_node = orbtree_node(impl, cur);
        -:  672:				}
        -:  673:			}
        -:  674:		}
        -:  675:	}
        -:  676:
        -:  677:	// not found
        1:  678:	return -1;
        -:  679:}
    #####:  680:int orbtree_remove_index_ranged(ORBTree *ptr, u32 index, ORBTreeTray *tray, const void *start_value,
        -:  681:								bool start_inclusive) {
    #####:  682:	return 0;
        -:  683:}
        -:  684:
       21:  685:int orbtree_get_index(const ORBTree *ptr, u32 index, ORBTreeTray *tray) {
       21:  686:	if (ptr == NULL || tray == NULL) {
    #####:  687:		SetErr(IllegalArgument);
    #####:  688:		return -1;
        -:  689:	}
        -:  690:
       21:  691:	tray->updated = false;
        -:  692:
        -:  693:	// obtain the impl from the ptr
       21:  694:	ORBTreeImpl *impl = ptr->impl;
        -:  695:
       21:  696:	if (impl == NULL) {
    #####:  697:		SetErr(IllegalState);
    #####:  698:		return -1;
        -:  699:	}
        -:  700:
       21:  701:	i64 size = orbtree_size(ptr);
       21:  702:	if (index >= size) {
        1:  703:		SetErr(IndexOutOfBounds);
        1:  704:		return -1;
        -:  705:	}
        -:  706:
       20:  707:	u32 itt = impl->root;
       20:  708:	u32 left_cur = 0;
        -:  709:
       51:  710:	while (itt != NIL) {
       51:  711:		ORBTreeNode *n = orbtree_node(impl, itt);
       51:  712:		left_cur += n->left_subtree_size;
       51:  713:		if (left_cur > index) {
       17:  714:			left_cur -= n->left_subtree_size;
       17:  715:			itt = n->left;
       34:  716:		} else if (left_cur < index) {
       14:  717:			left_cur += 1;
       14:  718:			itt = n->right;
        -:  719:		} else {
       20:  720:			break;
        -:  721:		}
        -:  722:	}
       20:  723:	if (itt == NIL) {
    #####:  724:		SetErr(IllegalState);
    #####:  725:		return -1;
        -:  726:	}
        -:  727:
       20:  728:	tray->value = orbtree_value(impl, itt);
       20:  729:	tray->updated = true;
        -:  730:
       20:  731:	return 0;
        -:  732:}
        -:  733:
       10:  734:int orbtree_remove_index(ORBTree *ptr, u32 index, ORBTreeTray *removed) {
        -:  735:	ORBTreeTray search;
       10:  736:	search.updated = false;
       10:  737:	int ret = orbtree_get_index(ptr, index, &search);
       10:  738:	if (ret)
    #####:  739:		return ret;
        -:  740:
       10:  741:	if (!search.updated) {
    #####:  742:		SetErr(IllegalState);
    #####:  743:		return -1;
        -:  744:	}
        -:  745:
       10:  746:	return orbtree_remove(ptr, search.value, removed);
        -:  747:}
        -:  748:
        -:  749:// set child's color to parent's
     1878:  750:void orbtree_set_color_based_on_parent(ORBTreeImpl *impl, u32 child, u32 parent) {
     1878:  751:	if (child != NIL) {
     1878:  752:		if (IS_RED(impl, parent)) {
      346:  753:			SET_RED(impl, child);
        -:  754:		} else {
     1532:  755:			SET_BLACK(impl, child);
        -:  756:		}
        -:  757:	}
     1878:  758:}
        -:  759:
     2794:  760:void orbtree_remove_fixup(ORBTreeImpl *impl, u32 parent, u32 w, u32 x) {
     5536:  761:	while (x != impl->root && IS_BLACK(impl, x)) {
     2742:  762:		ORBTreeNode *parent_node = orbtree_node(impl, parent);
     2742:  763:		ORBTreeNode *w_node = orbtree_node(impl, w);
     2742:  764:		ORBTreeNode *x_node = orbtree_node(impl, x);
     2742:  765:		if (w == parent_node->right) {
        -:  766:			// Case 1: Sibling is
        -:  767:			// red
     2219:  768:			if (IS_RED(impl, w)) {
      785:  769:				SET_BLACK(impl, w);
      785:  770:				SET_RED(impl, parent);
      785:  771:				orbtree_left_rotate(impl, parent);
      785:  772:				w = parent_node->right;
      785:  773:				w_node = orbtree_node(impl, w);
        -:  774:			}
        -:  775:
        -:  776:			// Case 2: Sibling's
        -:  777:			// children are both
        -:  778:			// black
     4187:  779:			if (IS_BLACK(impl, w_node->left) && IS_BLACK(impl, w_node->right)) {
     1968:  780:				SET_RED(impl, w);
     1968:  781:				x = parent;
     1968:  782:				x_node = orbtree_node(impl, x);
     1968:  783:				parent = parent_node->parent;
     1968:  784:				parent_node = orbtree_node(impl, parent);
     1968:  785:				ORBTreeNode *x_parent = orbtree_node(impl, x_node->parent);
     1968:  786:				if (x_parent == NULL) {
       34:  787:					w = NIL;
       34:  788:					w_node = NULL;
     1934:  789:				} else if (x == x_parent->left) {
     1701:  790:					w = x_parent->right;
     1701:  791:					w_node = orbtree_node(impl, w);
        -:  792:				} else {
      233:  793:					w = x_parent->left;
      233:  794:					w_node = orbtree_node(impl, w);
        -:  795:				}
        -:  796:			} else {
        -:  797:				// Case 3: Sibling's
        -:  798:				// right child is
        -:  799:				// black, left child
        -:  800:				// is red
      251:  801:				if (IS_BLACK(impl, w_node->right)) {
       57:  802:					SET_BLACK(impl, w_node->left);
       57:  803:					SET_RED(impl, w);
       57:  804:					orbtree_right_rotate(impl, w);
       57:  805:					w = parent_node->right;
       57:  806:					w_node = orbtree_node(impl, w);
        -:  807:				}
        -:  808:
        -:  809:				// Case 4: Sibling's
        -:  810:				// right child is
        -:  811:				// red
      251:  812:				orbtree_set_color_based_on_parent(impl, w, parent);
      251:  813:				SET_BLACK(impl, parent);
      251:  814:				SET_BLACK(impl, w_node->right);
      251:  815:				orbtree_left_rotate(impl, parent);
      251:  816:				x = impl->root; // Set x to root at the end, only once
      251:  817:				x_node = orbtree_node(impl, x);
        -:  818:			}
        -:  819:		} else {
        -:  820:			// Case 1: Sibling is
        -:  821:			// red
      523:  822:			if (IS_RED(impl, w)) {
       84:  823:				SET_BLACK(impl, w);
       84:  824:				SET_RED(impl, parent);
       84:  825:				orbtree_right_rotate(impl, parent);
       84:  826:				w = parent_node->left;
       84:  827:				w_node = orbtree_node(impl, w);
        -:  828:			}
        -:  829:
        -:  830:			// Case 2: Sibling's
        -:  831:			// children are both
        -:  832:			// black
      890:  833:			if (IS_BLACK(impl, w_node->right) && IS_BLACK(impl, w_node->left)) {
      367:  834:				SET_RED(impl, w);
      367:  835:				x = parent;
      367:  836:				x_node = orbtree_node(impl, x);
      367:  837:				parent = parent_node->parent;
      367:  838:				parent_node = orbtree_node(impl, parent);
      367:  839:				ORBTreeNode *x_parent = orbtree_node(impl, x_node->parent);
      367:  840:				if (x_parent == NULL) {
        5:  841:					w = NIL;
        5:  842:					w_node = NULL;
      362:  843:				} else if (x == x_parent->left) {
      158:  844:					w = x_parent->right;
      158:  845:					w_node = orbtree_node(impl, w);
        -:  846:				} else {
      204:  847:					w = x_parent->left;
      204:  848:					w_node = orbtree_node(impl, w);
        -:  849:				}
        -:  850:			} else {
        -:  851:				// Case 3: Sibling's
        -:  852:				// right child is
        -:  853:				// black, left child
        -:  854:				// is red
      156:  855:				if (IS_BLACK(impl, w_node->left)) {
       68:  856:					SET_BLACK(impl, w_node->right);
       68:  857:					SET_RED(impl, w);
       68:  858:					orbtree_left_rotate(impl, w);
       68:  859:					w = parent_node->left;
       68:  860:					w_node = orbtree_node(impl, w);
        -:  861:				}
        -:  862:
        -:  863:				// Case 4: Sibling's
        -:  864:				// right child is
        -:  865:				// red
      156:  866:				orbtree_set_color_based_on_parent(impl, w, parent);
      156:  867:				SET_BLACK(impl, parent);
      156:  868:				SET_BLACK(impl, w_node->left);
      156:  869:				orbtree_right_rotate(impl, parent);
      156:  870:				x = impl->root; // Set x to root at the end, only once
      156:  871:				x_node = orbtree_node(impl, x);
        -:  872:			}
        -:  873:		}
        -:  874:	}
        -:  875:
        -:  876:	// Ensure x is black at the end
        -:  877:	// of fixup
     2794:  878:	SET_BLACK(impl, x);
     2794:  879:}
        -:  880:
     4111:  881:int orbtree_remove(ORBTree *ptr, const void *value, ORBTreeTray *removed) {
        -:  882:	// validate input
     4111:  883:	if (ptr == NULL || value == NULL || removed == NULL) {
    #####:  884:		SetErr(IllegalArgument);
    #####:  885:		return -1;
        -:  886:	}
        -:  887:
        -:  888:	// obtain impl from the pointer
     4111:  889:	ORBTreeImpl *impl = ptr->impl;
        -:  890:
     4111:  891:	if (impl == NULL) {
    #####:  892:		SetErr(IllegalState);
    #####:  893:		return -1;
        -:  894:	}
        -:  895:
        -:  896:	// search for the node based on
        -:  897:	// this key.
        -:  898:	ORBTreeNodePair pair;
     4111:  899:	orbtree_search(impl, value, &pair);
        -:  900:
        -:  901:	// this node doesn't exist,
        -:  902:	// return -1
     4111:  903:	if (pair.self == NIL) {
     1013:  904:		removed->updated = false;
     1013:  905:		return -1;
        -:  906:	}
        -:  907:
        -:  908:	// we are assured a mutation at this point
     3098:  909:	impl->mutation_id++;
        -:  910:
     3098:  911:	removed->value = orbtree_value(impl, pair.self);
     3098:  912:	removed->updated = true;
     3098:  913:	removed->id = pair.self;
        -:  914:
     3098:  915:	ORBTreeNode *node_to_delete = orbtree_node(impl, pair.self);
     3098:  916:	ORBTreeNode *x = NULL;
     3098:  917:	ORBTreeNode *w = NULL;
     3098:  918:	ORBTreeNode *parent = NULL;
     3098:  919:	u32 x_id = NIL;
     3098:  920:	u32 w_id = NIL;
     3098:  921:	u32 parent_id = NIL;
     3098:  922:	bool do_fixup = IS_BLACK(impl, pair.self);
        -:  923:
     3098:  924:	if (node_to_delete->left == NIL) {
     1561:  925:		x_id = node_to_delete->right;
     1561:  926:		x = orbtree_node(impl, x_id);
     1561:  927:		orbtree_transplant(impl, pair.self, node_to_delete->right);
     1561:  928:		ORBTreeNode *node_to_delete_parent = orbtree_node(impl, node_to_delete->parent);
     1561:  929:		if (node_to_delete_parent == NULL) {
     1522:  930:		} else if (node_to_delete_parent->left == NIL) {
      778:  931:			w_id = node_to_delete_parent->right;
      778:  932:			w = orbtree_node(impl, w_id);
      744:  933:		} else if (node_to_delete_parent) {
      744:  934:			w_id = node_to_delete_parent->left;
      744:  935:			w = orbtree_node(impl, w_id);
        -:  936:		}
     1561:  937:		if (x_id != NIL) {
      614:  938:			x = orbtree_node(impl, x_id);
      614:  939:			parent_id = x->parent;
      614:  940:			parent = orbtree_node(impl, parent_id);
      947:  941:		} else if (w_id != NIL) {
      817:  942:			parent_id = w->parent;
      817:  943:			parent = orbtree_node(impl, parent_id);
        -:  944:		}
     1537:  945:	} else if (node_to_delete->right == NIL) {
       66:  946:		x_id = node_to_delete->left;
       66:  947:		x = orbtree_node(impl, x_id);
       66:  948:		orbtree_transplant(impl, pair.self, node_to_delete->left);
       66:  949:		ORBTreeNode *node_to_delete_parent = orbtree_node(impl, node_to_delete->parent);
       66:  950:		if (node_to_delete_parent) {
       64:  951:			w_id = node_to_delete_parent->left;
       64:  952:			w = orbtree_node(impl, w_id);
        -:  953:		}
       66:  954:		parent_id = x->parent;
       66:  955:		parent = orbtree_node(impl, parent_id);
        -:  956:	} else {
     1471:  957:		u32 successor_id = orbtree_find_successor(impl, pair.self);
     1471:  958:		ORBTreeNode *successor = orbtree_node(impl, successor_id);
     1471:  959:		do_fixup = IS_BLACK(impl, successor_id);
        -:  960:
     1471:  961:		x_id = successor->right;
     1471:  962:		ORBTreeNode *successor_parent = orbtree_node(impl, successor->parent);
     1471:  963:		w_id = successor_parent->right;
     1471:  964:		x = orbtree_node(impl, x_id);
     1471:  965:		w = orbtree_node(impl, w_id);
        -:  966:
     1471:  967:		if (w == NULL) {
       90:  968:			parent_id = NIL;
       90:  969:			parent = NULL;
     1381:  970:		} else if (w->parent == pair.self) {
      274:  971:			w_id = node_to_delete->left;
      274:  972:			w = orbtree_node(impl, w_id);
      274:  973:			parent_id = successor_id;
      274:  974:			parent = successor;
        -:  975:		} else {
     1107:  976:			parent_id = w->parent;
     1107:  977:			parent = orbtree_node(impl, w_id);
        -:  978:		}
        -:  979:
     1471:  980:		if (successor->parent != pair.self) {
     1197:  981:			orbtree_transplant(impl, successor_id, successor->right);
     1197:  982:			successor->right = node_to_delete->right;
     1197:  983:			successor->right_subtree_size = 0;
     1197:  984:			ORBTreeNode *successor_right = orbtree_node(impl, successor->right);
     1197:  985:			if (successor_right) {
     1197:  986:				successor->right_subtree_size =
     1197:  987:					1 + successor_right->right_subtree_size + successor_right->left_subtree_size;
     1197:  988:				successor_right->parent = successor_id;
        -:  989:			}
        -:  990:		}
        -:  991:
        -:  992:		// do final transpalnt and
        -:  993:		// update including color
        -:  994:		// match
     1471:  995:		orbtree_transplant(impl, pair.self, successor_id);
     1471:  996:		successor->left = node_to_delete->left;
     1471:  997:		ORBTreeNode *successor_left = orbtree_node(impl, successor->left);
     1471:  998:		successor->left_subtree_size = 0;
     1471:  999:		if (node_to_delete->left != NIL) {
     1471: 1000:			ORBTreeNode *ntdl = orbtree_node(impl, node_to_delete->left);
     1471: 1001:			successor->left_subtree_size = 1 + ntdl->right_subtree_size + ntdl->left_subtree_size;
        -: 1002:		}
        -: 1003:
     1471: 1004:		successor_left->parent = successor_id;
     1471: 1005:		orbtree_set_color_based_on_parent(impl, successor_id, pair.self);
        -: 1006:
        -: 1007:		// go up the tree
     1471: 1008:		orbtree_update_heights(impl, successor_id);
        -: 1009:	}
        -: 1010:
     3098: 1011:	if (do_fixup) {
     2835: 1012:		if (w_id != NIL && parent_id != NIL) {
     2794: 1013:			orbtree_remove_fixup(impl, parent_id, w_id, x_id);
        -: 1014:		} else {
        -: 1015:			// in these cases
        -: 1016:			// SET_BLACK only
       41: 1017:			if (impl->elements > 1)
       18: 1018:				SET_BLACK(impl, impl->root);
        -: 1019:		}
        -: 1020:	}
        -: 1021:
     3098: 1022:	impl->elements--;
        -: 1023:
     3098: 1024:	return 0;
        -: 1025:}
     2095: 1026:int orbtree_get(const ORBTree *ptr, const void *searched, ORBTreeTray *found) {
        -: 1027:	// validate input
     2095: 1028:	if (ptr == NULL || searched == NULL || found == NULL) {
    #####: 1029:		SetErr(IllegalArgument);
    #####: 1030:		return -1;
        -: 1031:	}
        -: 1032:
        -: 1033:	// obtain the impl from the ptr
     2095: 1034:	ORBTreeImpl *impl = ptr->impl;
        -: 1035:	// this pair is used to search
        -: 1036:	ORBTreeNodePair pair;
        -: 1037:
     2095: 1038:	if (impl == NULL) {
    #####: 1039:		SetErr(IllegalState);
    #####: 1040:		return -1;
        -: 1041:	}
        -: 1042:
        -: 1043:	// perform search for the key
     2095: 1044:	orbtree_search(impl, searched, &pair);
        -: 1045:
     2095: 1046:	if (pair.self != NIL) {
     1054: 1047:		found->updated = true;
     1054: 1048:		found->value = orbtree_value(impl, pair.self);
        -: 1049:	} else {
     1041: 1050:		found->updated = false;
        -: 1051:	}
        -: 1052:
     2095: 1053:	return 0;
        -: 1054:}
       61: 1055:i64 orbtree_size(const ORBTree *ptr) {
       61: 1056:	if (ptr == NULL) {
    #####: 1057:		SetErr(IllegalArgument);
    #####: 1058:		return -1;
        -: 1059:	}
       61: 1060:	ORBTreeImpl *impl = ptr->impl;
        -: 1061:
       61: 1062:	if (impl == NULL) {
    #####: 1063:		SetErr(IllegalState);
    #####: 1064:		return -1;
        -: 1065:	}
        -: 1066:
       61: 1067:	return impl->elements;
        -: 1068:}
        -: 1069:
       30: 1070:i64 orbtree_slabs(const ORBTree *ptr) {
       30: 1071:	if (ptr == NULL) {
    #####: 1072:		SetErr(IllegalArgument);
    #####: 1073:		return -1;
        -: 1074:	}
       30: 1075:	ORBTreeImpl *impl = ptr->impl;
        -: 1076:
       30: 1077:	if (impl == NULL) {
    #####: 1078:		SetErr(IllegalState);
    #####: 1079:		return -1;
        -: 1080:	}
        -: 1081:
       30: 1082:	if (impl->alloc == NULL) {
    #####: 1083:		SetErr(IllegalState);
    #####: 1084:		return -1;
        -: 1085:	}
        -: 1086:
       30: 1087:	return impl->alloc->size;
        -: 1088:}
        -: 1089:
      433: 1090:void orbtree_iterator_impl(ORBTreeImpl *impl, ORBTreeIterator *iter, const void *start_value,
        -: 1091:						   bool start_inclusive, const void *end_value, bool end_inclusive) {
        -: 1092:
      433: 1093:	ORBTreeIteratorImpl *rbimpl = $(iter->impl);
      433: 1094:	rbimpl->impl = impl;
      433: 1095:	rbimpl->stack_pointer = 0;
      433: 1096:	rbimpl->value_size = impl->value_size;
      433: 1097:	rbimpl->cur = impl->root;
      433: 1098:	rbimpl->min = NIL;
      433: 1099:	rbimpl->max = NIL;
        -: 1100:
      433: 1101:	if (start_value != NULL) {
      422: 1102:		u32 itt = impl->root;
      422: 1103:		int i = 0;
     3850: 1104:		while (itt != NIL) {
     3628: 1105:			ORBTreeNode *node = orbtree_node(impl, itt);
     3628: 1106:			int v = impl->compare(node->data, start_value);
     3628: 1107:			if (v == 0) {
        -: 1108:				// exact match
      400: 1109:				if (start_inclusive) {
      200: 1110:					rbimpl->min = itt;
      200: 1111:					break;
        -: 1112:				} else {
      200: 1113:					if (node->right != NIL)
      100: 1114:						rbimpl->min = node->right;
      200: 1115:					itt = node->right;
        -: 1116:				}
     3228: 1117:			} else if (v < 0) {
        -: 1118:				// continue down the
        -: 1119:				// chain to look for
        -: 1120:				// more
     1399: 1121:				itt = node->right;
        -: 1122:			} else {
        -: 1123:				// higher value
        -: 1124:				// found update min
     1829: 1125:				rbimpl->min = itt;
     1829: 1126:				itt = node->left;
        -: 1127:			}
        -: 1128:		}
        -: 1129:	}
        -: 1130:
      433: 1131:	if (end_value != NULL) {
      422: 1132:		u32 itt = impl->root;
      422: 1133:		int i = 0;
     4078: 1134:		while (itt != NIL) {
     3856: 1135:			ORBTreeNode *node = orbtree_node(impl, itt);
     3856: 1136:			int v = impl->compare(node->data, end_value);
     3856: 1137:			if (v == 0) {
        -: 1138:				// exact match
      400: 1139:				if (end_inclusive) {
      200: 1140:					rbimpl->max = itt;
      200: 1141:					break;
        -: 1142:				}
      200: 1143:				itt = node->left;
     3456: 1144:			} else if (v < 0) {
        -: 1145:				// lower value found
        -: 1146:				// update max
     1970: 1147:				rbimpl->max = itt;
     1970: 1148:				itt = node->right;
        -: 1149:			} else {
        -: 1150:				// continue down the
        -: 1151:				// chain to look for
        -: 1152:				// more
     1486: 1153:				itt = node->left;
        -: 1154:			}
        -: 1155:		}
        -: 1156:	}
      433: 1157:}
        -: 1158:
       11: 1159:int orbtree_iterator(const ORBTree *ptr, ORBTreeIterator *iter, const void *start_value,
        -: 1160:					 bool start_inclusive, const void *end_value, bool end_inclusive, bool send) {
       11: 1161:	if (ptr == NULL || iter == NULL) {
    #####: 1162:		SetErr(IllegalArgument);
    #####: 1163:		return -1;
        -: 1164:	}
        -: 1165:
       11: 1166:	ORBTreeImpl *impl = ptr->impl;
       11: 1167:	if (impl == NULL) {
    #####: 1168:		SetErr(IllegalState);
    #####: 1169:		return -1;
        -: 1170:	}
        -: 1171:
        -: 1172:	{
       22: 1173:		SendStateGuard _ = SetSend(send);
       11: 1174:		if (fam_alloc(&iter->impl, sizeof(ORBTreeIteratorImpl))) {
    #####: 1175:			iter->impl = null;
    #####: 1176:			return -1;
        -: 1177:		}
        -: 1178:	}
        -: 1179:
       11: 1180:	orbtree_iterator_impl(impl, iter, start_value, start_inclusive, end_value, end_inclusive);
       11: 1181:	return 0;
        -: 1182:}
        -: 1183:
      422: 1184:int orbtree_iterator_reset(ORBTreeIterator *iter, const void *start_value, bool start_inclusive,
        -: 1185:						   const void *end_value, bool end_inclusive) {
      422: 1186:	if (iter == NULL) {
    #####: 1187:		SetErr(IllegalArgument);
    #####: 1188:		return -1;
        -: 1189:	}
        -: 1190:
      422: 1191:	ORBTreeIteratorImpl *ittimpl = $(iter->impl);
      422: 1192:	ORBTreeImpl *impl = ittimpl->impl;
      422: 1193:	if (impl == NULL) {
    #####: 1194:		SetErr(IllegalState);
    #####: 1195:		return -1;
        -: 1196:	}
        -: 1197:
      422: 1198:	orbtree_iterator_impl(impl, iter, start_value, start_inclusive, end_value, end_inclusive);
      422: 1199:	return 0;
        -: 1200:}
        -: 1201:
       27: 1202:int orbtree_init_free_list(ORBTreeImpl *impl, u8 *data, u32 offset) {
       27: 1203:	u64 cur_index = offset / NODES_PER_CHUNK;
    27675: 1204:	for (int i = 0; i < NODES_PER_CHUNK; i++) {
    27648: 1205:		if (i < NODES_PER_CHUNK - 1)
    27621: 1206:			impl->alloc->free_list[i + offset] = offset + i + 1;
        -: 1207:		else
       27: 1208:			impl->alloc->free_list[i + offset] = UINT32_MAX;
        -: 1209:	}
       27: 1210:	return 0;
        -: 1211:}
        -: 1212:
     6612: 1213:int orbtree_allocate_tray(ORBTree *ptr, ORBTreeTray *tray) {
     6612: 1214:	if (ptr == NULL || tray == NULL) {
    #####: 1215:		SetErr(IllegalArgument);
    #####: 1216:		return -1;
        -: 1217:	}
     6612: 1218:	ORBTreeImpl *impl = ptr->impl;
     6612: 1219:	if (impl == NULL) {
    #####: 1220:		SetErr(IllegalState);
    #####: 1221:		return -1;
        -: 1222:	}
     6612: 1223:	if (impl->alloc->free_list_head == UINT32_MAX) {
        -: 1224:		void *tmp;
       27: 1225:		if (((impl->alloc->capacity / 100) % CHUNKS_PER_RESIZE) == 0) {
       26: 1226:			if (impl->alloc->capacity == 0) {
       26: 1227:				tmp = mymalloc(sizeof(void *) * CHUNKS_PER_RESIZE);
        -: 1228:			} else {
    #####: 1229:				u64 size = (impl->alloc->cur_chunks + CHUNKS_PER_RESIZE) * sizeof(void *);
    #####: 1230:				tmp = myrealloc(impl->alloc->data_chunks, size);
        -: 1231:			}
        -: 1232:
       26: 1233:			if (tmp == NULL) {
    #####: 1234:				return -1;
        -: 1235:			}
       26: 1236:			impl->alloc->cur_chunks += CHUNKS_PER_RESIZE;
       26: 1237:			impl->alloc->data_chunks = tmp;
        -: 1238:		}
       27: 1239:		u64 index = impl->alloc->size / NODES_PER_CHUNK;
       54: 1240:		impl->alloc->data_chunks[index] =
       27: 1241:			mymalloc(sizeof(u8) * NODES_PER_CHUNK * (impl->value_size + sizeof(ORBTreeNode)));
        -: 1242:
       27: 1243:		if (impl->alloc->data_chunks[index] == NULL) {
    #####: 1244:			if (impl->alloc->capacity == 0) {
    #####: 1245:				impl->alloc->cur_chunks = 0;
    #####: 1246:				impl->alloc->data_chunks = NULL;
    #####: 1247:				myfree(tmp);
        -: 1248:			}
    #####: 1249:			return -1;
        -: 1250:		}
        -: 1251:
       27: 1252:		void *free_list = NULL;
       27: 1253:		if (impl->alloc->capacity == 0) {
       26: 1254:			free_list = mymalloc(sizeof(u32) * (impl->alloc->cur_chunks + 1) * NODES_PER_CHUNK);
        -: 1255:		} else {
        1: 1256:			free_list = myrealloc(impl->alloc->free_list,
        1: 1257:								  sizeof(u32) * (impl->alloc->cur_chunks + 1) * NODES_PER_CHUNK);
        -: 1258:		}
       27: 1259:		if (free_list == NULL) {
    #####: 1260:			if (impl->alloc->capacity == 0) {
    #####: 1261:				impl->alloc->cur_chunks = 0;
    #####: 1262:				impl->alloc->data_chunks = NULL;
    #####: 1263:				myfree(tmp);
    #####: 1264:				myfree(free_list);
    #####: 1265:				return -1;
        -: 1266:			}
        -: 1267:		}
        -: 1268:
       27: 1269:		impl->alloc->free_list = free_list;
       27: 1270:		orbtree_init_free_list(impl, impl->alloc->data_chunks[index], impl->alloc->size);
       27: 1271:		impl->alloc->free_list_head = impl->alloc->size;
       27: 1272:		impl->alloc->capacity = (index + 1) * NODES_PER_CHUNK;
        -: 1273:	}
        -: 1274:
     6612: 1275:	u32 next = impl->alloc->free_list_head;
     6612: 1276:	if (next == NIL)
    #####: 1277:		return -1;
     6612: 1278:	tray->value = orbtree_value(impl, next);
     6612: 1279:	impl->alloc->free_list_head = impl->alloc->free_list[next];
     6612: 1280:	tray->updated = true;
     6612: 1281:	tray->id = next;
     6612: 1282:	impl->alloc->free_list[next] = UINT32_MAX - 1;
     6612: 1283:	impl->alloc->size++;
     6612: 1284:	return 0;
        -: 1285:}
        -: 1286:
     3094: 1287:int orbtree_deallocate_tray(ORBTree *ptr, ORBTreeTray *tray) {
     3094: 1288:	if (ptr == NULL || tray == NULL) {
    #####: 1289:		SetErr(IllegalArgument);
    #####: 1290:		return -1;
        -: 1291:	}
     3094: 1292:	ORBTreeImpl *impl = ptr->impl;
     3094: 1293:	if (impl == NULL) {
    #####: 1294:		SetErr(IllegalState);
    #####: 1295:		return -1;
        -: 1296:	}
        -: 1297:
     3094: 1298:	if (impl->alloc->free_list == NULL) {
    #####: 1299:		panic("free list not "
        -: 1300:			  "initialized!");
        -: 1301:	}
        -: 1302:
     3094: 1303:	if ((impl->alloc->free_list)[tray->id] != (UINT32_MAX - 1)) {
    #####: 1304:		panic("Potential double "
        -: 1305:			  "free. Id = %llu.",
        -: 1306:			  tray->id);
        -: 1307:	}
        -: 1308:
     3094: 1309:	impl->alloc->free_list[tray->id] = impl->alloc->free_list_head;
     3094: 1310:	impl->alloc->free_list_head = tray->id;
     3094: 1311:	impl->alloc->size--;
        -: 1312:
     3094: 1313:	return 0;
        -: 1314:}
        -: 1315:
        -: 1316:#ifdef NODE_ID
        -: 1317:
        -: 1318:void orbtree_validate_node(const ORBTreeImpl *impl, u32 node, int *black_count,
        -: 1319:						   int current_black_count) {
        -: 1320:	u64 value_size = impl->value_size;
        -: 1321:
        -: 1322:	// Base case: when we reach a
        -: 1323:	// NIL
        -: 1324:	if (node == NIL) {
        -: 1325:		// If this is the first NIL
        -: 1326:		// node reached, set the
        -: 1327:		// black count
        -: 1328:		if (*black_count == 0) {
        -: 1329:			*black_count = current_black_count; // Set the black count for the first path
        -: 1330:		} else {
        -: 1331:			// Check for black count
        -: 1332:			// consistency
        -: 1333:			assert(current_black_count == *black_count);
        -: 1334:		}
        -: 1335:		return; // Return for NIL
        -: 1336:				// nodes
        -: 1337:	}
        -: 1338:
        -: 1339:	ORBTreeNode *n = orbtree_node(impl, node);
        -: 1340:
        -: 1341:	// check subtree heights
        -: 1342:	u32 right_subtree_sum = 0;
        -: 1343:	if (n->right != NIL) {
        -: 1344:		ORBTreeNode *nr = orbtree_node(impl, n->right);
        -: 1345:		if (nr)
        -: 1346:			right_subtree_sum = 1 + nr->right_subtree_size + nr->left_subtree_size;
        -: 1347:	}
        -: 1348:	u32 left_subtree_sum = 0;
        -: 1349:	if (n->left != NIL) {
        -: 1350:		ORBTreeNode *nl = orbtree_node(impl, n->left);
        -: 1351:		if (n)
        -: 1352:			left_subtree_sum = 1 + nl->right_subtree_size + nl->left_subtree_size;
        -: 1353:	}
        -: 1354:
        -: 1355:	if (left_subtree_sum != n->left_subtree_size || right_subtree_sum != n->right_subtree_size) {
        -: 1356:		printf("invalid subtree "
        -: 1357:			   "counts at node = "
        -: 1358:			   "%llu\n",
        -: 1359:			   n->node_id);
        -: 1360:	}
        -: 1361:	assert(left_subtree_sum == n->left_subtree_size);
        -: 1362:	assert(right_subtree_sum == n->right_subtree_size);
        -: 1363:
        -: 1364:	// Increment black count if the
        -: 1365:	// current node is black
        -: 1366:	if (IS_BLACK(impl, node)) {
        -: 1367:		current_black_count++;
        -: 1368:	} else {
        -: 1369:		//   Check if the node is
        -: 1370:		//   red If the parent is
        -: 1371:		//   red, return false (Red
        -: 1372:		//   property violation)
        -: 1373:		assert(!(n->parent != NIL && IS_RED(impl, n->parent)));
        -: 1374:	}
        -: 1375:
        -: 1376:	// Recursive calls for left and
        -: 1377:	// right children
        -: 1378:	orbtree_validate_node(impl, n->left, black_count, current_black_count);
        -: 1379:	orbtree_validate_node(impl, n->right, black_count, current_black_count);
        -: 1380:}
        -: 1381:
        -: 1382:void orbtree_validate_impl(const ORBTreeImpl *impl) {
        -: 1383:	int black_count = 0;
        -: 1384:	// Validate from the root and
        -: 1385:	// check if the root is black
        -: 1386:	if (impl->root != NIL) {
        -: 1387:		assert(IS_BLACK(impl, impl->root));
        -: 1388:		orbtree_validate_node(impl, impl->root, &black_count, 0);
        -: 1389:	}
        -: 1390:}
        -: 1391:
        -: 1392:void orbtree_validate(const ORBTree *ptr) {
        -: 1393:	ORBTreeImpl *impl = ptr->impl;
        -: 1394:	orbtree_validate_impl(impl);
        -: 1395:}
        -: 1396:
        -: 1397:// Function to print a single node
        -: 1398:// with its color
        -: 1399:void orbtree_print_node(const ORBTreeImpl *impl, u32 node_id, int depth) {
        -: 1400:	if (node_id == NIL) {
        -: 1401:		for (int i = 0; i < depth; i++) {
        -: 1402:			printf("    ");
        -: 1403:		}
        -: 1404:		printf("0 (B)\n");
        -: 1405:		return;
        -: 1406:	}
        -: 1407:
        -: 1408:	ORBTreeNode *node = orbtree_node(impl, node_id);
        -: 1409:
        -: 1410:	// Print the right child first
        -: 1411:	// (for visual representation)
        -: 1412:	orbtree_print_node(impl, node->right, depth + 1);
        -: 1413:
        -: 1414:	// Indent according to depth
        -: 1415:	for (int i = 0; i < depth; i++) {
        -: 1416:		printf("    ");
        -: 1417:	}
        -: 1418:
        -: 1419:	// Print the current node with a
        -: 1420:	// clearer representation
        -: 1421:	printf("%llu (%s,r=%u,l=%u)\n", node->node_id, (IS_BLACK(impl, node_id)) ? "B" : "R",
        -: 1422:		   node->right_subtree_size, node->left_subtree_size);
        -: 1423:
        -: 1424:	// Print the left child
        -: 1425:	orbtree_print_node(impl, node->left, depth + 1);
        -: 1426:}
        -: 1427:
        -: 1428:void orbtree_print_impl(ORBTreeImpl *impl) {
        -: 1429:	ORBTreeNode *root = orbtree_node(impl, impl->root);
        -: 1430:	if (!root)
        -: 1431:		printf("Red-Black Tree (root "
        -: 1432:			   "= 0) Empty Tree!\n");
        -: 1433:	else {
        -: 1434:		printf("Red-Black Tree "
        -: 1435:			   "(root = %llu)\n",
        -: 1436:			   root->node_id);
        -: 1437:		printf("==================="
        -: 1438:			   "================"
        -: 1439:			   "\n"); // Separator
        -: 1440:					  // for better
        -: 1441:					  // clarity
        -: 1442:		orbtree_print_node(impl, impl->root, 0);
        -: 1443:		printf("==================="
        -: 1444:			   "================"
        -: 1445:			   "\n"); // Separator
        -: 1446:					  // for better
        -: 1447:					  // clarity
        -: 1448:	}
        -: 1449:}
        -: 1450:
        -: 1451:// Function to print the entire tree
        -: 1452:void orbtree_print(const ORBTree *ptr) {
        -: 1453:	ORBTreeImpl *impl = ptr->impl;
        -: 1454:	orbtree_print_impl(impl);
        -: 1455:}
        -: 1456:#else
        5: 1457:void orbtree_print(const ORBTree *ptr) {
        5: 1458:}
     4035: 1459:void orbtree_validate(const ORBTree *ptr) {
     4035: 1460:}
        -: 1461:#endif // NODE_ID
        -:    0:Source:rbtree.c
        -:    0:Graph:rbtree.gcno
        -:    0:Data:rbtree.gcda
        -:    0:Runs:29
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <base/bitflags.h>
        -:   17:#include <base/fam_alloc.h>
        -:   18:#include <base/fam_err.h>
        -:   19:#include <base/macro_utils.h>
        -:   20:#include <base/panic.h>
        -:   21:#include <stdio.h>
        -:   22:#include <string.h>
        -:   23:#include <util/rbtree.h>
        -:   24:
        -:   25:// Node id counter
        -:   26:static u64 node_id_counter = 10;
        -:   27:
        -:   28:// RBTreeNode (overhead on 64 bit system is: four pointers * 8 = 32 bytes + Fat pointer's slab has a
        -:   29:// next pointer (8 bytes) and the FatPointer impl (with 32 bit slabs, which is default) has 16 bytes
        -:   30:// overhead. So, total overhead is 56 bytes. With 64 bit slabs there's an additional 8 bytes.
        -:   31:// It's also important to note that key/values are padded to 16 bytes. So that may introduce
        -:   32:// additional overhead. The 'data' section holds both key/value and 1 byte for node color.
        -:   33:typedef struct RBTreeNode {
        -:   34:	FatPtr self;
        -:   35:	struct RBTreeNode *right;
        -:   36:	struct RBTreeNode *left;
        -:   37:	struct RBTreeNode *parent;
        -:   38:#ifdef TEST
        -:   39:	u64 node_id;
        -:   40:	u64 pad;
        -:   41:#endif // TEST
        -:   42:	char data[];
        -:   43:} RBTreeNode;
        -:   44:
        -:   45:// The internal RBTreeImpl storage data structure
        -:   46:typedef struct RBTreeImpl {
        -:   47:	u64 key_size;								// size of the keys
        -:   48:	u64 value_size;								// size of the values
        -:   49:	int (*compare)(const void *, const void *); // a comparion function (like qsort)
        -:   50:	RBTreeNode *root;							// pointer to the root node.
        -:   51:	u64 size;									// current size of the tree.
        -:   52:	bool send; // whether this RBTree can be sent to other threads (using global fam_alloc)
        -:   53:} RBTreeImpl;
        -:   54:
        -:   55:// Iterator impl
        -:   56:typedef struct RBTreeIteratorImpl {
        -:   57:	int (*compare)(const void *, const void *);
        -:   58:	RBTreeNode *cur;
        -:   59:	RBTreeNode *min;
        -:   60:	RBTreeNode *max;
        -:   61:	RBTreeNode *stack[128];
        -:   62:	u64 key_size;
        -:   63:	u8 stack_pointer;
        -:   64:	bool send;
        -:   65:	RBTreeImpl *impl;
        -:   66:} RBTreeIteratorImpl;
        -:   67:
        -:   68:// Data structure used for searching RBTrees.
        -:   69:typedef struct RBTreeNodePair {
        -:   70:	RBTreeNode *parent;
        -:   71:	RBTreeNode *self;
        -:   72:	bool is_right;
        -:   73:} RBTreeNodePair;
        -:   74:
        -:   75:// utility macros
        -:   76:#define BOOLEAN_SIZE 1
        -:   77:#define VALUE_PAD(key_size) (key_size % 16)
        -:   78:#define DATA_SIZE(impl)                                                                            \
        -:   79:	(sizeof(RBTreeNode) + (impl->key_size + impl->value_size) * sizeof(char) +                     \
        -:   80:	 VALUE_PAD(impl->key_size) + BOOLEAN_SIZE)
        -:   81:#define RED_OFFSET(key_size, value_size) (key_size + value_size + VALUE_PAD(key_size))
        -:   82:#define RBTREE_FLAGS_RED 0
        -:   83:#define INIT_FLAGS(impl, node)                                                                     \
        -:   84:	({                                                                                             \
        -:   85:		u64 offset = RED_OFFSET(impl->key_size, impl->value_size);                                 \
        -:   86:		node->data[offset] = 0;                                                                    \
        -:   87:	})
        -:   88:
        -:   89:#define SET_RED(impl, node)                                                                        \
        -:   90:	({                                                                                             \
        -:   91:		u64 offset = RED_OFFSET(impl->key_size, impl->value_size);                                 \
        -:   92:		BitFlags bf = {.flags = (u8 *)(node->data + offset), .capacity = 1};                       \
        -:   93:		bitflags_set(&bf, RBTREE_FLAGS_RED, true);                                                 \
        -:   94:	})
        -:   95:#define SET_BLACK(impl, node)                                                                      \
        -:   96:	({                                                                                             \
        -:   97:		u64 offset = RED_OFFSET(impl->key_size, impl->value_size);                                 \
        -:   98:		BitFlags bf = {.flags = (u8 *)(node->data + offset), .capacity = 1};                       \
        -:   99:		bitflags_set(&bf, RBTREE_FLAGS_RED, false);                                                \
        -:  100:	})
        -:  101:
        -:  102:#define IS_RED(impl, node)                                                                         \
        -:  103:	({                                                                                             \
        -:  104:		u64 offset = RED_OFFSET(impl->key_size, impl->value_size);                                 \
        -:  105:		BitFlags bf = {.flags = (u8 *)(node->data + offset), .capacity = 1};                       \
        -:  106:		node != NIL &&bitflags_check(&bf, RBTREE_FLAGS_RED);                                       \
        -:  107:	})
        -:  108:#define IS_BLACK(impl, node)                                                                       \
        -:  109:	({                                                                                             \
        -:  110:		u64 offset = RED_OFFSET(impl->key_size, impl->value_size);                                 \
        -:  111:		BitFlags bf = {.flags = (u8 *)(node->data + offset), .capacity = 1};                       \
        -:  112:		node == NIL || !bitflags_check(&bf, RBTREE_FLAGS_RED);                                     \
        -:  113:	})
        -:  114:
        -:  115:#if defined(__clang__)
        -:  116:// Clang-specific pragma
        -:  117:#pragma GCC diagnostic push
        -:  118:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  119:#elif defined(__GNUC__) && !defined(__clang__)
        -:  120:// GCC-specific pragma
        -:  121:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  122:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  123:#else
        -:  124:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  125:#endif
        -:  126:const static RBTreeNode NIL_DEFN = {
        -:  127:	.self = null, .right = &NIL_DEFN, .left = &NIL_DEFN, .parent = &NIL_DEFN};
        -:  128:static RBTreeNode *NIL = &NIL_DEFN;
        -:  129:#pragma GCC diagnostic pop
        -:  130:
        -:  131:// cleanup function for iterators
        3:  132:void rbtree_iterator_cleanup(RBTreeIteratorNc *ptr) {
        3:  133:	if (!nil(ptr->impl)) {
        -:  134:		// obtain referent to internal RBTreeImpl structure
        3:  135:		RBTreeIteratorImpl *impl = $(ptr->impl);
        -:  136:		// set appropriate chainguard status
        6:  137:		SendStateGuard _ = SetSend(impl->send);
        -:  138:
        -:  139:		// free RBTreeImpl structure
        3:  140:		fam_free(&ptr->impl);
        -:  141:	}
        3:  142:}
        -:  143:
        -:  144:// returns the next item in the iterator
     4111:  145:bool rbtree_iterator_next(RBTreeIterator *ptr, RbTreeKeyValue *kv) {
     4111:  146:	RBTreeIteratorImpl *impl = $(ptr->impl);
        -:  147:
        -:  148:	// If the iterator is empty, we're done
     4111:  149:	if (impl->cur == NIL && impl->stack_pointer == 0) {
        3:  150:		return false; // No more nodes to traverse
        -:  151:	}
        -:  152:
        -:  153:	// Traverse the tree
     8219:  154:	while (impl->cur != NIL || impl->stack_pointer > 0) {
        -:  155:		// Traverse left subtree
     8219:  156:		if (impl->cur != NIL) {
        -:  157:			// based on worst case log(n) * 2 + 1 this should not be possible
    4111*:  158:			assert(impl->stack_pointer < 128);
     4111:  159:			int v = 0;
     4111:  160:			if (impl->min != NIL)
        5:  161:				v = impl->compare(impl->cur->data, impl->min->data);
     4111:  162:			if (v < 0) {
        -:  163:				// we haven't hit the minimum yet
        2:  164:				impl->cur = impl->cur->right;
        -:  165:			} else {
        -:  166:				// Push the current node pointer onto the stack
     4109:  167:				impl->stack[impl->stack_pointer++] = impl->cur;
        -:  168:
        -:  169:				// Move to the left child
     4109:  170:				impl->cur = impl->cur->left;
        -:  171:			}
        -:  172:		} else {
        -:  173:			// Pop the top node from the stack
     4108:  174:			impl->cur = impl->stack[--impl->stack_pointer];
        -:  175:
        -:  176:			// Store the current node's data to return
     4108:  177:			void *ret = impl->cur->data;
        -:  178:
        -:  179:			// check if we hit our max node. If so, next will return false.
     4108:  180:			if (impl->cur == impl->max) {
        1:  181:				impl->cur = NIL;
        1:  182:				impl->stack_pointer = 0;
        -:  183:			}
        -:  184:
        -:  185:			// Move to the right child after visiting this node
     4108:  186:			impl->cur = impl->cur->right;
        -:  187:
     4108:  188:			kv->key = ret;
     4108:  189:			kv->value = ret + VALUE_PAD(impl->key_size) + impl->key_size;
     4108:  190:			break;
        -:  191:		}
        -:  192:	}
     4108:  193:	return true;
        -:  194:}
        -:  195:
     6677:  196:void rbtree_free_node(RBTreeNode *ptr) {
     6677:  197:	if (ptr != NIL) {
        -:  198:		// recursively free right node
     3335:  199:		rbtree_free_node(ptr->right);
        -:  200:		// recursively free left node
     3335:  201:		rbtree_free_node(ptr->left);
        -:  202:		// chain free current node
     3335:  203:		fam_free(&ptr->self);
        -:  204:	}
     6677:  205:}
        -:  206:
        -:  207:// internal search function used by get/insert/delete.
    22373:  208:void rbtree_search(RBTreeImpl *impl, const void *key, RBTreeNodePair *nodes) {
    22373:  209:	nodes->parent = NIL;
    22373:  210:	nodes->self = impl->root;
        -:  211:
    22373:  212:	int i = 0;
   239318:  213:	while (nodes->self != NIL) {
        -:  214:#ifdef TEST
        -:  215:		// should never have a case where this is not true
        -:  216:		// only NIL accepted
  228529*:  217:		assert(nodes->self->parent);
  228529*:  218:		assert(nodes->self->left);
  228529*:  219:		assert(nodes->self->right);
        -:  220:#endif // TEST
   228529:  221:		nodes->parent = nodes->self;
   228529:  222:		int v = impl->compare(nodes->self->data, key);
   228529:  223:		if (v == 0) {
    11584:  224:			break;
   216945:  225:		} else if (v < 0) {
   110418:  226:			nodes->self = nodes->self->right;
   110418:  227:			nodes->is_right = true;
        -:  228:		} else {
   106527:  229:			nodes->self = nodes->self->left;
   106527:  230:			nodes->is_right = false;
        -:  231:		}
        -:  232:	}
    22373:  233:}
        -:  234:
        -:  235:// do a left rotation
     5106:  236:void rbtree_left_rotate(RBTreeImpl *impl, RBTreeNode *x) {
        -:  237:
        -:  238:#ifdef TEST
        -:  239:	// should never have a case where this is not true
        -:  240:	// only NIL accepted
    5106*:  241:	assert(x->parent);
    5106*:  242:	assert(x->left);
    5106*:  243:	assert(x->right);
        -:  244:#endif // TEST
        -:  245:
     5106:  246:	RBTreeNode *y = x->right;
        -:  247:
        -:  248:	// Move y's left subtree to x's right subtree
     5106:  249:	x->right = y->left;
     5106:  250:	if (y->left != NIL) {
     1564:  251:		y->left->parent = x;
        -:  252:	}
        -:  253:
        -:  254:	// Update y's parent to x's parent
     5106:  255:	y->parent = x->parent;
        -:  256:
        -:  257:	// If x was the root, now y becomes the root
     5106:  258:	if (x->parent == NIL) {
       16:  259:		impl->root = y;
     5090:  260:	} else if (x == x->parent->left) {
     3180:  261:		x->parent->left = y;
        -:  262:	} else {
     1910:  263:		x->parent->right = y;
        -:  264:	}
        -:  265:
        -:  266:	// Place x as y's left child
     5106:  267:	y->left = x;
     5106:  268:	x->parent = y;
     5106:  269:}
        -:  270:
        -:  271:// do a right rotation
     4256:  272:void rbtree_right_rotate(RBTreeImpl *impl, RBTreeNode *x) {
        -:  273:
        -:  274:#ifdef TEST
        -:  275:	// should never have a case where this is not true
        -:  276:	// only NIL accepted
    4256*:  277:	assert(x->parent);
    4256*:  278:	assert(x->left);
    4256*:  279:	assert(x->right);
        -:  280:#endif // TEST
        -:  281:
     4256:  282:	RBTreeNode *y = x->left;
        -:  283:
        -:  284:	// Move y's right subtree to x's left subtree
     4256:  285:	x->left = y->right;
     4256:  286:	if (y->right != NIL) {
     1242:  287:		y->right->parent = x;
        -:  288:	}
        -:  289:
        -:  290:	// Update y's parent to x's parent
     4256:  291:	y->parent = x->parent;
        -:  292:
        -:  293:	// If x was the root, now y becomes the root
     4256:  294:	if (x->parent == NIL) {
        3:  295:		impl->root = y;
     4253:  296:	} else if (x == x->parent->right) {
     2938:  297:		x->parent->right = y;
        -:  298:	} else {
     1315:  299:		x->parent->left = y;
        -:  300:	}
        -:  301:
        -:  302:	// Place x as y's right child
     4256:  303:	y->right = x;
     4256:  304:	x->parent = y;
     4256:  305:}
        -:  306:
        -:  307:// Fixup operation after insertion to maintain Red-Black Tree properties
    10786:  308:void rbtree_put_fixup(RBTreeImpl *impl, RBTreeNode *k) {
    10786:  309:	int i = 0;
        -:  310:	// Loop until the node is the root or its parent's color is black
    19369:  311:	while (k != impl->root && IS_RED(impl, k->parent)) {
        -:  312:#ifdef TEST
        -:  313:		// Ensure that the parent, left, and right children are not NULL
        -:  314:		// The only exception is NIL nodes, which can be accepted
    8583*:  315:		assert(k->parent);
    8583*:  316:		assert(k->left);
    8583*:  317:		assert(k->right);
        -:  318:#endif // TEST
        -:  319:
     8583:  320:		if (k->parent == k->parent->parent->left) {
        -:  321:			// Case 1: Uncle is on the right
     3794:  322:			RBTreeNode *u = k->parent->parent->right;
        -:  323:
     3794:  324:			if (IS_RED(impl, u)) {
        -:  325:				// Case 1a: Uncle is red
        -:  326:				// Recolor the parent and uncle to black
     2067:  327:				SET_BLACK(impl, k->parent);
     2067:  328:				SET_BLACK(impl, u);
        -:  329:				// Recolor the grandparent to red
     2067:  330:				SET_RED(impl, k->parent->parent);
        -:  331:				// Move up the tree
     2067:  332:				k = k->parent->parent;
        -:  333:			} else {
        -:  334:				// Case 1b: Uncle is black
     1727:  335:				if (k == k->parent->right) {
        -:  336:					// Case 1b1: Node is a right child
        -:  337:					// Rotate left to make the node the left child
      890:  338:					k = k->parent;
      890:  339:					rbtree_left_rotate(impl, k);
        -:  340:				}
        -:  341:				// Recolor and rotate
     1727:  342:				SET_BLACK(impl, k->parent);
     1727:  343:				SET_RED(impl, k->parent->parent);
     1727:  344:				rbtree_right_rotate(impl, k->parent->parent);
        -:  345:			}
        -:  346:		} else {
        -:  347:			// Case 2: Uncle is on the left
     4789:  348:			RBTreeNode *u = k->parent->parent->left;
        -:  349:
     4789:  350:			if (IS_RED(impl, u)) {
        -:  351:				// Case 2a: Uncle is red
        -:  352:				// Recolor the parent and uncle to black
     2430:  353:				SET_BLACK(impl, k->parent);
     2430:  354:				SET_BLACK(impl, u);
        -:  355:				// Recolor the grandparent to red
     2430:  356:				SET_RED(impl, k->parent->parent);
        -:  357:				// Move up the tree
     2430:  358:				k = k->parent->parent;
        -:  359:			} else {
        -:  360:				// Case 2b: Uncle is black
     2359:  361:				if (k == k->parent->left) {
        -:  362:					// Case 2b1: Node is a left child
        -:  363:					// Rotate right to make the node the right child
     1095:  364:					k = k->parent;
     1095:  365:					rbtree_right_rotate(impl, k);
        -:  366:				}
        -:  367:				// Recolor and rotate
     2359:  368:				SET_BLACK(impl, k->parent);
     2359:  369:				SET_RED(impl, k->parent->parent);
     2359:  370:				rbtree_left_rotate(impl, k->parent->parent);
        -:  371:			}
        -:  372:		}
        -:  373:	}
        -:  374:	// Ensure the root is always black
    10786:  375:	SET_BLACK(impl, impl->root);
    10786:  376:}
        -:  377:
        -:  378:// cleanup function selects appropriate SendStateGuard based on configuration and
        -:  379:// deallocates memory
        7:  380:void rbtree_cleanup(RBTreeNc *ptr) {
        -:  381:	// check non-initialized conditions
        7:  382:	if (!nil(ptr->impl)) {
        -:  383:		// obtain referent to internal RBTree structure
        7:  384:		RBTreeImpl *impl = $(ptr->impl);
        -:  385:		// set appropriate chainguard status
       14:  386:		SendStateGuard _ = SetSend(impl->send);
        -:  387:
        7:  388:		rbtree_free_node(impl->root);
        -:  389:
        -:  390:		// free RBTreeImpl structure
        7:  391:		fam_free(&ptr->impl);
        -:  392:	}
        7:  393:}
        -:  394:
        9:  395:int rbtree_create(RBTree *ptr, const u64 key_size, const u64 value_size,
        -:  396:				  int (*compare)(const void *, const void *), bool send) {
        -:  397:	// validate input
        9:  398:	if (ptr == NULL || key_size == 0 || value_size == 0 || compare == NULL) {
        1:  399:		SetErr(IllegalArgument);
        1:  400:		return -1;
        -:  401:	}
        -:  402:
        -:  403:	RBTreeImpl *impl;
        -:  404:
        -:  405:	{
       16:  406:		SendStateGuard _ = SetSend(send);
        -:  407:		// try to allocate required size for RBTreeImpl
        8:  408:		if (fam_alloc(&ptr->impl, sizeof(RBTreeImpl))) {
        -:  409:			// set the fatptr to null so it's not cleaned up in cleanup function
        1:  410:			ptr->impl = null;
        1:  411:			return -1;
        -:  412:		}
        -:  413:	}
        -:  414:
        7:  415:	impl = $(ptr->impl);
        -:  416:	// initialize values of the RBTreeImpl structure
        7:  417:	impl->send = send;
        7:  418:	impl->key_size = key_size;
        7:  419:	impl->value_size = value_size;
        7:  420:	impl->compare = compare;
        7:  421:	impl->root = NIL;
        7:  422:	impl->size = 0;
        -:  423:
        7:  424:	return 0;
        -:  425:}
        -:  426:
    #####:  427:int rbtree_put_swap(RBTree *ptr, const void *key, const void *value, RbTreeKeyValue *swap) {
        -:  428:	// validate input
    #####:  429:	if (ptr == NULL || key == NULL || value == NULL) {
    #####:  430:		SetErr(IllegalArgument);
    #####:  431:		return -1;
        -:  432:	}
        -:  433:
        -:  434:	// obtain the impl from the fat ptr
    #####:  435:	RBTreeImpl *impl = $(ptr->impl);
        -:  436:	// this pair is used to search
        -:  437:	RBTreeNodePair pair;
        -:  438:	// pointer for our node
        -:  439:	RBTreeNode *node;
        -:  440:
        -:  441:	// perform search for the key
    #####:  442:	rbtree_search(impl, key, &pair);
        -:  443:
        -:  444:	// retreive the data size
    #####:  445:	u64 size = DATA_SIZE(impl);
    #####:  446:	if (pair.self != NIL) {
    #####:  447:		node = $(pair.self->self);
    #####:  448:		if (swap) {
    #####:  449:			if (swap->key)
    #####:  450:				memcpy(swap->key, node->data, impl->key_size);
    #####:  451:			if (swap->value)
    #####:  452:				memcpy(swap->value, node->data + VALUE_PAD(impl->key_size) + impl->key_size,
    #####:  453:					   impl->value_size);
    #####:  454:			swap->update = true;
        -:  455:		}
    #####:  456:		memcpy(node->data, key, impl->key_size);
    #####:  457:		memcpy(node->data + VALUE_PAD(impl->key_size) + impl->key_size, value, impl->value_size);
    #####:  458:		return 0;
        -:  459:	}
        -:  460:
        -:  461:	FatPtr self;
        -:  462:
        -:  463:	// using fam_alloc allocate memory for this node
        -:  464:	{
    #####:  465:		SendStateGuard _ = SetSend(impl->send);
    #####:  466:		if (fam_alloc(&self, size)) {
    #####:  467:			self = null;
    #####:  468:			return -1;
        -:  469:		}
        -:  470:	}
        -:  471:
        -:  472:	// using the allocated memory set node properties
    #####:  473:	node = $(self);
    #####:  474:	node->self = self;
    #####:  475:	if (impl->root == NIL) {
    #####:  476:		impl->root = node;
    #####:  477:	} else if (pair.is_right) {
    #####:  478:		pair.parent->right = node;
        -:  479:	} else {
    #####:  480:		pair.parent->left = node;
        -:  481:	}
    #####:  482:	node->right = NIL;			// always must be set to NIL at first.
    #####:  483:	node->left = NIL;			// always must be set to NIL at first.
    #####:  484:	node->parent = pair.parent; // set our parent pointer.
        -:  485:
        -:  486:	// copy data
    #####:  487:	memcpy(node->data, key, impl->key_size);
        -:  488:	// copy value
    #####:  489:	memcpy(node->data + VALUE_PAD(impl->key_size) + impl->key_size, value, impl->value_size);
        -:  490:	// nodes are initially red
    #####:  491:	INIT_FLAGS(impl, node);
    #####:  492:	SET_RED(impl, node);
        -:  493:
        -:  494:#ifdef TEST
    #####:  495:	node->node_id = node_id_counter++;
        -:  496:#endif // TEST
        -:  497:
        -:  498:	// increment the size counter
    #####:  499:	impl->size++;
        -:  500:
        -:  501:	// insert_fixup
    #####:  502:	rbtree_put_fixup(impl, node);
        -:  503:
    #####:  504:	return 0;
        -:  505:}
        -:  506:
        -:  507:// insert function
    10789:  508:int rbtree_put(RBTree *ptr, const void *key, const void *value) {
        -:  509:	// validate input
    10789:  510:	if (ptr == NULL || key == NULL || value == NULL) {
        1:  511:		SetErr(IllegalArgument);
        1:  512:		return -1;
        -:  513:	}
        -:  514:
        -:  515:	// obtain the impl from the fat ptr
    10788:  516:	RBTreeImpl *impl = $(ptr->impl);
        -:  517:	// this pair is used to search
        -:  518:	RBTreeNodePair pair;
        -:  519:	// pointer for our node
        -:  520:	RBTreeNode *node;
        -:  521:
        -:  522:	// perform search for the key
    10788:  523:	rbtree_search(impl, key, &pair);
        -:  524:
        -:  525:	// retreive the data size
    10788:  526:	u64 size = DATA_SIZE(impl);
    10788:  527:	if (pair.self != NIL) {
        1:  528:		node = $(pair.self->self);
        1:  529:		memcpy(node->data + VALUE_PAD(impl->key_size) + impl->key_size, value, impl->value_size);
        1:  530:		return 0;
        -:  531:	}
        -:  532:
        -:  533:	FatPtr self;
        -:  534:
        -:  535:	// using fam_alloc allocate memory for this node
        -:  536:	{
    21574:  537:		SendStateGuard _ = SetSend(impl->send);
    10787:  538:		if (fam_alloc(&self, size)) {
        1:  539:			self = null;
        1:  540:			return -1;
        -:  541:		}
        -:  542:	}
        -:  543:
        -:  544:	// using the allocated memory set node properties
    10786:  545:	node = $(self);
    10786:  546:	node->self = self;
    10786:  547:	if (impl->root == NIL) {
        9:  548:		impl->root = node;
    10777:  549:	} else if (pair.is_right) {
     5620:  550:		pair.parent->right = node;
        -:  551:	} else {
     5157:  552:		pair.parent->left = node;
        -:  553:	}
    10786:  554:	node->right = NIL;			// always must be set to NIL at first.
    10786:  555:	node->left = NIL;			// always must be set to NIL at first.
    10786:  556:	node->parent = pair.parent; // set our parent pointer.
        -:  557:
        -:  558:	// copy data
    10786:  559:	memcpy(node->data, key, impl->key_size);
        -:  560:	// copy value
    10786:  561:	memcpy(node->data + VALUE_PAD(impl->key_size) + impl->key_size, value, impl->value_size);
        -:  562:	// nodes are initially red
    10786:  563:	INIT_FLAGS(impl, node);
    10786:  564:	SET_RED(impl, node);
        -:  565:
        -:  566:#ifdef TEST
    10786:  567:	node->node_id = node_id_counter++;
        -:  568:#endif // TEST
        -:  569:
        -:  570:	// increment the size counter
    10786:  571:	impl->size++;
        -:  572:
        -:  573:	// insert_fixup
    10786:  574:	rbtree_put_fixup(impl, node);
        -:  575:
    10786:  576:	return 0;
        -:  577:}
        -:  578:
        -:  579:// find the successor node
     4412:  580:RBTreeNode *rbtree_find_successor(RBTreeImpl *impl, RBTreeNode *x) {
     4412:  581:	RBTreeNode *successor = x->right;
    11288:  582:	while (successor->left != NIL) {
     6876:  583:		successor = successor->left;
        -:  584:	}
     4412:  585:	return successor;
        -:  586:}
        -:  587:
        -:  588:// perform transplant operation
    10656:  589:void rbtree_transplant(RBTreeImpl *impl, RBTreeNode *dst, RBTreeNode *src) {
    10656:  590:	if (dst->parent == NIL)
       31:  591:		impl->root = src;
    10625:  592:	else if (dst == dst->parent->left)
     6967:  593:		dst->parent->left = src;
        -:  594:	else
     3658:  595:		dst->parent->right = src;
    10656:  596:	if (src != NIL) {
     5953:  597:		src->parent = dst->parent;
        -:  598:	}
    10656:  599:}
        -:  600:
        -:  601:// set child's color to parent's
     6294:  602:void set_color_based_on_parent(RBTreeImpl *impl, RBTreeNode *child, RBTreeNode *parent) {
     6294:  603:	if (child != NIL) {
     6294:  604:		if (IS_RED(impl, parent)) {
     2651:  605:			SET_RED(impl, child);
        -:  606:		} else {
     3643:  607:			SET_BLACK(impl, child);
        -:  608:		}
        -:  609:	}
     6294:  610:}
        -:  611:
        -:  612:// delete fixup
     5263:  613:void rbtree_remove_fixup(RBTreeImpl *impl, RBTreeNode *parent, RBTreeNode *w, RBTreeNode *x) {
     5263:  614:	int i = 0;
     9808:  615:	while (x != impl->root && IS_BLACK(impl, x)) {
     4545:  616:		if (w == parent->right) {
        -:  617:			// Case 1: Sibling is red
     2588:  618:			if (IS_RED(impl, w)) {
      330:  619:				SET_BLACK(impl, w);
      330:  620:				SET_RED(impl, parent);
      330:  621:				rbtree_left_rotate(impl, parent);
      330:  622:				w = parent->right;
        -:  623:			}
        -:  624:
        -:  625:			// Case 2: Sibling's children are both black
     2588:  626:			if (IS_BLACK(impl, w->left) && IS_BLACK(impl, w->right)) {
     1445:  627:				SET_RED(impl, w);
     1445:  628:				x = parent;
     1445:  629:				parent = parent->parent;
     1445:  630:				if (x == x->parent->left) {
      902:  631:					w = x->parent->right;
        -:  632:				} else {
      543:  633:					w = x->parent->left;
        -:  634:				}
        -:  635:			} else {
        -:  636:				// Case 3: Sibling's right child is black, left child is red
     1143:  637:				if (IS_BLACK(impl, w->right)) {
      462:  638:					SET_BLACK(impl, w->left);
      462:  639:					SET_RED(impl, w);
      462:  640:					rbtree_right_rotate(impl, w);
      462:  641:					w = parent->right;
        -:  642:				}
        -:  643:
        -:  644:				// Case 4: Sibling's right child is red
     1143:  645:				set_color_based_on_parent(impl, w, parent);
     1143:  646:				SET_BLACK(impl, parent);
     1143:  647:				SET_BLACK(impl, w->right);
     1143:  648:				rbtree_left_rotate(impl, parent);
     1143:  649:				x = impl->root; // Set x to root at the end, only once
        -:  650:			}
        -:  651:		} else {
        -:  652:			// Case 1: Sibling is red
     1957:  653:			if (IS_RED(impl, w)) {
      233:  654:				SET_BLACK(impl, w);
      233:  655:				SET_RED(impl, parent);
      233:  656:				rbtree_right_rotate(impl, parent);
      233:  657:				w = parent->left;
        -:  658:			}
        -:  659:			// Case 2: Sibling's children are both black
     1957:  660:			if (IS_BLACK(impl, w->right) && IS_BLACK(impl, w->left)) {
     1218:  661:				SET_RED(impl, w);
     1218:  662:				x = parent;
     1218:  663:				parent = parent->parent;
     1218:  664:				if (x == x->parent->left) {
      512:  665:					w = x->parent->right;
        -:  666:				} else {
      706:  667:					w = x->parent->left;
        -:  668:				}
        -:  669:			} else {
        -:  670:				// Case 3: Sibling's left child is black, right child is red
      739:  671:				if (IS_BLACK(impl, w->left)) {
      384:  672:					SET_BLACK(impl, w->right);
      384:  673:					SET_RED(impl, w);
      384:  674:					rbtree_left_rotate(impl, w);
      384:  675:					w = parent->left;
        -:  676:				}
        -:  677:				// Case 4: Sibling's left child is red
      739:  678:				set_color_based_on_parent(impl, w, parent);
      739:  679:				SET_BLACK(impl, parent);
      739:  680:				SET_BLACK(impl, w->left);
      739:  681:				rbtree_right_rotate(impl, parent);
      739:  682:				x = impl->root; // Set x to root at the end, only once
        -:  683:			}
        -:  684:		}
        -:  685:	}
        -:  686:
        -:  687:	// Ensure x is black at the end of fixup
     5263:  688:	SET_BLACK(impl, x);
     5263:  689:}
        -:  690:
        -:  691:// delete function
     7453:  692:int rbtree_remove(RBTree *ptr, const void *key, RbTreeKeyValue *swap) {
        -:  693:	// validate input
     7453:  694:	if (ptr == NULL || nil(ptr->impl) || key == NULL) {
        1:  695:		SetErr(IllegalArgument);
        1:  696:		return -1;
        -:  697:	}
        -:  698:
        -:  699:	// obtain impl from our opaque pointer
     7452:  700:	RBTreeImpl *impl = $(ptr->impl);
        -:  701:
        -:  702:	// search for the node based on this key.
        -:  703:	RBTreeNodePair pair;
     7452:  704:	rbtree_search(impl, key, &pair);
        -:  705:
        -:  706:	// this node doesn't exist, return -1
     7452:  707:	if (pair.self == NIL)
        1:  708:		return -1;
        -:  709:
     7451:  710:	if (swap) {
    #####:  711:		if (swap->key)
    #####:  712:			memcpy(swap->key, pair.self->data, impl->key_size);
    #####:  713:		if (swap->value)
    #####:  714:			memcpy(swap->value, pair.self->data + VALUE_PAD(impl->key_size) + impl->key_size,
    #####:  715:				   impl->value_size);
    #####:  716:		swap->update = true;
        -:  717:	}
        -:  718:
        -:  719:	// node exists, initialize variables
     7451:  720:	RBTreeNode *node_to_delete = pair.self;
     7451:  721:	RBTreeNode *x = NIL;
     7451:  722:	RBTreeNode *w = NIL;
     7451:  723:	RBTreeNode *parent = NIL;
        -:  724:
        -:  725:	// only do fixups if the node_to_delete is black.
     7451:  726:	bool do_fixup = IS_BLACK(impl, node_to_delete);
        -:  727:
     7451:  728:	if (node_to_delete->left == NIL) {
        -:  729:		// set variables for fixup and transplant
     2665:  730:		x = node_to_delete->right;
     2665:  731:		rbtree_transplant(impl, node_to_delete, node_to_delete->right);
     2665:  732:		if (node_to_delete->parent->left == NIL)
     1338:  733:			w = node_to_delete->parent->right;
        -:  734:		else
     1327:  735:			w = node_to_delete->parent->left;
     2665:  736:		if (x != NIL)
      601:  737:			parent = x->parent;
     2064:  738:		else if (w != NIL)
     1585:  739:			parent = w->parent;
     4786:  740:	} else if (node_to_delete->right == NIL) {
        -:  741:		// set variables for fixup and transplant
      374:  742:		x = node_to_delete->left;
      374:  743:		rbtree_transplant(impl, node_to_delete, node_to_delete->left);
      374:  744:		w = node_to_delete->parent->left;
      374:  745:		parent = x->parent;
        -:  746:	} else {
        -:  747:		// two children case
        -:  748:		// find successor
     4412:  749:		RBTreeNode *successor = rbtree_find_successor(impl, node_to_delete);
        -:  750:		// if it's black we need to do a fixup.
     4412:  751:		do_fixup = IS_BLACK(impl, successor);
        -:  752:
     4412:  753:		x = successor->right;
     4412:  754:		w = successor->parent->right;
        -:  755:
     4412:  756:		if (w->parent == node_to_delete) {
     1207:  757:			w = node_to_delete->left;
     1207:  758:			parent = successor;
        -:  759:		} else {
     3205:  760:			parent = w->parent;
        -:  761:		}
        -:  762:
        -:  763:		// if parent is not node_to_delete, do transplant and update children of successor
     4412:  764:		if (successor->parent != node_to_delete) {
     3205:  765:			rbtree_transplant(impl, successor, successor->right);
     3205:  766:			successor->right = node_to_delete->right;
     3205:  767:			successor->right->parent = successor;
        -:  768:		}
        -:  769:
        -:  770:		// do final transpalnnnt and update including color match
     4412:  771:		rbtree_transplant(impl, node_to_delete, successor);
     4412:  772:		successor->left = node_to_delete->left;
     4412:  773:		successor->left->parent = successor;
     4412:  774:		set_color_based_on_parent(impl, successor, node_to_delete);
        -:  775:	}
        -:  776:
        -:  777:	// if do_fixup, do fixup.
     7451:  778:	if (do_fixup) {
     5271:  779:		if (w != NIL && parent != NIL) {
     5263:  780:			rbtree_remove_fixup(impl, parent, w, x);
        -:  781:		} else {
        -:  782:			// in these cases SET_BLACK only
        8:  783:			if (impl->size > 1)
        4:  784:				SET_BLACK(impl, impl->root);
        -:  785:		}
        -:  786:	}
        -:  787:
        -:  788:	// Free the node which has been transplanted
        -:  789:	{
    14902:  790:		SendStateGuard _ = SetSend(impl->send);
     7451:  791:		fam_free(&node_to_delete->self);
        -:  792:	}
        -:  793:
     7451:  794:	impl->size--;
        -:  795:
     7451:  796:	return 0;
        -:  797:}
        -:  798:
        -:  799:// get operation
     4134:  800:const void *rbtree_get(const RBTree *ptr, const void *key) {
        -:  801:	// validate input
     4134:  802:	if (ptr == NULL || key == NULL) {
        1:  803:		SetErr(IllegalArgument);
        1:  804:		return NULL;
        -:  805:	}
        -:  806:
        -:  807:	// set impl
     4133:  808:	RBTreeImpl *impl = $(ptr->impl);
        -:  809:	RBTreeNodePair pair;
        -:  810:
        -:  811:	// search for the pair.
     4133:  812:	rbtree_search(impl, key, &pair);
        -:  813:
        -:  814:	// if found return value, otherwise NULL.
     4133:  815:	if (pair.self != NIL)
     4132:  816:		return pair.self->data + impl->key_size + VALUE_PAD(impl->key_size);
        -:  817:	else {
        1:  818:		return NULL;
        -:  819:	}
        -:  820:}
        -:  821:
    #####:  822:void *rbtree_get_mut(const RBTree *ptr, const void *key) {
        -:  823:	// validate input
    #####:  824:	if (ptr == NULL || key == NULL) {
    #####:  825:		SetErr(IllegalArgument);
    #####:  826:		return NULL;
        -:  827:	}
        -:  828:
        -:  829:	// set impl
    #####:  830:	RBTreeImpl *impl = $(ptr->impl);
        -:  831:	RBTreeNodePair pair;
        -:  832:
        -:  833:	// search for the pair.
    #####:  834:	rbtree_search(impl, key, &pair);
        -:  835:
        -:  836:	// if found return value, otherwise NULL.
    #####:  837:	if (pair.self != NIL)
    #####:  838:		return pair.self->data + impl->key_size + VALUE_PAD(impl->key_size);
        -:  839:	else {
    #####:  840:		return NULL;
        -:  841:	}
        -:  842:}
        -:  843:
        -:  844:// size in terms of number of nodes
    14110:  845:i64 rbtree_size(const RBTree *ptr) {
    14110:  846:	if (ptr == NULL) {
        1:  847:		SetErr(IllegalArgument);
        1:  848:		return -1;
        -:  849:	}
        -:  850:
    14109:  851:	RBTreeImpl *impl = $(ptr->impl);
    14109:  852:	return impl->size;
        -:  853:}
        -:  854:
        3:  855:int rbtree_iterator_impl(RBTreeImpl *impl, RBTreeIterator *iter, const void *start_key,
        -:  856:						 bool start_inclusive, const void *end_key, bool end_inclusive) {
        -:  857:
        3:  858:	RBTreeIteratorImpl *rbimpl = $(iter->impl);
        3:  859:	rbimpl->impl = impl;
        3:  860:	rbimpl->compare = impl->compare;
        3:  861:	rbimpl->stack_pointer = 0;
        3:  862:	rbimpl->send = impl->send;
        3:  863:	rbimpl->key_size = impl->key_size;
        3:  864:	rbimpl->cur = impl->root;
        3:  865:	rbimpl->min = NIL;
        3:  866:	rbimpl->max = NIL;
        -:  867:
        3:  868:	if (start_key != NULL) {
        1:  869:		RBTreeNode *itt = impl->root;
        4:  870:		while (itt != NIL) {
        3:  871:			int v = impl->compare(itt->data, start_key);
        3:  872:			if (v == 0) {
        -:  873:				// exact match
    #####:  874:				if (start_inclusive) {
    #####:  875:					rbimpl->min = itt;
    #####:  876:					break;
        -:  877:				}
        3:  878:			} else if (v < 0) {
        -:  879:				// continue down the chain to look for more
        2:  880:				itt = itt->right;
        -:  881:			} else {
        -:  882:				// higher value found update min
        1:  883:				rbimpl->min = itt;
        1:  884:				itt = itt->left;
        -:  885:			}
        -:  886:		}
        -:  887:	}
        -:  888:
        3:  889:	if (end_key != NULL) {
        1:  890:		RBTreeNode *itt = impl->root;
        5:  891:		while (itt != NIL) {
        4:  892:			int v = impl->compare(itt->data, end_key);
        4:  893:			if (v == 0) {
        -:  894:				// exact match
    #####:  895:				if (end_inclusive) {
    #####:  896:					rbimpl->max = itt;
    #####:  897:					break;
        -:  898:				}
        4:  899:			} else if (v < 0) {
        -:  900:				// lower value found update max
        3:  901:				rbimpl->max = itt;
        3:  902:				itt = itt->right;
        -:  903:			} else {
        -:  904:				// continue down the chain to look for more
        1:  905:				itt = itt->left;
        -:  906:			}
        -:  907:		}
        -:  908:	}
        -:  909:
        3:  910:	return 0;
        -:  911:}
        -:  912:
        -:  913:// reset the iterator (for reuse)
    #####:  914:int rbtree_iterator_reset(const RBTree *ptr, RBTreeIterator *iter, const void *start_key,
        -:  915:						  bool start_inclusive, const void *end_key, bool end_inclusive) {
    #####:  916:	if (iter == NULL) {
    #####:  917:		SetErr(IllegalArgument);
    #####:  918:		return -1;
        -:  919:	}
        -:  920:
    #####:  921:	RBTreeImpl *impl = $(ptr->impl);
    #####:  922:	return rbtree_iterator_impl(impl, iter, start_key, start_inclusive, end_key, end_inclusive);
        -:  923:}
        -:  924:
        -:  925:// return iterator object
        4:  926:int rbtree_iterator(const RBTree *ptr, RBTreeIterator *iter, const void *start_key,
        -:  927:					bool start_inclusive, const void *end_key, bool end_inclusive) {
        4:  928:	if (ptr == NULL || nil(ptr->impl)) {
        1:  929:		SetErr(IllegalArgument);
        1:  930:		return -1;
        -:  931:	}
        -:  932:
        3:  933:	RBTreeImpl *impl = $(ptr->impl);
        -:  934:
        -:  935:	{
        6:  936:		SendStateGuard _ = SetSend(impl->send);
        3:  937:		if (fam_alloc(&iter->impl, sizeof(RBTreeIteratorImpl))) {
    #####:  938:			iter->impl = null;
    #####:  939:			return -1;
        -:  940:		}
        -:  941:	}
        3:  942:	return rbtree_iterator_impl(impl, iter, start_key, start_inclusive, end_key, end_inclusive);
        -:  943:}
        -:  944:
        -:  945:#ifdef TEST
 67310004:  946:void rbtree_validate_node(const RBTree *ptr, const RBTreeNode *node, int *black_count,
        -:  947:						  int current_black_count, u64 ids[100]) {
 67310004:  948:	ids[current_black_count] = node->node_id;
 67310004:  949:	RBTreeImpl *impl = $(ptr->impl);
 67310004:  950:	u64 key_size = impl->key_size;
 67310004:  951:	u64 value_size = impl->value_size;
        -:  952:
        -:  953:	// Base case: when we reach a NIL
 67310004:  954:	if (node == NIL) {
        -:  955:		// If this is the first NIL node reached, set the black count
 33664116:  956:		if (*black_count == 0) {
    18228:  957:			*black_count = current_black_count; // Set the black count for the first path
        -:  958:		} else {
        -:  959:			// Check for black count consistency
33645888*:  960:			assert(current_black_count == *black_count);
        -:  961:		}
 33664116:  962:		return; // Return for NIL nodes
        -:  963:	}
        -:  964:
        -:  965:	// Increment black count if the current node is black
 33645888:  966:	if (IS_BLACK(impl, node)) {
 19129797:  967:		current_black_count++;
        -:  968:	} else {
        -:  969:		//   Check if the node is red
        -:  970:		//   If the parent is red, return false (Red property violation)
14516091*:  971:		assert(!(node->parent != NIL && IS_RED(impl, node->parent)));
        -:  972:	}
        -:  973:
        -:  974:	// Recursive calls for left and right children
 33645888:  975:	rbtree_validate_node(ptr, node->left, black_count, current_black_count, ids);
 33645888:  976:	rbtree_validate_node(ptr, node->right, black_count, current_black_count, ids);
        -:  977:}
        -:  978:
    18232:  979:void rbtree_validate(const RBTree *ptr) {
    18232:  980:	RBTreeImpl *impl = $(ptr->impl);
    18232:  981:	int black_count = 0;
        -:  982:	u64 ids[100];
        -:  983:	// Validate from the root and check if the root is black
    18232:  984:	if (impl->root != NIL) {
   18228*:  985:		assert(IS_BLACK(impl, impl->root));
    18228:  986:		rbtree_validate_node(ptr, impl->root, &black_count, 0, ids);
        -:  987:	}
    18232:  988:}
        -:  989:
 25263318:  990:void rbtree_node_depth(RBTreeImpl *impl, RBTreeNode *node, u64 *max_depth, u64 cur_depth) {
 25263318:  991:	if (cur_depth > *max_depth)
   185476:  992:		*max_depth = cur_depth;
 25263318:  993:	if (node->right != NIL)
 12833391:  994:		rbtree_node_depth(impl, node->right, max_depth, cur_depth + 1);
 25263318:  995:	if (node->left != NIL)
 12415810:  996:		rbtree_node_depth(impl, node->left, max_depth, cur_depth + 1);
 25263318:  997:}
        -:  998:
    14117:  999:u64 rbtree_max_depth(const RBTree *ptr) {
    14117: 1000:	RBTreeImpl *impl = $(ptr->impl);
    14117: 1001:	u64 max_depth = 0;
    14117: 1002:	rbtree_node_depth(impl, impl->root, &max_depth, 1);
    14117: 1003:	return max_depth;
        -: 1004:}
        -: 1005:
        -: 1006:// Function to print a single node with its color
        5: 1007:void rbtree_print_node(const RBTree *ptr, const RBTreeNode *node, int depth) {
        5: 1008:	RBTreeImpl *impl = $(ptr->impl);
        5: 1009:	if (node == NIL) {
        8: 1010:		for (int i = 0; i < depth; i++) {
        5: 1011:			printf("    ");
        -: 1012:		}
       3*: 1013:		printf("%llu (%s)\n", node->node_id, (IS_BLACK(impl, node)) ? "B" : "R");
        3: 1014:		return;
        -: 1015:	}
        -: 1016:
        -: 1017:	// Print the right child first (for visual representation)
        2: 1018:	rbtree_print_node(ptr, node->right, depth + 1);
        -: 1019:
        -: 1020:	// Indent according to depth
        3: 1021:	for (int i = 0; i < depth; i++) {
        1: 1022:		printf("    ");
        -: 1023:	}
        -: 1024:
        -: 1025:	// Print the current node with a clearer representation
        2: 1026:	printf("%llu (%s)\n", node->node_id, (IS_BLACK(impl, node)) ? "B" : "R");
        -: 1027:
        -: 1028:	// Print the left child
        2: 1029:	rbtree_print_node(ptr, node->left, depth + 1);
        -: 1030:}
        -: 1031:
        -: 1032:// Function to print the entire tree
        1: 1033:void rbtree_print(const RBTree *ptr) {
        1: 1034:	RBTreeImpl *impl = $(ptr->impl);
        -: 1035:
        1: 1036:	printf("Red-Black Tree (root = %llu)\n", impl->root->node_id);
        1: 1037:	printf("===================================\n"); // Separator for better clarity
        1: 1038:	rbtree_print_node(ptr, impl->root, 0);
        1: 1039:	printf("===================================\n"); // Separator for better clarity
        1: 1040:}
        -: 1041:
        -: 1042:#endif // TEST
        -:    0:Source:rc.c
        -:    0:Graph:rc.gcno
        -:    0:Data:rc.gcda
        -:    0:Runs:29
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <stdatomic.h>
        -:   18:#include <stdio.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:#include <util/rc.h>
        -:   22:
        -:   23:typedef struct RcMetaAtomic {
        -:   24:	atomic_ullong counts;	 // combined weak/strong counts (strong lower bits, weak upper bits)
        -:   25:	bool atomic;			 // whether or not this is an atomic reference counter
        -:   26:	void (*cleanup)(void *); // cleanup function to call when last Rc goes out of scope
        -:   27:	u64 size;				 // size of data
        -:   28:} RcMetaAtomic;
        -:   29:
        -:   30:// meta data associated with the Rc.
        -:   31:typedef struct RcMeta {
        -:   32:	u32 weak_count;			 // number of weak references
        -:   33:	u32 strong_count;		 // number of strong references
        -:   34:	bool atomic;			 // whether or not this is an atomic reference counter
        -:   35:	void (*cleanup)(void *); // cleanup function to call when last Rc goes out of scope
        -:   36:	u64 size;				 // size of data
        -:   37:} RcMeta;
        -:   38:
       29:   39:void __attribute__((constructor)) __check_atomic_size__() {
        -:   40:	if (sizeof(RcMetaAtomic) != sizeof(RcMeta)) {
        -:   41:		fprintf(stderr, "Error: sizes of RcMetaAtomic and RcMeta are not equal on this platform. "
        -:   42:						"Cannnot continue\n");
        -:   43:		exit(EXIT_FAILURE);
        -:   44:	}
       29:   45:}
        -:   46:
        -:   47:typedef struct RcImpl {
        -:   48:	RcMeta meta; // meta data for this Rc
        -:   49:	u8 data[];	 // data held in the Rc
        -:   50:} RcImpl;
        -:   51:
        -:   52:// cleanup function automatically called when the Rc goes out of scope
     2103:   53:void rc_cleanup(RcNc *ptr) {
     2103:   54:	if (nil(ptr->impl))
        1:   55:		return;
     2102:   56:	RcImpl *impl = $(ptr->impl);
        -:   57:
        -:   58:	u32 strong_count, weak_count;
        -:   59:
     2102:   60:	if (impl->meta.atomic) {
        5:   61:		RcMetaAtomic *atomic = ((RcMetaAtomic *)&impl->meta);
        -:   62:
        -:   63:		// Decrement strong count
        5:   64:		u64 combined_counts = atomic_fetch_sub(&atomic->counts, 1);
        5:   65:		weak_count = ((combined_counts & 0xFFFFFFFF00000000ULL) >> 32);
        5:   66:		strong_count = (u32)(combined_counts & 0xFFFFFFFFULL);
        5:   67:		strong_count--;
        -:   68:	} else {
     2097:   69:		strong_count = --impl->meta.strong_count;
     2097:   70:		weak_count = impl->meta.weak_count;
        -:   71:	}
        -:   72:
        -:   73:	// if strong count is 0, do cleanup tasks
     2102:   74:	if (strong_count == 0) {
        -:   75:		// first get chain guard
     2096:   76:		SendStateGuard _ = SetSend(impl->meta.atomic);
        -:   77:		// call user defined cleanup function
     1048:   78:		impl->meta.cleanup(impl->data);
        -:   79:
        -:   80:		// if there's no weak references left, also free pointer
     1048:   81:		if (weak_count == 0) {
     1046:   82:			fam_free(&ptr->impl);
        -:   83:		}
        -:   84:	}
     2102:   85:	ptr->impl = null;
        -:   86:}
        -:   87:
        -:   88:// cleanup function for the weak ref
        4:   89:void weak_cleanup(WeakNc *ptr) {
        4:   90:	if (nil(ptr->impl))
        2:   91:		return;
        2:   92:	RcImpl *impl = $(ptr->impl);
        -:   93:
        -:   94:	u32 strong_count, weak_count;
        -:   95:
        2:   96:	if (impl->meta.atomic) {
        1:   97:		RcMetaAtomic *atomic = ((RcMetaAtomic *)&impl->meta);
        -:   98:
        -:   99:		// Decrement weak count
        1:  100:		u64 combined_counts = atomic_fetch_sub(&atomic->counts, 1ULL << 32);
        1:  101:		weak_count = ((combined_counts & 0xFFFFFFFF00000000ULL) >> 32);
        1:  102:		strong_count = (u32)(combined_counts & 0xFFFFFFFFULL);
        1:  103:		weak_count--;
        -:  104:	} else {
        1:  105:		strong_count = impl->meta.strong_count;
        1:  106:		weak_count = --impl->meta.weak_count;
        -:  107:	}
        -:  108:
        -:  109:	// if both weak and strong counts are 0, we free the data here.
        2:  110:	if (strong_count == 0 && weak_count == 0) {
        4:  111:		SendStateGuard _ = SetSend(impl->meta.atomic);
        2:  112:		fam_free(&ptr->impl);
        -:  113:	}
        2:  114:	ptr->impl = null;
        -:  115:}
        -:  116:
        -:  117:// build an rc
     1048:  118:int rc_build(Rc *ptr, void *data, u64 size, bool atomic, void (*cleanup)(void *)) {
     1048:  119:	if (ptr == NULL || size == 0) {
    #####:  120:		SetErr(IllegalArgument);
    #####:  121:		return -1;
        -:  122:	}
        -:  123:
        -:  124:	{
        -:  125:		// allocate for both meta data and user data
     2096:  126:		SendStateGuard _ = SetSend(atomic);
     1048:  127:		if (fam_alloc(&ptr->impl, size + sizeof(RcMeta))) {
    #####:  128:			SetErr(AllocErr);
    #####:  129:			return -1;
        -:  130:		}
        -:  131:	}
        -:  132:
        -:  133:	// set initial values
     1048:  134:	RcImpl *impl = $(ptr->impl);
     1048:  135:	impl->meta.atomic = atomic;
        -:  136:
     1048:  137:	if (atomic) {
        2:  138:		RcMetaAtomic *atomic = ((RcMetaAtomic *)&impl->meta);
        2:  139:		atomic_store(&atomic->counts, 1ULL);
        -:  140:	} else {
     1046:  141:		impl->meta.weak_count = 0;
     1046:  142:		impl->meta.strong_count = 1;
        -:  143:	}
     1048:  144:	impl->meta.cleanup = cleanup;
     1048:  145:	impl->meta.size = size;
        -:  146:
        -:  147:	// copy data
     1048:  148:	memcpy(impl->data, data, size);
        -:  149:
     1048:  150:	return 0;
        -:  151:}
        -:  152:
        -:  153:// clone the reference counter incrementing the count
     1051:  154:int rc_clone(Rc *dst, const Rc *src) {
     1051:  155:	if (dst == NULL || src == NULL) {
    #####:  156:		SetErr(IllegalArgument);
    #####:  157:		return -1;
        -:  158:	}
        -:  159:
     1051:  160:	RcImpl *impl = $(src->impl);
     1051:  161:	if (impl->meta.atomic) {
        2:  162:		RcMetaAtomic *atomic = ((RcMetaAtomic *)&impl->meta);
        2:  163:		atomic_fetch_add(&atomic->counts, 1ULL);
        -:  164:	} else {
     1049:  165:		impl->meta.strong_count++;
        -:  166:	}
     1051:  167:	dst->impl = src->impl;
        -:  168:
     1051:  169:	return 0;
        -:  170:}
        -:  171:
    10518:  172:void *rc_access(Rc *ptr) {
    10518:  173:	if (ptr == NULL)
    #####:  174:		return NULL;
    10518:  175:	RcImpl *impl = $(ptr->impl);
    10518:  176:	return impl->data;
        -:  177:}
        -:  178:
        4:  179:int rc_weak(Weak *dst, const Rc *src) {
        4:  180:	if (dst == NULL || src == NULL) {
    #####:  181:		SetErr(IllegalArgument);
    #####:  182:		return -1;
        -:  183:	}
        4:  184:	RcImpl *impl = $(src->impl);
        4:  185:	if (impl->meta.atomic) {
        2:  186:		RcMetaAtomic *atomic = ((RcMetaAtomic *)&impl->meta);
        2:  187:		atomic_fetch_add(&atomic->counts, 1ULL << 32);
        -:  188:
        -:  189:	} else {
        2:  190:		impl->meta.weak_count++;
        -:  191:	}
        4:  192:	dst->impl = src->impl;
        -:  193:
        4:  194:	return 0;
        -:  195:}
        -:  196:
        3:  197:int rc_upgrade(Rc *upgraded, Weak *ptr) {
        3:  198:	RcImpl *impl = $(ptr->impl);
        -:  199:
        3:  200:	if (impl->meta.atomic) {
        2:  201:		RcMetaAtomic *atomic = ((RcMetaAtomic *)&impl->meta);
        -:  202:
        -:  203:		u64 combined_counts, new_combined_counts;
        -:  204:		u32 strong_count;
        -:  205:
        -:  206:		do {
        2:  207:			combined_counts = atomic_load(&atomic->counts);
        2:  208:			strong_count = (u32)(combined_counts & 0xFFFFFFFFULL);
        2:  209:			if (strong_count == 0) {
        1:  210:				return -1; // Object already deallocated
        -:  211:			}
        -:  212:
        -:  213:			// Calculate the new combined count after the upgrade
        1:  214:			new_combined_counts = combined_counts - (1ULL << 32) + 1;
        -:  215:
        -:  216:			// Try to atomically update the counts using compare-and-swap
        -:  217:		} while (
        1:  218:			!atomic_compare_exchange_weak(&atomic->counts, &combined_counts, new_combined_counts));
        -:  219:
        -:  220:	} else {
        1:  221:		if (impl->meta.strong_count == 0)
    #####:  222:			return -1;
        1:  223:		impl->meta.strong_count++;
        1:  224:		impl->meta.weak_count--;
        -:  225:	}
        -:  226:
        2:  227:	upgraded->impl = ptr->impl;
        2:  228:	ptr->impl = null;
        2:  229:	return 0;
        -:  230:}
        -:    0:Source:args.c
        -:    0:Graph:args.gcno
        -:    0:Data:args.gcda
        -:    0:Runs:20
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <base/colors.h>
        -:   17:#include <base/fam_err.h>
        -:   18:#include <base/misc.h>
        -:   19:#include <base/resources.h>
        -:   20:#include <stdarg.h>
        -:   21:#include <stdio.h>
        -:   22:#include <stdlib.h>
        -:   23:#include <string.h>
        -:   24:
       54:   25:bool args_param_copy(ArgsParam *dst, const ArgsParam *src) {
       54:   26:	dst->help = mymalloc(strlen(src->help) + 1);
       54:   27:	if (dst->help == NULL)
        1:   28:		return false;
        -:   29:
       53:   30:	if (src->default_value) {
       40:   31:		dst->default_value = mymalloc(strlen(src->default_value) + 1);
       40:   32:		if (dst->default_value == NULL) {
        1:   33:			myfree(dst->help);
        1:   34:			return false;
        -:   35:		}
        -:   36:	}
        -:   37:
       52:   38:	strcpy(dst->name, src->name);
       52:   39:	strcpy(dst->help, src->help);
       52:   40:	strcpy(dst->short_name, src->short_name);
       52:   41:	dst->takes_value = src->takes_value;
       52:   42:	dst->multiple = src->multiple;
       52:   43:	if (src->default_value)
       39:   44:		strcpy(dst->default_value, src->default_value);
        -:   45:	else
       13:   46:		dst->default_value = NULL;
        -:   47:
       52:   48:	return true;
        -:   49:}
        -:   50:
       72:   51:void args_param_cleanup(ArgsParamImpl *ptr) {
       72:   52:	if (ptr->help) {
       71:   53:		myfree(ptr->help);
       71:   54:		ptr->help = NULL;
        -:   55:	}
       72:   56:	if (ptr->default_value) {
       52:   57:		myfree(ptr->default_value);
       52:   58:		ptr->default_value = NULL;
        -:   59:	}
       72:   60:}
        -:   61:
       32:   62:int args_param_build(ArgsParam *ptr, const char *name, const char *help, const char *short_name,
        -:   63:					 const bool takes_value, const bool multiple, const char *default_value) {
       32:   64:	if (ptr == NULL || name == NULL || help == NULL || short_name == NULL) {
        1:   65:		print_error("Input may not be NULL");
        1:   66:		SetErr(IllegalArgument);
        1:   67:		return -1;
        -:   68:	}
        -:   69:
       31:   70:	if (strlen(name) > ARGS_MAX_ARGUMENT_NAME_LENGTH ||
       30:   71:		strlen(short_name) > ARGS_MAX_ARGUMENT_NAME_LENGTH) {
        1:   72:		print_error("Input too long");
        1:   73:		SetErr(IllegalArgument);
        1:   74:		return -1;
        -:   75:	}
        -:   76:
       30:   77:	u64 help_len = strlen(help);
       30:   78:	u64 default_value_len = 0;
       30:   79:	if (default_value)
       20:   80:		default_value_len = strlen(default_value);
        -:   81:
       30:   82:	ptr->help = mymalloc(sizeof(char) * (help_len + 1));
       30:   83:	if (default_value)
       20:   84:		ptr->default_value = mymalloc(sizeof(char) * (default_value_len + 1));
        -:   85:
       30:   86:	if (ptr->help == NULL || (ptr->default_value == NULL && default_value)) {
        1:   87:		print_error("Input may not be NULL");
        1:   88:		args_param_cleanup(ptr);
        1:   89:		return -1;
        -:   90:	}
        -:   91:
       29:   92:	strcpy(ptr->name, name);
       29:   93:	strcpy(ptr->short_name, short_name);
       29:   94:	strcpy(ptr->help, help);
       29:   95:	if (default_value)
       19:   96:		strcpy(ptr->default_value, default_value);
        -:   97:	else
       10:   98:		ptr->default_value = NULL;
       29:   99:	ptr->takes_value = takes_value;
       29:  100:	ptr->multiple = multiple;
        -:  101:
       29:  102:	return 0;
        -:  103:}
        -:  104:
       49:  105:bool sub_command_copy(SubCommand *dst, const SubCommand *src) {
       49:  106:	if (src->help == NULL)
        2:  107:		return false;
       47:  108:	dst->help = mymalloc(strlen(src->help) + 1);
       47:  109:	if (dst->help == NULL)
        1:  110:		return false;
        -:  111:
       46:  112:	if (src->arg_doc) {
       45:  113:		dst->arg_doc = mymalloc(strlen(src->arg_doc) + 1);
       45:  114:		if (dst->arg_doc == NULL) {
        1:  115:			myfree(dst->help);
        1:  116:			return false;
        -:  117:		}
        -:  118:	}
        -:  119:
       45:  120:	if (src->param_count == 0) {
       32:  121:		dst->param_count = 0;
       32:  122:		dst->is_specified = NULL;
       32:  123:		dst->params = NULL;
        -:  124:	} else {
       13:  125:		dst->params = mymalloc(sizeof(ArgsParam) * src->param_count);
       13:  126:		dst->is_specified = mymalloc(sizeof(bool) * src->param_count);
        -:  127:
       13:  128:		if (dst->params == NULL || dst->is_specified == NULL) {
        2:  129:			if (dst->params)
        1:  130:				myfree(dst->params);
        2:  131:			if (dst->is_specified)
        1:  132:				myfree(dst->is_specified);
        2:  133:			if (dst->help)
        2:  134:				myfree(dst->help);
        2:  135:			if (dst->arg_doc)
        2:  136:				myfree(dst->arg_doc);
        2:  137:			return false;
        -:  138:		}
        -:  139:
       11:  140:		memcpy(dst->is_specified, src->is_specified, sizeof(bool) * src->param_count);
       23:  141:		for (u32 i = 0; i < src->param_count; i++) {
       12:  142:			args_param_copy(&dst->params[i], &src->params[i]);
        -:  143:		}
       11:  144:		dst->param_count = src->param_count;
        -:  145:	}
        -:  146:
       43:  147:	strcpy(dst->name, src->name);
       43:  148:	strcpy(dst->help, src->help);
       43:  149:	if (src->arg_doc)
       42:  150:		strcpy(dst->arg_doc, src->arg_doc);
        -:  151:	else
        1:  152:		dst->arg_doc = NULL;
        -:  153:
       43:  154:	dst->min_args = src->min_args;
       43:  155:	dst->max_args = src->max_args;
        -:  156:
       43:  157:	return true;
        -:  158:}
        -:  159:
       77:  160:void sub_command_cleanup(SubCommandImpl *sc) {
      123:  161:	for (u32 i = 0; i < sc->param_count; i++) {
       46:  162:		args_param_cleanup(&sc->params[i]);
        -:  163:	}
       77:  164:	if (sc->params) {
       34:  165:		myfree(sc->params);
       34:  166:		sc->params = NULL;
        -:  167:	}
       77:  168:	if (sc->help) {
       77:  169:		myfree(sc->help);
       77:  170:		sc->help = NULL;
        -:  171:	}
       77:  172:	if (sc->arg_doc) {
       74:  173:		myfree(sc->arg_doc);
       74:  174:		sc->arg_doc = NULL;
        -:  175:	}
       77:  176:	if (sc->is_specified) {
       34:  177:		myfree(sc->is_specified);
       34:  178:		sc->is_specified = NULL;
        -:  179:	}
       77:  180:}
        -:  181:
       45:  182:int sub_command_build(SubCommand *sc, const char *name, const char *help, const u32 min_args,
        -:  183:					  const u32 max_args, const char *arg_doc) {
       45:  184:	if (sc == NULL || name == NULL || help == NULL || min_args > max_args) {
        2:  185:		SetErr(IllegalArgument);
        2:  186:		print_error("Invalid input");
        2:  187:		return -1;
        -:  188:	}
       43:  189:	sc->params = NULL;
       43:  190:	sc->help = NULL;
       43:  191:	sc->arg_doc = NULL;
       43:  192:	sc->is_specified = NULL;
       43:  193:	sc->param_count = 0;
        -:  194:
       43:  195:	if (strlen(name) > ARGS_MAX_SUBCOMMAND_LENGTH || min_args > max_args) {
        1:  196:		print_error("Invalid input");
        1:  197:		SetErr(IllegalArgument);
        1:  198:		return -1;
        -:  199:	}
        -:  200:
       42:  201:	if (help) {
       42:  202:		sc->help = mymalloc(sizeof(char) * strlen(help) + 1);
       42:  203:		if (sc->help == NULL) {
        1:  204:			print_error("Could not allocate sufficient memory");
        1:  205:			return -1;
        -:  206:		}
       41:  207:		strcpy(sc->help, help);
        -:  208:	}
        -:  209:
       41:  210:	if (arg_doc) {
       40:  211:		sc->arg_doc = mymalloc(sizeof(char) * strlen(arg_doc) + 1);
       40:  212:		if (sc->arg_doc == NULL) {
        1:  213:			print_error("Could not allocate sufficient memory");
        1:  214:			sub_command_cleanup(sc);
        1:  215:			return -1;
        -:  216:		}
       39:  217:		strcpy(sc->arg_doc, arg_doc);
        -:  218:	}
        -:  219:
       40:  220:	strcpy(sc->name, name);
       40:  221:	sc->min_args = min_args;
       40:  222:	sc->max_args = max_args;
        -:  223:
       40:  224:	return 0;
        -:  225:}
        -:  226:
       44:  227:int sub_command_add_param(SubCommand *sc, const ArgsParam *ap) {
       44:  228:	if (sc->params) {
        -:  229:		// already exists so realloc
        -:  230:		void *tmp;
       13:  231:		tmp = myrealloc(sc->params, sizeof(ArgsParam) * (sc->param_count + 1));
       13:  232:		if (tmp == NULL) {
        1:  233:			print_error("Could not allocate sufficient memory");
        1:  234:			return -1;
        -:  235:		}
       12:  236:		sc->params = tmp;
       12:  237:		tmp = myrealloc(sc->is_specified, sizeof(bool) * (sc->param_count + 1));
       12:  238:		if (tmp == NULL) {
        1:  239:			print_error("Could not allocate sufficient memory");
        1:  240:			return -1;
        -:  241:		}
       11:  242:		sc->is_specified = tmp;
        -:  243:
       11:  244:		args_param_copy(&sc->params[sc->param_count], ap);
       11:  245:		sc->is_specified[sc->param_count] = false;
        -:  246:
       11:  247:		sc->param_count += 1;
        -:  248:	} else {
       31:  249:		sc->params = mymalloc(sizeof(ArgsParam));
       31:  250:		sc->is_specified = mymalloc(sizeof(bool));
        -:  251:
       31:  252:		if (sc->params == NULL || sc->is_specified == NULL) {
        2:  253:			if (sc->params) {
        1:  254:				myfree(sc->params);
        1:  255:				sc->params = NULL;
        -:  256:			}
        2:  257:			if (sc->is_specified) {
        1:  258:				myfree(sc->is_specified);
        1:  259:				sc->is_specified = NULL;
        -:  260:			}
        2:  261:			print_error("Could not allocate sufficient memory");
        2:  262:			return -1;
        -:  263:		}
        -:  264:
       29:  265:		args_param_copy(&sc->params[sc->param_count], ap);
       29:  266:		sc->is_specified[sc->param_count] = false;
       29:  267:		sc->param_count += 1;
        -:  268:	}
       40:  269:	return 0;
        -:  270:}
        -:  271:
       24:  272:void args_cleanup(ArgsImpl *ptr) {
       61:  273:	for (u32 i = 0; i < ptr->subs_count; i++) {
       37:  274:		sub_command_cleanup(&ptr->subs[i]);
        -:  275:	}
       24:  276:	ptr->subs_count = 0;
       24:  277:	if (ptr->subs) {
       24:  278:		myfree(ptr->subs);
       24:  279:		ptr->subs = NULL;
        -:  280:	}
      104:  281:	for (u64 i = 0; i < ptr->argc; i++) {
       80:  282:		myfree(ptr->argv[i]);
        -:  283:	}
       24:  284:	if (ptr->argc) {
       15:  285:		myfree(ptr->argv);
       15:  286:		ptr->argc = 0;
        -:  287:	}
       24:  288:}
        -:  289:
       30:  290:int args_build(Args *args, const char *prog, const char *version, const char *author,
        -:  291:			   const u32 min_args, const u32 max_args, const char *arch) {
       30:  292:	if (prog == NULL || version == NULL || author == NULL) {
        1:  293:		print_error("Input may not be NULL");
        1:  294:		SetErr(IllegalArgument);
        1:  295:		return -1;
        -:  296:	}
        -:  297:
       29:  298:	if (strlen(prog) > ARGS_MAX_DETAIL_LENGTH || strlen(version) > ARGS_MAX_DETAIL_LENGTH ||
       28:  299:		strlen(author) > ARGS_MAX_DETAIL_LENGTH) {
        1:  300:		print_error("Input too long");
        1:  301:		SetErr(IllegalArgument);
        1:  302:		return -1;
        -:  303:	}
        -:  304:
        -:  305:	// first subcommand is our params (set it up)
       28:  306:	args->subs_count = 0;
       28:  307:	args->subs = NULL;
        -:  308:
        -:  309:	SubCommandImpl sc;
       28:  310:	if (sub_command_build(&sc, "", "", min_args, max_args, "")) {
        1:  311:		args->subs_count = 0;
        1:  312:		args->subs = NULL;
        1:  313:		return -1;
        -:  314:	}
       27:  315:	args_add_sub_command(args, &sc);
       27:  316:	sub_command_cleanup(&sc);
        -:  317:
       27:  318:	strcpy(args->prog, prog);
       27:  319:	strcpy(args->version, version);
       27:  320:	strcpy(args->author, author);
        -:  321:
       27:  322:	if (arch != NULL)
       23:  323:		strcpy(args->arch, arch);
        -:  324:	else
        4:  325:		strcpy(args->arch, "");
        -:  326:
       27:  327:	args->argv = NULL;
       27:  328:	args->argc = 0;
        -:  329:
       27:  330:	return 0;
        -:  331:}
        -:  332:
       27:  333:void args_exit_error(const Args *args, char *format, ...) {
        -:  334:	va_list va_args;
       27:  335:	va_start(va_args, format);
       27:  336:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
       27:  337:	vfprintf(stderr, format, va_args);
       27:  338:	fprintf(stderr, "\n\n");
       54:  339:	fprintf(stderr,
        -:  340:			"%sUSAGE%s:\n    %s%s%s [%sOPTIONS%s]\n\nFor more information "
        -:  341:			"try %s--help%s\n",
       27:  342:			DIMMED, RESET, BRIGHT_RED, args->prog, RESET, DIMMED, RESET, GREEN, RESET);
       27:  343:	va_end(va_args);
      27*:  344:	EXIT_ERR_IF_NO_DEBUG(-1);
       27:  345:}
        -:  346:
       30:  347:int args_add_param(Args *args, const ArgsParam *ap) {
       30:  348:	return sub_command_add_param(&args->subs[0], ap);
        -:  349:}
       45:  350:int args_add_sub_command(Args *args, SubCommand *sc) {
       45:  351:	if (args->subs_count == 0) {
       28:  352:		args->subs = mymalloc(sizeof(SubCommand));
       28:  353:		if (args->subs == NULL) {
        1:  354:			print_error("Could not allocate sufficient memory");
        1:  355:			return -1;
        -:  356:		}
        -:  357:	} else {
       17:  358:		void *tmp = myrealloc(args->subs, sizeof(SubCommand) * (args->subs_count + 1));
       17:  359:		if (tmp == NULL) {
        1:  360:			print_error("Could not allocate sufficient memory");
        1:  361:			return -1;
        -:  362:		}
       16:  363:		args->subs = tmp;
        -:  364:	}
        -:  365:
       43:  366:	bool ret = sub_command_copy(&args->subs[args->subs_count], sc);
       43:  367:	if (ret)
       42:  368:		args->subs_count++;
        -:  369:
       43:  370:	if (ret)
       42:  371:		return 0;
        -:  372:	else
        1:  373:		return -1;
        -:  374:}
        -:  375:
       10:  376:u64 args_subi_for(const Args *args, const char *sub) {
       10:  377:	u64 subi = 0;
       20:  378:	for (u64 i = 1; i < args->subs_count; i++) {
       10:  379:		if (!strcmp(sub, args->subs[i].name)) {
        9:  380:			subi = i;
        -:  381:		}
        -:  382:	}
       10:  383:	return subi;
        -:  384:}
        -:  385:
       45:  386:bool args_sub_takes_value(const Args *args, u64 subi, const char *name, bool is_short) {
       77:  387:	for (u64 i = 0; i < args->subs[subi].param_count; i++) {
       67:  388:		if (is_short && !strcmp(name, args->subs[subi].params[i].short_name)) {
       15:  389:			if (args->subs[subi].params[i].takes_value) {
       13:  390:				return true;
        -:  391:			} else
        2:  392:				break;
       52:  393:		} else if (!strcmp(name, args->subs[subi].params[i].name)) {
       20:  394:			if (args->subs[subi].params[i].takes_value) {
       18:  395:				return true;
        -:  396:			} else
        2:  397:				break;
        -:  398:		}
        -:  399:	}
       14:  400:	return false;
        -:  401:}
        -:  402:
       21:  403:bool args_check_option(const Args *args, u64 subi, const char *name, bool is_short,
        -:  404:					   const char *argv) {
       21:  405:	bool found = false;
       37:  406:	for (u64 j = 0; j < args->subs[subi].param_count; j++) {
       32:  407:		bool multi = args->subs[subi].params[j].multiple;
       32:  408:		if (is_short && !strcmp(args->subs[subi].params[j].short_name, name)) {
        7:  409:			found = true;
        7:  410:			if (args->subs[subi].is_specified[j] && !multi) {
        1:  411:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
        1:  412:				return false;
        -:  413:			}
        6:  414:			args->subs[subi].is_specified[j] = true;
        6:  415:			break;
       25:  416:		} else if (!is_short && !strcmp(args->subs[subi].params[j].name, name)) {
        9:  417:			found = true;
        9:  418:			if (args->subs[subi].is_specified[j] && !multi) {
        1:  419:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
        1:  420:				return false;
        -:  421:			}
        8:  422:			args->subs[subi].is_specified[j] = true;
        8:  423:			break;
        -:  424:		}
        -:  425:	}
       19:  426:	return found;
        -:  427:}
        -:  428:
       13:  429:void args_check_validity(const Args *args, int argc, const char **argv) {
        -:  430:	// check if there's a sub command and check arg count
       13:  431:	const char *sub = NULL;
       13:  432:	u32 arg_count = 0;
       13:  433:	u64 subi = 0;
       13:  434:	u64 sub_arg = UINT64_MAX;
       61:  435:	for (u64 i = 1; i < argc; i++) {
       48:  436:		u64 len = strlen(argv[i]);
       69:  437:		if (len > 0 && argv[i][0] == '-') {
       21:  438:			char name[len];
        -:  439:			bool is_short;
       21:  440:			bool found = false;
       21:  441:			if (len > 1 && args->argv[i][1] == '-') {
       14:  442:				strcpy(name, args->argv[i] + 2);
       14:  443:				is_short = false;
        -:  444:			} else {
        7:  445:				strcpy(name, args->argv[i] + 1);
        7:  446:				is_short = true;
        -:  447:			}
       21:  448:			if (args_sub_takes_value(args, subi, name, is_short)) {
       14:  449:				i += 1;
        -:  450:			}
        -:  451:		} else {
       27:  452:			if (!sub && args->subs_count > 1) {
       10:  453:				sub = argv[i];
       10:  454:				sub_arg = i;
       10:  455:				subi = args_subi_for(args, sub);
        -:  456:			} else
       17:  457:				arg_count += 1;
        -:  458:		}
        -:  459:	}
        -:  460:
       13:  461:	u64 sub_index = 0;
       13:  462:	if (sub) {
        -:  463:		// there's a sub so validate it
       10:  464:		bool valid = false;
       11:  465:		for (u64 i = 1; i < args->subs_count; i++) {
       10:  466:			if (!strcmp(sub, args->subs[i].name)) {
        9:  467:				valid = true;
        9:  468:				if (arg_count > args->subs[i].max_args || arg_count < args->subs[i].min_args) {
        4:  469:					args_exit_error(args,
        -:  470:									"Incorrect number of "
        -:  471:									"arguments for sub command '%s' "
        -:  472:									"(%i specified). "
        -:  473:									"Number of arguments must be "
        -:  474:									"between %i and %i.",
        4:  475:									args->subs[i].name, arg_count, args->subs[i].min_args,
        4:  476:									args->subs[i].max_args);
        -:  477:				}
        9:  478:				sub_index = i;
        -:  479:
        9:  480:				break;
        -:  481:			}
        -:  482:		}
       10:  483:		if (!valid) {
        1:  484:			args_exit_error(args, "Unknown SubCommand \"%s\"", sub);
        -:  485:		}
        3:  486:	} else if (args->subs_count > 1) {
        1:  487:		args_usage(args, NULL);
        -:  488:	} else {
        -:  489:		// no sub commands so we check the base min/max args.
        -:  490:		// check number of args
       2*:  491:		if (arg_count > args->subs[0].max_args || arg_count < args->subs[0].min_args) {
        2:  492:			args_exit_error(args,
        -:  493:							"Incorrect number of arguments "
        -:  494:							"(%i specified). "
        -:  495:							"Number of arguments must be "
        -:  496:							"between %i and %i.",
        2:  497:							arg_count, args->subs[0].min_args, args->subs[0].max_args);
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	// check options
       60:  502:	for (u64 i = 1; i < argc; i++) {
        -:  503:		u64 subi;
       48:  504:		if (i <= sub_arg) {
       29:  505:			subi = 0;
        -:  506:		} else {
       19:  507:			subi = sub_index;
        -:  508:		}
        -:  509:
       48:  510:		u64 len = strlen(argv[i]);
       48:  511:		if (len > 0 && argv[i][0] == '-') {
        -:  512:			// option to check
       21:  513:			char name[len];
        -:  514:			bool is_short;
       21:  515:			bool found = false;
       21:  516:			if (len > 1 && args->argv[i][1] == '-') {
       14:  517:				strcpy(name, args->argv[i] + 2);
       14:  518:				is_short = false;
        -:  519:			} else {
        7:  520:				strcpy(name, args->argv[i] + 1);
        7:  521:				is_short = true;
        -:  522:			}
        -:  523:
       21:  524:			found = args_check_option(args, subi, name, is_short, argv[i]);
       21:  525:			if (args_sub_takes_value(args, subi, name, is_short)) {
       14:  526:				i += 1;
        -:  527:			}
       21:  528:			if (!found) {
        7:  529:				if (subi == 0) {
        3:  530:					args_exit_error(args, "Unknown option: %s", argv[i]);
        -:  531:				} else {
        4:  532:					args_exit_error(args,
        -:  533:									"Unknown option: %s. Not valid for "
        -:  534:									"SubCommand \"%s\".",
        4:  535:									argv[i], args->subs[subi].name);
        -:  536:				}
        -:  537:			}
        -:  538:		}
        -:  539:	}
       12:  540:}
        -:  541:
        5:  542:void process_lines(Args *args, const char *arg1, char config_file[], size_t fsize) {
        -:  543:
        5:  544:	args->argv = mymalloc(sizeof(char *));
        5:  545:	if (args->argv == NULL) {
        1:  546:		args_exit_error(args, "Could not allocate sufficient memory");
        1:  547:		return;
        -:  548:	}
        -:  549:
        4:  550:	args->argv[0] = mymalloc(sizeof(char) * (strlen(arg1) + 1));
        4:  551:	if (args->argv[0] == NULL) {
        1:  552:		myfree(args->argv);
        1:  553:		args_exit_error(args, "Could not allocate sufficient memory");
        1:  554:		return;
        -:  555:	}
        3:  556:	strcpy(args->argv[0], arg1);
        -:  557:
        3:  558:	args->argc = 1;
        -:  559:
        -:  560:	// Use strtok to split the string into lines
        3:  561:	char *line = strtok(config_file, "\n");
        -:  562:
        8:  563:	while (line != NULL) {
        -:  564:		// allow for comments using '#'.
       41:  565:		for (int i = 0; i < strlen(line); i++) {
       37:  566:			if (line[i] == '#') {
        3:  567:				line[i] = 0;
        3:  568:				break;
        -:  569:			}
        -:  570:		}
        -:  571:		// trim
        7:  572:		char *trimmed = trim_whitespace(line);
        -:  573:
        7:  574:		if (*trimmed == '\0') {
        1:  575:			line = strtok(NULL, "\n"); // Skip empty lines
        1:  576:			continue;
        -:  577:		}
        -:  578:
        6:  579:		void *tmp = myrealloc(args->argv, sizeof(char *) * (args->argc + 1));
        6:  580:		if (tmp == NULL) {
        1:  581:			args_exit_error(args, "Could not allocate sufficient memory");
        1:  582:			return;
        -:  583:		}
        5:  584:		args->argv = tmp;
        5:  585:		args->argv[args->argc] = mymalloc(sizeof(char) * (strlen(trimmed) + 1));
        5:  586:		if (args->argv[args->argc] == NULL) {
        1:  587:			args_exit_error(args, "Could not allocate sufficient memory");
        1:  588:			return;
        -:  589:		}
        4:  590:		strcpy(args->argv[args->argc], trimmed);
        4:  591:		args->argc++;
        -:  592:
        -:  593:		// Get the next line
        4:  594:		line = strtok(NULL, "\n");
        -:  595:	}
        -:  596:}
        -:  597:
        -:  598:// Return 1 on successful file config created
        -:  599:// Return 0 if no file was specified
        -:  600:// Return -1 if an error occurs
       23:  601:int check_file_config(Args *args, const int argc, const char **argv) {
        -:  602:	// if file config is used there must be exactly two arguments fam @config.txt for example
       23:  603:	if (argc != 2)
       14:  604:		return 0;
        -:  605:
        -:  606:	// If the second argument does not start with an '@' symbol it is not a file.
        9:  607:	u64 arg_len = strlen(argv[1]);
        9:  608:	if (arg_len > 0 && argv[1][0] != '@') {
        3:  609:		return 0;
        -:  610:	}
        -:  611:
        -:  612:	// We have a file config process it.
        -:  613:	// get file size
        6:  614:	const char *file_name = argv[1] + 1;
        -:  615:
        6:  616:	Path path;
        6:  617:	path_for(&path, file_name);
        6:  618:	if (!path_exists(&path) || path_is_dir(&path)) {
        1:  619:		args_exit_error(args, "File not found at '%s'", path_to_string(&path));
        1:  620:		return -1;
        -:  621:	}
        5:  622:	u64 fsize = path_file_size(&path);
        -:  623:
        5:  624:	char config_file[fsize + 1];
        5:  625:	MYFILE *fp = myfopen(&path, "r");
        5:  626:	read_all(config_file, 1, fsize, fp);
        5:  627:	config_file[fsize] = 0;
        5:  628:	myfclose(fp);
        -:  629:
        5:  630:	process_lines(args, argv[0], config_file, fsize);
        -:  631:
        5:  632:	return 1;
        -:  633:}
        -:  634:
       24:  635:void args_init(Args *args, const int argc, const char **argv) {
        -:  636:	// check for NULLs (not allowed)
      120:  637:	for (int i = 0; i < argc; i++) {
       97:  638:		if (argv[i] == NULL) {
        1:  639:			args_exit_error(args, "argv may not have NULL value where i < argc");
        1:  640:			return;
        -:  641:		}
        -:  642:	}
        -:  643:	int r;
       23:  644:	if (check_file_config(args, argc, argv)) {
        -:  645:		// if true the file config as been loaded
        6:  646:		return;
        -:  647:	}
        -:  648:
        -:  649:	// scan args for an arg starting with '@'. Not valid here. It must be the first and only param.
        -:  650:	// Report error.
        -:  651:
        -:  652:	// If any args start with '@' it's an error because we already checked for file config
       82:  653:	for (u64 i = 1; i < argc; i++) {
       66:  654:		u64 arg_len = strlen(argv[i]);
       66:  655:		if (arg_len > 0 && argv[i][0] == '@') {
        1:  656:			args_exit_error(args,
        -:  657:							"File speicified with the '@' symbol must be the first argument.");
        1:  658:			return;
        -:  659:		}
        -:  660:	}
        -:  661:
       16:  662:	args->argc = argc;
       16:  663:	args->argv = mymalloc(sizeof(char *) * argc);
       16:  664:	if (args->argv == NULL) {
        1:  665:		args->argc = 0;
        1:  666:		args_exit_error(args, "Could not allocate sufficient memory");
        1:  667:		return;
        -:  668:	}
       91:  669:	for (u64 i = 0; i < argc; i++) {
       77:  670:		args->argv[i] = mymalloc(sizeof(char) * (strlen(argv[i]) + 1));
       77:  671:		if (args->argv[i] == NULL) {
        1:  672:			args->argc = 0;
        1:  673:			myfree(args->argv);
        1:  674:			args_exit_error(args, "Could not allocate sufficient memory");
        1:  675:			return;
        -:  676:		}
       76:  677:		strcpy(args->argv[i], argv[i]);
        -:  678:	}
        -:  679:
       75:  680:	for (u64 i = 1; i < argc; i++) {
       62:  681:		if (!strcmp(argv[i], "--version") || !strcmp(argv[i], "-V")) {
    #####:  682:			args_print_version(args);
        -:  683:		}
       62:  684:		if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
        5:  685:			const char *sub = NULL;
        8:  686:			for (u64 j = 1; j < i; j++) {
        7:  687:				u64 len = strlen(argv[j]);
        7:  688:				if (len > 0) {
        7:  689:					if (argv[j][0] != '-') {
        4:  690:						sub = argv[j];
        4:  691:						break;
        3:  692:					} else {
        3:  693:						char name[len + 1];
        -:  694:						bool is_short;
        3:  695:						if (len > 1 && args->argv[j][1] == '-') {
        2:  696:							strcpy(name, args->argv[j] + 2);
        2:  697:							is_short = false;
        -:  698:						} else {
        1:  699:							strcpy(name, args->argv[j] + 1);
        1:  700:							is_short = true;
        -:  701:						}
        -:  702:
        3:  703:						u64 subi = 0;
        3:  704:						if (args_sub_takes_value(args, subi, name, is_short)) {
        3:  705:							j += 1;
        -:  706:						}
        -:  707:					}
        -:  708:				}
        -:  709:			}
        5:  710:			args_usage(args, sub);
        -:  711:		}
        -:  712:	}
        -:  713:
       13:  714:	args_check_validity(args, argc, argv);
        -:  715:}
        -:  716:
        -:  717:// Returns -2 if an error occurs and sets fam_err.
        -:  718:// Returns -1 if the value is not present.
        -:  719:// Returns 0 if the value is found (flags or max_value_len == 0)
        -:  720:// Returns the length of the value (takes_value true and max_value_len > 0)
       13:  721:int args_value_of(const Args *args, const char *param_name, char *value_buf,
       13:  722:				  const u64 max_value_len, const u32 index) {
       13:  723:	if (args == NULL || param_name == NULL) {
        1:  724:		SetErr(IllegalArgument);
        1:  725:		print_error("Input may not be NULL");
        1:  726:		return -2;
        -:  727:	}
       12:  728:	u64 plen = strlen(param_name);
        -:  729:
       12:  730:	char param_name_buf[plen + 3];
       12:  731:	strcpy(param_name_buf, "--");
       12:  732:	strcat(param_name_buf, param_name);
        -:  733:
       12:  734:	char short_name_buf[plen + 3];
       12:  735:	strcpy(short_name_buf, "-");
       12:  736:	bool found = false;
       12:  737:	char *default_value = NULL;
       12:  738:	bool takes_value = false;
        -:  739:
        -:  740:	// linear search through all elements. Potential to improve here.
       36:  741:	for (u64 i = 0; i < args->subs_count; i++) {
       48:  742:		for (u64 j = 0; j < args->subs[i].param_count; j++) {
       24:  743:			if (!strcmp(args->subs[i].params[j].name, param_name)) {
       17:  744:				found = true;
       17:  745:				strcat(short_name_buf, args->subs[i].params[j].short_name);
       17:  746:				default_value = args->subs[i].params[j].default_value;
       17:  747:				takes_value = args->subs[i].params[j].takes_value;
        -:  748:			}
        -:  749:		}
        -:  750:	}
        -:  751:
       12:  752:	if (!found) {
        1:  753:		print_error("Unknown parameter tested");
        1:  754:		SetErr(ResourceNotAvailable);
        1:  755:		return -2;
        -:  756:	}
       11:  757:	u64 itt_index = 0;
       26:  758:	for (u64 i = 1; i < args->argc; i++) {
       23:  759:		if (!strcmp(args->argv[i], param_name_buf) || !strcmp(args->argv[i], short_name_buf)) {
        9:  760:			if (itt_index == index) {
        8:  761:				if (takes_value && i + 1 < args->argc) {
        4:  762:					if (value_buf == NULL) {
        1:  763:						SetErr(IllegalArgument);
        1:  764:						print_error("Input may not be NULL");
        1:  765:						return -2;
        -:  766:					}
        3:  767:					return snprintf(value_buf, max_value_len, "%s", args->argv[i + 1]);
        4:  768:				} else if (takes_value && max_value_len > 0) {
        2:  769:					if (value_buf == NULL) {
        1:  770:						SetErr(IllegalArgument);
        1:  771:						print_error("Input may not be NULL");
        1:  772:						return -2;
        -:  773:					}
        1:  774:					strcpy(value_buf, "");
        1:  775:					return 0;
        -:  776:				} else {
        2:  777:					return 0;
        -:  778:				}
        -:  779:			} else {
        1:  780:				itt_index += 1;
        -:  781:			}
        -:  782:		}
        -:  783:	}
        -:  784:
        3:  785:	if (default_value != NULL && index == 0) {
        2:  786:		if (value_buf == NULL && max_value_len > 0) {
        1:  787:			SetErr(IllegalArgument);
        1:  788:			print_error("Input may not be NULL");
        1:  789:			return -2;
        -:  790:		}
        1:  791:		return snprintf(value_buf, max_value_len, "%s", default_value);
        -:  792:	}
        -:  793:
        1:  794:	return -1;
        -:  795:}
        -:  796:
       14:  797:int args_get_argument(const Args *args, const u32 index, char *value_buf, const u64 max_value_len) {
       14:  798:	if (args == NULL) {
        1:  799:		print_error("Input may not be NULL");
        1:  800:		SetErr(IllegalArgument);
        1:  801:		return -2;
        -:  802:	}
       13:  803:	u64 index_itt = 0;
       49:  804:	for (u64 i = 1; i < args->argc; i++) {
       46:  805:		i32 len = strlen(args->argv[i]);
       62:  806:		if (len > 1 && args->argv[i][0] == '-') {
       16:  807:			char name[len];
        -:  808:			bool is_short;
       16:  809:			bool found = false;
       16:  810:			if (len > 1 && args->argv[i][1] == '-') {
       11:  811:				strcpy(name, args->argv[i] + 2);
       11:  812:				is_short = false;
        -:  813:			} else {
        5:  814:				strcpy(name, args->argv[i] + 1);
        5:  815:				is_short = true;
        -:  816:			}
        -:  817:
        -:  818:			// linear search through all elements. Potential to improve here.
       48:  819:			for (u64 k = 0; k < args->subs_count; k++) {
       59:  820:				for (u64 j = 0; j < args->subs[k].param_count; j++) {
       37:  821:					if (is_short && !strcmp(name, args->subs[k].params[j].short_name)) {
        5:  822:						if (args->subs[k].params[j].takes_value) {
        5:  823:							i += 1;
        5:  824:							found = true;
        5:  825:							break;
        -:  826:						}
       32:  827:					} else if (!strcmp(name, args->subs[k].params[j].name)) {
       11:  828:						if (args->subs[k].params[j].takes_value) {
        5:  829:							i += 1;
        5:  830:							found = true;
        5:  831:							break;
        -:  832:						}
        -:  833:					}
        -:  834:				}
        -:  835:			}
        -:  836:		} else {
       30:  837:			if (index_itt == index) {
       10:  838:				if (value_buf == NULL && max_value_len != 0) {
        1:  839:					print_error("Input may not be NULL");
        1:  840:					SetErr(IllegalArgument);
        1:  841:					return -2;
        -:  842:				}
        9:  843:				return snprintf(value_buf, max_value_len, "%s", args->argv[i]);
        -:  844:			}
       20:  845:			index_itt += 1;
        -:  846:		}
        -:  847:	}
        3:  848:	return -1;
        -:  849:}
        -:  850:
        1:  851:void args_print_version(const Args *args) {
        1:  852:	const char *prog = args->prog;
        1:  853:	const char *version = args->version;
        1:  854:	const char *arch = args->arch;
        1:  855:	if (strlen(arch) == 0) {
        1:  856:		arch = "";
        -:  857:	}
        1:  858:	fprintf(stderr, "%s%s%s %s%s%s (%s%s%s)\n", BRIGHT_RED, prog, RESET, CYAN, version, RESET,
        -:  859:			YELLOW, arch, RESET);
       1*:  860:	EXIT_ERR_IF_NO_DEBUG(0);
        1:  861:}
        -:  862:
       10:  863:void args_usage(const Args *args, const char *sub_command) {
       10:  864:	bool found = false;
       10:  865:	u64 subs_count = args->subs_count;
       10:  866:	u64 sub_index = 0;
        -:  867:
       10:  868:	if (sub_command) {
       12:  869:		for (u64 i = 1; i < subs_count; i++) {
        6:  870:			char *name = args->subs[i].name;
        6:  871:			if (!strcmp(name, sub_command)) {
        5:  872:				sub_index = i;
        5:  873:				found = true;
        -:  874:			}
        -:  875:		}
        -:  876:	} else // general help displayed
        4:  877:		found = true;
        -:  878:
       10:  879:	if (!found) {
        1:  880:		args_exit_error(args, "Unknown SubCommand \"%s\"", sub_command);
        1:  881:		return;
        -:  882:	}
        -:  883:
        9:  884:	u64 count = args->subs[0].param_count;
        9:  885:	u64 max_len = 0;
       24:  886:	for (u64 i = 0; i < count; i++) {
       15:  887:		bool takes_value = args->subs[0].params[i].takes_value;
       15:  888:		bool multi = args->subs[0].params[i].multiple;
       15:  889:		char *name = args->subs[0].params[i].name;
       15:  890:		char *short_name = args->subs[0].params[i].short_name;
        -:  891:		u64 len;
       15:  892:		if (!takes_value)
        4:  893:			len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
       11:  894:		else if (multi)
        3:  895:			len = snprintf(NULL, 0, "    -%s, --%s (<%s>, ...)", short_name, name, name);
        -:  896:		else
        8:  897:			len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
       15:  898:		if (len > max_len)
       11:  899:			max_len = len;
        -:  900:	}
        -:  901:
        9:  902:	max_len += 4;
        -:  903:
        9:  904:	if (max_len < 17)
        2:  905:		max_len = 17;
        -:  906:
        9:  907:	const char *prog = args->prog;
        9:  908:	const char *author = args->author;
        9:  909:	const char *version = args->version;
        -:  910:	char buffer[1025];
        -:  911:	char buffer2[1025];
        -:  912:	u64 i;
      324:  913:	for (i = 0; i < max_len - 13 && i < 1024; i++)
      315:  914:		buffer[i] = ' ';
        9:  915:	buffer[i] = 0;
        -:  916:
      297:  917:	for (i = 0; i < max_len - 16 && i < 1024; i++)
      288:  918:		buffer2[i] = ' ';
        9:  919:	buffer2[i] = 0;
        -:  920:	u64 sub_command_str_len;
        9:  921:	if (sub_command)
        5:  922:		sub_command_str_len = strlen(sub_command);
        -:  923:	else
        4:  924:		sub_command_str_len = 0;
        9:  925:	char sub_command_str[sub_command_str_len + 30];
        9:  926:	char *sub_arg_doc_str = "";
        -:  927:
        9:  928:	if (sub_command) {
        5:  929:		snprintf(sub_command_str, sub_command_str_len + 30, "%s%s%s", BRIGHT_RED, sub_command,
        -:  930:				 RESET);
        5:  931:		sub_arg_doc_str = args->subs[sub_index].arg_doc;
        -:  932:	} else {
        4:  933:		snprintf(sub_command_str, sub_command_str_len + 30, "[%sSUB_COMMAND%s]", DIMMED, RESET);
        -:  934:	}
        -:  935:
        9:  936:	fprintf(stderr,
        -:  937:			"%s%s%s %s%s%s\n%s%s%s\n\n%sUSAGE%s:\n    %s%s%s "
        -:  938:			"[%sCORE_OPTIONS%s] %s [%sSUB_OPTIONS%s] %s\n\n"
        -:  939:			"%sCORE_FLAGS%s:\n"
        -:  940:			"    %s-h%s, %s--help%s%sPrints help information\n"
        -:  941:			"    %s-V%s, %s--version%s%sPrints version "
        -:  942:			"information\n",
        -:  943:			CYAN, prog, RESET, YELLOW, version, RESET, GREEN, author, RESET, DIMMED, RESET,
        -:  944:			BRIGHT_RED, prog, RESET, DIMMED, RESET, sub_command_str, DIMMED, RESET, sub_arg_doc_str,
        -:  945:			DIMMED, RESET, CYAN, RESET, YELLOW, RESET, buffer, CYAN, RESET, YELLOW, RESET, buffer2);
        -:  946:
       24:  947:	for (u64 i = 0; i < count; i++) {
       15:  948:		bool takes_value = args->subs[0].params[i].takes_value;
       15:  949:		if (!takes_value) {
        4:  950:			char *name = args->subs[0].params[i].name;
        4:  951:			char *short_name = args->subs[0].params[i].short_name;
        4:  952:			char *help = args->subs[0].params[i].help;
        4:  953:			u64 len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
        4:  954:			if (len > max_len)
    #####:  955:				len = max_len;
        -:  956:			u64 i;
      458:  957:			for (i = 0; i < max_len - len && i < 1024; i++)
      454:  958:				buffer[i] = ' ';
        4:  959:			buffer[i] = 0;
        4:  960:			fprintf(stderr, "    %s-%s%s, %s--%s%s %s%s\n", CYAN, short_name, RESET, YELLOW, name,
        -:  961:					RESET, buffer, help);
        -:  962:		}
        -:  963:	}
        -:  964:
        9:  965:	if (count) {
        7:  966:		fprintf(stderr, "\n%sCORE_OPTIONS%s:\n", DIMMED, RESET);
        -:  967:
       22:  968:		for (u64 i = 0; i < count; i++) {
       15:  969:			bool takes_value = args->subs[0].params[i].takes_value;
       15:  970:			if (takes_value) {
       11:  971:				char *name = args->subs[0].params[i].name;
       11:  972:				char *short_name = args->subs[0].params[i].short_name;
       11:  973:				char *help = args->subs[0].params[i].help;
       11:  974:				bool multi = args->subs[0].params[i].multiple;
       11:  975:				char *default_value = args->subs[0].params[i].default_value;
        -:  976:				u64 default_value_str_len;
       11:  977:				if (default_value == NULL) {
        4:  978:					default_value_str_len = 1;
        -:  979:				} else {
        7:  980:					default_value_str_len = strlen(default_value) + 100;
        -:  981:				}
       11:  982:				char default_value_str[default_value_str_len];
       11:  983:				if (default_value == NULL)
        4:  984:					strcpy(default_value_str, "");
        -:  985:				else
        7:  986:					snprintf(default_value_str, default_value_str_len, " (default value: '%s')",
        -:  987:							 default_value);
        -:  988:
       11:  989:				if (multi) {
        3:  990:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>, ...", short_name, name, name);
        3:  991:					if (len > max_len)
    #####:  992:						len = max_len;
        -:  993:					u64 i;
       21:  994:					for (i = 0; i < max_len - len && i < 1024; i++)
       18:  995:						buffer[i] = ' ';
        3:  996:					buffer[i] = 0;
        3:  997:					fprintf(stderr,
        -:  998:							"    %s-%s%s, %s--%s%s "
        -:  999:							"<%s>, "
        -: 1000:							"... %s%s%s\n",
        -: 1001:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -: 1002:							default_value_str);
        -: 1003:				} else {
        -: 1004:
        8: 1005:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
        8: 1006:					if (len > max_len)
    #####: 1007:						len = max_len;
        -: 1008:					u64 i;
       56: 1009:					for (i = 0; i < max_len - len && i < 1024; i++)
       48: 1010:						buffer[i] = ' ';
        8: 1011:					buffer[i] = 0;
        -: 1012:
        8: 1013:					fprintf(stderr,
        -: 1014:							"    %s-%s%s, %s--%s%s "
        -: 1015:							"<%s> "
        -: 1016:							"%s%s%s\n",
        -: 1017:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -: 1018:							default_value_str);
        -: 1019:				}
        -: 1020:			}
        -: 1021:		}
        -: 1022:	}
        -: 1023:
        9: 1024:	if (subs_count > 1 && sub_command == NULL) {
        3: 1025:		fprintf(stderr, "\n%sSUB_COMMANDS%s:\n", DIMMED, RESET);
        6: 1026:		for (u64 i = 1; i < subs_count; i++) {
        -: 1027:
        3: 1028:			char *name = args->subs[i].name;
        3: 1029:			char *help = args->subs[i].help;
        3: 1030:			char *arg_doc = args->subs[i].arg_doc;
        -: 1031:
        3: 1032:			u64 len = strlen(name) + strlen(arg_doc) + 4;
        3: 1033:			if (len > max_len)
    #####: 1034:				len = max_len;
        -: 1035:			char buffer[1025];
        -: 1036:			u64 j;
      130: 1037:			for (j = 0; j < (max_len - len) && j < 1024; j++)
      127: 1038:				buffer[j] = ' ';
        3: 1039:			buffer[j] = 0;
        -: 1040:
        3: 1041:			fprintf(stderr, "    %s%s%s %s%s%s\n", CYAN, name, RESET, arg_doc, buffer, help);
        -: 1042:		}
        -: 1043:	}
        9: 1044:	if (sub_command) {
        5: 1045:		u64 param_index = 0;
       10: 1046:		for (u64 i = 1; i < subs_count; i++) {
        5: 1047:			char *name = args->subs[i].name;
        5: 1048:			if (!strcmp(name, sub_command)) {
        5: 1049:				param_index = i;
        -: 1050:			}
        -: 1051:		}
        -: 1052:
        5: 1053:		if (param_index > 0) {
        5: 1054:			count = args->subs[param_index].param_count;
        5: 1055:			fprintf(stderr, "\n%sSUB_FLAGS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -: 1056:					RESET);
        -: 1057:
        9: 1058:			for (u64 i = 0; i < count; i++) {
        4: 1059:				char *name = args->subs[param_index].params[i].name;
        4: 1060:				char *short_name = args->subs[param_index].params[i].short_name;
        4: 1061:				bool takes_value = args->subs[param_index].params[i].takes_value;
        4: 1062:				char *help = args->subs[param_index].params[i].help;
        -: 1063:
        4: 1064:				if (!takes_value) {
        3: 1065:					u64 len = strlen(name) + 10;
        3: 1066:					if (len > max_len)
    #####: 1067:						len = max_len;
        -: 1068:					char buffer[1025];
        -: 1069:					u64 j;
       32: 1070:					for (j = 0; j < (max_len - len) && j < 1024; j++)
       29: 1071:						buffer[j] = ' ';
        3: 1072:					buffer[j] = 0;
        3: 1073:					fprintf(stderr,
        -: 1074:							"    %s-%s%s, "
        -: 1075:							"%s--%s%s%s %s\n",
        -: 1076:							CYAN, short_name, RESET, YELLOW, name, RESET, buffer, help);
        -: 1077:				}
        -: 1078:			}
        5: 1079:			fprintf(stderr, "\n%sSUB_OPTIONS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -: 1080:					RESET);
        9: 1081:			for (u64 i = 0; i < count; i++) {
        4: 1082:				char *name = args->subs[param_index].params[i].name;
        4: 1083:				char *short_name = args->subs[param_index].params[i].short_name;
        4: 1084:				bool takes_value = args->subs[param_index].params[i].takes_value;
        4: 1085:				char *help = args->subs[param_index].params[i].help;
        4: 1086:				bool multiple = args->subs[param_index].params[i].multiple;
        -: 1087:
        4: 1088:				char *default_value = args->subs[param_index].params[i].default_value;
        -: 1089:				u64 default_value_str_len;
        4: 1090:				if (default_value == NULL) {
        1: 1091:					default_value_str_len = 1;
        -: 1092:				} else {
        3: 1093:					default_value_str_len = strlen(default_value) + 100;
        -: 1094:				}
        4: 1095:				char default_value_str[default_value_str_len];
        4: 1096:				if (default_value == NULL)
        1: 1097:					strcpy(default_value_str, "");
        -: 1098:				else
        3: 1099:					snprintf(default_value_str, default_value_str_len, " (default value: %s)",
        -: 1100:							 default_value);
        -: 1101:
        4: 1102:				if (takes_value) {
        1: 1103:					if (multiple) {
    #####: 1104:						u64 len = 2 * strlen(name) + 19;
        -: 1105:						char buffer[1025];
        -: 1106:						u64 j;
    #####: 1107:						if (len > max_len)
    #####: 1108:							len = max_len;
    #####: 1109:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####: 1110:							buffer[j] = ' ';
    #####: 1111:						buffer[j] = ' ';
    #####: 1112:						buffer[j + 1] = 0;
    #####: 1113:						fprintf(stderr,
        -: 1114:								"    %s-%s%s, "
        -: 1115:								"%s--%s%s "
        -: 1116:								"<%s>, ...%s %s"
        -: 1117:								"%s\n",
        -: 1118:								CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -: 1119:								default_value_str);
        -: 1120:					} else {
        1: 1121:						u64 len = 2 * strlen(name) + 13;
        -: 1122:						char buffer[1025];
        -: 1123:						u64 j;
        1: 1124:						if (len > max_len)
        1: 1125:							len = max_len;
       1*: 1126:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####: 1127:							buffer[j] = ' ';
        1: 1128:						buffer[j] = 0;
        1: 1129:						fprintf(stderr,
        -: 1130:								"    %s-%s%s, "
        -: 1131:								"%s--%s%s "
        -: 1132:								"<%s>%s "
        -: 1133:								"%s%s\n",
        -: 1134:								CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -: 1135:								default_value_str);
        -: 1136:					}
        -: 1137:				}
        -: 1138:			}
        -: 1139:		}
        -: 1140:	}
        -: 1141:
        9: 1142:	EXIT_ERR_IF_NO_DEBUG(0);
        -: 1143:}
