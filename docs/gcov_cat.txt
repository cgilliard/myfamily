        -:    0:Source:backtrace.c
        -:    0:Graph:backtrace.gcno
        -:    0:Data:backtrace.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/backtrace.h>
        -:   16:#include <base/colors.h>
        -:   17:#include <base/fam_err.h>
        -:   18:#include <base/os.h>
        -:   19:#include <base/print_util.h>
        -:   20:#include <base/stream.h>
        -:   21:#include <base/string.h>
        -:   22:#include <base/types.h>
        -:   23:
        -:   24:#ifdef __APPLE__
        -:   25:#include <dlfcn.h>
        -:   26:#endif // __APPLE__
        -:   27:#include <unistd.h>
        -:   28:
    #####:   29:i32 get_file_line(const u8 *bin, const u8 *addr, u8 *line_num, u8 *file_path, i32 max_len) {
    #####:   30:	u64 cmd_max_len = strlen(bin) + strlen(addr) + 100;
    #####:   31:	u8 cmd[cmd_max_len];
    #####:   32:	strcpy(cmd, "");
    #####:   33:	sprint(cmd, cmd_max_len, "atos --fullPath -o {} {}", bin, addr);
    #####:   34:	Stream strm = {};
    #####:   35:	if (strm_open(&strm, cmd, "r")) {
    #####:   36:		SetErr(POpenErr);
    #####:   37:		return -1;
        -:   38:	}
        -:   39:	u8 buffer[MAX_ENTRY_SIZE + 1];
    #####:   40:	while (sgets(buffer, MAX_ENTRY_SIZE + 1, &strm)) {
    #####:   41:		bool found_first_paren = false;
    #####:   42:		bool found_second_paren = false;
    #####:   43:		bool found_colon = false;
    #####:   44:		u64 len = strlen(buffer);
    #####:   45:		i32 line_num_itt = 0;
    #####:   46:		i32 line_count_itt = 0;
    #####:   47:		for (i32 i = 0; i < len; i++) {
    #####:   48:			if (!found_first_paren && buffer[i] == '(') {
    #####:   49:				found_first_paren = true;
    #####:   50:			} else if (!found_second_paren && buffer[i] == '(') {
    #####:   51:				found_second_paren = true;
    #####:   52:			} else if (found_second_paren && found_first_paren) {
    #####:   53:				if (found_colon) {
    #####:   54:					if (buffer[i] == ')') {
    #####:   55:						break;
        -:   56:					} else {
    #####:   57:						line_num[line_count_itt] = buffer[i];
    #####:   58:						line_num_itt++;
    #####:   59:						line_count_itt++;
        -:   60:					}
    #####:   61:				} else if (buffer[i] == ':') {
    #####:   62:					found_colon = true;
    #####:   63:					file_path[line_num_itt] = 0;
    #####:   64:					line_num_itt++;
    #####:   65:				} else if (buffer[i] == ')') {
    #####:   66:					break;
        -:   67:				} else {
    #####:   68:					file_path[line_num_itt] = buffer[i];
    #####:   69:					line_num_itt++;
    #####:   70:					if (line_num_itt == max_len)
    #####:   71:						break;
        -:   72:				}
        -:   73:			}
        -:   74:		}
    #####:   75:		file_path[line_num_itt] = 0;
    #####:   76:		line_num[line_count_itt] = 0;
        -:   77:	}
    #####:   78:	strm_close(&strm);
    #####:   79:	return 0;
        -:   80:}
        -:   81:
    #####:   82:void backtrace_set_entry_values(BacktraceEntry *ptr, const u8 *name, const u8 *bin_name,
        -:   83:								const u8 *address, const u8 *file_path) {
    #####:   84:	u64 offset = 0;
    #####:   85:	ptr->start_bin = MAX_ENTRY_SIZE;
    #####:   86:	ptr->start_addr = MAX_ENTRY_SIZE;
    #####:   87:	ptr->start_file_path = MAX_ENTRY_SIZE;
    #####:   88:	memset(ptr->data, '\0', MAX_ENTRY_SIZE);
        -:   89:
    #####:   90:	strncpy((u8 *)(ptr->data + offset), name, MAX_ENTRY_SIZE - offset);
    #####:   91:	offset += strlen(name) + 1;
        -:   92:
    #####:   93:	if (offset >= MAX_ENTRY_SIZE)
    #####:   94:		return;
        -:   95:
    #####:   96:	ptr->start_bin = offset;
    #####:   97:	strncpy((u8 *)(ptr->data + offset), bin_name, MAX_ENTRY_SIZE - offset);
    #####:   98:	offset += strlen(bin_name) + 1;
        -:   99:
    #####:  100:	if (offset >= MAX_ENTRY_SIZE)
    #####:  101:		return;
        -:  102:
    #####:  103:	ptr->start_addr = offset;
    #####:  104:	strncpy((u8 *)(ptr->data + offset), address, MAX_ENTRY_SIZE - offset);
    #####:  105:	offset += strlen(address) + 1;
        -:  106:
    #####:  107:	if (offset >= MAX_ENTRY_SIZE)
    #####:  108:		return;
        -:  109:
    #####:  110:	ptr->start_file_path = offset;
    #####:  111:	strncpy((u8 *)(ptr->data + offset), file_path, MAX_ENTRY_SIZE - offset);
    #####:  112:	offset += strlen(address) + 1;
        -:  113:}
        -:  114:
    #####:  115:bool backtrace_add_entry(Backtrace *ptr, const u8 *name, const u8 *bin_name, const u8 *address,
        -:  116:						 const u8 *file_path) {
    #####:  117:	u64 count = ptr->cur_entries;
    #####:  118:	if (count >= MAX_ENTRIES)
    #####:  119:		return false;
    #####:  120:	backtrace_set_entry_values(&ptr->entries[count], name, bin_name, address, file_path);
    #####:  121:	ptr->cur_entries++;
    #####:  122:	return true;
        -:  123:}
        -:  124:
        1:  125:i32 backtrace_generate(Backtrace *ptr) {
        1:  126:	if (ptr == NULL) {
    #####:  127:		SetErr(IllegalArgument);
    #####:  128:		return -1;
        -:  129:	}
        -:  130:
        1:  131:	ptr->cur_entries = 0;
        -:  132:	void *array[MAX_ENTRIES];
        1:  133:	i32 size = backtrace(array, MAX_ENTRIES);
        -:  134:
        1:  135:	if (size < 0) {
    #####:  136:		SetErr(BacktraceErr);
    #####:  137:		return -1;
        -:  138:	}
        -:  139:
        1:  140:	u8 **strings = backtrace_symbols(array, size);
        -:  141:
        1:  142:	if (strings == NULL)
    #####:  143:		size = 0;
        -:  144:
       11:  145:	for (i32 i = 0; i < size; i++) {
        -:  146:#ifdef __APPLE__
        -:  147:		u64 path_max = pathconf("/", _PC_PATH_MAX);
        -:  148:		u8 address[30];
        -:  149:		strcpy(address, "");
        -:  150:		Dl_info info;
        -:  151:		dladdr(array[i], &info);
        -:  152:		u64 addr = 0x0000000100000000 + info.dli_saddr - info.dli_fbase;
        -:  153:		sprint(address, 30, "0x{hex}", addr);
        -:  154:		u64 snamelen = strlen(info.dli_sname) + 1;
        -:  155:		u64 fnamelen = strlen(info.dli_fname) + 1;
        -:  156:		u8 fn_name[snamelen];
        -:  157:		u8 bin_name[fnamelen];
        -:  158:		strncpy(fn_name, info.dli_sname, snamelen);
        -:  159:		strncpy(bin_name, info.dli_fname, fnamelen);
        -:  160:
        -:  161:		u8 file_path[path_max + 101];
        -:  162:		u8 line_num[path_max + 101];
        -:  163:		strcpy(file_path, "");
        -:  164:		strcpy(line_num, "");
        -:  165:
        -:  166:		get_file_line(bin_name, address, line_num, file_path, path_max + 100);
        -:  167:
        -:  168:		u8 real_bin_name[path_max + 1];
        -:  169:		if (strlen(bin_name) > 0) {
        -:  170:			realpath(bin_name, real_bin_name);
        -:  171:		} else
        -:  172:			strncpy(real_bin_name, bin_name, 1 + strlen(bin_name));
        -:  173:
        -:  174:		u8 real_file_path[path_max + 1];
        -:  175:		bool has_file = true;
        -:  176:		bool has_line_no = true;
        -:  177:		if (!strncmp(file_path, "", 1)) {
        -:  178:			strcpy(real_file_path, "Unknown");
        -:  179:			has_file = false;
        -:  180:		} else
        -:  181:			realpath(file_path, real_file_path);
        -:  182:		if (!strncmp(line_num, "", 1)) {
        -:  183:			has_line_no = false;
        -:  184:			strcpy(line_num, "Unknown");
        -:  185:		}
        -:  186:
        -:  187:		if (has_line_no && has_file) {
        -:  188:			strncat(file_path, ":", 2);
        -:  189:			strncat(file_path, line_num, 1 + strlen(line_num));
        -:  190:		}
        -:  191:
        -:  192:		if (!backtrace_add_entry(ptr, fn_name, real_bin_name, address, file_path))
        -:  193:			break;
        -:  194:#else  // Linux
        -:  195:#endif // OS Specific code
        -:  196:	}
        -:  197:
        1:  198:	if (strings)
        1:  199:		release_no_stat(strings);
        -:  200:
        1:  201:	return 0;
        -:  202:}
        -:  203:
        1:  204:void backtrace_print(const Backtrace *ptr) {
        1:  205:	if (env("CBACKTRACE") != NULL) {
    #####:  206:		const BacktraceEntry *rows = ptr->entries;
    #####:  207:		u64 count = ptr->cur_entries;
    #####:  208:		if (count == 0) {
    #####:  209:			println("-------------Backtrace not available-------------");
        -:  210:		} else {
    #####:  211:			println("Backtrace:");
    #####:  212:			for (i32 i = 0; i < count; i++) {
    #####:  213:				const u8 *function_name = rows[i].data;
        -:  214:				const u8 *bin_name;
    #####:  215:				if (rows[i].start_bin < MAX_ENTRY_SIZE)
    #####:  216:					bin_name = rows[i].data + rows[i].start_bin;
        -:  217:				else
    #####:  218:					bin_name = (u8 *)"";
        -:  219:				const u8 *address;
    #####:  220:				if (rows[i].start_bin < MAX_ENTRY_SIZE)
    #####:  221:					address = rows[i].data + rows[i].start_addr;
        -:  222:				else
    #####:  223:					address = (u8 *)"";
        -:  224:
        -:  225:				const u8 *file_path;
    #####:  226:				if (rows[i].start_file_path < MAX_ENTRY_SIZE)
    #####:  227:					file_path = rows[i].data + rows[i].start_file_path;
        -:  228:				else
    #####:  229:					file_path = (u8 *)"";
    #####:  230:				println("#{}:\n\
        -:  231:	[{}fn={}{}{}{}']\n\
        -:  232:	[{}binary={}'{}{}{}'] [{}address={}{}]\n\
        -:  233:	[{}code={}'{}{}{}']",
        -:  234:						i, DIMMED, RESET, GREEN, function_name, RESET, DIMMED, RESET, CYAN,
        -:  235:						bin_name, RESET, DIMMED, RESET, address, DIMMED, RESET, YELLOW, file_path,
        -:  236:						RESET);
        -:  237:			}
        -:  238:		}
        -:  239:	} else {
        1:  240:		println("Backtrace currently disabled set env variable CBACKTRACE to enable");
        -:  241:	}
        1:  242:}
        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/os.h>
        -:   17:
    #####:   18:char *get_dimmed() {
    #####:   19:	if (env("NO_COLOR") != NULL) {
    #####:   20:		return "";
        -:   21:	} else {
    #####:   22:		return "\x1b[2m";
        -:   23:	}
        -:   24:}
        -:   25:
    #####:   26:char *get_red() {
    #####:   27:	if (env("NO_COLOR") != NULL) {
    #####:   28:		return "";
        -:   29:	} else {
    #####:   30:		return "\x1b[31m";
        -:   31:	}
        -:   32:}
        -:   33:
    #####:   34:char *get_bright_red() {
    #####:   35:	if (env("NO_COLOR") != NULL) {
    #####:   36:		return "";
        -:   37:	} else {
    #####:   38:		return "\x1b[91m";
        -:   39:	}
        -:   40:}
        -:   41:
    #####:   42:char *get_green() {
    #####:   43:	if (env("NO_COLOR") != NULL) {
    #####:   44:		return "";
        -:   45:	} else {
    #####:   46:		return "\x1b[32m";
        -:   47:	}
        -:   48:}
        -:   49:
    #####:   50:char *get_yellow() {
    #####:   51:	if (env("NO_COLOR") != NULL) {
    #####:   52:		return "";
        -:   53:	} else {
    #####:   54:		return "\x1b[33m";
        -:   55:	}
        -:   56:}
        -:   57:
    #####:   58:char *get_cyan() {
    #####:   59:	if (env("NO_COLOR") != NULL) {
    #####:   60:		return "";
        -:   61:	} else {
    #####:   62:		return "\x1b[36m";
        -:   63:	}
        -:   64:}
        -:   65:
    #####:   66:char *get_magenta() {
    #####:   67:	if (env("NO_COLOR") != NULL) {
    #####:   68:		return "";
        -:   69:	} else {
    #####:   70:		return "\x1b[35m";
        -:   71:	}
        -:   72:}
        -:   73:
    #####:   74:char *get_blue() {
    #####:   75:	if (env("NO_COLOR") != NULL) {
    #####:   76:		return "";
        -:   77:	} else {
    #####:   78:		return "\x1b[34m";
        -:   79:	}
        -:   80:}
        -:   81:
    #####:   82:char *get_reset() {
    #####:   83:	if (env("NO_COLOR") != NULL) {
    #####:   84:		return "";
        -:   85:	} else {
    #####:   86:		return "\x1b[0m";
        -:   87:	}
        -:   88:}
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/macro_util.h>
        -:   17:#include <base/os.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <base/string.h>
        -:   20:
        -:   21:_Thread_local u8 fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local i32 fam_err = NoErrors;
        -:   24:_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const u8 *get_err() {
    #####:   27:	return strncpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
        -:   28:}
        -:   29:
    #####:   30:void print_err(const u8 *text) {
    #####:   31:	println("{}: {}", FamErrText[fam_err], text);
    #####:   32:	backtrace_print(&thread_local_bt__);
    #####:   33:}
        -:   34:
    #####:   35:void do_backtrace_generate(Backtrace *bt) {
    #####:   36:	if (env("CBACKTRACE") != NULL) {
    #####:   37:		backtrace_generate(bt);
        -:   38:	}
    #####:   39:}
        -:    0:Source:os.c
        -:    0:Graph:os.gcno
        -:    0:Data:os.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/print_util.h>
        -:   18:#include <base/string.h>
        -:   19:
        -:   20:#include <errno.h>
        -:   21:#include <fcntl.h>
        -:   22:#include <limits.h>
        -:   23:#include <stdio.h>
        -:   24:#include <sys/mman.h>
        -:   25:#include <sys/stat.h>
        -:   26:#include <unistd.h>
        -:   27:
        -:   28:u8 *getenv(const u8 *name);
        -:   29:void *malloc(size_t size);
        -:   30:void *realloc(void *ptr, size_t size);
        -:   31:void free(void *ptr);
        -:   32:void *memset(void *ptr, i32 x, size_t n);
        -:   33:
        -:   34:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   35:
    #####:   36:void *alloc(u64 size, bool zeroed) {
    #####:   37:	if (!size) {
    #####:   38:		SetErr(IllegalArgument);
    #####:   39:		return NULL;
        -:   40:	}
        -:   41:	void *ret;
    #####:   42:	ret = malloc(size);
        -:   43:
    #####:   44:	if (ret) {
    #####:   45:		THREAD_LOCAL_RESOURCE_STATS.alloc_sum += 1;
    #####:   46:		if (zeroed)
    #####:   47:			memset(ret, 0, size);
        -:   48:	} else
    #####:   49:		SetErr(AllocErr);
    #####:   50:	return ret;
        -:   51:}
    #####:   52:void *resize(void *ptr, u64 size, bool zeroed) {
    #####:   53:	if (!ptr || !size) {
    #####:   54:		SetErr(IllegalArgument);
    #####:   55:		return NULL;
        -:   56:	}
        -:   57:	void *ret;
    #####:   58:	ret = realloc(ptr, size);
        -:   59:
    #####:   60:	if (ret) {
    #####:   61:		THREAD_LOCAL_RESOURCE_STATS.resize_sum += 1;
    #####:   62:		if (zeroed)
    #####:   63:			memset(ret, 0, size);
        -:   64:	} else
    #####:   65:		SetErr(AllocErr);
    #####:   66:	return ret;
        -:   67:}
        -:   68:
    #####:   69:void release(void *ptr) {
    #####:   70:	if (!ptr) {
    #####:   71:		SetErr(IllegalArgument);
    #####:   72:		return;
        -:   73:	}
    #####:   74:	THREAD_LOCAL_RESOURCE_STATS.release_sum += 1;
    #####:   75:	free(ptr);
        -:   76:}
        -:   77:
        1:   78:void release_no_stat(void *ptr) {
        1:   79:	if (!ptr) {
    #####:   80:		SetErr(IllegalArgument);
    #####:   81:		return;
        -:   82:	}
        1:   83:	free(ptr);
        -:   84:}
        -:   85:
       12:   86:u64 alloc_sum() {
       12:   87:	return THREAD_LOCAL_RESOURCE_STATS.alloc_sum;
        -:   88:}
    #####:   89:u64 resize_sum() {
    #####:   90:	return THREAD_LOCAL_RESOURCE_STATS.resize_sum;
        -:   91:}
       12:   92:u64 release_sum() {
       12:   93:	return THREAD_LOCAL_RESOURCE_STATS.release_sum;
        -:   94:}
        -:   95:
        -:   96:// Persistence
    #####:   97:void *persistent_alloc(const u8 *path, u64 size, bool zeroed) {
    #####:   98:	return NULL;
        -:   99:}
        -:  100:
    #####:  101:void *persistent_resize(const u8 *name, u64 size) {
    #####:  102:	return NULL;
        -:  103:}
        -:  104:
    #####:  105:i32 persistent_sync(void *ptr) {
    #####:  106:	return 0;
        -:  107:}
        -:  108:
    #####:  109:i32 persistent_delete(const u8 *name) {
    #####:  110:	return 0;
        -:  111:}
        -:  112:
        1:  113:u8 *env(const u8 *name) {
        1:  114:	return getenv(name);
        -:  115:}
        -:  116:
       67:  117:i64 strm_write(const Stream *strm, const void *buf, u64 len) {
       67:  118:	if (!strm || strm->handle < 0 || buf == NULL || len == 0) {
    #####:  119:		SetErr(IllegalArgument);
    #####:  120:		return -1;
        -:  121:	}
       67:  122:	return write(strm->handle, buf, len);
        -:  123:}
        -:  124:
    #####:  125:i64 strm_read(const Stream *strm, void *buf, u64 len) {
    #####:  126:	if (!strm || strm->handle < 0 || buf == NULL || len == 0) {
    #####:  127:		SetErr(IllegalArgument);
    #####:  128:		return -1;
        -:  129:	}
    #####:  130:	return read(strm->handle, buf, len);
        -:  131:}
        -:  132:
    #####:  133:i64 strm_open(Stream *strm, const u8 *command, const u8 *type) {
    #####:  134:	FILE *fp = popen(command, type);
    #####:  135:	if (fp == NULL) {
    #####:  136:		SetErr(POpenErr);
    #####:  137:		return -1;
        -:  138:	}
    #####:  139:	i32 fd = fileno(fp);
    #####:  140:	strm->handle = fd;
    #####:  141:	strm->strm = fp;
    #####:  142:	return 0;
        -:  143:}
        -:  144:
    #####:  145:void strm_close(const Stream *strm) {
    #####:  146:	if (strm->strm != NULL)
    #####:  147:		pclose(strm->strm);
        -:  148:	else
    #####:  149:		close(strm->handle);
    #####:  150:}
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/macro_util.h>
        -:   17:#include <base/os.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <base/string.h>
        -:   20:#include <inttypes.h>
        -:   21:
        -:   22:#define BUF_LEN 64
        -:   23:
        -:   24:// get the va functionality (with GCC/Clang use the builtin version, otherwise use stdarg)
        -:   25:#if defined(__GNUC__) || defined(__clang__)
        -:   26:typedef __builtin_va_list va_list;
        -:   27:#define va_start(ap, param) __builtin_va_start(ap, param)
        -:   28:#define va_end(ap) __builtin_va_end(ap)
        -:   29:#define va_arg(ap, type) __builtin_va_arg(ap, type)
        -:   30:#else // __GNUC__ or __clang__
        -:   31:#include <stdarg.h>
        -:   32:#endif // __GNUC__ or __clang__
        -:   33:
      111:   34:i32 write_loop(const Stream *strm, u8 *s, i32 *cur, i32 limit, const u8 *buf, u64 len) {
      111:   35:	if (s) {
       37:   36:		if (strm->handle == -1) {
        -:   37:			// length only
    #####:   38:			*cur += len;
       37:   39:		} else if (*cur < limit) {
        -:   40:			u8 *res;
       37:   41:			if (*cur == 0) {
        2:   42:				res = strncpy(s, buf, len);
        2:   43:				if (res == NULL)
    #####:   44:					return -1;
        -:   45:			} else {
       35:   46:				res = strncat(s, buf, len);
       35:   47:				if (res == NULL)
    #####:   48:					return -1;
        -:   49:			}
        -:   50:
       37:   51:			i32 l = strlen(buf);
       37:   52:			*cur = l;
        -:   53:		}
        -:   54:	} else {
      141:   55:		while (len > 0) {
       67:   56:			i64 w = strm_write(strm, buf, len);
       67:   57:			if (w < 0) {
    #####:   58:				SetErr(IO);
    #####:   59:				return w;
        -:   60:			}
        -:   61:
       67:   62:			len -= w;
        -:   63:		}
        -:   64:	}
      111:   65:	return 0;
        -:   66:}
        -:   67:
        8:   68:i32 print_impl(const Stream *strm, u8 *s, i32 capacity, bool nl, bool do_exit, i32 code,
        -:   69:			   const u8 *prefix, const u8 *fmt, ...) {
        8:   70:	int ret = 0;
        8:   71:	if (capacity < 0 && s) {
    #####:   72:		SetErr(IllegalArgument);
    #####:   73:		ret = -1;
        -:   74:	}
        8:   75:	if (s) {
        1:   76:		memset(s, '\0', capacity);
        -:   77:	}
        -:   78:	va_list args;
        8:   79:	va_start(args, fmt);
        8:   80:	i32 max = capacity;
        8:   81:	capacity = 0;
        -:   82:
       8*:   83:	if (prefix && ret != -1) {
    #####:   84:		if (write_loop(strm, s, &capacity, max, prefix, strlen(prefix)))
    #####:   85:			ret = -1;
        -:   86:	}
        -:   87:
       56:   88:	while (ret != -1) {
       56:   89:		bool is_hex = false;
       56:   90:		const u8 *next = strstr(fmt, "{}");
       56:   91:		const u8 *next_hex = strstr(fmt, "{hex}");
      56*:   92:		if ((next_hex && !next) || (next_hex && next_hex < next)) {
    #####:   93:			next = next_hex;
    #####:   94:			is_hex = true;
        -:   95:		}
        -:   96:
       56:   97:		if (next == NULL) {
        8:   98:			if (write_loop(strm, s, &capacity, max, fmt, strlen(fmt))) {
    #####:   99:				ret = -1;
       8*:  100:				break;
        -:  101:			}
        8:  102:			if (nl)
        7:  103:				if (write_loop(strm, s, &capacity, max, "\n", 1)) {
    #####:  104:					ret = -1;
    #####:  105:					break;
        -:  106:				}
        8:  107:			break;
       48:  108:		} else {
       48:  109:			u64 diff = next - fmt;
       48:  110:			u8 buf[1 + diff];
       48:  111:			memset(buf, '\0', 1 + diff);
       48:  112:			strncpy(buf, fmt, diff);
       48:  113:			if (write_loop(strm, s, &capacity, max, buf, diff)) {
    #####:  114:				ret = -1;
    #####:  115:				break;
        -:  116:			}
        -:  117:		}
        -:  118:
       48:  119:		PrintPair arg = va_arg(args, PrintPair);
        -:  120:
       48:  121:		if (arg.type == PrintTypeTerm) {
    #####:  122:			if (next) {
    #####:  123:				if (write_loop(strm, s, &capacity, max, next, strlen(next))) {
    #####:  124:					ret = -1;
    #####:  125:					break;
        -:  126:				}
    #####:  127:				if (nl)
    #####:  128:					if (write_loop(strm, s, &capacity, max, "\n", 1)) {
    #####:  129:						ret = -1;
    #####:  130:						break;
        -:  131:					}
        -:  132:			}
    #####:  133:			break;
       48:  134:		} else if (arg.type == PrintTypeBool) {
        -:  135:			bool value;
        6:  136:			memcpy(&value, arg.buf, sizeof(bool));
        -:  137:			u8 buf[BUF_LEN];
        6:  138:			if (value)
        3:  139:				strncpy(buf, "true", 5);
        -:  140:			else
        3:  141:				strncpy(buf, "false", 6);
        6:  142:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  143:				ret = -1;
    #####:  144:				break;
        -:  145:			}
       42:  146:		} else if (arg.type == PrintTypeF64) {
        -:  147:			f64 value;
        3:  148:			memcpy(&value, arg.buf, sizeof(f64));
        -:  149:			u8 buf[BUF_LEN];
        3:  150:			strcpy(buf, "");
        3:  151:			snprintf(buf, BUF_LEN - 1, "%lf", value);
        3:  152:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  153:				ret = -1;
    #####:  154:				break;
        -:  155:			}
       39:  156:		} else if (arg.type == PrintTypeF32) {
        -:  157:			f32 value;
        4:  158:			memcpy(&value, arg.buf, sizeof(f32));
        -:  159:			u8 buf[BUF_LEN];
        4:  160:			strcpy(buf, "");
        4:  161:			snprintf(buf, BUF_LEN - 1, "%f", value);
        4:  162:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  163:				ret = -1;
    #####:  164:				break;
        -:  165:			}
       35:  166:		} else if (arg.type == PrintTypeI64) {
        -:  167:			i64 value;
        2:  168:			memcpy(&value, arg.buf, sizeof(i64));
        -:  169:			u8 buf[BUF_LEN];
        2:  170:			strcpy(buf, "");
        2:  171:			if (is_hex)
    #####:  172:				snprintf(buf, BUF_LEN - 1, "%llX", value);
        -:  173:			else
        2:  174:				snprintf(buf, BUF_LEN - 1, "%lli", value);
        2:  175:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  176:				ret = -1;
    #####:  177:				break;
        -:  178:			}
       33:  179:		} else if (arg.type == PrintTypeU64) {
        -:  180:			u64 value;
        2:  181:			memcpy(&value, arg.buf, sizeof(u64));
        -:  182:			u8 buf[BUF_LEN];
        2:  183:			strcpy(buf, "");
        2:  184:			if (is_hex)
    #####:  185:				snprintf(buf, BUF_LEN - 1, "%llx", value);
        -:  186:			else
        2:  187:				snprintf(buf, BUF_LEN - 1, "%llu", value);
        -:  188:
        2:  189:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  190:				ret = -1;
    #####:  191:				break;
        -:  192:			}
       31:  193:		} else if (arg.type == PrintTypeI32) {
        -:  194:			i32 value;
        4:  195:			memcpy(&value, arg.buf, sizeof(i32));
        -:  196:			u8 buf[BUF_LEN];
        4:  197:			strcpy(buf, "");
        4:  198:			snprintf(buf, BUF_LEN - 1, "%i", value);
        4:  199:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  200:				ret = -1;
    #####:  201:				break;
        -:  202:			}
       27:  203:		} else if (arg.type == PrintTypeU32) {
        -:  204:			u32 value;
        2:  205:			memcpy(&value, arg.buf, sizeof(u32));
        -:  206:			u8 buf[BUF_LEN];
        2:  207:			strcpy(buf, "");
        2:  208:			snprintf(buf, BUF_LEN - 1, "%u", value);
        2:  209:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  210:				ret = -1;
    #####:  211:				break;
        -:  212:			}
       25:  213:		} else if (arg.type == PrintTypeI16) {
        -:  214:			i16 value;
        2:  215:			memcpy(&value, arg.buf, sizeof(i16));
        -:  216:			u8 buf[BUF_LEN];
        2:  217:			strcpy(buf, "");
        2:  218:			snprintf(buf, BUF_LEN - 1, "%i", value);
        2:  219:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  220:				ret = -1;
    #####:  221:				break;
        -:  222:			}
       23:  223:		} else if (arg.type == PrintTypeU16) {
        -:  224:			u16 value;
        2:  225:			memcpy(&value, arg.buf, sizeof(u16));
        -:  226:			u8 buf[BUF_LEN];
        2:  227:			strcpy(buf, "");
        2:  228:			snprintf(buf, BUF_LEN - 1, "%u", value);
        2:  229:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  230:				ret = -1;
    #####:  231:				break;
        -:  232:			}
       21:  233:		} else if (arg.type == PrintTypeI8) {
        -:  234:			i8 value;
        2:  235:			memcpy(&value, arg.buf, sizeof(i8));
        -:  236:			u8 buf[BUF_LEN];
        2:  237:			strcpy(buf, "");
        2:  238:			snprintf(buf, BUF_LEN - 1, "%i", value);
        2:  239:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  240:				ret = -1;
    #####:  241:				break;
        -:  242:			}
       19:  243:		} else if (arg.type == PrintTypeU8) {
        -:  244:			u8 value;
        2:  245:			memcpy(&value, arg.buf, sizeof(u8));
        -:  246:			u8 buf[BUF_LEN];
        2:  247:			strcpy(buf, "");
        2:  248:			snprintf(buf, BUF_LEN - 1, "%u", value);
        2:  249:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
    #####:  250:				ret = -1;
    #####:  251:				break;
        -:  252:			}
       17:  253:		} else if (arg.type == PrintTypeString) {
       17:  254:			if (write_loop(strm, s, &capacity, max, arg.data, strlen(arg.data))) {
    #####:  255:				ret = -1;
    #####:  256:				break;
        -:  257:			}
        -:  258:		}
       48:  259:		if (is_hex)
    #####:  260:			fmt = next + 5;
        -:  261:		else
       48:  262:			fmt = next + 2;
        -:  263:	}
        -:  264:
        8:  265:	va_end(args);
        -:  266:
        8:  267:	if (do_exit) {
        -:  268:		Backtrace bt;
    #####:  269:		backtrace_generate(&bt);
    #####:  270:		backtrace_print(&bt);
        -:  271:
    #####:  272:		exit(code);
        -:  273:	}
        -:  274:
        8:  275:	if (ret == -1)
    #####:  276:		return ret;
        8:  277:	return capacity;
        -:  278:}
        -:    0:Source:stream.c
        -:    0:Graph:stream.gcno
        -:    0:Data:stream.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/print_util.h>
        -:   18:#include <base/stream.h>
        -:   19:#include <base/types.h>
        -:   20:
    #####:   21:u8 *sgets(u8 *buf, u64 limit, Stream *strm) {
    #####:   22:	if (!buf || limit == 0 || strm == NULL) {
    #####:   23:		SetErr(IllegalArgument);
    #####:   24:		return NULL;
        -:   25:	}
    #####:   26:	i64 len = strm_read(strm, buf, limit - 1);
    #####:   27:	if (len <= 0) {
    #####:   28:		return NULL;
        -:   29:	}
        -:   30:
        -:   31:	i64 i;
    #####:   32:	for (i = 0; i < len; i++) {
    #####:   33:		if (buf[len] == '\n') {
    #####:   34:			i++;
    #####:   35:			break;
        -:   36:		}
        -:   37:	}
    #####:   38:	buf[i] = '\0';
    #####:   39:	return buf;
        -:   40:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:9
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/print_util.h>
        -:   16:#include <base/types.h>
        -:   17:
        9:   18:bool __is_little_endian() {
        9:   19:	u16 test = 0x1;
        9:   20:	return (*(u8 *)&test == 0x1);
        -:   21:}
        -:   22:
        9:   23:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   24:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   25:	panic("This program requires a 64-bit architecture to run.");
        -:   26:#endif // arch
        -:   27:	if (__SIZEOF_SIZE_T__ != 8)
        -:   28:		panic("This program requires a 64-bit architecture to run.");
        -:   29:	if (sizeof(u8) != 1 || sizeof(u16) != 2 || sizeof(u32) != 4 || sizeof(u64) != 8 ||
        -:   30:		sizeof(u128) != 16 || sizeof(i8) != 1 || sizeof(i16) != 2 || sizeof(i32) != 4 ||
        -:   31:		sizeof(i64) != 8 || sizeof(i128) != 16 || sizeof(f32) != 4 || sizeof(f64) != 8 ||
        -:   32:		sizeof(bool) != 1) {
        -:   33:		panic("Invalid data type size! Check your c compiler configuration options.");
        -:   34:	}
        -:   35:
        9:   36:	if (!__is_little_endian()) {
    #####:   37:		panic("Big endian systems not supported");
        -:   38:	}
        -:   39:
        -:   40:	if (sizeof(au64) != 8) {
        -:   41:		panic("Unexpected size for atomic_ullong. Check your compiler and architecture.");
        -:   42:	}
        -:   43:	if (sizeof(au32) != 4) {
        -:   44:		panic("Unexpected size for atomic_uint. Check your compiler and architecture.");
        -:   45:	}
        9:   46:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
