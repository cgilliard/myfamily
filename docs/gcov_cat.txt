        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int main(int argc, char **argv) {
    #####:   18:	return real_main(argc, argv);
        -:   19:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <limits.h>
        -:   18:#include <main/main.h>
        -:   19:#include <stdio.h>
        -:   20:#include <string.h>
        -:   21:
    #####:   22:void write_to_disk(const char *dir, const char *file_name, const unsigned char *data, u64 size) {
        -:   23:	char path[PATH_MAX + 1];
    #####:   24:	snprintf(path, sizeof(path), "%s/%s", dir, file_name);
    #####:   25:	Path ensure_parent;
    #####:   26:	path_for(&ensure_parent, path);
    #####:   27:	char *pfile_name = path_file_name(&ensure_parent);
        -:   28:	char pfile_name_copy[PATH_MAX + 1];
    #####:   29:	strcpy(pfile_name_copy, pfile_name);
    #####:   30:	path_pop(&ensure_parent);
    #####:   31:	path_canonicalize(&ensure_parent);
    #####:   32:	path_mkdir(&ensure_parent, 0700, true);
    #####:   33:	path_push(&ensure_parent, pfile_name_copy);
    #####:   34:	MYFILE *f = myfopen(&ensure_parent, "wb");
    #####:   35:	if (f) {
    #####:   36:		fwrite(data, 1, size, (FILE *)f);
    #####:   37:		myfclose(f);
        -:   38:	} else {
    #####:   39:		exit_error("Could not open file for writing");
        -:   40:	}
    #####:   41:}
        -:   42:
    #####:   43:bool check_build_id(const char *config_dir) {
    #####:   44:	Path bid_file;
    #####:   45:	path_for(&bid_file, config_dir);
    #####:   46:	path_push(&bid_file, "build_id");
    #####:   47:	path_canonicalize(&bid_file);
        -:   48:	// check build id
    #####:   49:	MYFILE *fp = myfopen(&bid_file, "r");
    #####:   50:	if (!fp) {
    #####:   51:		exit_error("could not open the build file");
        -:   52:	}
        -:   53:	char bid_file_contents[1024];
    #####:   54:	size_t rlen = read_all(bid_file_contents, 1, 100, fp);
    #####:   55:	bid_file_contents[rlen] = 0;
    #####:   56:	return !strcmp(bid_file_contents, BUILD_ID);
        -:   57:}
        -:   58:
    #####:   59:void setup_config_dir(const char *config_dir) {
    #####:   60:	Path cd;
    #####:   61:	path_for(&cd, config_dir);
    #####:   62:	path_canonicalize(&cd);
    #####:   63:	if (path_exists(&cd)) {
    #####:   64:		if (check_build_id(config_dir))
    #####:   65:			return;
    #####:   66:		remove_directory(&cd, false);
        -:   67:	}
    #####:   68:	fprintf(stderr, "Installing config directory at %s. Build id = %s\n", config_dir, BUILD_ID);
    #####:   69:	if (!path_mkdir(&cd, 0700, true)) {
    #####:   70:		exit_error("Could not create config directory at path [%s].", path_to_string(&cd));
        -:   71:	}
        -:   72:
    #####:   73:	Path rd;
    #####:   74:	path_copy(&rd, &cd);
    #####:   75:	path_push(&rd, "resources");
        -:   76:
    #####:   77:	if (!path_mkdir(&rd, 0700, true)) {
    #####:   78:		exit_error("Could not create resources directory at path [%s].", path_to_string(&rd));
        -:   79:	}
        -:   80:
    #####:   81:	BUILD_RESOURCE_DIR(path_to_string(&rd), fam);
    #####:   82:	WRITE_BUILD_ID(config_dir);
        -:   83:}
        -:   84:
    #####:   85:int real_main(int argc, char **argv) {
    #####:   86:	setup_config_dir("~/.fam");
    #####:   87:	return 0;
        -:   88:}
        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:#ifdef __linux__
        -:   19:#define getenv(x) secure_getenv(x)
        -:   20:#endif // __linux__
        -:   21:
        2:   22:char *get_dimmed() {
        2:   23:	if (getenv("NO_COLOR") != NULL) {
        1:   24:		return "";
        -:   25:	} else {
        1:   26:		return "\x1b[2m";
        -:   27:	}
        -:   28:}
        -:   29:
        2:   30:char *get_red() {
        2:   31:	if (getenv("NO_COLOR") != NULL) {
        1:   32:		return "";
        -:   33:	} else {
        1:   34:		return "\x1b[31m";
        -:   35:	}
        -:   36:}
        -:   37:
        2:   38:char *get_bright_red() {
        2:   39:	if (getenv("NO_COLOR") != NULL) {
        1:   40:		return "";
        -:   41:	} else {
        1:   42:		return "\x1b[91m";
        -:   43:	}
        -:   44:}
        -:   45:
        2:   46:char *get_green() {
        2:   47:	if (getenv("NO_COLOR") != NULL) {
        1:   48:		return "";
        -:   49:	} else {
        1:   50:		return "\x1b[32m";
        -:   51:	}
        -:   52:}
        -:   53:
        2:   54:char *get_yellow() {
        2:   55:	if (getenv("NO_COLOR") != NULL) {
        1:   56:		return "";
        -:   57:	} else {
        1:   58:		return "\x1b[33m";
        -:   59:	}
        -:   60:}
        -:   61:
        2:   62:char *get_cyan() {
        2:   63:	if (getenv("NO_COLOR") != NULL) {
        1:   64:		return "";
        -:   65:	} else {
        1:   66:		return "\x1b[36m";
        -:   67:	}
        -:   68:}
        -:   69:
        2:   70:char *get_magenta() {
        2:   71:	if (getenv("NO_COLOR") != NULL) {
        1:   72:		return "";
        -:   73:	} else {
        1:   74:		return "\x1b[35m";
        -:   75:	}
        -:   76:}
        -:   77:
        2:   78:char *get_blue() {
        2:   79:	if (getenv("NO_COLOR") != NULL) {
        1:   80:		return "";
        -:   81:	} else {
        1:   82:		return "\x1b[34m";
        -:   83:	}
        -:   84:}
        -:   85:
        2:   86:char *get_reset() {
        2:   87:	if (getenv("NO_COLOR") != NULL) {
        1:   88:		return "";
        -:   89:	} else {
        1:   90:		return "\x1b[0m";
        -:   91:	}
        -:   92:}
        -:    0:Source:misc.c
        -:    0:Graph:misc.gcno
        -:    0:Data:misc.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/resources.h>
        -:   17:#include <base/types.h>
        -:   18:#include <dirent.h>
        -:   19:#include <errno.h>
        -:   20:#include <limits.h>
        -:   21:#include <stdarg.h>
        -:   22:#include <stdio.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <string.h>
        -:   25:#include <sys/stat.h>
        -:   26:#include <unistd.h>
        -:   27:
       79:   28:const char *rstrstr(const char *s1, const char *s2) {
       79:   29:	size_t s1len = strlen(s1);
       79:   30:	size_t s2len = strlen(s2);
        -:   31:	const char *s;
        -:   32:
       79:   33:	if (s2len > s1len)
        1:   34:		return NULL;
      270:   35:	for (s = s1 + s1len - s2len; s >= s1; --s)
      268:   36:		if (strncmp(s, s2, s2len) == 0)
       76:   37:			return s;
        2:   38:	return NULL;
        -:   39:}
        -:   40:
        3:   41:u64 read_all(void *buffer, size_t size, size_t count, FILE *stream) {
        3:   42:	size_t total_read = 0;
        3:   43:	size_t bytes_to_read = size * count;
        -:   44:	size_t bytes_read;
        -:   45:
        5:   46:	while (total_read < bytes_to_read) {
        5:   47:		bytes_read = fread((char *)buffer + total_read, 1, bytes_to_read - total_read, stream);
        5:   48:		if (bytes_read == 0) {
        -:   49:			// Check for EOF or error
        3:   50:			if (feof(stream)) {
        3:   51:				break; // End of file reached
    #####:   52:			} else if (ferror(stream)) {
    #####:   53:				perror("Read error");
    #####:   54:				break; // Error occurred
        -:   55:			}
        -:   56:		}
        2:   57:		total_read += bytes_read;
        -:   58:	}
        -:   59:
        3:   60:	return total_read;
        -:   61:}
        -:   62:
        4:   63:int copy_file(const Path *dst_path, const Path *src_path) {
        4:   64:	if (dst_path == NULL || src_path == NULL) {
        1:   65:		errno = EINVAL;
        1:   66:		return -1;
        -:   67:	}
        -:   68:	FILE *source_file, *dest_file;
        -:   69:	size_t bytes;
        -:   70:
        -:   71:	// Open the source file in binary read mode
        3:   72:	source_file = (FILE *)myfopen(src_path, "rb");
        3:   73:	if (source_file == NULL) {
        1:   74:		errno = EINVAL;
        1:   75:		return -1;
        -:   76:	}
        -:   77:
        -:   78:	// Determine the file size
        2:   79:	fseek(source_file, 0, SEEK_END);
        2:   80:	long file_size = ftell(source_file);
        2:   81:	fseek(source_file, 0, SEEK_SET);
        2:   82:	char buffer[file_size];
        -:   83:
        -:   84:	// Open the destination file in binary write mode
        2:   85:	dest_file = (FILE *)myfopen(dst_path, "wb");
        2:   86:	if (dest_file == NULL) {
        1:   87:		errno = ENOENT;
        1:   88:		myfclose((MYFILE *)source_file);
        1:   89:		return -1;
        -:   90:	}
        -:   91:
        -:   92:	// Copy the file content
        2:   93:	while ((bytes = fread(buffer, 1, file_size, source_file)) > 0) {
        1:   94:		if (fwrite(buffer, 1, bytes, dest_file) != bytes) {
    #####:   95:			errno = EIO;
    #####:   96:			myfclose((MYFILE *)source_file);
    #####:   97:			myfclose((MYFILE *)dest_file);
    #####:   98:			return -1;
        -:   99:		}
        -:  100:	}
        -:  101:
        -:  102:	// Close both files
        1:  103:	myfclose((MYFILE *)source_file);
        1:  104:	myfclose((MYFILE *)dest_file);
        -:  105:
        1:  106:	return 0;
        -:  107:}
        -:  108:
        -:  109:// Function to recursively remove a directory and its contents
       18:  110:int remove_directory(const Path *p, bool preserve_dir) {
       18:  111:	const char *path = path_to_string(p);
        -:  112:	struct dirent *entry;
       18:  113:	DIR *dir = opendir(path);
        -:  114:
       18:  115:	if (dir == NULL) {
        5:  116:		return -1;
        -:  117:	}
        -:  118:
       52:  119:	while ((entry = readdir(dir)) != NULL) {
        -:  120:		char full_path[PATH_MAX];
        -:  121:
        -:  122:		// Skip the special entries "." and ".."
       39:  123:		if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
       26:  124:			continue;
        -:  125:		}
        -:  126:
        -:  127:		// Construct the full path to the file/directory
       13:  128:		snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        -:  129:
        -:  130:		struct stat statbuf;
       13:  131:		if (stat(full_path, &statbuf) == -1) {
    #####:  132:			perror("stat");
    #####:  133:			closedir(dir);
    #####:  134:			return -1;
        -:  135:		}
        -:  136:
       13:  137:		if (S_ISDIR(statbuf.st_mode)) {
        -:  138:			// It's a directory, recurse into it
        6:  139:			Path full_path_p;
        6:  140:			path_for(&full_path_p, full_path);
        6:  141:			if (remove_directory(&full_path_p, false) == -1) {
    #####:  142:				closedir(dir);
    #####:  143:				return -1;
        -:  144:			}
        -:  145:		} else {
        -:  146:			// It's a file, unlink (delete) it
        7:  147:			if (unlink(full_path) == -1) {
    #####:  148:				perror("unlink");
    #####:  149:				closedir(dir);
    #####:  150:				return -1;
        -:  151:			}
        -:  152:		}
        -:  153:	}
        -:  154:
       13:  155:	closedir(dir);
        -:  156:
        -:  157:	// Now the directory is empty, so we can remove it
       13:  158:	if (!preserve_dir) {
       12:  159:		if (rmdir(path) == -1) {
    #####:  160:			perror("rmdir");
    #####:  161:			return -1;
        -:  162:		}
        -:  163:	}
        -:  164:
       13:  165:	return 0;
        -:  166:}
        -:  167:
    #####:  168:void exit_error(char *format, ...) {
        -:  169:	va_list va_args;
    #####:  170:	va_start(va_args, format);
    #####:  171:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
    #####:  172:	vfprintf(stderr, format, va_args);
    #####:  173:	fprintf(stderr, "\n");
    #####:  174:	va_end(va_args);
    #####:  175:	exit(-1);
        -:  176:}
        -:    0:Source:path.c
        -:    0:Graph:path.gcno
        -:    0:Data:path.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <errno.h>
        -:   19:#include <limits.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:#include <sys/stat.h>
        -:   24:#include <unistd.h>
        -:   25:
       41:   26:void path_cleanup(PathImpl *ptr) {
       41:   27:	if (ptr->ptr)
       38:   28:		myfree(ptr->ptr);
       41:   29:}
        -:   30:
       43:   31:int path_for(Path *p, const char *path) {
       43:   32:	if (p == NULL) {
        1:   33:		errno = EINVAL;
        1:   34:		return -1;
        -:   35:	}
       42:   36:	if (path == NULL) {
        1:   37:		errno = EINVAL;
        1:   38:		p->ptr = NULL;
        1:   39:		return -1;
        -:   40:	}
       41:   41:	int len = strlen(path);
       41:   42:	if (len == 0) {
        1:   43:		errno = EINVAL;
        1:   44:		p->ptr = NULL;
        1:   45:		return -1;
        -:   46:	}
       40:   47:	p->ptr = mymalloc(len + 1);
       40:   48:	if (!p->ptr)
        2:   49:		return -1;
       38:   50:	p->len = len;
       38:   51:	strcpy(p->ptr, path);
       38:   52:	return 0;
        -:   53:}
        -:   54:
        2:   55:int path_replace_home(Path *p) {
        2:   56:	const char *home_dir = getenv("HOME");
        2:   57:	if (home_dir == NULL) {
    #####:   58:		errno = EINVAL;
    #####:   59:		return -1;
        -:   60:	}
        2:   61:	if (((char *)(p->ptr))[0] == '~') {
        2:   62:		int nlen = strlen(home_dir) + strlen(PATH_SEPARATOR) + strlen(p->ptr);
        2:   63:		if (nlen >= PATH_MAX) {
    #####:   64:			errno = E2BIG;
       1*:   65:			return -1;
        -:   66:		}
        2:   67:		if (nlen >= p->len) {
        2:   68:			void *nptr = myrealloc(p->ptr, nlen + 1);
        2:   69:			if (nptr == NULL)
        1:   70:				return -1;
        1:   71:			p->ptr = nptr;
        1:   72:			p->len = nlen;
        -:   73:		}
        -:   74:		char buf[PATH_MAX + 1];
       1*:   75:		if (strlen(p->ptr) > 1 && ((char *)(p->ptr))[1] == PATH_SEPARATOR_CHAR)
    #####:   76:			snprintf(buf, PATH_MAX, "%s%s", home_dir, (char *)(p->ptr + 1));
        -:   77:		else
        1:   78:			snprintf(buf, PATH_MAX, "%s%s%s", home_dir, PATH_SEPARATOR, (char *)(p->ptr + 1));
        1:   79:		strcpy(p->ptr, buf);
        -:   80:	}
        1:   81:	return 0;
        -:   82:}
        -:   83:
        2:   84:int path_canonicalize(Path *p) {
        2:   85:	if (path_replace_home(p))
        1:   86:		return -1;
        -:   87:	char buf[PATH_MAX];
        1:   88:	errno = 0;
        1:   89:	if (realpath(p->ptr, buf) == NULL) {
    #####:   90:		return -1;
        -:   91:	}
        1:   92:	int nlen = strlen(buf);
        1:   93:	if (nlen == 0) {
    #####:   94:		errno = EFAULT;
    #####:   95:		return -1;
        -:   96:	}
        1:   97:	if (nlen >= p->len) {
    #####:   98:		void *nptr = myrealloc(p->ptr, nlen + 1);
    #####:   99:		if (nptr == NULL)
    #####:  100:			return -1;
    #####:  101:		p->ptr = nptr;
    #####:  102:		p->len = nlen;
        -:  103:	}
        1:  104:	strcpy(p->ptr, buf);
        1:  105:	return 0;
        -:  106:}
       65:  107:int path_push(Path *p, const char *next) {
       65:  108:	if (p == NULL) {
        1:  109:		errno = EINVAL;
        1:  110:		return -1;
        -:  111:	}
       64:  112:	if (next == NULL) {
        1:  113:		errno = EINVAL;
        1:  114:		return -1;
        -:  115:	}
       63:  116:	int slen = strlen(p->ptr);
       63:  117:	if (slen <= 0 || strlen(next) == 0) {
        1:  118:		errno = EFAULT;
        1:  119:		return -1;
        -:  120:	}
       62:  121:	bool need_sep = false;
       62:  122:	if (((char *)p->ptr)[slen - 1] != PATH_SEPARATOR_CHAR) {
       62:  123:		need_sep = true;
        -:  124:	}
        -:  125:
       62:  126:	int nlen = slen + strlen(next);
       62:  127:	if (need_sep)
       62:  128:		nlen += strlen(PATH_SEPARATOR);
        -:  129:
       62:  130:	if (nlen >= p->len) {
       60:  131:		void *nptr = myrealloc(p->ptr, nlen + 1);
       60:  132:		if (nptr == NULL)
        1:  133:			return -1;
       59:  134:		p->ptr = nptr;
       59:  135:		p->len = nlen;
        -:  136:	}
        -:  137:
       61:  138:	if (need_sep)
       61:  139:		strcat(p->ptr, PATH_SEPARATOR);
       61:  140:	strcat(p->ptr, next);
       61:  141:	return 0;
        -:  142:}
       27:  143:int path_pop(Path *p) {
       27:  144:	char *res = rstrstr(p->ptr, PATH_SEPARATOR);
       27:  145:	if (res) {
       26:  146:		int index = res - (char *)p->ptr;
       26:  147:		((char *)(p->ptr))[index] = 0;
        -:  148:	} else {
        1:  149:		((char *)(p->ptr))[0] = '.';
        1:  150:		((char *)(p->ptr))[1] = 0;
        -:  151:	}
       27:  152:	return 0;
        -:  153:}
        -:  154:
       58:  155:char *path_to_string(const Path *p) {
       58:  156:	return p->ptr;
        -:  157:}
        -:  158:
       51:  159:char *path_file_name(const Path *p) {
       51:  160:	char *ret = rstrstr(p->ptr, PATH_SEPARATOR);
       51:  161:	if (ret != NULL && strlen(ret) > 0)
       50:  162:		return ret + 1;
        -:  163:
        1:  164:	return ret;
        -:  165:}
        -:  166:
       11:  167:bool path_exists(const Path *p) {
       11:  168:	if (p->ptr == NULL || p->len == 0) {
        1:  169:		errno = EINVAL;
        1:  170:		return false;
        -:  171:	}
       10:  172:	return access(p->ptr, F_OK) == 0;
        -:  173:}
        6:  174:bool path_is_dir(const Path *p) {
        6:  175:	if (p->ptr == NULL || p->len == 0) {
        1:  176:		errno = EINVAL;
        1:  177:		return false;
        -:  178:	}
        -:  179:	struct stat s;
        5:  180:	if (stat(p->ptr, &s) == 0) {
        2:  181:		return s.st_mode & S_IFDIR;
        -:  182:	}
        3:  183:	return false;
        -:  184:}
        -:  185:
       44:  186:bool path_mkdir(Path *p, u64 mode, bool parent) {
       44:  187:	if (p->ptr == NULL || p->len == 0) {
        1:  188:		errno = EINVAL;
        1:  189:		return false;
        -:  190:	}
        -:  191:
        -:  192:	struct stat s;
        -:  193:
        -:  194:	// Check if the path exists
       43:  195:	if (stat(p->ptr, &s) == 0) {
        -:  196:		// If the path exists and it's a directory, return success
        2:  197:		if (s.st_mode & S_IFDIR) {
        1:  198:			return true;
        -:  199:		} else {
        -:  200:			// Path exists but it's not a directory
        1:  201:			errno = ENOTDIR;
        1:  202:			return false;
        -:  203:		}
        -:  204:	}
        -:  205:
        -:  206:	// If parent is false, attempt to create only the target directory
       41:  207:	if (!parent) {
       37:  208:		if (mkdir(p->ptr, mode) != 0) {
       25:  209:			return false;
        -:  210:		}
       12:  211:		return true;
        -:  212:	}
        -:  213:
        -:  214:	// Create the directory structure (parent is true)
        4:  215:	Path temp_path;
        4:  216:	if (path_copy(&temp_path, p) != 0) {
        1:  217:		return false;
        -:  218:	}
        -:  219:
        3:  220:	int i = 0;
        -:  221:	char path_bufs[20][PATH_MAX];
       23:  222:	while (true) {
       26:  223:		if (path_mkdir(&temp_path, mode, false)) {
        6:  224:			for (int j = i - 1; j >= 0; j--) {
        4:  225:				path_push(&temp_path, path_bufs[j]);
        4:  226:				if (!path_mkdir(&temp_path, mode, false))
    #####:  227:					return false;
        -:  228:			}
        2:  229:			return true;
        -:  230:		}
       24:  231:		const char *dir_part = path_file_name(&temp_path);
       24:  232:		path_pop(&temp_path);
       24:  233:		strcpy(path_bufs[i], dir_part);
       24:  234:		if (path_file_name(&temp_path) == NULL)
    #####:  235:			break;
       24:  236:		i++;
       24:  237:		if (i == 20)
        1:  238:			break;
        -:  239:	}
        1:  240:	return false;
        -:  241:}
        -:  242:
       24:  243:int path_copy(Path *dst, const Path *src) {
       24:  244:	return path_for(dst, path_to_string(src));
        -:  245:}
        -:  246:
        1:  247:int path_file_stem(const Path *p, char *buf, u64 limit) {
        -:  248:	// Copy the file name into the buffer, ensuring proper null termination
        1:  249:	strncpy(buf, path_file_name(p), limit - 1);
        1:  250:	buf[limit - 1] = '\0'; // Manually ensure null-termination
        -:  251:
        1:  252:	u64 buflen = strlen(buf); // Compute length once
        4:  253:	for (ssize_t i = buflen - 1; i >= 0; i--) {
        4:  254:		if (buf[i] == '.') {
        1:  255:			buf[i] = '\0'; // Null-terminate at the dot
        1:  256:			break;
        3:  257:		} else if (buf[i] == '/') {
    #####:  258:			break; // Stop if we encounter a directory separator
        -:  259:		}
        -:  260:	}
        1:  261:	return 0;
        -:  262:}
        -:    0:Source:resources.c
        -:    0:Graph:resources.gcno
        -:    0:Data:resources.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <base/types.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:
        -:   20:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   21:#ifdef TEST
        -:   22:bool __is_debug_malloc = false;
        -:   23:bool __is_debug_realloc = false;
        -:   24:#endif // TEST
        -:   25:
       41:   26:void *mymalloc(u64 size) {
        -:   27:#ifdef TEST
       41:   28:	if (__is_debug_malloc) {
        2:   29:		return NULL;
        -:   30:	}
        -:   31:#endif // TEST
        -:   32:	void *ret;
       39:   33:	ret = malloc(size);
        -:   34:
       39:   35:	if (ret) {
       39:   36:		THREAD_LOCAL_RESOURCE_STATS.malloc_sum += 1;
        -:   37:	}
       39:   38:	return ret;
        -:   39:}
       63:   40:void *myrealloc(void *ptr, u64 size) {
        -:   41:#ifdef TEST
       63:   42:	if (__is_debug_realloc) {
        2:   43:		return NULL;
        -:   44:	}
        -:   45:#endif // TEST
        -:   46:	void *ret;
       61:   47:	ret = realloc(ptr, size);
        -:   48:
       61:   49:	if (ret) {
       61:   50:		THREAD_LOCAL_RESOURCE_STATS.realloc_sum += 1;
        -:   51:	}
       61:   52:	return ret;
        -:   53:}
       39:   54:void myfree(void *ptr) {
       39:   55:	THREAD_LOCAL_RESOURCE_STATS.free_sum += 1;
       39:   56:	free(ptr);
       39:   57:}
       14:   58:MYFILE *myfopen(const Path *path, const char *mode) {
       14:   59:	const char *path_str = path_to_string(path);
       14:   60:	FILE *ret = fopen(path_str, mode);
       14:   61:	if (ret) {
       12:   62:		THREAD_LOCAL_RESOURCE_STATS.fopen_sum += 1;
        -:   63:	}
       14:   64:	return (MYFILE *)ret;
        -:   65:}
       12:   66:void myfclose(MYFILE *ptr) {
       12:   67:	THREAD_LOCAL_RESOURCE_STATS.fclose_sum += 1;
       12:   68:	fclose((FILE *)ptr);
       12:   69:}
       12:   70:u64 mymalloc_sum() {
       12:   71:	return THREAD_LOCAL_RESOURCE_STATS.malloc_sum;
        -:   72:}
        2:   73:u64 myrealloc_sum() {
        2:   74:	return THREAD_LOCAL_RESOURCE_STATS.realloc_sum;
        -:   75:}
       12:   76:u64 myfree_sum() {
       12:   77:	return THREAD_LOCAL_RESOURCE_STATS.free_sum;
        -:   78:}
       15:   79:u64 myfopen_sum() {
       15:   80:	return THREAD_LOCAL_RESOURCE_STATS.fopen_sum;
        -:   81:}
       15:   82:u64 myfclose_sum() {
       15:   83:	return THREAD_LOCAL_RESOURCE_STATS.fclose_sum;
        -:   84:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stddef.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:
        6:   19:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   20:	if (sizeof(size_t) != 8) {
        -:   21:		fprintf(stderr, "Error: This program requires a 64-bit architecture to run.\n");
        -:   22:		exit(EXIT_FAILURE);
        -:   23:	}
        6:   24:}
