        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int main(int argc, char **argv) {
    #####:   18:	return real_main(argc, argv);
        -:   19:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
    #####:   15:int real_main(int argc, char **argv) {
    #####:   16:	return 0;
        -:   17:}
        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:#ifdef __linux__
        -:   19:#define getenv(x) secure_getenv(x)
        -:   20:#endif // __linux__
        -:   21:
        2:   22:char *get_dimmed() {
        2:   23:	if (getenv("NO_COLOR") != NULL) {
        1:   24:		return "";
        -:   25:	} else {
        1:   26:		return "\x1b[2m";
        -:   27:	}
        -:   28:}
        -:   29:
        2:   30:char *get_red() {
        2:   31:	if (getenv("NO_COLOR") != NULL) {
        1:   32:		return "";
        -:   33:	} else {
        1:   34:		return "\x1b[31m";
        -:   35:	}
        -:   36:}
        -:   37:
        2:   38:char *get_bright_red() {
        2:   39:	if (getenv("NO_COLOR") != NULL) {
        1:   40:		return "";
        -:   41:	} else {
        1:   42:		return "\x1b[91m";
        -:   43:	}
        -:   44:}
        -:   45:
        2:   46:char *get_green() {
        2:   47:	if (getenv("NO_COLOR") != NULL) {
        1:   48:		return "";
        -:   49:	} else {
        1:   50:		return "\x1b[32m";
        -:   51:	}
        -:   52:}
        -:   53:
        2:   54:char *get_yellow() {
        2:   55:	if (getenv("NO_COLOR") != NULL) {
        1:   56:		return "";
        -:   57:	} else {
        1:   58:		return "\x1b[33m";
        -:   59:	}
        -:   60:}
        -:   61:
        2:   62:char *get_cyan() {
        2:   63:	if (getenv("NO_COLOR") != NULL) {
        1:   64:		return "";
        -:   65:	} else {
        1:   66:		return "\x1b[36m";
        -:   67:	}
        -:   68:}
        -:   69:
        2:   70:char *get_magenta() {
        2:   71:	if (getenv("NO_COLOR") != NULL) {
        1:   72:		return "";
        -:   73:	} else {
        1:   74:		return "\x1b[35m";
        -:   75:	}
        -:   76:}
        -:   77:
        2:   78:char *get_blue() {
        2:   79:	if (getenv("NO_COLOR") != NULL) {
        1:   80:		return "";
        -:   81:	} else {
        1:   82:		return "\x1b[34m";
        -:   83:	}
        -:   84:}
        -:   85:
        2:   86:char *get_reset() {
        2:   87:	if (getenv("NO_COLOR") != NULL) {
        1:   88:		return "";
        -:   89:	} else {
        1:   90:		return "\x1b[0m";
        -:   91:	}
        -:   92:}
        -:    0:Source:misc.c
        -:    0:Graph:misc.gcno
        -:    0:Data:misc.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/resources.h>
        -:   17:#include <base/types.h>
        -:   18:#include <dirent.h>
        -:   19:#include <errno.h>
        -:   20:#include <limits.h>
        -:   21:#include <stdarg.h>
        -:   22:#include <stdio.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <string.h>
        -:   25:#include <sys/stat.h>
        -:   26:#include <unistd.h>
        -:   27:
       79:   28:const char *rstrstr(const char *s1, const char *s2) {
       79:   29:	size_t s1len = strlen(s1);
       79:   30:	size_t s2len = strlen(s2);
        -:   31:	const char *s;
        -:   32:
       79:   33:	if (s2len > s1len)
        1:   34:		return NULL;
      270:   35:	for (s = s1 + s1len - s2len; s >= s1; --s)
      268:   36:		if (strncmp(s, s2, s2len) == 0)
       76:   37:			return s;
        2:   38:	return NULL;
        -:   39:}
        -:   40:
        3:   41:u64 read_all(void *buffer, size_t size, size_t count, FILE *stream) {
        3:   42:	size_t total_read = 0;
        3:   43:	size_t bytes_to_read = size * count;
        -:   44:	size_t bytes_read;
        -:   45:
        5:   46:	while (total_read < bytes_to_read) {
        5:   47:		bytes_read = fread((char *)buffer + total_read, 1, bytes_to_read - total_read, stream);
        5:   48:		if (bytes_read == 0) {
        -:   49:			// Check for EOF or error
        3:   50:			if (feof(stream)) {
        3:   51:				break; // End of file reached
    #####:   52:			} else if (ferror(stream)) {
    #####:   53:				perror("Read error");
    #####:   54:				break; // Error occurred
        -:   55:			}
        -:   56:		}
        2:   57:		total_read += bytes_read;
        -:   58:	}
        -:   59:
        3:   60:	return total_read;
        -:   61:}
        -:   62:
        4:   63:int copy_file(const Path *dst_path, const Path *src_path) {
        4:   64:	if (dst_path == NULL || src_path == NULL) {
        1:   65:		errno = EINVAL;
        1:   66:		return -1;
        -:   67:	}
        -:   68:	FILE *source_file, *dest_file;
        -:   69:	size_t bytes;
        -:   70:
        -:   71:	// Open the source file in binary read mode
        3:   72:	source_file = (FILE *)myfopen(src_path, "rb");
        3:   73:	if (source_file == NULL) {
        1:   74:		errno = EINVAL;
        1:   75:		return -1;
        -:   76:	}
        -:   77:
        -:   78:	// Determine the file size
        2:   79:	fseek(source_file, 0, SEEK_END);
        2:   80:	long file_size = ftell(source_file);
        2:   81:	fseek(source_file, 0, SEEK_SET);
        2:   82:	char buffer[file_size];
        -:   83:
        -:   84:	// Open the destination file in binary write mode
        2:   85:	dest_file = (FILE *)myfopen(dst_path, "wb");
        2:   86:	if (dest_file == NULL) {
        1:   87:		errno = ENOENT;
        1:   88:		myfclose((MYFILE *)source_file);
        1:   89:		return -1;
        -:   90:	}
        -:   91:
        -:   92:	// Copy the file content
        2:   93:	while ((bytes = fread(buffer, 1, file_size, source_file)) > 0) {
        1:   94:		if (fwrite(buffer, 1, bytes, dest_file) != bytes) {
    #####:   95:			errno = EIO;
    #####:   96:			myfclose((MYFILE *)source_file);
    #####:   97:			myfclose((MYFILE *)dest_file);
    #####:   98:			return -1;
        -:   99:		}
        -:  100:	}
        -:  101:
        -:  102:	// Close both files
        1:  103:	myfclose((MYFILE *)source_file);
        1:  104:	myfclose((MYFILE *)dest_file);
        -:  105:
        1:  106:	return 0;
        -:  107:}
        -:  108:
        -:  109:// Function to recursively remove a directory and its contents
       18:  110:int remove_directory(const Path *p, bool preserve_dir) {
       18:  111:	const char *path = path_to_string(p);
        -:  112:	struct dirent *entry;
       18:  113:	DIR *dir = opendir(path);
        -:  114:
       18:  115:	if (dir == NULL) {
        5:  116:		return -1;
        -:  117:	}
        -:  118:
       52:  119:	while ((entry = readdir(dir)) != NULL) {
        -:  120:		char full_path[PATH_MAX];
        -:  121:
        -:  122:		// Skip the special entries "." and ".."
       39:  123:		if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
       26:  124:			continue;
        -:  125:		}
        -:  126:
        -:  127:		// Construct the full path to the file/directory
       13:  128:		snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        -:  129:
        -:  130:		struct stat statbuf;
       13:  131:		if (stat(full_path, &statbuf) == -1) {
    #####:  132:			perror("stat");
    #####:  133:			closedir(dir);
    #####:  134:			return -1;
        -:  135:		}
        -:  136:
       13:  137:		if (S_ISDIR(statbuf.st_mode)) {
        -:  138:			// It's a directory, recurse into it
        6:  139:			Path full_path_p;
        6:  140:			path_for(&full_path_p, full_path);
        6:  141:			if (remove_directory(&full_path_p, false) == -1) {
    #####:  142:				closedir(dir);
    #####:  143:				return -1;
        -:  144:			}
        -:  145:		} else {
        -:  146:			// It's a file, unlink (delete) it
        7:  147:			if (unlink(full_path) == -1) {
    #####:  148:				perror("unlink");
    #####:  149:				closedir(dir);
    #####:  150:				return -1;
        -:  151:			}
        -:  152:		}
        -:  153:	}
        -:  154:
       13:  155:	closedir(dir);
        -:  156:
        -:  157:	// Now the directory is empty, so we can remove it
       13:  158:	if (!preserve_dir) {
       12:  159:		if (rmdir(path) == -1) {
    #####:  160:			perror("rmdir");
    #####:  161:			return -1;
        -:  162:		}
        -:  163:	}
        -:  164:
       13:  165:	return 0;
        -:  166:}
        -:  167:
    #####:  168:void exit_error(char *format, ...) {
        -:  169:	va_list va_args;
    #####:  170:	va_start(va_args, format);
    #####:  171:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
    #####:  172:	vfprintf(stderr, format, va_args);
    #####:  173:	fprintf(stderr, "\n");
    #####:  174:	va_end(va_args);
    #####:  175:	exit(-1);
        -:  176:}
        -:    0:Source:path.c
        -:    0:Graph:path.gcno
        -:    0:Data:path.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <errno.h>
        -:   19:#include <limits.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:#include <sys/stat.h>
        -:   24:#include <unistd.h>
        -:   25:
       41:   26:void path_cleanup(PathImpl *ptr) {
       41:   27:	if (ptr->ptr)
       38:   28:		myfree(ptr->ptr);
       41:   29:}
        -:   30:
       43:   31:int path_for(Path *p, const char *path) {
       43:   32:	if (p == NULL) {
        1:   33:		errno = EINVAL;
        1:   34:		return -1;
        -:   35:	}
       42:   36:	if (path == NULL) {
        1:   37:		errno = EINVAL;
        1:   38:		p->ptr = NULL;
        1:   39:		return -1;
        -:   40:	}
       41:   41:	int len = strlen(path);
       41:   42:	if (len == 0) {
        1:   43:		errno = EINVAL;
        1:   44:		p->ptr = NULL;
        1:   45:		return -1;
        -:   46:	}
       40:   47:	p->ptr = mymalloc(len + 1);
       40:   48:	if (!p->ptr)
        2:   49:		return -1;
       38:   50:	p->len = len;
       38:   51:	strcpy(p->ptr, path);
       38:   52:	return 0;
        -:   53:}
        -:   54:
        2:   55:int path_replace_home(Path *p) {
        2:   56:	const char *home_dir = getenv("HOME");
        2:   57:	if (home_dir == NULL) {
    #####:   58:		errno = EINVAL;
    #####:   59:		return -1;
        -:   60:	}
        2:   61:	if (((char *)(p->ptr))[0] == '~') {
        2:   62:		int nlen = strlen(home_dir) + strlen(PATH_SEPARATOR) + strlen(p->ptr);
        2:   63:		if (nlen >= PATH_MAX) {
    #####:   64:			errno = E2BIG;
       1*:   65:			return -1;
        -:   66:		}
        2:   67:		if (nlen >= p->len) {
        2:   68:			void *nptr = myrealloc(p->ptr, nlen + 1);
        2:   69:			if (nptr == NULL)
        1:   70:				return -1;
        1:   71:			p->ptr = nptr;
        1:   72:			p->len = nlen;
        -:   73:		}
        -:   74:		char buf[PATH_MAX + 1];
        1:   75:		snprintf(buf, PATH_MAX, "%s%s%s", home_dir, PATH_SEPARATOR, (char *)(p->ptr + 1));
        1:   76:		strcpy(p->ptr, buf);
        -:   77:	}
        1:   78:	return 0;
        -:   79:}
        -:   80:
        2:   81:int path_canonicalize(Path *p) {
        2:   82:	if (path_replace_home(p))
        1:   83:		return -1;
        -:   84:	char buf[PATH_MAX];
        1:   85:	errno = 0;
        1:   86:	if (realpath(p->ptr, buf) == NULL) {
    #####:   87:		return -1;
        -:   88:	}
        1:   89:	int nlen = strlen(buf);
        1:   90:	if (nlen == 0) {
    #####:   91:		errno = EFAULT;
    #####:   92:		return -1;
        -:   93:	}
        1:   94:	if (nlen >= p->len) {
    #####:   95:		void *nptr = myrealloc(p->ptr, nlen + 1);
    #####:   96:		if (nptr == NULL)
    #####:   97:			return -1;
    #####:   98:		p->ptr = nptr;
    #####:   99:		p->len = nlen;
        -:  100:	}
        1:  101:	strcpy(p->ptr, buf);
        1:  102:	return 0;
        -:  103:}
       65:  104:int path_push(Path *p, const char *next) {
       65:  105:	if (p == NULL) {
        1:  106:		errno = EINVAL;
        1:  107:		return -1;
        -:  108:	}
       64:  109:	if (next == NULL) {
        1:  110:		errno = EINVAL;
        1:  111:		return -1;
        -:  112:	}
       63:  113:	int slen = strlen(p->ptr);
       63:  114:	if (slen <= 0 || strlen(next) == 0) {
        1:  115:		errno = EFAULT;
        1:  116:		return -1;
        -:  117:	}
       62:  118:	bool need_sep = false;
       62:  119:	if (((char *)p->ptr)[slen - 1] != PATH_SEPARATOR_CHAR) {
       62:  120:		need_sep = true;
        -:  121:	}
        -:  122:
       62:  123:	int nlen = slen + strlen(next);
       62:  124:	if (need_sep)
       62:  125:		nlen += strlen(PATH_SEPARATOR);
        -:  126:
       62:  127:	if (nlen >= p->len) {
       60:  128:		void *nptr = myrealloc(p->ptr, nlen + 1);
       60:  129:		if (nptr == NULL)
        1:  130:			return -1;
       59:  131:		p->ptr = nptr;
       59:  132:		p->len = nlen;
        -:  133:	}
        -:  134:
       61:  135:	if (need_sep)
       61:  136:		strcat(p->ptr, PATH_SEPARATOR);
       61:  137:	strcat(p->ptr, next);
       61:  138:	return 0;
        -:  139:}
       27:  140:int path_pop(Path *p) {
       27:  141:	char *res = rstrstr(p->ptr, PATH_SEPARATOR);
       27:  142:	if (res) {
       26:  143:		int index = res - (char *)p->ptr;
       26:  144:		((char *)(p->ptr))[index] = 0;
        -:  145:	} else {
        1:  146:		((char *)(p->ptr))[0] = '.';
        1:  147:		((char *)(p->ptr))[1] = 0;
        -:  148:	}
       27:  149:	return 0;
        -:  150:}
        -:  151:
       58:  152:char *path_to_string(const Path *p) {
       58:  153:	return p->ptr;
        -:  154:}
        -:  155:
       51:  156:char *path_file_name(const Path *p) {
       51:  157:	char *ret = rstrstr(p->ptr, PATH_SEPARATOR);
       51:  158:	if (ret != NULL && strlen(ret) > 0)
       50:  159:		return ret + 1;
        -:  160:
        1:  161:	return ret;
        -:  162:}
        -:  163:
       11:  164:bool path_exists(const Path *p) {
       11:  165:	if (p->ptr == NULL || p->len == 0) {
        1:  166:		errno = EINVAL;
        1:  167:		return false;
        -:  168:	}
       10:  169:	return access(p->ptr, F_OK) == 0;
        -:  170:}
        6:  171:bool path_is_dir(const Path *p) {
        6:  172:	if (p->ptr == NULL || p->len == 0) {
        1:  173:		errno = EINVAL;
        1:  174:		return false;
        -:  175:	}
        -:  176:	struct stat s;
        5:  177:	if (stat(p->ptr, &s) == 0) {
        2:  178:		return s.st_mode & S_IFDIR;
        -:  179:	}
        3:  180:	return false;
        -:  181:}
        -:  182:
       44:  183:bool path_mkdir(Path *p, u64 mode, bool parent) {
       44:  184:	if (p->ptr == NULL || p->len == 0) {
        1:  185:		errno = EINVAL;
        1:  186:		return false;
        -:  187:	}
        -:  188:
        -:  189:	struct stat s;
        -:  190:
        -:  191:	// Check if the path exists
       43:  192:	if (stat(p->ptr, &s) == 0) {
        -:  193:		// If the path exists and it's a directory, return success
        2:  194:		if (s.st_mode & S_IFDIR) {
        1:  195:			return true;
        -:  196:		} else {
        -:  197:			// Path exists but it's not a directory
        1:  198:			errno = ENOTDIR;
        1:  199:			return false;
        -:  200:		}
        -:  201:	}
        -:  202:
        -:  203:	// If parent is false, attempt to create only the target directory
       41:  204:	if (!parent) {
       37:  205:		if (mkdir(p->ptr, mode) != 0) {
       25:  206:			return false;
        -:  207:		}
       12:  208:		return true;
        -:  209:	}
        -:  210:
        -:  211:	// Create the directory structure (parent is true)
        4:  212:	Path temp_path;
        4:  213:	if (path_copy(&temp_path, p) != 0) {
        1:  214:		return false;
        -:  215:	}
        -:  216:
        3:  217:	int i = 0;
        -:  218:	char path_bufs[20][PATH_MAX];
       23:  219:	while (true) {
       26:  220:		if (path_mkdir(&temp_path, mode, false)) {
        6:  221:			for (int j = i - 1; j >= 0; j--) {
        4:  222:				path_push(&temp_path, path_bufs[j]);
        4:  223:				if (!path_mkdir(&temp_path, mode, false))
    #####:  224:					return false;
        -:  225:			}
        2:  226:			return true;
        -:  227:		}
       24:  228:		const char *dir_part = path_file_name(&temp_path);
       24:  229:		path_pop(&temp_path);
       24:  230:		strcpy(path_bufs[i], dir_part);
       24:  231:		if (path_file_name(&temp_path) == NULL)
    #####:  232:			break;
       24:  233:		i++;
       24:  234:		if (i == 20)
        1:  235:			break;
        -:  236:	}
        1:  237:	return false;
        -:  238:}
        -:  239:
       24:  240:int path_copy(Path *dst, const Path *src) {
       24:  241:	return path_for(dst, path_to_string(src));
        -:  242:}
        -:  243:
        1:  244:int path_file_stem(const Path *p, char *buf, u64 limit) {
        -:  245:	// Copy the file name into the buffer, ensuring proper null termination
        1:  246:	strncpy(buf, path_file_name(p), limit - 1);
        1:  247:	buf[limit - 1] = '\0'; // Manually ensure null-termination
        -:  248:
        1:  249:	u64 buflen = strlen(buf); // Compute length once
        4:  250:	for (ssize_t i = buflen - 1; i >= 0; i--) {
        4:  251:		if (buf[i] == '.') {
        1:  252:			buf[i] = '\0'; // Null-terminate at the dot
        1:  253:			break;
        3:  254:		} else if (buf[i] == '/') {
    #####:  255:			break; // Stop if we encounter a directory separator
        -:  256:		}
        -:  257:	}
        1:  258:	return 0;
        -:  259:}
        -:    0:Source:resources.c
        -:    0:Graph:resources.gcno
        -:    0:Data:resources.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <base/types.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:
        -:   20:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   21:#ifdef TEST
        -:   22:bool __is_debug_malloc = false;
        -:   23:bool __is_debug_realloc = false;
        -:   24:#endif // TEST
        -:   25:
       41:   26:void *mymalloc(u64 size) {
        -:   27:#ifdef TEST
       41:   28:	if (__is_debug_malloc) {
        2:   29:		return NULL;
        -:   30:	}
        -:   31:#endif // TEST
        -:   32:	void *ret;
       39:   33:	ret = malloc(size);
        -:   34:
       39:   35:	if (ret) {
       39:   36:		THREAD_LOCAL_RESOURCE_STATS.malloc_sum += 1;
        -:   37:	}
       39:   38:	return ret;
        -:   39:}
       63:   40:void *myrealloc(void *ptr, u64 size) {
        -:   41:#ifdef TEST
       63:   42:	if (__is_debug_realloc) {
        2:   43:		return NULL;
        -:   44:	}
        -:   45:#endif // TEST
        -:   46:	void *ret;
       61:   47:	ret = realloc(ptr, size);
        -:   48:
       61:   49:	if (ret) {
       61:   50:		THREAD_LOCAL_RESOURCE_STATS.realloc_sum += 1;
        -:   51:	}
       61:   52:	return ret;
        -:   53:}
       39:   54:void myfree(void *ptr) {
       39:   55:	THREAD_LOCAL_RESOURCE_STATS.free_sum += 1;
       39:   56:	free(ptr);
       39:   57:}
       14:   58:MYFILE *myfopen(const Path *path, const char *mode) {
       14:   59:	const char *path_str = path_to_string(path);
       14:   60:	FILE *ret = fopen(path_str, mode);
       14:   61:	if (ret) {
       12:   62:		THREAD_LOCAL_RESOURCE_STATS.fopen_sum += 1;
        -:   63:	}
       14:   64:	return (MYFILE *)ret;
        -:   65:}
       12:   66:void myfclose(MYFILE *ptr) {
       12:   67:	THREAD_LOCAL_RESOURCE_STATS.fclose_sum += 1;
       12:   68:	fclose((FILE *)ptr);
       12:   69:}
       12:   70:u64 mymalloc_sum() {
       12:   71:	return THREAD_LOCAL_RESOURCE_STATS.malloc_sum;
        -:   72:}
        2:   73:u64 myrealloc_sum() {
        2:   74:	return THREAD_LOCAL_RESOURCE_STATS.realloc_sum;
        -:   75:}
       12:   76:u64 myfree_sum() {
       12:   77:	return THREAD_LOCAL_RESOURCE_STATS.free_sum;
        -:   78:}
       15:   79:u64 myfopen_sum() {
       15:   80:	return THREAD_LOCAL_RESOURCE_STATS.fopen_sum;
        -:   81:}
       15:   82:u64 myfclose_sum() {
       15:   83:	return THREAD_LOCAL_RESOURCE_STATS.fclose_sum;
        -:   84:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:6
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stddef.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:
        6:   19:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   20:	if (sizeof(size_t) != 8) {
        -:   21:		fprintf(stderr, "Error: This program requires a 64-bit architecture to run.\n");
        -:   22:		exit(EXIT_FAILURE);
        -:   23:	}
        6:   24:}
