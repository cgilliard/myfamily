        -:    0:Source:backtrace.c
        -:    0:Graph:backtrace.gcno
        -:    0:Data:backtrace.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/backtrace.h>
        -:   16:#include <base/colors.h>
        -:   17:#include <base/fam_err.h>
        -:   18:#include <base/types.h>
        -:   19:
    #####:   20:i32 backtrace_generate(Backtrace *ptr) {
    #####:   21:	return 0;
        -:   22:}
        -:   23:
    #####:   24:void backtrace_print(const Backtrace *ptr) {
    #####:   25:}
        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/os.h>
        -:   17:
    #####:   18:char *get_dimmed() {
    #####:   19:	if (env("NO_COLOR") != NULL) {
    #####:   20:		return "";
        -:   21:	} else {
    #####:   22:		return "\x1b[2m";
        -:   23:	}
        -:   24:}
        -:   25:
    #####:   26:char *get_red() {
    #####:   27:	if (env("NO_COLOR") != NULL) {
    #####:   28:		return "";
        -:   29:	} else {
    #####:   30:		return "\x1b[31m";
        -:   31:	}
        -:   32:}
        -:   33:
    #####:   34:char *get_bright_red() {
    #####:   35:	if (env("NO_COLOR") != NULL) {
    #####:   36:		return "";
        -:   37:	} else {
    #####:   38:		return "\x1b[91m";
        -:   39:	}
        -:   40:}
        -:   41:
    #####:   42:char *get_green() {
    #####:   43:	if (env("NO_COLOR") != NULL) {
    #####:   44:		return "";
        -:   45:	} else {
    #####:   46:		return "\x1b[32m";
        -:   47:	}
        -:   48:}
        -:   49:
    #####:   50:char *get_yellow() {
    #####:   51:	if (env("NO_COLOR") != NULL) {
    #####:   52:		return "";
        -:   53:	} else {
    #####:   54:		return "\x1b[33m";
        -:   55:	}
        -:   56:}
        -:   57:
    #####:   58:char *get_cyan() {
    #####:   59:	if (env("NO_COLOR") != NULL) {
    #####:   60:		return "";
        -:   61:	} else {
    #####:   62:		return "\x1b[36m";
        -:   63:	}
        -:   64:}
        -:   65:
    #####:   66:char *get_magenta() {
    #####:   67:	if (env("NO_COLOR") != NULL) {
    #####:   68:		return "";
        -:   69:	} else {
    #####:   70:		return "\x1b[35m";
        -:   71:	}
        -:   72:}
        -:   73:
    #####:   74:char *get_blue() {
    #####:   75:	if (env("NO_COLOR") != NULL) {
    #####:   76:		return "";
        -:   77:	} else {
    #####:   78:		return "\x1b[34m";
        -:   79:	}
        -:   80:}
        -:   81:
    #####:   82:char *get_reset() {
    #####:   83:	if (env("NO_COLOR") != NULL) {
    #####:   84:		return "";
        -:   85:	} else {
    #####:   86:		return "\x1b[0m";
        -:   87:	}
        -:   88:}
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/macro_util.h>
        -:   17:#include <base/os.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <base/string.h>
        -:   20:
        -:   21:_Thread_local u8 fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local i32 fam_err = NoErrors;
        -:   24:_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const u8 *get_err() {
    #####:   27:	return mystrcpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
        -:   28:}
        -:   29:
    #####:   30:void print_err(const u8 *text) {
    #####:   31:	println("%s: %s", FamErrText[fam_err], text);
    #####:   32:	if (env("CBACKTRACE") != NULL) {
        -:   33:		// backtrace_print(&thread_local_bt__);
        -:   34:	} else {
    #####:   35:		println("Backtrace currently disabled set env variable CBACKTRACE to enable");
        -:   36:	}
    #####:   37:}
        -:   38:
    #####:   39:void do_backtrace_generate(Backtrace *bt) {
    #####:   40:	if (env("CBACKTRACE") != NULL) {
        -:   41:		// backtrace_generate(bt);
        -:   42:	}
    #####:   43:}
        -:    0:Source:os.c
        -:    0:Graph:os.gcno
        -:    0:Data:os.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/string.h>
        -:   18:
        -:   19:#include <errno.h>
        -:   20:#include <fcntl.h>
        -:   21:#include <limits.h>
        -:   22:#include <stdio.h>
        -:   23:#include <sys/mman.h>
        -:   24:#include <sys/stat.h>
        -:   25:#include <unistd.h>
        -:   26:
        -:   27:u8 *getenv(const u8 *name);
        -:   28:void *malloc(size_t size);
        -:   29:void *realloc(void *ptr, size_t size);
        -:   30:void free(void *ptr);
        -:   31:void *memset(void *ptr, i32 x, size_t n);
        -:   32:
        -:   33:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   34:
    #####:   35:void *alloc(u64 size, bool zeroed) {
    #####:   36:	if (!size) {
    #####:   37:		SetErr(IllegalArgument);
    #####:   38:		return NULL;
        -:   39:	}
        -:   40:	void *ret;
    #####:   41:	ret = malloc(size);
        -:   42:
    #####:   43:	if (ret) {
    #####:   44:		THREAD_LOCAL_RESOURCE_STATS.alloc_sum += 1;
    #####:   45:		if (zeroed)
    #####:   46:			memset(ret, 0, size);
        -:   47:	} else
    #####:   48:		SetErr(AllocErr);
    #####:   49:	return ret;
        -:   50:}
    #####:   51:void *resize(void *ptr, u64 size, bool zeroed) {
    #####:   52:	if (!ptr || !size) {
    #####:   53:		SetErr(IllegalArgument);
    #####:   54:		return NULL;
        -:   55:	}
        -:   56:	void *ret;
    #####:   57:	ret = realloc(ptr, size);
        -:   58:
    #####:   59:	if (ret) {
    #####:   60:		THREAD_LOCAL_RESOURCE_STATS.resize_sum += 1;
    #####:   61:		if (zeroed)
    #####:   62:			memset(ret, 0, size);
        -:   63:	} else
    #####:   64:		SetErr(AllocErr);
    #####:   65:	return ret;
        -:   66:}
        -:   67:
    #####:   68:void release(void *ptr) {
    #####:   69:	if (!ptr) {
    #####:   70:		SetErr(IllegalArgument);
    #####:   71:		return;
        -:   72:	}
    #####:   73:	THREAD_LOCAL_RESOURCE_STATS.release_sum += 1;
    #####:   74:	free(ptr);
        -:   75:}
        -:   76:
        4:   77:u64 alloc_sum() {
        4:   78:	return THREAD_LOCAL_RESOURCE_STATS.alloc_sum;
        -:   79:}
    #####:   80:u64 resize_sum() {
    #####:   81:	return THREAD_LOCAL_RESOURCE_STATS.resize_sum;
        -:   82:}
        4:   83:u64 release_sum() {
        4:   84:	return THREAD_LOCAL_RESOURCE_STATS.release_sum;
        -:   85:}
        -:   86:
        -:   87:// Persistence
    #####:   88:void *persistent_alloc(const u8 *path, u64 size, bool zeroed) {
    #####:   89:	return NULL;
        -:   90:}
        -:   91:
    #####:   92:void *persistent_resize(const u8 *name, u64 size) {
    #####:   93:	return NULL;
        -:   94:}
        -:   95:
    #####:   96:i32 persistent_sync(void *ptr) {
    #####:   97:	return 0;
        -:   98:}
        -:   99:
    #####:  100:i32 persistent_delete(const u8 *name) {
    #####:  101:	return 0;
        -:  102:}
        -:  103:
    #####:  104:u8 *env(const u8 *name) {
    #####:  105:	return getenv(name);
        -:  106:}
        -:  107:
        8:  108:i32 write_impl(i32 fd, const void *buf, u64 len) {
        8:  109:	return write(fd, buf, len);
        -:  110:}
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/macro_util.h>
        -:   17:#include <base/os.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <base/string.h>
        -:   20:
        -:   21:// get the va functionality (with GCC/Clang use the builtin version, otherwise use stdarg)
        -:   22:#if defined(__GNUC__) || defined(__clang__)
        -:   23:typedef __builtin_va_list va_list;
        -:   24:#define va_start(ap, param) __builtin_va_start(ap, param)
        -:   25:#define va_end(ap) __builtin_va_end(ap)
        -:   26:#define va_arg(ap, type) __builtin_va_arg(ap, type)
        -:   27:#else // __GNUC__ or __clang__
        -:   28:#include <stdarg.h>
        -:   29:#endif // __GNUC__ or __clang__
        -:   30:
        -:   31:#define BUF_LEN 64
        -:   32:
       10:   33:i32 write_loop(const Stream *strm, u8 *s, i32 *cur, i32 limit, const u8 *buf, u64 len) {
       10:   34:	if (s) {
    #####:   35:		if (strm->handle == -1) {
        -:   36:			// length only
    #####:   37:			*cur += len;
    #####:   38:		} else if (*cur < limit) {
        -:   39:			u8 *res;
    #####:   40:			if (*cur == 0) {
    #####:   41:				res = mystrcpy(s, buf, limit);
    #####:   42:				if (res == NULL)
    #####:   43:					return -1;
        -:   44:			} else {
    #####:   45:				res = mystrcat(s, buf, limit);
    #####:   46:				if (res == NULL)
    #####:   47:					return -1;
        -:   48:			}
    #####:   49:			*cur = res - s;
        -:   50:		}
        -:   51:	} else
       18:   52:		while (len > 0) {
        8:   53:			i64 w = write_impl(strm->handle, buf, len);
        8:   54:			if (w < 0) {
    #####:   55:				SetErr(IO);
    #####:   56:				return w;
        -:   57:			}
        -:   58:
        8:   59:			len -= w;
        -:   60:		}
       10:   61:	return 0;
        -:   62:}
        -:   63:
        2:   64:i32 print_impl(const Stream *strm, u8 *s, i32 capacity, bool nl, bool do_exit, i32 code,
        -:   65:			   const u8 *prefix, const u8 *fmt, ...) {
        2:   66:	int ret = 0;
        2:   67:	if (capacity < 0 && s) {
    #####:   68:		SetErr(IllegalArgument);
    #####:   69:		ret = -1;
        -:   70:	}
        -:   71:	va_list args;
        2:   72:	va_start(args, fmt);
        2:   73:	i32 max = capacity;
        2:   74:	capacity = 0;
        -:   75:
       2*:   76:	if (prefix && ret != -1) {
    #####:   77:		if (write_loop(strm, s, &capacity, max, prefix, mystrlen(prefix)))
    #####:   78:			ret = -1;
        -:   79:	}
        -:   80:
        5:   81:	while (ret != -1) {
        5:   82:		const u8 *next = mystrstr(fmt, "{}");
        -:   83:
        5:   84:		if (next == NULL) {
        2:   85:			if (write_loop(strm, s, &capacity, max, fmt, mystrlen(fmt))) {
    #####:   86:				ret = -1;
       2*:   87:				break;
        -:   88:			}
        2:   89:			if (nl)
        2:   90:				if (write_loop(strm, s, &capacity, max, "\n", 1)) {
    #####:   91:					ret = -1;
    #####:   92:					break;
        -:   93:				}
        2:   94:			break;
        3:   95:		} else {
        3:   96:			u64 diff = next - fmt;
        3:   97:			u8 buf[1 + diff];
        3:   98:			mystrcpy(buf, fmt, 1 + diff);
        3:   99:			if (write_loop(strm, s, &capacity, max, buf, diff)) {
    #####:  100:				ret = -1;
    #####:  101:				break;
        -:  102:			}
        -:  103:		}
        -:  104:
        3:  105:		PrintPair arg = va_arg(args, PrintPair);
        -:  106:
        3:  107:		if (arg.type == PrintTypeTerm) {
    #####:  108:			if (next) {
    #####:  109:				if (write_loop(strm, s, &capacity, max, next, mystrlen(next))) {
    #####:  110:					ret = -1;
    #####:  111:					break;
        -:  112:				}
    #####:  113:				if (nl)
    #####:  114:					if (write_loop(strm, s, &capacity, max, "\n", 1)) {
    #####:  115:						ret = -1;
    #####:  116:						break;
        -:  117:					}
        -:  118:			}
    #####:  119:			break;
        3:  120:		} else if (arg.type == PrintTypeU64) {
        -:  121:			u64 value;
    #####:  122:			mymemcpy(&value, arg.buf, sizeof(u64));
        -:  123:			u8 buf[BUF_LEN];
    #####:  124:			citoau64(value, buf, 10);
    #####:  125:			if (write_loop(strm, s, &capacity, max, buf, mystrlen(buf))) {
    #####:  126:				ret = -1;
    #####:  127:				break;
        -:  128:			}
        3:  129:		} else if (arg.type == PrintTypeI32) {
        -:  130:			i32 value;
        1:  131:			mymemcpy(&value, arg.buf, sizeof(i32));
        -:  132:			u8 buf[BUF_LEN];
        1:  133:			citoai64(value, buf, 10);
        1:  134:			if (write_loop(strm, s, &capacity, max, buf, mystrlen(buf))) {
    #####:  135:				ret = -1;
    #####:  136:				break;
        -:  137:			}
        2:  138:		} else if (arg.type == PrintTypeI16) {
        -:  139:			i16 value;
    #####:  140:			mymemcpy(&value, arg.buf, sizeof(i16));
        -:  141:			u8 buf[BUF_LEN];
    #####:  142:			citoai64(value, buf, 10);
    #####:  143:			if (write_loop(strm, s, &capacity, max, buf, mystrlen(buf))) {
    #####:  144:				ret = -1;
    #####:  145:				break;
        -:  146:			}
        2:  147:		} else if (arg.type == PrintTypeString) {
        2:  148:			if (write_loop(strm, s, &capacity, max, arg.data, mystrlen(arg.data))) {
    #####:  149:				ret = -1;
    #####:  150:				break;
        -:  151:			}
        -:  152:		}
        3:  153:		fmt = next + 2;
        -:  154:	}
        -:  155:
        2:  156:	va_end(args);
        -:  157:
        2:  158:	if (do_exit) {
    #####:  159:		exit(code);
        -:  160:	}
        -:  161:
        2:  162:	if (ret == -1)
    #####:  163:		return ret;
        2:  164:	return capacity;
        -:  165:}
        -:    0:Source:string.c
        -:    0:Graph:string.gcno
        -:    0:Data:string.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <base/string.h>
        -:   18:#include <base/types.h>
        -:   19:
        -:   20:bool __is_debug_mystrlen_overflow = false;
        -:   21:
        3:   22:i32 mymemcmp(const u8 *X, const u8 *Y, u64 len) {
        3:   23:	if (!X || !Y) {
    #####:   24:		SetErr(IllegalArgument);
    #####:   25:		return -1;
        -:   26:	}
        3:   27:	if (len == 0)
    #####:   28:		return 0;
        9:   29:	while (len--) {
        6:   30:		if (*X > *Y)
    #####:   31:			return 1;
        6:   32:		else if (*X < *Y)
    #####:   33:			return -1;
        -:   34:
        6:   35:		X++;
        6:   36:		Y++;
        -:   37:	}
        3:   38:	return 0;
        -:   39:}
        -:   40:
    #####:   41:i32 mystrcmp(const u8 *X, const u8 *Y) {
    #####:   42:	if (!X || !Y) {
    #####:   43:		SetErr(IllegalArgument);
    #####:   44:		return -1;
        -:   45:	}
    #####:   46:	while (*X && *Y) {
    #####:   47:		if (*X > *Y)
    #####:   48:			return 1;
    #####:   49:		else if (*X < *Y)
    #####:   50:			return -1;
        -:   51:
    #####:   52:		X++;
    #####:   53:		Y++;
        -:   54:	}
        -:   55:
    #####:   56:	if (*X != '\0')
    #####:   57:		return 1;
        -:   58:
    #####:   59:	else if (*Y != '\0')
    #####:   60:		return -1;
        -:   61:	else
    #####:   62:		return 0;
        -:   63:}
        -:   64:
    #####:   65:i32 mystrncmp(const u8 *X, const u8 *Y, u64 limit) {
    #####:   66:	if (!X || !Y) {
    #####:   67:		SetErr(IllegalArgument);
    #####:   68:		return -1;
        -:   69:	}
    #####:   70:	if (limit == 0)
    #####:   71:		return 0;
    #####:   72:	while (*X && *Y && limit) {
    #####:   73:		if (*X > *Y)
    #####:   74:			return 1;
    #####:   75:		else if (*X < *Y)
    #####:   76:			return -1;
        -:   77:
    #####:   78:		X++;
    #####:   79:		Y++;
    #####:   80:		limit--;
        -:   81:	}
        -:   82:
    #####:   83:	if (limit && *X != '\0')
    #####:   84:		return 1;
    #####:   85:	else if (limit && *Y != '\0')
    #####:   86:		return -1;
        -:   87:	else
    #####:   88:		return 0;
        -:   89:}
        -:   90:
       10:   91:i32 mystrlen(const u8 *Y) {
       10:   92:	if (!Y) {
    #####:   93:		SetErr(IllegalArgument);
    #####:   94:		return -1;
        -:   95:	}
       10:   96:	u64 ret = 0;
       53:   97:	while (*Y) {
       43:   98:		ret++;
       43:   99:		Y++;
       43:  100:		if (ret == INT32_MAX || __is_debug_mystrlen_overflow) {
    #####:  101:			SetErr(Overflow);
    #####:  102:			return -1;
        -:  103:		}
        -:  104:	}
       10:  105:	return ret;
        -:  106:}
        -:  107:
        5:  108:const u8 *mystrstr(const u8 *X, const u8 *Y) {
        5:  109:	if (!X || !Y) {
    #####:  110:		SetErr(IllegalArgument);
    #####:  111:		return NULL;
        -:  112:	}
        5:  113:	u64 len = mystrlen(Y);
       20:  114:	while (*X != '\0') {
        -:  115:
       18:  116:		if ((*X == *Y) && !mymemcmp(X, Y, len)) {
        3:  117:			return X;
        -:  118:		}
        -:  119:
       15:  120:		X++;
        -:  121:	}
        -:  122:
        2:  123:	return NULL;
        -:  124:}
        -:  125:
    #####:  126:u8 *mystrcat(u8 *X, const u8 *Y, u64 limit) {
    #####:  127:	if (!X || !Y) {
    #####:  128:		SetErr(IllegalArgument);
    #####:  129:		return NULL;
        -:  130:	}
    #####:  131:	if (limit == 0)
    #####:  132:		return X;
    #####:  133:	while (*X) {
    #####:  134:		X++;
        -:  135:	}
    #####:  136:	return mystrcpy(X, Y, limit);
        -:  137:}
        -:  138:
        3:  139:u8 *mystrcpy(u8 *X, const u8 *Y, u64 limit) {
        3:  140:	if (!X || !Y) {
    #####:  141:		SetErr(IllegalArgument);
    #####:  142:		return NULL;
        -:  143:	}
        -:  144:
        3:  145:	if (limit == 0)
    #####:  146:		return X;
       18:  147:	while (*Y != '\0' && (limit - 1)) {
       15:  148:		*X = *Y;
       15:  149:		X++;
       15:  150:		Y++;
       15:  151:		limit--;
        -:  152:	}
        3:  153:	*X = '\0';
        3:  154:	return X;
        -:  155:}
        -:  156:
        2:  157:void *mymemcpy(void *X, const void *Y, u64 limit) {
        2:  158:	if (!X || !Y) {
    #####:  159:		SetErr(IllegalArgument);
    #####:  160:		return NULL;
        -:  161:	}
        2:  162:	u8 *ret = X;
        2:  163:	if (limit == 0)
    #####:  164:		return ret;
        -:  165:
       10:  166:	while (limit) {
        8:  167:		*(u8 *)X = *(u8 *)Y;
        8:  168:		X++;
        8:  169:		Y++;
        8:  170:		limit--;
        -:  171:	}
        -:  172:
        2:  173:	return ret;
        -:  174:}
        -:  175:
        -:  176:// A utility function to reverse a string
        1:  177:void reverse(u8 str[], u64 length) {
        1:  178:	int start = 0;
        1:  179:	int end = length - 1;
        1:  180:	while (start < end) {
    #####:  181:		char temp = str[start];
    #####:  182:		str[start] = str[end];
    #####:  183:		str[end] = temp;
    #####:  184:		end--;
    #####:  185:		start++;
        -:  186:	}
        1:  187:}
        -:  188:
    #####:  189:u8 *citoau64(u64 num, u8 *str, u64 base) {
    #####:  190:	u64 i = 0;
        -:  191:
    #####:  192:	if (num == 0) {
    #####:  193:		str[i++] = '0';
    #####:  194:		str[i] = '\0';
    #####:  195:		return str;
        -:  196:	}
        -:  197:
    #####:  198:	while (num != 0) {
    #####:  199:		u64 rem = num % base;
    #####:  200:		str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
    #####:  201:		num = num / base;
        -:  202:	}
        -:  203:
    #####:  204:	str[i] = '\0';
        -:  205:
    #####:  206:	reverse(str, i);
        -:  207:
    #####:  208:	return str;
        -:  209:}
        -:  210:
        1:  211:u8 *citoai64(i64 num, u8 *str, u64 base) {
        1:  212:	u64 i = 0;
        1:  213:	bool isNegative = false;
        -:  214:
        1:  215:	if (num == 0) {
    #####:  216:		str[i++] = '0';
    #####:  217:		str[i] = '\0';
    #####:  218:		return str;
        -:  219:	}
        -:  220:
       1*:  221:	if (num < 0 && base == 10) {
    #####:  222:		isNegative = true;
    #####:  223:		num = -num;
        -:  224:	}
        -:  225:
        2:  226:	while (num != 0) {
        1:  227:		u64 rem = num % base;
       1*:  228:		str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
        1:  229:		num = num / base;
        -:  230:	}
        -:  231:
        1:  232:	if (isNegative)
    #####:  233:		str[i++] = '-';
        -:  234:
        1:  235:	str[i] = '\0';
        -:  236:
        1:  237:	reverse(str, i);
        -:  238:
        1:  239:	return str;
        -:  240:}
        -:  241:
    #####:  242:const u8 *rstrstr(const u8 *s1, const u8 *s2) {
    #####:  243:	u64 s1len = mystrlen(s1);
    #####:  244:	u64 s2len = mystrlen(s2);
        -:  245:	const u8 *s;
        -:  246:
    #####:  247:	if (s2len > s1len)
    #####:  248:		return NULL;
    #####:  249:	for (s = s1 + s1len - s2len; s >= s1; --s)
    #####:  250:		if (mystrncmp(s, s2, s2len) == 0)
    #####:  251:			return s;
    #####:  252:	return NULL;
        -:  253:}
        -:  254:
        -:  255:// set memory at memory location 'ptr' of size 'size' to 0.
    #####:  256:void memzero(void *ptr, u64 size) {
    #####:  257:	if (!ptr) {
    #####:  258:		SetErr(IllegalArgument);
    #####:  259:		return;
        -:  260:	}
    #####:  261:	if (size == 0)
    #####:  262:		return;
    #####:  263:	while (size--)
    #####:  264:		*(u8 *)ptr = '\0';
        -:  265:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:5
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:// #include <base/print_util.h>
        -:   16:#include <base/types.h>
        -:   17:
    #####:   18:bool __is_little_endian() {
    #####:   19:	u16 test = 0x1;
    #####:   20:	return (*(u8 *)&test == 0x1);
        -:   21:}
        -:   22:
        5:   23:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   24:	/*
        -:   25:	#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   26:		panic("Error: This program requires a 64-bit architecture to run.");
        -:   27:	#endif // arch
        -:   28:
        -:   29:		if (__SIZEOF_SIZE_T__ != 8)
        -:   30:			panic("Error: This program requires a 64-bit architecture to run.");
        -:   31:		if (sizeof(u8) != 1 || sizeof(u16) != 2 || sizeof(u32) != 4 || sizeof(u64) != 8 ||
        -:   32:			sizeof(u128) != 16 || sizeof(i8) != 1 || sizeof(i16) != 2 || sizeof(i32) != 4 ||
        -:   33:			sizeof(i64) != 8 || sizeof(i128) != 16 || sizeof(f32) != 4 || sizeof(f64) != 8 ||
        -:   34:			sizeof(bool) != 1) {
        -:   35:			panic("Invalid data type size! Check your c compiler configuration options.");
        -:   36:		}
        -:   37:
        -:   38:		if (!__is_little_endian()) {
        -:   39:			panic("Big endian systems not supported");
        -:   40:		}
        -:   41:
        -:   42:		if (sizeof(au64) != 8) {
        -:   43:			panic("Error: Unexpected size for atomic_ullong. Check your compiler and
        -:   44:	architecture.");
        -:   45:		}
        -:   46:		if (sizeof(au32) != 4) {
        -:   47:			panic("Error: Unexpected size for atomic_uint. Check your compiler and architecture.");
        -:   48:		}
        -:   49:	*/
        5:   50:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
