        -:    0:Source:alloc.c
        -:    0:Graph:alloc.gcno
        -:    0:Data:alloc.gcda
        -:    0:Runs:12
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/osdef.h>
        -:   18:#include <base/print_util.h>
        -:   19:
        -:   20:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   21:
        2:   22:unsigned int page_aligned_size(unsigned int size) {
        2:   23:	size_t slabs_page_size = getpagesize();
        2:   24:	size_t aligned_size =
        2:   25:		((size_t)size + slabs_page_size - 1) & ~(slabs_page_size - 1);
        2:   26:	if (aligned_size >= UINT32_MAX) {
    #####:   27:		SetErr(Overflow);
    #####:   28:		return UINT32_MAX;
        -:   29:	}
        2:   30:	return aligned_size;
        -:   31:}
        -:   32:
        1:   33:Alloc alloc(unsigned int size) {
        1:   34:	unsigned int aligned_size = page_aligned_size(size);
        1:   35:	if (aligned_size >= UINT32_MAX) {
    #####:   36:		SetErr(Overflow);
    #####:   37:		Alloc ret = {};
    #####:   38:		return ret;
        -:   39:	}
        1:   40:	void *ret = mmap(NULL, aligned_size, PROT_READ | PROT_WRITE,
        -:   41:					 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        1:   42:	if (ret) {
        1:   43:		THREAD_LOCAL_RESOURCE_STATS.alloc_sum += 1;
        -:   44:	} else {
    #####:   45:		SetErr(AllocErr);
        -:   46:	}
        -:   47:
        1:   48:	Alloc aret = {.ptr = ret, .size = aligned_size};
        1:   49:	return aret;
        -:   50:}
        -:   51:
        1:   52:void release(Alloc ptr) {
        -:   53:	int code;
        1:   54:	if ((code = munmap(ptr.ptr, ptr.size))) {
    #####:   55:		panic("munmap error = %i\n", code);
        -:   56:	}
        1:   57:	THREAD_LOCAL_RESOURCE_STATS.release_sum += 1;
        1:   58:}
        -:   59:
        8:   60:int64 alloc_sum() {
        8:   61:	return THREAD_LOCAL_RESOURCE_STATS.alloc_sum;
        -:   62:}
    #####:   63:int64 resize_sum() {
    #####:   64:	return THREAD_LOCAL_RESOURCE_STATS.resize_sum;
        -:   65:}
        8:   66:int64 release_sum() {
        8:   67:	return THREAD_LOCAL_RESOURCE_STATS.release_sum;
        -:   68:}
        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:12
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/osdef.h>
        -:   17:
    #####:   18:byte *get_dimmed() {
    #####:   19:	if (getenv("NO_COLOR") != NULL) {
    #####:   20:		return "";
        -:   21:	} else {
    #####:   22:		return "\x1b[2m";
        -:   23:	}
        -:   24:}
        -:   25:
    #####:   26:byte *get_red() {
    #####:   27:	if (getenv("NO_COLOR") != NULL) {
    #####:   28:		return "";
        -:   29:	} else {
    #####:   30:		return "\x1b[31m";
        -:   31:	}
        -:   32:}
        -:   33:
    #####:   34:byte *get_bright_red() {
    #####:   35:	if (getenv("NO_COLOR") != NULL) {
    #####:   36:		return "";
        -:   37:	} else {
    #####:   38:		return "\x1b[91m";
        -:   39:	}
        -:   40:}
        -:   41:
        2:   42:byte *get_green() {
        2:   43:	if (getenv("NO_COLOR") != NULL) {
    #####:   44:		return "";
        -:   45:	} else {
        2:   46:		return "\x1b[32m";
        -:   47:	}
        -:   48:}
        -:   49:
    #####:   50:byte *get_yellow() {
    #####:   51:	if (getenv("NO_COLOR") != NULL) {
    #####:   52:		return "";
        -:   53:	} else {
    #####:   54:		return "\x1b[33m";
        -:   55:	}
        -:   56:}
        -:   57:
    #####:   58:byte *get_cyan() {
    #####:   59:	if (getenv("NO_COLOR") != NULL) {
    #####:   60:		return "";
        -:   61:	} else {
    #####:   62:		return "\x1b[36m";
        -:   63:	}
        -:   64:}
        -:   65:
    #####:   66:byte *get_magenta() {
    #####:   67:	if (getenv("NO_COLOR") != NULL) {
    #####:   68:		return "";
        -:   69:	} else {
    #####:   70:		return "\x1b[35m";
        -:   71:	}
        -:   72:}
        -:   73:
        2:   74:byte *get_blue() {
        2:   75:	if (getenv("NO_COLOR") != NULL) {
    #####:   76:		return "";
        -:   77:	} else {
        2:   78:		return "\x1b[34m";
        -:   79:	}
        -:   80:}
        -:   81:
        4:   82:byte *get_reset() {
        4:   83:	if (getenv("NO_COLOR") != NULL) {
    #####:   84:		return "";
        -:   85:	} else {
        4:   86:		return "\x1b[0m";
        -:   87:	}
        -:   88:}
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:12
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:// #include <base/macro_util.h>
        -:   17:// #include <base/os.h>
        -:   18://  #include <base/print_util.h>
        -:   19://  #include <base/string.h>
        -:   20:
        -:   21:_Thread_local byte fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local int64 fam_err = NoErrors;
        -:   24://_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const byte *get_err() {
        -:   27:	// return strncpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
    #####:   28:	return NULL;
        -:   29:}
        -:   30:
    #####:   31:void print_err(const byte *text) {
        -:   32:	// println("{}: {}", FamErrText[fam_err], text);
        -:   33:	// backtrace_print(&thread_local_bt__);
    #####:   34:}
        -:   35:
        -:   36:// void do_backtrace_generate(Backtrace *bt) {
        -:   37:// if (env("CBACKTRACE") != NULL) {
        -:   38://  backtrace_generate(bt);
        -:   39://	}
        -:   40://}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:12
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/lock.h>
        -:   16:#include <base/macros.h>
        -:   17:#include <base/print_util.h>
        -:   18:
        -:   19:_Thread_local bool _lock_is_write__ = false;
        -:   20:
    #####:   21:Lock lock_create() {
    #####:   22:	return 0;
        -:   23:}
        2:   24:void lock_read(Lock *lock) {
        2:   25:	_lock_is_write__ = false;
        -:   26:	unsigned long long state;
        -:   27:	unsigned long long state_update;
        -:   28:	do {
        -:   29:		// get current state set the write_pending bit to false
        2:   30:		state = ALOAD(lock) & ~0x80000000ULL;
        -:   31:		// increment the read counter and add 1 to the sequence number (upper 32
        -:   32:		// bits)
        2:   33:		state_update = (state + 0x100000000ULL) + 1ULL;
        -:   34:		// while our target state (no change including sequence number and
        -:   35:		// write_pending != false, we spin)
        2:   36:	} while (!CAS_ACQUIRE(lock, &state, state_update));
        2:   37:}
        2:   38:void lock_write(Lock *lock) {
        2:   39:	_lock_is_write__ = true;
        -:   40:	unsigned long long state;
        -:   41:	unsigned long long state_update;
        -:   42:
        -:   43:	// first step, set write bit true indicating a writer is waiting
        -:   44:	// this lock should be obtained soon after the previous writer
        -:   45:	// is complete indicating to readers our desire to write
        -:   46:	// this avoids write starvation
        -:   47:	do {
        2:   48:		state = ALOAD(lock) & ~0x80000000ULL;
        2:   49:		state_update = (state + 0x100000000ULL) | 0x80000000ULL;
        2:   50:	} while (!CAS(lock, &state, state_update));
        -:   51:
        -:   52:	// second step, obtain total lock before proceeding
        -:   53:	do {
        -:   54:		// get current state. We will wait for the read count to go to 0.
        2:   55:		state = ALOAD(lock) & 0xFFFFFFFF80000000ULL;
        -:   56:		// set the updated value to set the write bit true and read count to 0,
        -:   57:		// increment the sequence number
        2:   58:		state_update = (state + 0x100000000ULL) & 0xFFFFFFFF80000000ULL;
        2:   59:	} while (!CAS_ACQUIRE(lock, &state, state_update));
        2:   60:}
        -:   61:
        4:   62:void lock_unlock(Lock *lock) {
        -:   63:	unsigned long long state;
        -:   64:	unsigned long long state_update;
        -:   65:	// check thread local write variable
        4:   66:	if (_lock_is_write__) {
        -:   67:		// writer
        -:   68:		do {
        -:   69:			// get current state
        2:   70:			state = ALOAD(lock);
        -:   71:			// unset the write bit and increment the sequence number
        2:   72:			state_update = (state + 0x100000000ULL) & ~0x80000000ULL;
        2:   73:		} while (!CAS_RELEASE(lock, &state, state_update));
        -:   74:	} else {
        -:   75:		// reader
        -:   76:		do {
        -:   77:			// get current state
        2:   78:			state = ALOAD(lock);
       2*:   79:			if ((state & 0x7FFFFFFF) == 0) panic("underflow!");
        -:   80:			// subtract 1 from the read count and increment the sequence number
        2:   81:			state_update = (state + 0x100000000ULL) - 1ULL;
        2:   82:		} while (!CAS_RELEASE(lock, &state, state_update));
        -:   83:	}
        4:   84:}
        -:   85:
        2:   86:void lock_guard_cleanup(LockGuard *l) {
        2:   87:	lock_unlock(l);
        2:   88:}
        -:   89:
        1:   90:LockGuard lock_guard_read(Lock l) {
        1:   91:	lock_read(&l);
        1:   92:	return l;
        -:   93:}
        1:   94:LockGuard lock_guard_write(Lock l) {
        1:   95:	lock_write(&l);
        1:   96:	return l;
        -:   97:}
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:12
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/print_util.h>
        -:   17:
        -:   18:// currently using stdio, will move to write
        -:   19:#include <stdio.h>
        -:   20:
    #####:   21:void __attribute__((no_return)) panic(const char *fmt, ...) {
        -:   22:	char buf[1024];
        -:   23:	__builtin_va_list args;
    #####:   24:	print("Panic: ");
    #####:   25:	__builtin_va_start(args, fmt);
    #####:   26:	vfprintf(stderr, fmt, args);
        -:   27:	// vsnprintf(buf, 1024, fmt, args);
    #####:   28:	__builtin_va_end(args);
    #####:   29:	fprintf(stderr, "\n");
        -:   30:
    #####:   31:	exit(-1);
        -:   32:}
        -:   33:
        2:   34:int println(const char *fmt, ...) {
        -:   35:	__builtin_va_list args;
        2:   36:	__builtin_va_start(args, fmt);
        2:   37:	vfprintf(stderr, fmt, args);
        2:   38:	__builtin_va_end(args);
        2:   39:	fprintf(stderr, "\n");
        2:   40:	return 0;
        -:   41:}
        -:   42:
    #####:   43:int print(const char *fmt, ...) {
        -:   44:	__builtin_va_list args;
    #####:   45:	__builtin_va_start(args, fmt);
    #####:   46:	vfprintf(stderr, fmt, args);
    #####:   47:	__builtin_va_end(args);
    #####:   48:	return 0;
        -:   49:}
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:12
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/lock.h>
        -:   18:#include <base/macros.h>
        -:   19:#include <base/osdef.h>
        -:   20:#include <base/print_util.h>
        -:   21:#include <base/slabs.h>
        -:   22:
        -:   23:typedef struct SlabImpl {
        -:   24:	struct SlabImpl *next;
        -:   25:	byte data[];
        -:   26:} SlabImpl;
        -:   27:
   100000:   28:byte *slab_get(Slab s) {
   100000:   29:	return s->data;
        -:   30:}
        -:   31:
        -:   32:SlabImpl slab_allocated_impl = {.next = NULL};
        -:   33:Slab slab_allocated_reqd = &slab_allocated_impl;
        -:   34:#define SLAB_ALLOCATED slab_allocated_reqd
        -:   35:
      110:   36:Slab slab_allocator_grow(SlabAllocator *sa) {
      110:   37:	if (__atomic_fetch_add(&sa->total_slabs, 1, __ATOMIC_RELAXED) >
      110:   38:		sa->max_total_slabs) {
    #####:   39:		__atomic_fetch_sub(&sa->total_slabs, 1, __ATOMIC_RELAXED);
    #####:   40:		SetErr(CapacityExceeded);
    #####:   41:		return NULL;
        -:   42:	}
      110:   43:	Slab ret = malloc(sizeof(SlabImpl) + sa->slab_size);
      110:   44:	if (ret == NULL) {
    #####:   45:		SetErr(AllocErr);
    #####:   46:		__atomic_fetch_sub(&sa->total_slabs, 1, __ATOMIC_RELAXED);
    #####:   47:		return NULL;
        -:   48:	}
      110:   49:	ret->next = SLAB_ALLOCATED;
      110:   50:	return ret;
        -:   51:}
        -:   52:
        3:   53:void slab_allocator_cleanup(SlabAllocator *sa) {
        3:   54:	Slab itt = sa->head;
      113:   55:	while (itt) {
      110:   56:		Slab to_delete = itt;
      110:   57:		itt = itt->next;
      110:   58:		free(to_delete);
        -:   59:	}
        3:   60:}
        -:   61:
        -:   62:// initialize slab allocator as a michael-scott queue with specified slab_size
        3:   63:int slab_allocator_init(SlabAllocator *sa, unsigned int slab_size,
        -:   64:						unsigned long long max_free_slabs,
        -:   65:						unsigned long long max_total_slabs) {
        3:   66:	Slab s = malloc(sizeof(SlabImpl) + slab_size);
        3:   67:	if (s == NULL) {
    #####:   68:		SetErr(AllocErr);
    #####:   69:		return -1;
        -:   70:	}
        3:   71:	__atomic_store_n(&sa->free_size, 1, __ATOMIC_SEQ_CST);
        3:   72:	__atomic_store_n(&sa->total_slabs, 1, __ATOMIC_SEQ_CST);
        3:   73:	sa->slab_size = slab_size;
        3:   74:	sa->max_free_slabs = max_free_slabs;
        3:   75:	sa->max_total_slabs = max_total_slabs;
        3:   76:	s->next = NULL;
        3:   77:	sa->head = sa->tail = s;
        3:   78:	return 0;
        -:   79:}
        -:   80:
        -:   81:// allocate is dequeue. If null "grow" by mallocing a slab.
    50108:   82:Slab slab_allocator_allocate(SlabAllocator *sa) {
        -:   83:	Slab head, tail, next, ret;
        -:   84:	loop {
    50108:   85:		head = sa->head;
    50108:   86:		tail = sa->tail;
    50108:   87:		next = head->next;
    50108:   88:		if (head == sa->head) {
    50108:   89:			if (head == tail) {
      110:   90:				if (next == NULL) {
      110:   91:					ret = slab_allocator_grow(sa);
      110:   92:					return ret;
        -:   93:				}
    #####:   94:				CAS_SEQ(&sa->tail, &tail, next);
        -:   95:			} else {
    49998:   96:				ret = head;
    49998:   97:				if (CAS_SEQ(&sa->head, &head, next)) break;
        -:   98:			}
        -:   99:		}
        -:  100:	}
        -:  101:
    49998:  102:	__atomic_fetch_sub(&sa->free_size, 1, __ATOMIC_RELAXED);
    49998:  103:	__atomic_store_n(&ret->next, SLAB_ALLOCATED, __ATOMIC_RELAXED);
    49998:  104:	return ret;
        -:  105:}
        -:  106:
        -:  107:// free is enqueue.
    50105:  108:void slab_allocator_free(SlabAllocator *sa, Slab slab) {
    50105:  109:	if (!CAS(&slab->next, &SLAB_ALLOCATED, NULL))
    #####:  110:		panic("Double free attempt! %p %p", &slab->next, &SLAB_ALLOCATED);
    50105:  111:	if (__atomic_fetch_add(&sa->free_size, 1, __ATOMIC_RELAXED) >
    50105:  112:		sa->max_free_slabs) {
    #####:  113:		free(slab);
    #####:  114:		__atomic_fetch_sub(&sa->total_slabs, 1, __ATOMIC_RELAXED);
    #####:  115:		return;
        -:  116:	}
        -:  117:
        -:  118:	Slab tail, next;
        -:  119:
        -:  120:	loop {
    50105:  121:		tail = sa->tail;
    50105:  122:		next = tail->next;
    50105:  123:		if (tail == sa->tail) {
    50105:  124:			if (next == NULL) {
    50105:  125:				if (CAS_SEQ(&tail->next, &next, slab)) {
    50105:  126:					CAS_SEQ(&sa->tail, &tail, slab);
    50105:  127:					break;
        -:  128:				}
        -:  129:			} else {
    #####:  130:				CAS_SEQ(&sa->tail, &tail, next);
        -:  131:			}
        -:  132:		}
        -:  133:	}
        -:  134:}
        -:  135:
    10002:  136:unsigned long long slab_allocator_free_size(SlabAllocator *sa) {
    10002:  137:	return ALOAD(&sa->free_size);
        -:  138:}
    10002:  139:unsigned long long slab_allocator_total_slabs(SlabAllocator *sa) {
    10002:  140:	return ALOAD(&sa->total_slabs);
        -:  141:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:12
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <base/types.h>
        -:   18:
       12:   19:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   20:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   21:	panic("Supported architectures: __x86_64__, _M_X64, and __aarch64__");
        -:   22:#endif	// arch
        -:   23:
        -:   24:	// check size_t
        -:   25:	if (__SIZEOF_SIZE_T__ != 8) panic("size_t must be 8 bytes. Invalid arch!");
        -:   26:	// check primitive types
        -:   27:	if (sizeof(byte) != 1) panic("byte must be 1 byte. Invalid arch!");
        -:   28:
        -:   29:	if (sizeof(int64) != 8) panic("must be 8 bytes. Invalid arch!");
        -:   30:
        -:   31:	if (sizeof(int) != 4) panic("int must be 4 bytes. Invalid arch!");
        -:   32:
        -:   33:	if (sizeof(float64) != 8) panic("float64 must be 8 bytes. Invalid arch!");
        -:   34:
        -:   35:	if (sizeof(bool) != 1) panic("bool must be 1 byte. Invalid arch!");
        -:   36:
        -:   37:	// little endian check
       12:   38:	int test = 0x1;
       12:   39:	if (*(byte *)&test != 0x1) {
    #####:   40:		panic("Big endian is not supported!");
        -:   41:	}
       12:   42:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
