        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/os.h>
        -:   17:
    #####:   18:byte *get_dimmed() {
    #####:   19:	if (env("NO_COLOR") != NULL) {
    #####:   20:		return "";
        -:   21:	} else {
    #####:   22:		return "\x1b[2m";
        -:   23:	}
        -:   24:}
        -:   25:
    #####:   26:byte *get_red() {
    #####:   27:	if (env("NO_COLOR") != NULL) {
    #####:   28:		return "";
        -:   29:	} else {
    #####:   30:		return "\x1b[31m";
        -:   31:	}
        -:   32:}
        -:   33:
    #####:   34:byte *get_bright_red() {
    #####:   35:	if (env("NO_COLOR") != NULL) {
    #####:   36:		return "";
        -:   37:	} else {
    #####:   38:		return "\x1b[91m";
        -:   39:	}
        -:   40:}
        -:   41:
    #####:   42:byte *get_green() {
    #####:   43:	if (env("NO_COLOR") != NULL) {
    #####:   44:		return "";
        -:   45:	} else {
    #####:   46:		return "\x1b[32m";
        -:   47:	}
        -:   48:}
        -:   49:
    #####:   50:byte *get_yellow() {
    #####:   51:	if (env("NO_COLOR") != NULL) {
    #####:   52:		return "";
        -:   53:	} else {
    #####:   54:		return "\x1b[33m";
        -:   55:	}
        -:   56:}
        -:   57:
    #####:   58:byte *get_cyan() {
    #####:   59:	if (env("NO_COLOR") != NULL) {
    #####:   60:		return "";
        -:   61:	} else {
    #####:   62:		return "\x1b[36m";
        -:   63:	}
        -:   64:}
        -:   65:
    #####:   66:byte *get_magenta() {
    #####:   67:	if (env("NO_COLOR") != NULL) {
    #####:   68:		return "";
        -:   69:	} else {
    #####:   70:		return "\x1b[35m";
        -:   71:	}
        -:   72:}
        -:   73:
    #####:   74:byte *get_blue() {
    #####:   75:	if (env("NO_COLOR") != NULL) {
    #####:   76:		return "";
        -:   77:	} else {
    #####:   78:		return "\x1b[34m";
        -:   79:	}
        -:   80:}
        -:   81:
    #####:   82:byte *get_reset() {
    #####:   83:	if (env("NO_COLOR") != NULL) {
    #####:   84:		return "";
        -:   85:	} else {
    #####:   86:		return "\x1b[0m";
        -:   87:	}
        -:   88:}
        -:    0:Source:fam_alloc.c
        -:    0:Graph:fam_alloc.gcno
        -:    0:Data:fam_alloc.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/macros.h>
        -:   18:#include <base/osdef.h>
        -:   19:#include <base/print_util.h>
        -:   20:
        -:   21:#include <stdio.h>
        -:   22:
        -:   23:SlabAllocator global_slab_allocator = NULL;
        -:   24:
       14:   25:void __attribute__((constructor)) __init_sa() {
       14:   26:	if (global_slab_allocator == NULL) {
       14:   27:		global_slab_allocator = slab_allocator_create();
       14:   28:		if (global_slab_allocator == NULL) {
    #####:   29:			panic("Could not initialize global slab allocator!");
        -:   30:		}
        -:   31:	}
       14:   32:}
        -:   33:
    #####:   34:void __attribute__((destuctor)) __init_sa_tear_down() {
    #####:   35:	if (global_slab_allocator)
    #####:   36:		slab_allocator_cleanup(&global_slab_allocator);
    #####:   37:	global_slab_allocator = NULL;
    #####:   38:}
        -:   39:
        -:   40:// use highest byte in aux for flags
   200042:   41:void ptr_flag_set(Ptr ptr, byte flag, bool value) {
   200042:   42:	int64 *aux = ptr_aux(ptr);
   200042:   43:	if (value)
    #####:   44:		*aux |= (0x1ULL << (unsigned long long)flag) << 56;
        -:   45:	else
   200042:   46:		*aux &= ~((0x1ULL << (unsigned long long)flag) << 56);
   200042:   47:}
        -:   48:
   200042:   49:bool ptr_flag_check(Ptr ptr, byte flag) {
   200042:   50:	int64 *aux = ptr_aux(ptr);
   200042:   51:	return (*aux) & ((0x1ULL << (unsigned long long)flag) << 56);
        -:   52:}
        -:   53:
   200042:   54:Ptr fam_alloc(unsigned int size) {
        -:   55:	// this size is reserved for 'null'
   200042:   56:	if (size == UINT32_MAX) {
    #####:   57:		SetErr(Overflow);
    #####:   58:		return NULL;
        -:   59:	}
        -:   60:
        -:   61:	Ptr ret;
   200042:   62:	if (size > MAX_SLAB_SIZE)
    #####:   63:		ret = ptr_direct_alloc(size);
        -:   64:	else {
   200042:   65:		ret = slab_allocator_allocate(global_slab_allocator, size);
        -:   66:	}
        -:   67:
   200042:   68:	if (ret) {
   200042:   69:		int64 *aux = ptr_aux(ret);
   200042:   70:		*aux = 0;
   200042:   71:		ptr_flag_set(ret, PTR_FLAGS_DIRECT, size > MAX_SLAB_SIZE);
        -:   72:	}
        -:   73:
   200042:   74:	return ret;
        -:   75:}
        1:   76:Ptr fam_resize(Ptr ptr, unsigned int size) {
        -:   77:	// this size is reserved for 'null'
        1:   78:	if (size == UINT32_MAX) {
    #####:   79:		SetErr(Overflow);
    #####:   80:		return NULL;
        -:   81:	}
        -:   82:
        1:   83:	if (ptr == NULL) {
    #####:   84:		SetErr(IllegalArgument);
    #####:   85:		return NULL;
        -:   86:	}
        -:   87:
        1:   88:	Ptr ret = fam_alloc(size);
        1:   89:	if (ret) {
        1:   90:		unsigned int len = $len(ptr);
        1:   91:		if (len > size)
    #####:   92:			len = size;
        1:   93:		memcpy($(ret), $(ptr), len);
        1:   94:		fam_release(&ptr);
        -:   95:	}
        -:   96:
        1:   97:	return ret;
        -:   98:}
        -:   99:
   200042:  100:void fam_release(Ptr *ptr) {
  200042*:  101:	if (nil(*ptr) || ptr_len(*ptr) == UINT32_MAX) {
    #####:  102:		panic("fam_free on nil or special ptr!");
   200042:  103:	} else if (ptr_flag_check(*ptr, PTR_FLAGS_DIRECT)) {
    #####:  104:		ptr_direct_release(*ptr);
        -:  105:	} else {
   200042:  106:		slab_allocator_free(global_slab_allocator, *ptr);
        -:  107:	}
   200042:  108:}
        -:  109:
        -:  110:#ifdef TEST
       11:  111:void fam_alloc_cleanup() {
       11:  112:	if (global_slab_allocator)
       11:  113:		slab_allocator_cleanup(&global_slab_allocator);
       11:  114:	global_slab_allocator = NULL;
       11:  115:}
       11:  116:int64 fam_alloc_count_global_allocator() {
       11:  117:	return slab_allocator_cur_slabs_allocated(global_slab_allocator);
        -:  118:}
        -:  119:#endif // TEST
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/macro_util.h>
        -:   17:#include <base/os.h>
        -:   18:// #include <base/print_util.h>
        -:   19:// #include <base/string.h>
        -:   20:
        -:   21:_Thread_local byte fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local int64 fam_err = NoErrors;
        -:   24://_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const byte *get_err() {
        -:   27:	// return strncpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
    #####:   28:	return NULL;
        -:   29:}
        -:   30:
    #####:   31:void print_err(const byte *text) {
        -:   32:	// println("{}: {}", FamErrText[fam_err], text);
        -:   33:	// backtrace_print(&thread_local_bt__);
    #####:   34:}
        -:   35:
        -:   36:// void do_backtrace_generate(Backtrace *bt) {
        -:   37:// if (env("CBACKTRACE") != NULL) {
        -:   38://  backtrace_generate(bt);
        -:   39://	}
        -:   40://}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/lock.h>
        -:   18:#include <base/osdef.h>
        -:   19:#include <base/print_util.h>
        -:   20:
        -:   21:#include <errno.h>
        -:   22:#include <pthread.h>
        -:   23:
        -:   24:#include <stdio.h>
        -:   25:
        -:   26:typedef struct LockImpl {
        -:   27:	pthread_rwlock_t rw_lock;
        -:   28:	pthread_mutex_t mutex_lock;
        -:   29:	pthread_cond_t cond;
        -:   30:	bool condition;
        -:   31:} LockImpl;
        -:   32:
        4:   33:Lock lock_create() {
        4:   34:	Ptr ret = fam_alloc(sizeof(LockImpl));
        4:   35:	errno = 0;
       4*:   36:	if (nil(ret))
    #####:   37:		return ret;
        4:   38:	LockImpl *l = $(ret);
        4:   39:	if (pthread_rwlock_init(&l->rw_lock, NULL)) {
    #####:   40:		SetErr(LockInitErr);
    #####:   41:		fam_release(&ret);
    #####:   42:		return NULL;
        -:   43:	}
        4:   44:	if (pthread_mutex_init(&l->mutex_lock, NULL)) {
    #####:   45:		SetErr(LockInitErr);
    #####:   46:		pthread_mutex_destroy(&l->mutex_lock);
    #####:   47:		fam_release(&ret);
    #####:   48:		return NULL;
        -:   49:	}
        -:   50:
        4:   51:	if (pthread_cond_init(&l->cond, NULL)) {
    #####:   52:		SetErr(LockInitErr);
    #####:   53:		pthread_mutex_destroy(&l->mutex_lock);
    #####:   54:		pthread_rwlock_destroy(&l->rw_lock);
    #####:   55:		fam_release(&ret);
    #####:   56:		return NULL;
        -:   57:	}
        4:   58:	l->condition = false;
        -:   59:
        4:   60:	return ret;
        -:   61:}
        -:   62:
    #####:   63:void lock_condtion_reset(Lock lock) {
    #####:   64:	LockImpl *l = $(lock);
    #####:   65:	l->condition = false;
    #####:   66:}
        -:   67:
       11:   68:void lock_read(Lock lock) {
       11:   69:	LockImpl *l = $(lock);
        -:   70:	int code;
       11:   71:	errno = 0;
       11:   72:	if ((code = pthread_rwlock_rdlock(&l->rw_lock)))
    #####:   73:		panic("pthread_rwlock_rdlock: returned error: %i (%i)", code, errno);
       11:   74:}
       13:   75:void lock_write(Lock lock) {
       13:   76:	LockImpl *l = $(lock);
        -:   77:	int code;
       13:   78:	errno = 0;
       13:   79:	if ((code = pthread_rwlock_wrlock(&l->rw_lock)))
    #####:   80:		panic("pthread_rwlock_wrlock: returned error: %i (%i)", code, errno);
       13:   81:}
        -:   82:
       24:   83:void lock_unlock(Lock lock) {
       24:   84:	LockImpl *l = $(lock);
        -:   85:	int code;
       24:   86:	errno = 0;
       24:   87:	if ((code = pthread_rwlock_unlock(&l->rw_lock)))
    #####:   88:		panic("pthread_rwlock_unlock: returned error: %i (%i)", code, errno);
       24:   89:}
        -:   90:
        1:   91:void lock_notify(Lock lock) {
        1:   92:	LockImpl *l = $(lock);
        -:   93:	int code;
        1:   94:	l->condition = true;
        1:   95:	errno = 0;
        1:   96:	if ((code = pthread_cond_signal(&l->cond)))
    #####:   97:		panic("pthread_cond_signal: returned error: %i (%i)", code, errno);
        1:   98:}
        -:   99:
        1:  100:void lock_wait(Lock lock) {
        -:  101:	int code;
        1:  102:	LockImpl *l = $(lock);
        1:  103:	errno = 0;
        1:  104:	if ((code = pthread_mutex_lock(&l->mutex_lock)))
    #####:  105:		panic("pthread_mutex_lock: returned error: %i (%i)", code, errno);
        2:  106:	while (!l->condition) {
        1:  107:		errno = 0;
        1:  108:		if ((code = pthread_rwlock_rdlock(&l->rw_lock)))
    #####:  109:			panic("pthread_rwlock_rdlock: returned error: %i (%i)", code, errno);
        1:  110:		if ((code = pthread_cond_wait(&l->cond, &l->mutex_lock)))
    #####:  111:			panic("pthread_cond_wait: returned error: %i (%i)", code, errno);
        1:  112:		if ((code = pthread_rwlock_unlock(&l->rw_lock)))
    #####:  113:			panic("pthread_rwlock_unlock: returned error: %i (%i)", code, errno);
        -:  114:	}
        1:  115:	l->condition = false;
        1:  116:	errno = 0;
        1:  117:	if ((code = pthread_mutex_unlock(&l->mutex_lock)))
    #####:  118:		panic("pthread_rwlock_unlock: returned error: %i (%i)", code, errno);
        1:  119:}
        -:  120:
    #####:  121:void lock_wait_timeout(Lock lock, unsigned int milliseconds) {
        -:  122:	int code;
        -:  123:	struct timespec timeout;
    #####:  124:	if ((code = clock_gettime(CLOCK_REALTIME, &timeout)))
    #####:  125:		panic("clock_gettime: returned error: %i (%i)", code, errno);
        -:  126:
        -:  127:	// Calculate timeout in seconds and nanoseconds
    #####:  128:	timeout.tv_sec += milliseconds / 1000;
    #####:  129:	timeout.tv_nsec += (milliseconds % 1000) * 1000000;
        -:  130:
        -:  131:	// Normalize the timespec structure (handle nanosecond overflow)
    #####:  132:	if (timeout.tv_nsec >= 1000000000) {
    #####:  133:		timeout.tv_sec++;
    #####:  134:		timeout.tv_nsec -= 1000000000;
        -:  135:	}
        -:  136:
    #####:  137:	LockImpl *l = $(lock);
    #####:  138:	if ((code = pthread_mutex_lock(&l->mutex_lock)))
    #####:  139:		panic("pthread_mutex_lock: returned error: %i (%i)", code, errno);
    #####:  140:	while (!l->condition) {
    #####:  141:		if ((code = pthread_rwlock_rdlock(&l->rw_lock)))
    #####:  142:			panic("pthread_rwlock_rdlock: returned error: %i (%i)", code, errno);
    #####:  143:		if ((code = pthread_cond_timedwait(&l->cond, &l->mutex_lock, &timeout)))
    #####:  144:			panic("pthread_cond_timedwait: returned error: %i (%i)", code, errno);
    #####:  145:		if ((code = pthread_rwlock_unlock(&l->rw_lock)))
    #####:  146:			panic("pthread_rwlock_unlock: returned error: %i (%i)", code, errno);
        -:  147:	}
    #####:  148:	l->condition = false;
    #####:  149:	if ((code = pthread_mutex_unlock(&l->mutex_lock)))
    #####:  150:		panic("pthread_mutex_unlock: returned error: %i (%i)", code, errno);
    #####:  151:}
        -:  152:
        -:  153:typedef struct LockGuardImpl {
        -:  154:	Lock lock;
        -:  155:} LockGuardImpl;
        -:  156:
       10:  157:LockGuard lock_guard_read(Lock l) {
       10:  158:	LockImpl *li = $(l);
       10:  159:	Ptr ret = fam_alloc(sizeof(LockGuardImpl));
       10:  160:	LockGuardImpl *lgi = $(ret);
       10:  161:	lgi->lock = l;
       10:  162:	lock_read(lgi->lock);
       10:  163:	return ret;
        -:  164:}
       11:  165:LockGuard lock_guard_write(Lock l) {
       11:  166:	LockImpl *li = $(l);
       11:  167:	Ptr ret = fam_alloc(sizeof(LockGuardImpl));
       11:  168:	LockGuardImpl *lgi = $(ret);
       11:  169:	lgi->lock = l;
       11:  170:	lock_write(lgi->lock);
       11:  171:	return ret;
        -:  172:}
        -:  173:
        -:  174:// Functions that require override of const
        -:  175:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  176:#pragma clang diagnostic ignored "-Wunknown-warning-option"
        -:  177:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  178:
        4:  179:void Lock_cleanup(const Lock *lock) {
        4:  180:	errno = 0;
        4:  181:	if (initialized(*lock)) {
        4:  182:		LockImpl *l = $(*lock);
        -:  183:		int code;
        4:  184:		if ((code = pthread_rwlock_destroy(&l->rw_lock)))
    #####:  185:			panic("pthread_rwlock_destroy: returned error: %i (%i)", code, errno);
        4:  186:		if ((code = pthread_mutex_destroy(&l->mutex_lock)))
    #####:  187:			panic("pthread_mutex_destroy: returned error: %i (%i)", code, errno);
        4:  188:		if ((code = pthread_cond_destroy(&l->cond)))
    #####:  189:			panic("pthread_cond_destroy: returned error: %i (%i)", code, errno);
        4:  190:		fam_release(lock);
        -:  191:	}
        4:  192:}
        -:  193:
       21:  194:void LockGuard_cleanup(const LockGuard *lg) {
       21:  195:	if (initialized(*lg)) {
       21:  196:		LockGuardImpl *lgi = $(*lg);
       21:  197:		lock_unlock(lgi->lock);
       21:  198:		fam_release(lg);
        -:  199:	}
       21:  200:}
        -:    0:Source:object.c
        -:    0:Graph:object.gcno
        -:    0:Data:object.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/object.h>
        -:   18:#include <base/osdef.h>
        -:   19:
        -:   20:#include <stdio.h>
        -:   21:
        -:   22:#define OBJECT_FLAG_FAM_ALLOC_RESERVED1 0
        -:   23:#define OBJECT_FLAG_SEND 1
        -:   24:#define OBJECT_FLAG_TYPE0 2
        -:   25:#define OBJECT_FLAG_TYPE1 3
        -:   26:#define OBJECT_FLAG_TYPE2 4
        -:   27:
        -:   28:#define PTR_SIZE 16
        -:   29:
        5:   30:const void *object_box_value_of(const Object obj) {
       5*:   31:	if (nil(obj)) {
    #####:   32:		SetErr(ObjectConsumed);
    #####:   33:		return NULL;
        -:   34:	}
        5:   35:	return $(obj);
        -:   36:}
        -:   37:
   200013:   38:unsigned int object_get_size(ObjectType type) {
   200013:   39:	if (type == ObjectTypeInt)
   200005:   40:		return 0;
        8:   41:	else if (type == ObjectTypeByte)
        1:   42:		return 0;
        7:   43:	else if (type == ObjectTypeBool)
        2:   44:		return 0;
        5:   45:	else if (type == ObjectTypeFloat)
        1:   46:		return 0;
        4:   47:	else if (type == ObjectTypeWeak)
        1:   48:		return sizeof(int64);
        3:   49:	else if (type == ObjectTypeBox)
        3:   50:		return sizeof(int64);
        -:   51:
    #####:   52:	return -1;
        -:   53:}
        -:   54:
   800048:   55:void object_set_ptr_flag(Ptr ptr, unsigned long long flag, bool value) {
   800048:   56:	int64 *aux = ptr_aux(ptr);
   800048:   57:	if (value)
   200014:   58:		*aux |= (0x1ULL << (unsigned long long)flag) << 56;
        -:   59:	else
   600034:   60:		*aux &= ~((0x1ULL << (unsigned long long)flag) << 56);
   800048:   61:}
        -:   62:
  2600259:   63:bool object_get_ptr_flag(Ptr ptr, unsigned long long flag) {
  2600259:   64:	int64 *aux = ptr_aux(ptr);
  2600259:   65:	return ((0x1ULL << (unsigned long long)flag) << 56) & *aux;
        -:   66:}
        -:   67:
   200012:   68:void object_set_ptr_type(Ptr ptr, ObjectType type) {
   200012:   69:	if (type == ObjectTypeWeak) {
        1:   70:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE0, true);
        1:   71:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE1, false);
        1:   72:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE2, true);
   200011:   73:	} else if (type == ObjectTypeBox) {
        2:   74:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE0, true);
        2:   75:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE1, false);
        2:   76:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE2, false);
   200009:   77:	} else if (type == ObjectTypeFloat) {
        1:   78:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE0, false);
        1:   79:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE1, true);
        1:   80:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE2, true);
   200008:   81:	} else if (type == ObjectTypeBool) {
        2:   82:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE0, false);
        2:   83:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE1, true);
        2:   84:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE2, false);
   200006:   85:	} else if (type == ObjectTypeByte) {
        1:   86:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE0, false);
        1:   87:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE1, false);
        1:   88:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE2, true);
   200005:   89:	} else if (type == ObjectTypeInt) {
   200005:   90:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE0, false);
   200005:   91:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE1, false);
   200005:   92:		object_set_ptr_flag(ptr, OBJECT_FLAG_TYPE2, false);
        -:   93:	}
   200012:   94:}
        -:   95:
   200010:   96:Object object_create_impl(ObjectType type, const void *value, bool send) {
   200010:   97:	unsigned int size = object_get_size(type);
   200010:   98:	Ptr ret = fam_alloc(size);
   200010:   99:	if (ret == NULL)
    #####:  100:		return ret;
        -:  101:
   200010:  102:	if (size)
        1:  103:		memcpy($(ret), value, size);
   200010:  104:	int64 *aux = ptr_aux(ret);
   200010:  105:	object_set_ptr_type(ret, type);
   200010:  106:	object_set_ptr_flag(ret, OBJECT_FLAG_SEND, send);
        -:  107:	// set strong count to 1
   200010:  108:	(*aux) |= 0x0000000000000001L;
        -:  109:
   200010:  110:	if (type == ObjectTypeInt || type == ObjectTypeFloat) {
        -:  111:		int v;
   200006:  112:		memcpy(&v, value, 4);
   200006:  113:		int64 count = ((unsigned long long)v << 24) & 0x00FFFFFFFFFFFFFFULL;
   200006:  114:		*aux |= count;
        4:  115:	} else if (type == ObjectTypeBool || type == ObjectTypeByte) {
        3:  116:		int v = 0;
        3:  117:		memcpy(&v, value, 1);
        3:  118:		int64 count = ((int64)v << 24);
        3:  119:		*aux |= count;
        -:  120:	}
        -:  121:
   200010:  122:	return ret;
        -:  123:}
        -:  124:
   200008:  125:Object object_create(ObjectType type, const void *value, bool send) {
   200008:  126:	if (value == NULL || type < 0 || type >= __ObjectTypeCount__ || type == ObjectTypeWeak ||
        -:  127:		type == ObjectTypeBox) {
    #####:  128:		SetErr(IllegalArgument);
    #####:  129:		return NULL;
        -:  130:	}
        -:  131:
   200008:  132:	return object_create_impl(type, value, send);
        -:  133:}
        -:  134:
        2:  135:Object object_create_box(unsigned int size, bool send) {
        2:  136:	if (size == 0) {
    #####:  137:		SetErr(IllegalArgument);
    #####:  138:		return NULL;
        -:  139:	}
        2:  140:	unsigned int box_size = object_get_size(ObjectTypeBox);
        2:  141:	Ptr ret = fam_alloc(box_size);
        2:  142:	if (ret == NULL)
    #####:  143:		return ret;
        2:  144:	Ptr ptr = fam_alloc(size);
        2:  145:	if (ptr == NULL) {
    #####:  146:		fam_release(&ret);
    #####:  147:		return NULL;
        -:  148:	}
        2:  149:	memcpy($(ret), &ptr, box_size);
        2:  150:	int64 *aux = ptr_aux(ret);
        2:  151:	object_set_ptr_type(ret, ObjectTypeBox);
        2:  152:	object_set_ptr_flag(ret, OBJECT_FLAG_SEND, send);
        -:  153:
        -:  154:	// set strong count to 1
        2:  155:	(*aux) |= 0x0000000000000001L;
        -:  156:
        2:  157:	return ret;
        -:  158:}
        -:  159:
        1:  160:int object_mutate(Object obj, const void *value) {
       1*:  161:	if (nil(obj)) {
    #####:  162:		SetErr(ObjectConsumed);
    #####:  163:		return -1;
        -:  164:	}
        1:  165:	ObjectType type = object_type(obj);
        1:  166:	if (type == ObjectTypeWeak) {
    #####:  167:		SetErr(IllegalArgument);
    #####:  168:		return -1;
        -:  169:	}
        -:  170:
        1:  171:	unsigned int size = object_get_size(type);
        1:  172:	if (size)
        1:  173:		memcpy($(obj), value, size);
        1:  174:	return 0;
        -:  175:}
        -:  176:
        1:  177:int object_resize(Object obj, unsigned int size) {
       1*:  178:	if (nil(obj)) {
    #####:  179:		SetErr(ObjectConsumed);
    #####:  180:		return -1;
        -:  181:	}
        1:  182:	ObjectType type = object_type(obj);
        1:  183:	if (type != ObjectTypeBox) {
    #####:  184:		SetErr(UnsupportedOperation);
    #####:  185:		return -1;
        -:  186:	}
        -:  187:
        1:  188:	Ptr ptr = NULL;
        1:  189:	object_value_of(obj, &ptr, 8);
       1*:  190:	if (nil(ptr)) {
    #####:  191:		SetErr(IllegalState);
    #####:  192:		return -1;
        -:  193:	}
        -:  194:
        1:  195:	Ptr updated = fam_resize(ptr, size);
       1*:  196:	if (nil(updated)) {
    #####:  197:		SetErr(AllocErr);
    #####:  198:		return -1;
        -:  199:	}
        1:  200:	return object_mutate(obj, &updated);
        -:  201:}
        -:  202:
   200018:  203:int object_value_of(const Object obj, void *buffer, unsigned int limit) {
   200018:  204:	if (nil(obj)) {
        1:  205:		SetErr(ObjectConsumed);
        1:  206:		return -1;
        -:  207:	}
   200017:  208:	if (buffer == NULL) {
    #####:  209:		SetErr(IllegalArgument);
    #####:  210:		return -1;
        -:  211:	}
   200017:  212:	int max = limit;
   200017:  213:	ObjectType type = object_type(obj);
   200017:  214:	if (type == ObjectTypeInt || type == ObjectTypeFloat) {
        -:  215:
   200008:  216:		if (limit > 4)
    #####:  217:			max = 4;
        9:  218:	} else if (type == ObjectTypeByte || type == ObjectTypeBool) {
        3:  219:		if (limit > 1)
    #####:  220:			max = 1;
        6:  221:	} else if (type == ObjectTypeBox) {
        6:  222:		if (limit > 8)
    #####:  223:			max = 8;
        -:  224:	}
        -:  225:
   200017:  226:	int ret = 0;
   200017:  227:	if (type == ObjectTypeInt || type == ObjectTypeFloat || type == ObjectTypeByte ||
   200011:  228:		type == ObjectTypeBool) {
   200011:  229:		int64 *aux = ptr_aux(obj);
   200011:  230:		ret = max;
   200011:  231:		int count = ((*aux) & 0xFFFFFFFF000000LL) >> 24;
   200011:  232:		memcpy((byte *)buffer, &count, ret);
        6:  233:	} else if (type == ObjectTypeBox) {
        6:  234:		ret = max;
        6:  235:		memcpy((byte *)buffer, $(obj), ret);
        -:  236:	}
   200017:  237:	return ret;
        -:  238:}
        -:  239:
   800079:  240:ObjectType object_type(const Object obj) {
   800079:  241:	if (nil(obj)) {
        1:  242:		SetErr(ObjectConsumed);
        1:  243:		return -1;
        -:  244:	}
   800078:  245:	if (object_get_ptr_flag(obj, OBJECT_FLAG_TYPE0)) {
       27:  246:		if (object_get_ptr_flag(obj, OBJECT_FLAG_TYPE1)) {
        -:  247:		} else {
       27:  248:			if (object_get_ptr_flag(obj, OBJECT_FLAG_TYPE2))
        3:  249:				return ObjectTypeWeak;
        -:  250:			else
       24:  251:				return ObjectTypeBox;
        -:  252:		}
        -:  253:	} else {
   800051:  254:		if (object_get_ptr_flag(obj, OBJECT_FLAG_TYPE1)) {
       18:  255:			if (object_get_ptr_flag(obj, OBJECT_FLAG_TYPE2))
       10:  256:				return ObjectTypeFloat;
        -:  257:			else
        8:  258:				return ObjectTypeBool;
        -:  259:		} else {
   800033:  260:			if (object_get_ptr_flag(obj, OBJECT_FLAG_TYPE2))
        4:  261:				return ObjectTypeByte;
        -:  262:			else
   800029:  263:				return ObjectTypeInt;
        -:  264:		}
        -:  265:	}
    #####:  266:	return ObjectTypeBool;
        -:  267:}
        -:  268:
    #####:  269:int object_set_property(Object obj, const char *key, const Object value) {
    #####:  270:	return 0;
        -:  271:}
    #####:  272:Object object_delete_property(Object obj, const char *key) {
    #####:  273:	return NULL;
        -:  274:}
    #####:  275:Object object_get_property(const Object obj, const char *key) {
    #####:  276:	return NULL;
        -:  277:}
        -:  278:
   200015:  279:int object_decrement_strong(Object obj) {
   200015:  280:	bool send = object_get_ptr_flag(obj, OBJECT_FLAG_SEND);
   200015:  281:	ObjectType type = object_type(obj);
   200015:  282:	if (send) {
   200006:  283:		int64 *aux = ptr_aux(obj);
   200006:  284:		int64 aux_val = __sync_fetch_and_sub(aux, 1);
   200006:  285:		if ((aux_val & 0xFFFFFF) > 1) {
        -:  286:			// return strong count
        1:  287:			return aux_val - 1;
        -:  288:		} else {
        -:  289:			// return weak count
   200005:  290:			if (type == ObjectTypeInt || type == ObjectTypeFloat || type == ObjectTypeByte ||
        -:  291:				type == ObjectTypeBool)
   200004:  292:				return 0;
        -:  293:			else
        1:  294:				return (aux_val & 0xFFFFFF000000LL) >> 24;
        -:  295:		}
        -:  296:	} else {
        9:  297:		int64 *aux = ptr_aux(obj);
        9:  298:		int64 count = *aux & 0xFFFFFF;
        9:  299:		int64 flags = *aux & 0xFFFFFFFFFF000000LL;
        9:  300:		count--;
        9:  301:		*aux = count | flags;
        9:  302:		if (count) {
        -:  303:			// return strong count
        3:  304:			return count;
        -:  305:		} else {
        -:  306:			// return the weak count
        6:  307:			if (type == ObjectTypeInt || type == ObjectTypeFloat || type == ObjectTypeByte ||
        -:  308:				type == ObjectTypeBool)
        5:  309:				return 0;
        -:  310:			else
        1:  311:				return (*aux & 0xFFFFFF000000LL) >> 24;
        -:  312:		}
        -:  313:	}
        -:  314:}
        -:  315:
        3:  316:int object_increment_strong(Object obj) {
        3:  317:	bool send = object_get_ptr_flag(obj, OBJECT_FLAG_SEND);
        3:  318:	if (send) {
        1:  319:		int64 *aux = ptr_aux(obj);
        -:  320:		int64 old_count;
        -:  321:		int64 new_count;
        -:  322:		do {
        1:  323:			old_count = __sync_fetch_and_add(aux, 0); // Atomically load the current count
        1:  324:			new_count = old_count + 1;
        1:  325:			if ((new_count & 0xFFFFFF) == 0xFFFFFF) { // Check for overflow
    #####:  326:				SetErr(Overflow);
    #####:  327:				return -1;
        -:  328:			}
        1:  329:		} while (!__sync_val_compare_and_swap(aux, old_count, new_count));
        -:  330:		// Try to atomically increment the count if it hasn't changed
        -:  331:
        -:  332:	} else {
        2:  333:		int64 *aux = ptr_aux(obj);
        2:  334:		if ((*aux & 0xFFFFFF) == 0xFFFFFF) {
    #####:  335:			SetErr(Overflow);
    #####:  336:			return -1;
        -:  337:		}
        -:  338:
        2:  339:		(*aux)++;
        -:  340:	}
        -:  341:
        3:  342:	return 0;
        -:  343:}
        -:  344:
        1:  345:int object_decrement_weak(Object obj) {
        1:  346:	bool send = object_get_ptr_flag(obj, OBJECT_FLAG_SEND);
        -:  347:
        1:  348:	if (send) {
    #####:  349:		int64 *aux = ptr_aux(obj);
    #####:  350:		int64 aux_val = __sync_fetch_and_sub(aux, 0x1 << 24);
    #####:  351:		int64 weak_count = (aux_val & 0xFFFFFF000000LL) >> 24;
    #####:  352:		if (weak_count > 1) {
        -:  353:			// return weak count
    #####:  354:			return weak_count - 1;
        -:  355:		} else {
        -:  356:			// return strong count
    #####:  357:			return aux_val & 0xFFFFFF;
        -:  358:		}
        -:  359:	} else {
        1:  360:		int64 *aux = ptr_aux(obj);
        1:  361:		int64 count = *aux & 0xFFFFFF000000LL;
        1:  362:		int64 flags = *aux & 0xFFFF000000FFFFFFLL;
        1:  363:		count -= (0x1 << 24);
        1:  364:		*aux = count | flags;
        -:  365:
        1:  366:		if (count) {
        -:  367:			// return weak count
    #####:  368:			return count;
        -:  369:		} else {
        -:  370:			// return the strong count
        1:  371:			return ((*aux) & 0xFFFFFF);
        -:  372:		}
        -:  373:	}
        -:  374:}
        -:  375:
        1:  376:int object_increment_weak(Object obj) {
        1:  377:	bool send = object_get_ptr_flag(obj, OBJECT_FLAG_SEND);
        1:  378:	if (send) {
    #####:  379:		int64 *aux = ptr_aux(obj);
        -:  380:		int64 old_count;
        -:  381:		int64 new_count;
        -:  382:		do {
    #####:  383:			old_count = __sync_fetch_and_add(aux, 0); // Atomically load the current count
    #####:  384:			new_count = old_count + (0x1 << 24);
    #####:  385:			if ((new_count & 0xFFFFFF000000LL) == 0xFFFFFF000000LL) { // Check for overflow
    #####:  386:				SetErr(Overflow);
    #####:  387:				return -1;
        -:  388:			}
    #####:  389:		} while (!__sync_val_compare_and_swap(aux, old_count, new_count));
        -:  390:		// Try to atomically increment the count if it hasn't changed
        -:  391:
        -:  392:	} else {
        1:  393:		int64 *aux = ptr_aux(obj);
        1:  394:		if ((*aux & 0xFFFFFF000000LL) == 0xFFFFFF000000LL) {
    #####:  395:			SetErr(Overflow);
    #####:  396:			return -1;
        -:  397:		}
        1:  398:		(*aux) += (0x1 << 24);
        -:  399:	}
        -:  400:
        1:  401:	return 0;
        -:  402:}
        -:  403:
        4:  404:Object object_ref_impl(Object src, bool incr) {
       4*:  405:	if (nil(src)) {
    #####:  406:		SetErr(ObjectConsumed);
    #####:  407:		return NULL;
        -:  408:	}
        4:  409:	if (object_type(src) == ObjectTypeWeak) {
    #####:  410:		SetErr(IllegalArgument);
    #####:  411:		return NULL;
        -:  412:	}
        -:  413:
        4:  414:	if (incr) {
        3:  415:		if (object_increment_strong(src))
    #####:  416:			return NULL;
        -:  417:	}
        -:  418:
        4:  419:	ObjectNc ret = src;
        4:  420:	return ret;
        -:  421:}
        -:  422:
        -:  423:// Functions that require override of const
        -:  424:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  425:#pragma clang diagnostic ignored "-Wunknown-warning-option"
        -:  426:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  427:
        2:  428:Object object_move(const Object src) {
       2*:  429:	if (nil(src)) {
    #####:  430:		SetErr(ObjectConsumed);
    #####:  431:		return NULL;
        -:  432:	}
        2:  433:	ObjectType type = object_type(src);
        2:  434:	if (type == ObjectTypeWeak) {
    #####:  435:		SetErr(IllegalArgument);
    #####:  436:		return NULL;
        -:  437:	}
        -:  438:
        2:  439:	bool send = object_get_ptr_flag(src, OBJECT_FLAG_SEND);
        -:  440:	ObjectNc ret;
        2:  441:	if (type == ObjectTypeInt || type == ObjectTypeFloat || type == ObjectTypeByte ||
        1:  442:		type == ObjectTypeBool) {
        1:  443:		int64 *aux = ptr_aux(src);
        1:  444:		int value = ((*aux) & 0xFFFFFFFF000000LL) >> 24;
        1:  445:		ret = object_create_impl(type, &value, send);
        -:  446:
        -:  447:	} else {
        1:  448:		ret = object_ref(src);
        -:  449:		// ret = object_create_impl(type, $(src), send);
        -:  450:	}
        2:  451:	Object_cleanup(&src);
        2:  452:	return ret;
        -:  453:}
        3:  454:Object object_ref(const Object src) {
        3:  455:	ObjectType type = object_type(src);
        3:  456:	if (type == ObjectTypeWeak) {
    #####:  457:		SetErr(IllegalArgument);
    #####:  458:		return NULL;
        -:  459:	}
        3:  460:	return object_ref_impl(src, true);
        -:  461:}
        -:  462:
        3:  463:Object object_weak(const Object src) {
       3*:  464:	if (nil(src)) {
    #####:  465:		SetErr(ObjectConsumed);
    #####:  466:		return NULL;
        -:  467:	}
        3:  468:	ObjectType type = object_type(src);
        3:  469:	if (type == ObjectTypeInt || type == ObjectTypeFloat || type == ObjectTypeByte ||
        1:  470:		type == ObjectTypeBool || type == ObjectTypeWeak) {
        2:  471:		SetErr(IllegalArgument);
        2:  472:		return NULL;
        -:  473:	}
        1:  474:	unsigned long long v = (unsigned long long)src;
        1:  475:	bool send = object_get_ptr_flag(src, OBJECT_FLAG_SEND);
        1:  476:	ObjectNc weak = object_create_impl(ObjectTypeWeak, &v, send);
        1:  477:	if (object_increment_weak(src))
    #####:  478:		return NULL;
        -:  479:
        1:  480:	return weak;
        -:  481:}
        -:  482:
        2:  483:Object object_upgrade(const Object src) {
       2*:  484:	if (nil(src)) {
    #####:  485:		SetErr(ObjectConsumed);
    #####:  486:		return NULL;
        -:  487:	}
        2:  488:	if (object_type(src) != ObjectTypeWeak) {
    #####:  489:		SetErr(IllegalArgument);
    #####:  490:		return NULL;
        -:  491:	}
        -:  492:
        2:  493:	unsigned long long *target = object_box_value_of(src);
        2:  494:	ObjectNc w = (ObjectNc)*target;
        2:  495:	bool send = object_get_ptr_flag(src, OBJECT_FLAG_SEND);
        2:  496:	if (send) {
    #####:  497:		int64 *aux = ptr_aux(w);
        -:  498:		int64 old_count;
        -:  499:		do {
    #####:  500:			old_count = __sync_fetch_and_add(aux, 0);
    #####:  501:			if ((old_count & 0xFFFFFF) == 0) {
    #####:  502:				return NULL; // Object is already deallocated
        -:  503:			}
    #####:  504:		} while (!__sync_val_compare_and_swap(aux, old_count, old_count + 1));
        -:  505:
        -:  506:	} else {
        2:  507:		int64 *aux = ptr_aux(w);
        2:  508:		int64 strong_count = *aux & 0xFFFFFF;
        -:  509:
        2:  510:		if (!strong_count) {
        1:  511:			return NULL;
        -:  512:		}
        1:  513:		(*aux)++;
        -:  514:	}
        -:  515:
        1:  516:	return object_ref_impl(w, false);
        -:  517:}
        -:  518:
   200020:  519:void Object_cleanup(const Object *obj) {
   200020:  520:	if (initialized(*obj)) {
   200016:  521:		if (object_type(*obj) == ObjectTypeWeak) {
        1:  522:			unsigned long long *target = object_box_value_of(*obj);
        1:  523:			ObjectNc w = (ObjectNc)*target;
        -:  524:
        1:  525:			int odwval = object_decrement_weak(w);
        1:  526:			if (!odwval) {
        -:  527:				// deallocate the pointer
        1:  528:				if (object_type(w) == ObjectTypeBox) {
        1:  529:					Ptr inner = *(Ptr *)object_box_value_of(w);
        1:  530:					fam_release(&inner);
        -:  531:				}
        1:  532:				fam_release(&w);
        -:  533:			}
        1:  534:			fam_release(obj);
        -:  535:		} else {
   200015:  536:			int odsval = object_decrement_strong(*obj);
   200015:  537:			if (!odsval) {
        -:  538:				// deallocate the pointer
   200010:  539:				if (object_type(*obj) == ObjectTypeBox) {
        1:  540:					Ptr inner = *(Ptr *)object_box_value_of(*obj);
        1:  541:					fam_release(&inner);
        -:  542:				}
   200010:  543:				fam_release(obj);
        -:  544:			}
        -:  545:		}
        -:  546:	}
   200020:  547:}
        -:    0:Source:os.c
        -:    0:Graph:os.gcno
        -:    0:Data:os.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/osdef.h>
        -:   18:
        -:   19:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   20:
      108:   21:void *alloc(int64 size, int64 zeroed) {
      108:   22:	if (!size) {
    #####:   23:		SetErr(IllegalArgument);
    #####:   24:		return NULL;
        -:   25:	}
        -:   26:	void *ret;
      108:   27:	ret = malloc(size);
        -:   28:
      108:   29:	if (ret) {
      108:   30:		THREAD_LOCAL_RESOURCE_STATS.alloc_sum += 1;
      108:   31:		if (zeroed)
    #####:   32:			memset(ret, 0, size);
        -:   33:	} else {
    #####:   34:		SetErr(AllocErr);
        -:   35:	}
        -:   36:
      108:   37:	return ret;
        -:   38:}
       64:   39:void *resize(void *ptr, int64 size) {
       64:   40:	if (!ptr || !size) {
    #####:   41:		SetErr(IllegalArgument);
    #####:   42:		return NULL;
        -:   43:	}
        -:   44:	void *ret;
       64:   45:	ret = realloc(ptr, size);
        -:   46:
       64:   47:	if (ret) {
       64:   48:		THREAD_LOCAL_RESOURCE_STATS.resize_sum += 1;
        -:   49:	} else {
    #####:   50:		SetErr(AllocErr);
        -:   51:	}
       64:   52:	return ret;
        -:   53:}
        -:   54:
      105:   55:void release(void *ptr) {
      105:   56:	if (!ptr) {
    #####:   57:		SetErr(IllegalArgument);
    #####:   58:		return;
        -:   59:	}
      105:   60:	THREAD_LOCAL_RESOURCE_STATS.release_sum += 1;
      105:   61:	free(ptr);
        -:   62:}
        -:   63:
       22:   64:int64 alloc_sum() {
       22:   65:	return THREAD_LOCAL_RESOURCE_STATS.alloc_sum;
        -:   66:}
    #####:   67:int64 resize_sum() {
    #####:   68:	return THREAD_LOCAL_RESOURCE_STATS.resize_sum;
        -:   69:}
       22:   70:int64 release_sum() {
       22:   71:	return THREAD_LOCAL_RESOURCE_STATS.release_sum;
        -:   72:}
        -:   73:
        -:   74:char *getenv(const char *name);
        -:   75:
    #####:   76:byte *env(const byte *name) {
    #####:   77:	return getenv(name);
        -:   78:}
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <stdarg.h>
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
    #####:   18:void __attribute__((no_return)) panic(const char *fmt, ...) {
        -:   19:	char buf[1024];
        -:   20:	va_list args;
    #####:   21:	fprintf(stderr, "Panic: ");
    #####:   22:	va_start(args, fmt);
    #####:   23:	vfprintf(stderr, fmt, args);
    #####:   24:	vsnprintf(buf, 1024, fmt, args);
    #####:   25:	va_end(args);
    #####:   26:	fprintf(stderr, "\n");
        -:   27:
    #####:   28:	exit(-1);
        -:   29:}
        -:   30:
        -:   31:/*
        -:   32:#include <base/fam_err.h>
        -:   33:#include <base/macro_util.h>
        -:   34:#include <base/os.h>
        -:   35:#include <base/print_util.h>
        -:   36:#include <base/string.h>
        -:   37:
        -:   38:#define BUF_LEN 64
        -:   39:
        -:   40:// get the va functionality (with GCC/Clang use the builtin version, otherwise use stdarg)
        -:   41:#if defined(__GNUC__) || defined(__clang__)
        -:   42:typedef __builtin_va_list va_list;
        -:   43:#define va_start(ap, param) __builtin_va_start(ap, param)
        -:   44:#define va_end(ap) __builtin_va_end(ap)
        -:   45:#define va_arg(ap, type) __builtin_va_arg(ap, type)
        -:   46:#else // __GNUC__ or __clang__
        -:   47:#include <stdarg.h>
        -:   48:#endif // __GNUC__ or __clang__
        -:   49:
        -:   50:i32 write_loop(const Stream *strm, u8 *s, i32 *cur, i32 limit, const u8 *buf, u64 len) {
        -:   51:	if (s) {
        -:   52:		if (strm->handle == -1) {
        -:   53:			// length only
        -:   54:			*cur += len;
        -:   55:		} else if (*cur < limit) {
        -:   56:			u8 *res;
        -:   57:			if (*cur == 0) {
        -:   58:				res = strncpy(s, buf, len);
        -:   59:				if (res == NULL)
        -:   60:					return -1;
        -:   61:			} else {
        -:   62:				res = strncat(s, buf, len);
        -:   63:				if (res == NULL)
        -:   64:					return -1;
        -:   65:			}
        -:   66:
        -:   67:			i32 l = strlen(buf);
        -:   68:			*cur = l;
        -:   69:		}
        -:   70:	} else {
        -:   71:		while (len > 0) {
        -:   72:			i64 w = strm_write(strm, buf, len);
        -:   73:			if (w < 0) {
        -:   74:				SetErr(IO);
        -:   75:				return w;
        -:   76:			}
        -:   77:
        -:   78:			len -= w;
        -:   79:		}
        -:   80:	}
        -:   81:	return 0;
        -:   82:}
        -:   83:
        -:   84:i32 print_impl(const Stream *strm, u8 *s, i32 capacity, bool nl, bool do_exit, i32 code,
        -:   85:			   const u8 *prefix, const u8 *fmt, ...) {
        -:   86:	int ret = 0;
        -:   87:	if (capacity < 0 && s) {
        -:   88:		SetErr(IllegalArgument);
        -:   89:		ret = -1;
        -:   90:	}
        -:   91:	if (s) {
        -:   92:		memset(s, '\0', capacity);
        -:   93:	}
        -:   94:	va_list args;
        -:   95:	va_start(args, fmt);
        -:   96:	i32 max = capacity;
        -:   97:	capacity = 0;
        -:   98:
        -:   99:	if (prefix && ret != -1) {
        -:  100:		if (write_loop(strm, s, &capacity, max, prefix, strlen(prefix)))
        -:  101:			ret = -1;
        -:  102:	}
        -:  103:
        -:  104:	while (ret != -1) {
        -:  105:		bool is_hex = false;
        -:  106:		const u8 *next = strstr(fmt, "{}");
        -:  107:		const u8 *next_hex = strstr(fmt, "{hex}");
        -:  108:		if ((next_hex && !next) || (next_hex && next_hex < next)) {
        -:  109:			next = next_hex;
        -:  110:			is_hex = true;
        -:  111:		}
        -:  112:
        -:  113:		if (next == NULL) {
        -:  114:			if (write_loop(strm, s, &capacity, max, fmt, strlen(fmt))) {
        -:  115:				ret = -1;
        -:  116:				break;
        -:  117:			}
        -:  118:			if (nl)
        -:  119:				if (write_loop(strm, s, &capacity, max, "\n", 1)) {
        -:  120:					ret = -1;
        -:  121:					break;
        -:  122:				}
        -:  123:			break;
        -:  124:		} else {
        -:  125:			u64 diff = next - fmt;
        -:  126:			u8 buf[1 + diff];
        -:  127:			memset(buf, '\0', 1 + diff);
        -:  128:			strncpy(buf, fmt, diff);
        -:  129:			if (write_loop(strm, s, &capacity, max, buf, diff)) {
        -:  130:				ret = -1;
        -:  131:				break;
        -:  132:			}
        -:  133:		}
        -:  134:
        -:  135:		PrintPair arg = va_arg(args, PrintPair);
        -:  136:
        -:  137:		if (arg.type == PrintTypeTerm) {
        -:  138:			if (next) {
        -:  139:				if (write_loop(strm, s, &capacity, max, next, strlen(next))) {
        -:  140:					ret = -1;
        -:  141:					break;
        -:  142:				}
        -:  143:				if (nl)
        -:  144:					if (write_loop(strm, s, &capacity, max, "\n", 1)) {
        -:  145:						ret = -1;
        -:  146:						break;
        -:  147:					}
        -:  148:			}
        -:  149:			break;
        -:  150:		} else if (arg.type == PrintTypeBool) {
        -:  151:			bool value;
        -:  152:			memcpy(&value, arg.buf, sizeof(bool));
        -:  153:			u8 buf[BUF_LEN];
        -:  154:			if (value)
        -:  155:				strncpy(buf, "true", 5);
        -:  156:			else
        -:  157:				strncpy(buf, "false", 6);
        -:  158:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  159:				ret = -1;
        -:  160:				break;
        -:  161:			}
        -:  162:		} else if (arg.type == PrintTypeF64) {
        -:  163:			f64 value;
        -:  164:			memcpy(&value, arg.buf, sizeof(f64));
        -:  165:			u8 buf[BUF_LEN];
        -:  166:			strcpy(buf, "");
        -:  167:			snprintf(buf, BUF_LEN - 1, "%lf", value);
        -:  168:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  169:				ret = -1;
        -:  170:				break;
        -:  171:			}
        -:  172:		} else if (arg.type == PrintTypeF32) {
        -:  173:			f32 value;
        -:  174:			memcpy(&value, arg.buf, sizeof(f32));
        -:  175:			u8 buf[BUF_LEN];
        -:  176:			strcpy(buf, "");
        -:  177:			snprintf(buf, BUF_LEN - 1, "%f", value);
        -:  178:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  179:				ret = -1;
        -:  180:				break;
        -:  181:			}
        -:  182:		} else if (arg.type == PrintTypeI64) {
        -:  183:			i64 value;
        -:  184:			memcpy(&value, arg.buf, sizeof(i64));
        -:  185:			u8 buf[BUF_LEN];
        -:  186:			strcpy(buf, "");
        -:  187:			if (is_hex)
        -:  188:				snprintf(buf, BUF_LEN - 1, "%llX", value);
        -:  189:			else
        -:  190:				snprintf(buf, BUF_LEN - 1, "%lli", value);
        -:  191:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  192:				ret = -1;
        -:  193:				break;
        -:  194:			}
        -:  195:		} else if (arg.type == PrintTypeU64) {
        -:  196:			u64 value;
        -:  197:			memcpy(&value, arg.buf, sizeof(u64));
        -:  198:			u8 buf[BUF_LEN];
        -:  199:			strcpy(buf, "");
        -:  200:			if (is_hex)
        -:  201:				snprintf(buf, BUF_LEN - 1, "%llx", value);
        -:  202:			else
        -:  203:				snprintf(buf, BUF_LEN - 1, "%llu", value);
        -:  204:
        -:  205:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  206:				ret = -1;
        -:  207:				break;
        -:  208:			}
        -:  209:		} else if (arg.type == PrintTypeI32) {
        -:  210:			i32 value;
        -:  211:			memcpy(&value, arg.buf, sizeof(i32));
        -:  212:			u8 buf[BUF_LEN];
        -:  213:			strcpy(buf, "");
        -:  214:			snprintf(buf, BUF_LEN - 1, "%i", value);
        -:  215:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  216:				ret = -1;
        -:  217:				break;
        -:  218:			}
        -:  219:		} else if (arg.type == PrintTypeU32) {
        -:  220:			u32 value;
        -:  221:			memcpy(&value, arg.buf, sizeof(u32));
        -:  222:			u8 buf[BUF_LEN];
        -:  223:			strcpy(buf, "");
        -:  224:			snprintf(buf, BUF_LEN - 1, "%u", value);
        -:  225:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  226:				ret = -1;
        -:  227:				break;
        -:  228:			}
        -:  229:		} else if (arg.type == PrintTypeI16) {
        -:  230:			i16 value;
        -:  231:			memcpy(&value, arg.buf, sizeof(i16));
        -:  232:			u8 buf[BUF_LEN];
        -:  233:			strcpy(buf, "");
        -:  234:			snprintf(buf, BUF_LEN - 1, "%i", value);
        -:  235:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  236:				ret = -1;
        -:  237:				break;
        -:  238:			}
        -:  239:		} else if (arg.type == PrintTypeU16) {
        -:  240:			u16 value;
        -:  241:			memcpy(&value, arg.buf, sizeof(u16));
        -:  242:			u8 buf[BUF_LEN];
        -:  243:			strcpy(buf, "");
        -:  244:			snprintf(buf, BUF_LEN - 1, "%u", value);
        -:  245:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  246:				ret = -1;
        -:  247:				break;
        -:  248:			}
        -:  249:		} else if (arg.type == PrintTypeI8) {
        -:  250:			i8 value;
        -:  251:			memcpy(&value, arg.buf, sizeof(i8));
        -:  252:			u8 buf[BUF_LEN];
        -:  253:			strcpy(buf, "");
        -:  254:			snprintf(buf, BUF_LEN - 1, "%i", value);
        -:  255:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  256:				ret = -1;
        -:  257:				break;
        -:  258:			}
        -:  259:		} else if (arg.type == PrintTypeU8) {
        -:  260:			u8 value;
        -:  261:			memcpy(&value, arg.buf, sizeof(u8));
        -:  262:			u8 buf[BUF_LEN];
        -:  263:			strcpy(buf, "");
        -:  264:			snprintf(buf, BUF_LEN - 1, "%u", value);
        -:  265:			if (write_loop(strm, s, &capacity, max, buf, strlen(buf))) {
        -:  266:				ret = -1;
        -:  267:				break;
        -:  268:			}
        -:  269:		} else if (arg.type == PrintTypeString) {
        -:  270:			if (write_loop(strm, s, &capacity, max, arg.data, strlen(arg.data))) {
        -:  271:				ret = -1;
        -:  272:				break;
        -:  273:			}
        -:  274:		}
        -:  275:		if (is_hex)
        -:  276:			fmt = next + 5;
        -:  277:		else
        -:  278:			fmt = next + 2;
        -:  279:	}
        -:  280:
        -:  281:	va_end(args);
        -:  282:
        -:  283:	if (do_exit) {
        -:  284:		Backtrace bt;
        -:  285:		backtrace_generate(&bt);
        -:  286:		backtrace_print(&bt);
        -:  287:
        -:  288:		exit(code);
        -:  289:	}
        -:  290:
        -:  291:	if (ret == -1)
        -:  292:		return ret;
        -:  293:	return capacity;
        -:  294:}
        -:  295:*/
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/print_util.h>
        -:   18:#include <base/slabs.h>
        -:   19:
        -:   20:#include <errno.h>
        -:   21:#include <pthread.h>
        -:   22:
        -:   23:#define MAX_SLAB_TYPES 256
        -:   24:#define SLAB_SIZES 257
        -:   25:#define SLABS_PER_RESIZE 128
        -:   26:#define INITIAL_CHUNKS 0
        -:   27:
        -:   28:typedef struct Type {
        -:   29:	// slab id used internally by sa
        -:   30:	unsigned int id;
        -:   31:	// len of slab
        -:   32:	unsigned int len;
        -:   33:	int64 aux; // aux data can be used by caller as desired
        -:   34:	// user data
        -:   35:	byte data[];
        -:   36:} Type;
        -:   37:
        -:   38:const Type null_impl = {.id = 0, .len = UINT32_MAX};
        -:   39:const struct Type *null = &null_impl;
        -:   40:const struct Type not_null_impl = {.id = 1, .len = UINT32_MAX};
        -:   41:const struct Type *Ok = &not_null_impl;
        -:   42:
        -:   43:#define SLAB_OVERHEAD sizeof(Type)
        -:   44:
  1822326:   45:unsigned int ptr_len(const Ptr ptr) {
  1822326:   46:	return ptr->len;
        -:   47:}
        -:   48:
     9225:   49:unsigned int ptr_id(const Ptr ptr) {
     9225:   50:	return ptr->id;
        -:   51:}
        -:   52:
        -:   53:// reutrn pointer to slab data
     9802:   54:void *ptr_data(const Ptr ptr) {
     9802:   55:	return ptr->data;
        -:   56:}
        -:   57:
  4600479:   58:void *ptr_aux(const Ptr ptr) {
  4600479:   59:	return &ptr->aux;
        -:   60:}
        -:   61:
        -:   62:// Direct alloc
    #####:   63:Ptr ptr_direct_alloc(unsigned int size) {
        -:   64:	if (size < 0) {
        -:   65:		SetErr(IllegalArgument);
        -:   66:		return NULL;
        -:   67:	}
    #####:   68:	Ptr ret = alloc(size, false);
    #####:   69:	ret->len = size;
    #####:   70:	return ret;
        -:   71:}
    #####:   72:void ptr_direct_release(Ptr ptr) {
    #####:   73:	release(ptr);
    #####:   74:	*ptr = null_impl;
    #####:   75:}
        -:   76:
        -:   77:// Slab Type definition
        -:   78:typedef struct SlabType {
        -:   79:	unsigned int slab_size;
        -:   80:	unsigned int slabs_per_resize;
        -:   81:	unsigned int initial_chunks;
        -:   82:	unsigned int max_slabs;
        -:   83:} SlabType;
        -:   84:
        -:   85:typedef struct SlabData {
        -:   86:	SlabType type;
        -:   87:	byte **data;
        -:   88:	unsigned int *free_list;
        -:   89:	unsigned int cur_chunks;
        -:   90:	unsigned int cur_slabs;
        -:   91:	unsigned int free_list_head;
        -:   92:} SlabData;
        -:   93:
        -:   94:typedef struct SlabAllocatorImpl {
        -:   95:	int64 sd_count;
        -:   96:	pthread_rwlock_t lock;
        -:   97:	SlabData sd_arr[];
        -:   98:} SlabAllocatorImpl;
        -:   99:
       15:  100:void slab_allocator_cleanup(SlabAllocator *ptr) {
       15:  101:	SlabAllocatorNc sa = *ptr;
       15:  102:	if (sa) {
       15:  103:		if (sa->sd_count) {
     3870:  104:			for (int i = 0; i < sa->sd_count; i++) {
     3855:  105:				SlabData *sd = &sa->sd_arr[i];
     3855:  106:				if (sd->cur_chunks) {
       19:  107:					release(sd->free_list);
       70:  108:					for (int64 j = 0; j < sd->cur_chunks; j++)
       51:  109:						release(sd->data[j]);
       19:  110:					release(sd->data);
       19:  111:					sd->cur_chunks = 0;
        -:  112:				}
        -:  113:			}
        -:  114:		}
        -:  115:
        -:  116:		int code;
       15:  117:		if ((code = pthread_rwlock_destroy(&sa->lock)))
    #####:  118:			panic("pthread_rwlock_destroy: %i (%i)", code, errno);
       15:  119:		release(sa);
        -:  120:
       15:  121:		*ptr = NULL;
        -:  122:	}
       15:  123:}
        -:  124:
   204658:  125:int64 slab_allocator_slab_data_index(SlabData *sd, int64 id) {
   204658:  126:	return id / sd->type.slabs_per_resize;
        -:  127:}
        -:  128:
   204658:  129:int64 slab_allocator_slab_data_offset(SlabData *sd, int64 id) {
   204658:  130:	return (id % sd->type.slabs_per_resize) * (SLAB_OVERHEAD + sd->type.slab_size);
        -:  131:}
        -:  132:
       51:  133:void slab_allocator_init_free_list(SlabData *sd, int64 chunks) {
       51:  134:	sd->free_list_head = sd->cur_chunks * sd->type.slabs_per_resize;
       51:  135:	int64 count = chunks * (int64)sd->type.slabs_per_resize;
     6579:  136:	for (int64 i = 0; i < count; i++) {
     6528:  137:		if (i == count - 1) {
       51:  138:			sd->free_list[i + sd->free_list_head] = UINT32_MAX;
        -:  139:		} else {
     6477:  140:			sd->free_list[i + sd->free_list_head] = 1 + i + sd->free_list_head;
        -:  141:		}
        -:  142:	}
       51:  143:}
        -:  144:
       51:  145:int slab_allocator_increase_chunks(SlabData *sd, int64 chunks) {
       51:  146:	if (sd->cur_chunks == 0) {
       19:  147:		sd->free_list = alloc(chunks * sd->type.slabs_per_resize * sizeof(unsigned int), false);
       19:  148:		if (sd->free_list == NULL)
    #####:  149:			return -1;
       19:  150:		sd->data = alloc(chunks * sizeof(byte *), false);
       19:  151:		if (sd->data == NULL) {
    #####:  152:			release(sd->free_list);
    #####:  153:			return -1;
        -:  154:		}
       38:  155:		for (int64 i = 0; i < chunks; i++) {
       38:  156:			sd->data[i] =
       19:  157:				alloc(sd->type.slabs_per_resize * (SLAB_OVERHEAD + sd->type.slab_size), false);
       19:  158:			if (sd->data[i] == NULL) {
    #####:  159:				release(sd->free_list);
    #####:  160:				for (int64 j = i - 1; j >= 0; j--) {
    #####:  161:					release(sd->data[j]);
        -:  162:				}
    #####:  163:				release(sd->data);
    #####:  164:				return -1;
        -:  165:			}
        -:  166:		}
        -:  167:	} else {
       32:  168:		if ((chunks + (int64)sd->cur_chunks) * (int64)sd->type.slabs_per_resize >
       32:  169:			sd->type.max_slabs) {
    #####:  170:			SetErr(Overflow);
    #####:  171:			return -1;
        -:  172:		}
       32:  173:		void *tmp = resize(sd->free_list, (chunks + sd->cur_chunks) * sd->type.slabs_per_resize *
        -:  174:											  sizeof(unsigned int));
       32:  175:		if (tmp == NULL)
    #####:  176:			return -1;
       32:  177:		sd->free_list = tmp;
       32:  178:		void *tmp2 = resize(sd->data, (chunks + sd->cur_chunks) * sizeof(byte *));
       32:  179:		if (tmp2 == NULL) {
    #####:  180:			release(sd->free_list);
    #####:  181:			return -1;
        -:  182:		}
       32:  183:		sd->data = tmp2;
       64:  184:		for (int64 i = 0; i < chunks; i++) {
       64:  185:			sd->data[i + sd->cur_chunks] =
       32:  186:				alloc(sd->type.slabs_per_resize * (SLAB_OVERHEAD + sd->type.slab_size), false);
       32:  187:			if (sd->data[i + sd->cur_chunks] == NULL) {
    #####:  188:				release(sd->free_list);
    #####:  189:				for (int64 j = i - 1; j >= 0; j--) {
    #####:  190:					release(sd->data[j + sd->cur_chunks]);
        -:  191:				}
    #####:  192:				release(sd->data);
    #####:  193:				return -1;
        -:  194:			}
        -:  195:		}
        -:  196:	}
        -:  197:
       51:  198:	slab_allocator_init_free_list(sd, chunks);
       51:  199:	sd->cur_chunks += chunks;
       51:  200:	return 0;
        -:  201:}
        -:  202:
     4626:  203:int slab_allocator_init_data(SlabData *sd) {
     4626:  204:	sd->cur_slabs = 0;
     4626:  205:	sd->cur_chunks = 0;
     4626:  206:	sd->free_list_head = UINT32_MAX;
     4626:  207:	sd->free_list = NULL;
     4626:  208:	sd->data = NULL;
        -:  209:
     4626:  210:	if (sd->type.initial_chunks) {
    #####:  211:		if (slab_allocator_increase_chunks(sd, sd->type.initial_chunks))
    #####:  212:			return -1;
        -:  213:	}
     4626:  214:	return 0;
        -:  215:}
        -:  216:
       18:  217:int slab_allocator_init_state(SlabAllocator sa) {
     4644:  218:	for (int i = 0; i < sa->sd_count; i++) {
     4626:  219:		if (slab_allocator_init_data(&sa->sd_arr[i]))
    #####:  220:			return -1;
        -:  221:	}
        -:  222:
       18:  223:	return 0;
        -:  224:}
        -:  225:
       18:  226:SlabAllocator slab_allocator_create() {
       18:  227:	SlabAllocatorNc ret = (SlabAllocatorImpl *)alloc(
        -:  228:		sizeof(SlabAllocatorImpl) + SLAB_SIZES * sizeof(SlabData), false);
       18:  229:	if (ret == NULL)
    #####:  230:		return NULL;
       18:  231:	if (pthread_rwlock_init(&ret->lock, NULL)) {
    #####:  232:		SetErr(LockInitErr);
    #####:  233:		release(ret);
    #####:  234:		return NULL;
        -:  235:	}
       18:  236:	ret->sd_count = SLAB_SIZES;
     4644:  237:	for (int i = 0; i < ret->sd_count; i++) {
     4626:  238:		SlabData *sd = &ret->sd_arr[i];
     4626:  239:		sd->type = (const SlabType) {.slab_size = i * 16,
        -:  240:									 .slabs_per_resize = SLABS_PER_RESIZE,
        -:  241:									 .initial_chunks = INITIAL_CHUNKS,
        -:  242:									 .max_slabs = UINT32_MAX};
     4626:  243:		sd->cur_chunks = 0;
        -:  244:	}
        -:  245:
       18:  246:	if (slab_allocator_init_state(ret)) {
    #####:  247:		slab_allocator_cleanup(&ret);
    #####:  248:		return NULL;
        -:  249:	}
       18:  250:	return ret;
        -:  251:}
        -:  252:
   409311:  253:int slab_allocator_index(SlabAllocator sa, unsigned int size) {
   409311:  254:	int ret = (15 + size) / 16;
   409311:  255:	if (size < 0 || ret >= SLAB_SIZES)
        1:  256:		return -1;
   409310:  257:	return ret;
        -:  258:}
        -:  259:
   204658:  260:Ptr slab_allocator_allocate_sd(SlabData *sd, SlabAllocator sa) {
        -:  261:	int code;
   204658:  262:	errno = 0;
   204658:  263:	if (sd->free_list_head == UINT32_MAX) {
       51:  264:		if ((code = pthread_rwlock_unlock(&sa->lock)))
    #####:  265:			panic("pthread_rwlock_unlock: failed due to %i (%i)", code, errno);
       51:  266:		if ((code = pthread_rwlock_wrlock(&sa->lock)))
    #####:  267:			panic("pthread_rwlock_wrlock: failed due to %i (%i)", code, errno);
       51:  268:		if (sd->free_list_head == UINT32_MAX) {
       51:  269:			if (slab_allocator_increase_chunks(sd, 1)) {
    #####:  270:				return NULL;
        -:  271:			}
       51:  272:			if (sd->free_list_head == UINT32_MAX) {
    #####:  273:				SetErr(CapacityExceeded);
    #####:  274:				return NULL;
        -:  275:			}
        -:  276:		}
       51:  277:		if ((code = pthread_rwlock_unlock(&sa->lock)))
    #####:  278:			panic("pthread_rwlock_unlock: failed due to %i (%i)", code, errno);
       51:  279:		if ((code = pthread_rwlock_rdlock(&sa->lock)))
    #####:  280:			panic("pthread_rwlock_rdlock: failed due to %i (%i)", code, errno);
        -:  281:	}
        -:  282:
        -:  283:	unsigned int old_free_list_head;
        -:  284:	unsigned int new_free_list_head;
        -:  285:	Ptr ptr;
        -:  286:
        -:  287:	do {
   204658:  288:		old_free_list_head = sd->free_list_head;
   204658:  289:		int64 index = slab_allocator_slab_data_index(sd, old_free_list_head);
   204658:  290:		int64 offset = slab_allocator_slab_data_offset(sd, old_free_list_head);
        -:  291:
   204658:  292:		ptr = (Type *)(sd->data[index] + offset);
   204658:  293:		ptr->id = old_free_list_head;
   204658:  294:		ptr->len = sd->type.slab_size;
   204658:  295:		new_free_list_head = sd->free_list[ptr->id];
        -:  296:
   204658:  297:	} while (!__atomic_compare_exchange_n(&sd->free_list_head, &old_free_list_head,
        -:  298:										  new_free_list_head, false, __ATOMIC_RELAXED,
        -:  299:										  __ATOMIC_RELAXED));
        -:  300:
   204658:  301:	__atomic_fetch_add(&sd->cur_slabs, 1, __ATOMIC_RELAXED);
        -:  302:
   204658:  303:	return ptr;
        -:  304:}
        -:  305:
   204652:  306:void slab_allocator_data_free(SlabData *sd, unsigned int id) {
        -:  307:	unsigned int old_free_list_head;
        -:  308:	unsigned int new_free_list_head;
        -:  309:	do {
   204652:  310:		old_free_list_head = sd->free_list_head;
   204652:  311:		new_free_list_head = id;				// Calculate new_free_list_head here
   204652:  312:		sd->free_list[id] = old_free_list_head; // Update sd->free_list[id] here
   204652:  313:	} while (!__atomic_compare_exchange_n(&sd->free_list_head, &old_free_list_head,
        -:  314:										  new_free_list_head, false, __ATOMIC_RELAXED,
        -:  315:										  __ATOMIC_RELAXED));
   204652:  316:	__atomic_fetch_sub(&sd->cur_slabs, 1, __ATOMIC_RELAXED);
   204652:  317:}
        -:  318:
   204659:  319:Ptr slab_allocator_allocate(SlabAllocator sa, unsigned int size) {
        -:  320:	int code;
   204659:  321:	errno = 0;
   204659:  322:	int index = slab_allocator_index(sa, size);
   204659:  323:	if (index < 0)
        1:  324:		return NULL;
        -:  325:
   204658:  326:	if ((code = pthread_rwlock_rdlock(&sa->lock)))
    #####:  327:		panic("pthread_rwlock_rdlock: failed due to %i (%i)", code, errno);
   204658:  328:	Ptr ret = slab_allocator_allocate_sd(&sa->sd_arr[index], sa);
        -:  329:
   204658:  330:	if ((code = pthread_rwlock_unlock(&sa->lock)))
    #####:  331:		panic("pthread_rwlock_unlock: failed due to %i (%i)", code, errno);
        -:  332:
   204658:  333:	return ret;
        -:  334:}
        -:  335:
   204652:  336:void slab_allocator_free(SlabAllocator sa, Ptr ptr) {
        -:  337:	int code;
   204652:  338:	errno = 0;
   204652:  339:	if (ptr == NULL || sa == NULL) {
    #####:  340:		panic("Invalid ptr sent to slab_allocator free!");
        -:  341:	}
   204652:  342:	unsigned int len = ptr_len(ptr);
   204652:  343:	int index = slab_allocator_index(sa, len);
   204652:  344:	if (index < 0) {
    #####:  345:		panic("Invalid ptr sent to slab_allocator free! Unknown size %lli.", len);
        -:  346:	}
   204652:  347:	if (sa->sd_arr[index].type.slab_size != len) {
    #####:  348:		panic("Invalid ptr sent to slab_allocator free! Size mismatch %lli vs. %lli.",
        -:  349:			  sa->sd_arr[index].type.slab_size, len);
        -:  350:	}
        -:  351:
   204652:  352:	if ((code = pthread_rwlock_rdlock(&sa->lock)))
    #####:  353:		panic("pthread_rwlock_rdlock: failed due to %i (%i)", code, errno);
   204652:  354:	slab_allocator_data_free(&sa->sd_arr[index], ptr->id);
        -:  355:
   204652:  356:	if ((code = pthread_rwlock_unlock(&sa->lock)))
    #####:  357:		panic("pthread_rwlock_unlock: failed due to %i (%i)", code, errno);
        -:  358:
   204652:  359:	*ptr = null_impl;
   204652:  360:}
       21:  361:int64 slab_allocator_cur_slabs_allocated(const SlabAllocator sa) {
       21:  362:	int64 slabs = 0;
     5418:  363:	for (int i = 0; i < sa->sd_count; i++) {
     5397:  364:		SlabData *sd = &sa->sd_arr[i];
     5397:  365:		slabs += __atomic_fetch_add(&sd->cur_slabs, 0, __ATOMIC_RELAXED);
        -:  366:	}
       21:  367:	return slabs;
        -:  368:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <base/types.h>
        -:   18:
       14:   19:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   20:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   21:	panic("Supported architectures: __x86_64__, _M_X64, and __aarch64__");
        -:   22:#endif // arch
        -:   23:
        -:   24:	// check size_t
        -:   25:	if (__SIZEOF_SIZE_T__ != 8)
        -:   26:		panic("size_t must be 8 bytes. Invalid arch!");
        -:   27:	// check primitive types
        -:   28:	if (sizeof(byte) != 1)
        -:   29:		panic("byte must be 1 byte. Invalid arch!");
        -:   30:
        -:   31:	if (sizeof(int64) != 8)
        -:   32:		panic("must be 8 bytes. Invalid arch!");
        -:   33:
        -:   34:	if (sizeof(int) != 4)
        -:   35:		panic("int must be 4 bytes. Invalid arch!");
        -:   36:
        -:   37:	if (sizeof(float64) != 8)
        -:   38:		panic("float64 must be 8 bytes. Invalid arch!");
        -:   39:
        -:   40:	if (sizeof(bool) != 1)
        -:   41:		panic("bool must be 1 byte. Invalid arch!");
        -:   42:
        -:   43:	if (sizeof(aint64) != 8)
        -:   44:		panic("aint64 must be 8 bytes. Invalid arch!");
        -:   45:
        -:   46:	if (sizeof(abool) != 1)
        -:   47:		panic("abool must be 1 byte. Invalid arch!");
        -:   48:
        -:   49:	// little endian check
       14:   50:	int test = 0x1;
       14:   51:	if (*(byte *)&test != 0x1) {
    #####:   52:		panic("Big endian is not supported!");
        -:   53:	}
       14:   54:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
