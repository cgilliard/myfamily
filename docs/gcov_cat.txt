        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
    #####:   16:int main(int argc, char **argv)
        -:   17:{
    #####:   18:	return real_main(argc, argv);
        -:   19:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <base/misc.h>
        -:   17:#include <base/version.h>
        -:   18:#include <bible/bible.h>
        -:   19:#include <build/build.h>
        -:   20:#include <core/std.h>
        -:   21:#include <dirent.h>
        -:   22:#include <errno.h>
        -:   23:#include <main/main.h>
        -:   24:#include <main/resources.h>
        -:   25:#include <stdio.h>
        -:   26:#include <string.h>
        -:   27:#include <sys/stat.h>
        -:   28:#include <unistd.h>
        -:   29:
    #####:   30:void build_args(Args *args)
    #####:   31:{
    #####:   32:	const char *home_dir = get_home_directory();
        -:   33:
    #####:   34:	args_build(args, "fam", FAM_VERSION, "The MyFamily Developers", 0, 0, 0);
        -:   35:
        -:   36:	// build the init SubCommand
        -:   37:	SubCommand init;
        -:   38:	ArgsParam cfg_dir;
    #####:   39:	args_param_build(&cfg_dir, "dir",
        -:   40:		"Directory to initialize the project in (defaults to "
        -:   41:		"the project name if not specified)",
        -:   42:		"p", true, false, NULL);
        -:   43:	ArgsParam cfg_authors;
    #####:   44:	args_param_build(&cfg_authors, "author", "Author of this project", "a", true, true,
        -:   45:		"The MyFamily Developers");
        -:   46:	ArgsParam cfg_lib;
    #####:   47:	args_param_build(&cfg_lib, "lib",
        -:   48:		"Initialize the project as a library project. (If not set, the project will be a binary "
        -:   49:		"project)",
        -:   50:		"l", false, false, NULL);
        -:   51:	ArgsParam cfg_description;
    #####:   52:	args_param_build(&cfg_description, "description",
        -:   53:		"Project description (defaults to the project name)", "d", true, false, NULL);
    #####:   54:	sub_command_build(&init, "init", "Initialize project", 1, 1, "<project_name>");
    #####:   55:	sub_command_add_param(&init, &cfg_dir);
    #####:   56:	sub_command_add_param(&init, &cfg_authors);
    #####:   57:	sub_command_add_param(&init, &cfg_lib);
    #####:   58:	sub_command_add_param(&init, &cfg_description);
        -:   59:
    #####:   60:	args_add_sub_command(args, &init);
        -:   61:
        -:   62:	// build the build SubCommand
        -:   63:	SubCommand build;
        -:   64:	ArgsParam cfg_base;
    #####:   65:	args_param_build(&cfg_base, "base", "The base directory of the project. (defaults to '.')", "b",
        -:   66:		true, false, ".");
    #####:   67:	sub_command_build(&build, "build", "Build project in release mode", 0, 0, "");
    #####:   68:	sub_command_add_param(&build, &cfg_base);
        -:   69:
    #####:   70:	args_add_sub_command(args, &build);
        -:   71:
        -:   72:	// build the debug SubCommand
        -:   73:	SubCommand bdebug;
    #####:   74:	sub_command_build(&bdebug, "debug", "Build project in debug mode", 0, 0, "");
        -:   75:
    #####:   76:	args_add_sub_command(args, &bdebug);
        -:   77:
        -:   78:	// build the test SubCommand
        -:   79:	SubCommand test;
    #####:   80:	sub_command_build(&test, "test", "Run tests", 0, 0, "");
        -:   81:
    #####:   82:	args_add_sub_command(args, &test);
        -:   83:
        -:   84:	// build the doc SubCommand
        -:   85:	SubCommand doc;
    #####:   86:	sub_command_build(&doc, "doc", "Build documentation", 0, 0, "");
        -:   87:
    #####:   88:	args_add_sub_command(args, &doc);
        -:   89:
        -:   90:	// build the verse SubCommand
        -:   91:	SubCommand verse;
    #####:   92:	sub_command_build(&verse, "verse", "Print a random Bible verse", 0, 0, "");
        -:   93:	ArgsParam no_colors_param, book_param, chapter_param, verse_param;
    #####:   94:	args_param_build(
        -:   95:		&no_colors_param, "no_colors", "Do not display colors", "n", false, false, NULL);
    #####:   96:	args_param_build(&book_param, "book",
        -:   97:		"Randomly select a verse from the specified book of the Bible", "b", true, false, NULL);
    #####:   98:	args_param_build(&chapter_param, "chapter",
        -:   99:		"Randomly select a verse from the specified chapter of the Bible. "
        -:  100:		"This option requires that --book be specified as well.",
        -:  101:		"x", true, false, NULL);
    #####:  102:	args_param_build(&verse_param, "verse",
        -:  103:		"Select the specified verse. This option requires "
        -:  104:		"that --book and --chapter be specified as well.",
        -:  105:		"v", true, false, NULL);
        -:  106:
    #####:  107:	sub_command_add_param(&verse, &no_colors_param);
    #####:  108:	sub_command_add_param(&verse, &book_param);
    #####:  109:	sub_command_add_param(&verse, &chapter_param);
    #####:  110:	sub_command_add_param(&verse, &verse_param);
        -:  111:
    #####:  112:	args_add_sub_command(args, &verse);
        -:  113:
        -:  114:	// build the node SubCommand
        -:  115:	SubCommand node;
        -:  116:	ArgsParam cfg_threads, cfg_show;
    #####:  117:	args_param_build(
        -:  118:		&cfg_show, "show_request", "Show request information", "s", false, false, NULL);
    #####:  119:	args_param_build(
        -:  120:		&cfg_threads, "threads", "Number of threads to execute", "t", true, false, "1");
        -:  121:
    #####:  122:	sub_command_build(&node, "node", "Run full node", 0, 0, "");
    #####:  123:	sub_command_add_param(&node, &cfg_threads);
    #####:  124:	sub_command_add_param(&node, &cfg_show);
        -:  125:
    #####:  126:	args_add_sub_command(args, &node);
        -:  127:
        -:  128:	// build core options
        -:  129:	ArgsParam cfg_config_dir;
        -:  130:	ArgsParam cfg_debug;
        -:  131:
    #####:  132:	args_param_build(
        -:  133:		&cfg_debug, "debug", "Prints additional debugging information", "d", false, false, NULL);
        -:  134:
    #####:  135:	char default_config_dir[strlen(home_dir) + 100];
    #####:  136:	snprintf(default_config_dir, strlen(home_dir) + 100, "%s/.fam", home_dir);
    #####:  137:	args_param_build(&cfg_config_dir, "config_dir",
        -:  138:		"Directory where configuration files are stored", "c", true, false, default_config_dir);
        -:  139:
    #####:  140:	args_add_param(args, &cfg_debug);
    #####:  141:	args_add_param(args, &cfg_config_dir);
    #####:  142:}
        -:  143:
    #####:  144:void process_verse(Args *args, char *config_dir)
    #####:  145:{
    #####:  146:	bool no_colors = args_value_of(args, "no_colors", NULL, 0, 0) >= 0;
        -:  147:	char book[100];
    #####:  148:	args_value_of(args, "book", book, 100, 0);
        -:  149:	char chapter_buf[100];
    #####:  150:	int chapter_int = -1;
    #####:  151:	if (args_value_of(args, "chapter", chapter_buf, 100, 0) != -1) {
    #####:  152:		chapter_int = atoi(chapter_buf);
    #####:  153:		if (chapter_int <= 0 || chapter_int > 255) {
    #####:  154:			fprintf(stderr,
        -:  155:				"The chapter specified must be a positive "
        -:  156:				"integer which is equal to or less than 255.\n");
    #####:  157:			exit(-1);
        -:  158:		}
        -:  159:	}
        -:  160:	char verse_buf[100];
    #####:  161:	int verse_int = -1;
    #####:  162:	if (args_value_of(args, "verse", verse_buf, 100, 0) != -1) {
    #####:  163:		verse_int = atoi(verse_buf);
    #####:  164:		if (verse_int <= 0 || verse_int > 255) {
    #####:  165:			fprintf(stderr,
        -:  166:				"The verse specified must be a positive "
        -:  167:				"integer which is equal to or less than 255.\n");
    #####:  168:			exit(-1);
        -:  169:		}
        -:  170:	}
        -:  171:
        -:  172:	Bible bible;
    #####:  173:	char bible_path[strlen(config_dir) + 10];
    #####:  174:	strcpy(bible_path, config_dir);
    #####:  175:	strcat(bible_path, "/resources/akjv.txt");
    #####:  176:	if (bible_build(&bible, bible_path)) {
    #####:  177:		fprintf(stderr, "Could not load bible at path %s: %s\n", bible_path, strerror(errno));
    #####:  178:		exit(-1);
        -:  179:	}
        -:  180:
        -:  181:	char buf[1024];
        -:  182:	char book_buf[100];
        -:  183:	u8 chapter, verse;
        -:  184:
    #####:  185:	u8 *chapter_ptr = NULL;
    #####:  186:	if (chapter_int != -1) {
    #####:  187:		chapter = chapter_int;
    #####:  188:		chapter_ptr = &chapter;
        -:  189:	}
    #####:  190:	u8 *verse_ptr = NULL;
    #####:  191:	if (verse_int != -1) {
    #####:  192:		verse = verse_int;
    #####:  193:		verse_ptr = &verse;
        -:  194:	}
        -:  195:
    #####:  196:	if (verse_int != -1 && chapter_int == -1) {
    #####:  197:		fprintf(stderr,
        -:  198:			"If --verse is specified, --chapter must also "
        -:  199:			"be specified\n");
    #####:  200:		exit(-1);
        -:  201:	}
    #####:  202:	if (chapter_int != -1 && (strlen(book) == 0)) {
    #####:  203:		fprintf(stderr,
        -:  204:			"If --chapter is specified, --book must also "
        -:  205:			"be specified\n");
    #####:  206:		exit(-1);
        -:  207:	}
    #####:  208:	if (bible_random_verse_to_string(&bible, buf, 1024, !no_colors, book, chapter_ptr, verse_ptr)
        -:  209:		< 0) {
    #####:  210:		fprintf(stderr, "Could not find random verse due to: %s\n", strerror(errno));
    #####:  211:		exit(-1);
        -:  212:	}
        -:  213:
    #####:  214:	printf("%s\n", buf);
    #####:  215:	bible_cleanup(&bible);
    #####:  216:}
        -:  217:
    #####:  218:void process_build(Args *args, char *config_dir)
        -:  219:{
        -:  220:	char base_dir[PATH_MAX];
    #####:  221:	args_value_of(args, "base", base_dir, PATH_MAX - 1, 0);
    #####:  222:	proc_build(base_dir, config_dir);
    #####:  223:}
        -:  224:
    #####:  225:void process_init(Args *args, char *config_dir)
        -:  226:{
        -:  227:	char proj_name[128];
    #####:  228:	strcpy(proj_name, "");
    #####:  229:	args_get_argument(args, 1, proj_name, 127);
        -:  230:	char proj_path[PATH_MAX];
    #####:  231:	strcpy(proj_path, proj_name);
    #####:  232:	args_value_of(args, "dir", proj_path, 1023, 0);
        -:  233:
        -:  234:	char author[11][1024];
    #####:  235:	int count = 0;
        -:  236:	loop
    #####:  237:	{
    #####:  238:		int v = args_value_of(args, "author", author[count], 1023, count);
    #####:  239:		if (v == -1)
    #####:  240:			break;
    #####:  241:		count++;
    #####:  242:		if (count >= 10) {
    #####:  243:			fprintf(stderr, "A maximum of 10 authors is allowed.");
    #####:  244:			exit(-1);
        -:  245:		}
        -:  246:	}
        -:  247:
    #####:  248:	bool lib = args_value_of(args, "lib", NULL, 0, 0) >= 0;
        -:  249:
        -:  250:	char description[1024];
    #####:  251:	args_value_of(args, "description", description, 1023, 0);
    #####:  252:	proc_build_init(config_dir, proj_name, proj_path, author, count, lib, description);
    #####:  253:}
        -:  254:
    #####:  255:void setup_config_dir(const char *config_dir)
    #####:  256:{
    #####:  257:	if (mkdir(config_dir, 0700)) {
    #####:  258:		perror("Failed to create specified config directory");
    #####:  259:		exit(-1);
        -:  260:	}
        -:  261:
    #####:  262:	char resources_dir[strlen(config_dir) + 100];
    #####:  263:	strcpy(resources_dir, config_dir);
    #####:  264:	strcat(resources_dir, "/resources");
        -:  265:
    #####:  266:	if (mkdir(resources_dir, 0700)) {
    #####:  267:		perror("Failed to create specified resources directory");
    #####:  268:		exit(-1);
        -:  269:	}
        -:  270:
    #####:  271:	BUILD_RESOURCE_DIR(resources_dir, fam);
    #####:  272:}
        -:  273:
    #####:  274:int real_main(int argc, char **argv)
    #####:  275:{
        -:  276:	Args args;
    #####:  277:	build_args(&args);
    #####:  278:	args_init(&args, argc, argv);
        -:  279:
        -:  280:	// we always ensure that the config directory exists.
    #####:  281:	int config_dir_len = args_value_of(&args, "config_dir", NULL, 0, 0);
    #####:  282:	char config_dir[config_dir_len + 1];
    #####:  283:	args_value_of(&args, "config_dir", config_dir, config_dir_len + 1, 0);
    #####:  284:	if (access(config_dir, F_OK)) {
    #####:  285:		setup_config_dir(config_dir);
    #####:  286:		WRITE_BUILD_ID(config_dir);
        -:  287:	} else {
        -:  288:		// check build id
        -:  289:		char bid_file[PATH_MAX];
    #####:  290:		strcpy(bid_file, config_dir);
    #####:  291:		strcat(bid_file, PATH_SEPARATOR);
    #####:  292:		strcat(bid_file, "build_id");
    #####:  293:		FILE *fp = myfopen(bid_file, "r");
    #####:  294:		if (!fp) {
    #####:  295:			exit_error("could not open the build file");
        -:  296:		}
        -:  297:		char bid_file_contents[1024];
    #####:  298:		size_t rlen = read_all(bid_file_contents, 1, 100, fp);
    #####:  299:		bid_file_contents[rlen] = 0;
    #####:  300:		if (strcmp(bid_file_contents, BUILD_ID)) {
    #####:  301:			remove_directory(config_dir, false);
    #####:  302:			setup_config_dir(config_dir);
    #####:  303:			WRITE_BUILD_ID(config_dir);
        -:  304:		}
    #####:  305:		myfclose(fp);
        -:  306:	}
        -:  307:
        -:  308:	// get first argument (subcommand)
        -:  309:	char command[100];
    #####:  310:	int ret = args_get_argument(&args, 0, command, 100);
    #####:  311:	if (ret > 0) {
    #####:  312:		if (!strcmp(command, "verse")) {
    #####:  313:			process_verse(&args, config_dir);
    #####:  314:		} else if (!strcmp(command, "init")) {
    #####:  315:			process_init(&args, config_dir);
    #####:  316:		} else if (!strcmp(command, "build")) {
    #####:  317:			process_build(&args, config_dir);
        -:  318:		} else {
    #####:  319:			printf("Not implemented!\n");
        -:  320:		}
        -:  321:	}
        -:  322:
    #####:  323:	args_cleanup(&args);
        -:  324:
    #####:  325:	return 0;
        -:  326:}
        -:    0:Source:toml.c
        -:    0:Graph:toml.gcno
        -:    0:Data:toml.gcda
        -:    0:Runs:3
        -:    1:/*
        -:    2:
        -:    3:  MIT License
        -:    4:
        -:    5:  Copyright (c) CK Tan
        -:    6:  https://github.com/cktan/tomlc99
        -:    7:
        -:    8:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    9:  of this software and associated documentation files (the "Software"), to deal
        -:   10:  in the Software without restriction, including without limitation the rights
        -:   11:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   12:  copies of the Software, and to permit persons to whom the Software is
        -:   13:  furnished to do so, subject to the following conditions:
        -:   14:
        -:   15:  The above copyright notice and this permission notice shall be included in all
        -:   16:  copies or substantial portions of the Software.
        -:   17:
        -:   18:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   19:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   20:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   21:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   22:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   23:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   24:  SOFTWARE.
        -:   25:
        -:   26:*/
        -:   27:#define _POSIX_C_SOURCE 200809L
        -:   28:#include <assert.h>
        -:   29:#include <ctype.h>
        -:   30:#include <errno.h>
        -:   31:#include <stdbool.h>
        -:   32:#include <stdint.h>
        -:   33:#include <stdio.h>
        -:   34:#include <stdlib.h>
        -:   35:#include <string.h>
        -:   36:#include <toml/toml.h>
        -:   37:
        -:   38:static void* (*ppmalloc)(size_t) = malloc;
        -:   39:static void (*ppfree)(void*) = free;
        -:   40:
    #####:   41:void toml_set_memutil(void* (*xxmalloc)(size_t), void (*xxfree)(void*))
        -:   42:{
    #####:   43:	if (xxmalloc)
    #####:   44:		ppmalloc = xxmalloc;
    #####:   45:	if (xxfree)
    #####:   46:		ppfree = xxfree;
    #####:   47:}
        -:   48:
        -:   49:#define ALIGN8(sz) (((sz) + 7) & ~7)
        -:   50:#define MALLOC(a) ppmalloc(a)
        -:   51:#define FREE(a) ppfree(a)
        -:   52:
        -:   53:#define malloc(x) error - forbidden - use MALLOC instead
        -:   54:#define free(x) error - forbidden - use FREE instead
        -:   55:#define calloc(x, y) error - forbidden - use CALLOC instead
        -:   56:
    #####:   57:static void* CALLOC(size_t nmemb, size_t sz)
        -:   58:{
    #####:   59:	int nb = ALIGN8(sz) * nmemb;
    #####:   60:	void* p = MALLOC(nb);
    #####:   61:	if (p)
        -:   62:	{
    #####:   63:		memset(p, 0, nb);
        -:   64:	}
    #####:   65:	return p;
        -:   66:}
        -:   67:
        -:   68:// some old platforms define strdup macro -- drop it.
        -:   69:#undef strdup
        -:   70:#define strdup(x) error - forbidden - use STRDUP instead
        -:   71:
    #####:   72:static char* STRDUP(const char* s)
        -:   73:{
    #####:   74:	int len = strlen(s);
    #####:   75:	char* p = MALLOC(len + 1);
    #####:   76:	if (p)
        -:   77:	{
    #####:   78:		memcpy(p, s, len);
    #####:   79:		p[len] = 0;
        -:   80:	}
    #####:   81:	return p;
        -:   82:}
        -:   83:
        -:   84:// some old platforms define strndup macro -- drop it.
        -:   85:#undef strndup
        -:   86:#define strndup(x) error - forbiden - use STRNDUP instead
        -:   87:
    #####:   88:static char* STRNDUP(const char* s, size_t n)
        -:   89:{
    #####:   90:	size_t len = strnlen(s, n);
    #####:   91:	char* p = MALLOC(len + 1);
    #####:   92:	if (p)
        -:   93:	{
    #####:   94:		memcpy(p, s, len);
    #####:   95:		p[len] = 0;
        -:   96:	}
    #####:   97:	return p;
        -:   98:}
        -:   99:
        -:  100:/**
        -:  101: * Convert a char in utf8 into UCS, and store it in *ret.
        -:  102: * Return bytes consumed or -1 on failure.
        -:  103: */
    #####:  104:int toml_utf8_to_ucs(const char* orig, int len, int64_t* ret)
        -:  105:{
    #####:  106:	const unsigned char* buf = (const unsigned char*)orig;
    #####:  107:	unsigned i = *buf++;
        -:  108:	int64_t v;
        -:  109:
        -:  110:	/* 0x00000000 - 0x0000007F:
        -:  111:	   0xxxxxxx
        -:  112:	*/
    #####:  113:	if (0 == (i >> 7))
        -:  114:	{
    #####:  115:		if (len < 1)
    #####:  116:			return -1;
    #####:  117:		v = i;
    #####:  118:		return *ret = v, 1;
        -:  119:	}
        -:  120:	/* 0x00000080 - 0x000007FF:
        -:  121:	   110xxxxx 10xxxxxx
        -:  122:	*/
    #####:  123:	if (0x6 == (i >> 5))
        -:  124:	{
    #####:  125:		if (len < 2)
    #####:  126:			return -1;
    #####:  127:		v = i & 0x1f;
    #####:  128:		for (int j = 0; j < 1; j++)
        -:  129:		{
    #####:  130:			i = *buf++;
    #####:  131:			if (0x2 != (i >> 6))
    #####:  132:				return -1;
    #####:  133:			v = (v << 6) | (i & 0x3f);
        -:  134:		}
    #####:  135:		return *ret = v, (const char*)buf - orig;
        -:  136:	}
        -:  137:
        -:  138:	/* 0x00000800 - 0x0000FFFF:
        -:  139:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  140:	*/
    #####:  141:	if (0xE == (i >> 4))
        -:  142:	{
    #####:  143:		if (len < 3)
    #####:  144:			return -1;
    #####:  145:		v = i & 0x0F;
    #####:  146:		for (int j = 0; j < 2; j++)
        -:  147:		{
    #####:  148:			i = *buf++;
    #####:  149:			if (0x2 != (i >> 6))
    #####:  150:				return -1;
    #####:  151:			v = (v << 6) | (i & 0x3f);
        -:  152:		}
    #####:  153:		return *ret = v, (const char*)buf - orig;
        -:  154:	}
        -:  155:
        -:  156:	/* 0x00010000 - 0x001FFFFF:
        -:  157:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  158:	*/
    #####:  159:	if (0x1E == (i >> 3))
        -:  160:	{
    #####:  161:		if (len < 4)
    #####:  162:			return -1;
    #####:  163:		v = i & 0x07;
    #####:  164:		for (int j = 0; j < 3; j++)
        -:  165:		{
    #####:  166:			i = *buf++;
    #####:  167:			if (0x2 != (i >> 6))
    #####:  168:				return -1;
    #####:  169:			v = (v << 6) | (i & 0x3f);
        -:  170:		}
    #####:  171:		return *ret = v, (const char*)buf - orig;
        -:  172:	}
        -:  173:
        -:  174:	/* 0x00200000 - 0x03FFFFFF:
        -:  175:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  176:	*/
    #####:  177:	if (0x3E == (i >> 2))
        -:  178:	{
    #####:  179:		if (len < 5)
    #####:  180:			return -1;
    #####:  181:		v = i & 0x03;
    #####:  182:		for (int j = 0; j < 4; j++)
        -:  183:		{
    #####:  184:			i = *buf++;
    #####:  185:			if (0x2 != (i >> 6))
    #####:  186:				return -1;
    #####:  187:			v = (v << 6) | (i & 0x3f);
        -:  188:		}
    #####:  189:		return *ret = v, (const char*)buf - orig;
        -:  190:	}
        -:  191:
        -:  192:	/* 0x04000000 - 0x7FFFFFFF:
        -:  193:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  194:	*/
    #####:  195:	if (0x7e == (i >> 1))
        -:  196:	{
    #####:  197:		if (len < 6)
    #####:  198:			return -1;
    #####:  199:		v = i & 0x01;
    #####:  200:		for (int j = 0; j < 5; j++)
        -:  201:		{
    #####:  202:			i = *buf++;
    #####:  203:			if (0x2 != (i >> 6))
    #####:  204:				return -1;
    #####:  205:			v = (v << 6) | (i & 0x3f);
        -:  206:		}
    #####:  207:		return *ret = v, (const char*)buf - orig;
        -:  208:	}
    #####:  209:	return -1;
        -:  210:}
        -:  211:
        -:  212:/**
        -:  213: *	Convert a UCS char to utf8 code, and return it in buf.
        -:  214: *	Return bytes used in buf to encode the char, or
        -:  215: *	-1 on error.
        -:  216: */
    #####:  217:int toml_ucs_to_utf8(int64_t code, char buf[6])
        -:  218:{
        -:  219:	/* http://stackoverflow.com/questions/6240055/manually-converting-unicode-codepoints-into-utf-8-and-utf-16
        -:  220:	 */
        -:  221:	/* The UCS code values 0xd800â€“0xdfff (UTF-16 surrogates) as well
        -:  222:	 * as 0xfffe and 0xffff (UCS noncharacters) should not appear in
        -:  223:	 * conforming UTF-8 streams.
        -:  224:	 */
    #####:  225:	if (0xd800 <= code && code <= 0xdfff)
    #####:  226:		return -1;
    #####:  227:	if (0xfffe <= code && code <= 0xffff)
    #####:  228:		return -1;
        -:  229:
        -:  230:	/* 0x00000000 - 0x0000007F:
        -:  231:	   0xxxxxxx
        -:  232:	*/
    #####:  233:	if (code < 0)
    #####:  234:		return -1;
    #####:  235:	if (code <= 0x7F)
        -:  236:	{
    #####:  237:		buf[0] = (unsigned char)code;
    #####:  238:		return 1;
        -:  239:	}
        -:  240:
        -:  241:	/* 0x00000080 - 0x000007FF:
        -:  242:	   110xxxxx 10xxxxxx
        -:  243:	*/
    #####:  244:	if (code <= 0x000007FF)
        -:  245:	{
    #####:  246:		buf[0] = (unsigned char)(0xc0 | (code >> 6));
    #####:  247:		buf[1] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  248:		return 2;
        -:  249:	}
        -:  250:
        -:  251:	/* 0x00000800 - 0x0000FFFF:
        -:  252:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  253:	*/
    #####:  254:	if (code <= 0x0000FFFF)
        -:  255:	{
    #####:  256:		buf[0] = (unsigned char)(0xe0 | (code >> 12));
    #####:  257:		buf[1] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  258:		buf[2] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  259:		return 3;
        -:  260:	}
        -:  261:
        -:  262:	/* 0x00010000 - 0x001FFFFF:
        -:  263:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  264:	*/
    #####:  265:	if (code <= 0x001FFFFF)
        -:  266:	{
    #####:  267:		buf[0] = (unsigned char)(0xf0 | (code >> 18));
    #####:  268:		buf[1] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  269:		buf[2] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  270:		buf[3] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  271:		return 4;
        -:  272:	}
        -:  273:
        -:  274:	/* 0x00200000 - 0x03FFFFFF:
        -:  275:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  276:	*/
    #####:  277:	if (code <= 0x03FFFFFF)
        -:  278:	{
    #####:  279:		buf[0] = (unsigned char)(0xf8 | (code >> 24));
    #####:  280:		buf[1] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  281:		buf[2] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  282:		buf[3] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  283:		buf[4] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  284:		return 5;
        -:  285:	}
        -:  286:
        -:  287:	/* 0x04000000 - 0x7FFFFFFF:
        -:  288:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  289:	*/
    #####:  290:	if (code <= 0x7FFFFFFF)
        -:  291:	{
    #####:  292:		buf[0] = (unsigned char)(0xfc | (code >> 30));
    #####:  293:		buf[1] = (unsigned char)(0x80 | ((code >> 24) & 0x3f));
    #####:  294:		buf[2] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  295:		buf[3] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  296:		buf[4] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  297:		buf[5] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  298:		return 6;
        -:  299:	}
        -:  300:
    #####:  301:	return -1;
        -:  302:}
        -:  303:
        -:  304:/*
        -:  305: *	TOML has 3 data structures: value, array, table.
        -:  306: *	Each of them can have identification key.
        -:  307: */
        -:  308:typedef struct toml_keyval_t toml_keyval_t;
        -:  309:struct toml_keyval_t
        -:  310:{
        -:  311:	const char* key; /* key to this value */
        -:  312:	const char* val; /* the raw value */
        -:  313:};
        -:  314:
        -:  315:typedef struct toml_arritem_t toml_arritem_t;
        -:  316:struct toml_arritem_t
        -:  317:{
        -:  318:	int valtype; /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring,
        -:  319:			't'ime, 'D'ate, 'T'imestamp */
        -:  320:	char* val;
        -:  321:	toml_array_t* arr;
        -:  322:	toml_table_t* tab;
        -:  323:};
        -:  324:
        -:  325:struct toml_array_t
        -:  326:{
        -:  327:	const char* key; /* key to this array */
        -:  328:	int kind;	 /* element kind: 'v'alue, 'a'rray, or 't'able, 'm'ixed */
        -:  329:	int type;	 /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring, 't'ime,
        -:  330:			    'D'ate, 'T'imestamp, 'm'ixed */
        -:  331:
        -:  332:	int nitem; /* number of elements */
        -:  333:	toml_arritem_t* item;
        -:  334:};
        -:  335:
        -:  336:struct toml_table_t
        -:  337:{
        -:  338:	const char* key; /* key to this table */
        -:  339:	bool implicit;	 /* table was created implicitly */
        -:  340:	bool readonly;	 /* no more modification allowed */
        -:  341:
        -:  342:	/* key-values in the table */
        -:  343:	int nkval;
        -:  344:	toml_keyval_t** kval;
        -:  345:
        -:  346:	/* arrays in the table */
        -:  347:	int narr;
        -:  348:	toml_array_t** arr;
        -:  349:
        -:  350:	/* tables in the table */
        -:  351:	int ntab;
        -:  352:	toml_table_t** tab;
        -:  353:};
        -:  354:
    #####:  355:static inline void xfree(const void* x)
        -:  356:{
    #####:  357:	if (x)
    #####:  358:		FREE((void*)(intptr_t)x);
    #####:  359:}
        -:  360:
        -:  361:enum tokentype_t
        -:  362:{
        -:  363:	INVALID,
        -:  364:	DOT,
        -:  365:	COMMA,
        -:  366:	EQUAL,
        -:  367:	LBRACE,
        -:  368:	RBRACE,
        -:  369:	NEWLINE,
        -:  370:	LBRACKET,
        -:  371:	RBRACKET,
        -:  372:	STRING,
        -:  373:};
        -:  374:typedef enum tokentype_t tokentype_t;
        -:  375:
        -:  376:typedef struct token_t token_t;
        -:  377:struct token_t
        -:  378:{
        -:  379:	tokentype_t tok;
        -:  380:	int lineno;
        -:  381:	char* ptr; /* points into context->start */
        -:  382:	int len;
        -:  383:	int eof;
        -:  384:};
        -:  385:
        -:  386:typedef struct context_t context_t;
        -:  387:struct context_t
        -:  388:{
        -:  389:	char* start;
        -:  390:	char* stop;
        -:  391:	char* errbuf;
        -:  392:	int errbufsz;
        -:  393:
        -:  394:	token_t tok;
        -:  395:	toml_table_t* root;
        -:  396:	toml_table_t* curtab;
        -:  397:
        -:  398:	struct
        -:  399:	{
        -:  400:		int top;
        -:  401:		char* key[10];
        -:  402:		token_t tok[10];
        -:  403:	} tpath;
        -:  404:};
        -:  405:
        -:  406:#define STRINGIFY(x) #x
        -:  407:#define TOSTRING(x) STRINGIFY(x)
        -:  408:#define FLINE __FILE__ ":" TOSTRING(__LINE__)
        -:  409:
        -:  410:static int next_token(context_t* ctx, int dotisspecial);
        -:  411:
        -:  412:/*
        -:  413:  Error reporting. Call when an error is detected. Always return -1.
        -:  414:*/
    #####:  415:static int e_outofmemory(context_t* ctx, const char* fline)
        -:  416:{
    #####:  417:	snprintf(ctx->errbuf, ctx->errbufsz, "ERROR: out of memory (%s)",
        -:  418:		 fline);
    #####:  419:	return -1;
        -:  420:}
        -:  421:
    #####:  422:static int e_internal(context_t* ctx, const char* fline)
        -:  423:{
    #####:  424:	snprintf(ctx->errbuf, ctx->errbufsz, "internal error (%s)", fline);
    #####:  425:	return -1;
        -:  426:}
        -:  427:
    #####:  428:static int e_syntax(context_t* ctx, int lineno, const char* msg)
        -:  429:{
    #####:  430:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  431:	return -1;
        -:  432:}
        -:  433:
    #####:  434:static int e_badkey(context_t* ctx, int lineno)
        -:  435:{
    #####:  436:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: bad key", lineno);
    #####:  437:	return -1;
        -:  438:}
        -:  439:
    #####:  440:static int e_keyexists(context_t* ctx, int lineno)
        -:  441:{
    #####:  442:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: key exists", lineno);
    #####:  443:	return -1;
        -:  444:}
        -:  445:
    #####:  446:static int e_forbid(context_t* ctx, int lineno, const char* msg)
        -:  447:{
    #####:  448:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  449:	return -1;
        -:  450:}
        -:  451:
    #####:  452:static void* expand(void* p, int sz, int newsz)
        -:  453:{
    #####:  454:	void* s = MALLOC(newsz);
    #####:  455:	if (!s)
    #####:  456:		return 0;
        -:  457:
    #####:  458:	if (p)
        -:  459:	{
    #####:  460:		memcpy(s, p, sz);
    #####:  461:		FREE(p);
        -:  462:	}
    #####:  463:	return s;
        -:  464:}
        -:  465:
    #####:  466:static void** expand_ptrarr(void** p, int n)
        -:  467:{
    #####:  468:	void** s = MALLOC((n + 1) * sizeof(void*));
    #####:  469:	if (!s)
    #####:  470:		return 0;
        -:  471:
    #####:  472:	s[n] = 0;
    #####:  473:	if (p)
        -:  474:	{
    #####:  475:		memcpy(s, p, n * sizeof(void*));
    #####:  476:		FREE(p);
        -:  477:	}
    #####:  478:	return s;
        -:  479:}
        -:  480:
    #####:  481:static toml_arritem_t* expand_arritem(toml_arritem_t* p, int n)
        -:  482:{
    #####:  483:	toml_arritem_t* pp = expand(p, n * sizeof(*p), (n + 1) * sizeof(*p));
    #####:  484:	if (!pp)
    #####:  485:		return 0;
        -:  486:
    #####:  487:	memset(&pp[n], 0, sizeof(pp[n]));
    #####:  488:	return pp;
        -:  489:}
        -:  490:
    #####:  491:static char* norm_lit_str(const char* src, int srclen, int multiline,
        -:  492:			  char* errbuf, int errbufsz)
        -:  493:{
    #####:  494:	char* dst = 0; /* will write to dst[] and return it */
    #####:  495:	int max = 0;   /* max size of dst[] */
    #####:  496:	int off = 0;   /* cur offset in dst[] */
    #####:  497:	const char* sp = src;
    #####:  498:	const char* sq = src + srclen;
        -:  499:	int ch;
        -:  500:
        -:  501:	/* scan forward on src */
        -:  502:	for (;;)
        -:  503:	{
    #####:  504:		if (off >= max - 10)
        -:  505:		{ /* have some slack for misc stuff */
    #####:  506:			int newmax = max + 50;
    #####:  507:			char* x = expand(dst, max, newmax);
    #####:  508:			if (!x)
        -:  509:			{
    #####:  510:				xfree(dst);
    #####:  511:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  512:				return 0;
        -:  513:			}
    #####:  514:			dst = x;
    #####:  515:			max = newmax;
        -:  516:		}
        -:  517:
        -:  518:		/* finished? */
    #####:  519:		if (sp >= sq)
    #####:  520:			break;
        -:  521:
    #####:  522:		ch = *sp++;
        -:  523:		/* control characters other than tab is not allowed */
    #####:  524:		if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f))
        -:  525:		{
    #####:  526:			if (!(multiline && (ch == '\r' || ch == '\n')))
        -:  527:			{
    #####:  528:				xfree(dst);
    #####:  529:				snprintf(errbuf, errbufsz,
        -:  530:					 "invalid char U+%04x", ch);
    #####:  531:				return 0;
        -:  532:			}
        -:  533:		}
        -:  534:
        -:  535:		// a plain copy suffice
    #####:  536:		dst[off++] = ch;
        -:  537:	}
        -:  538:
    #####:  539:	dst[off++] = 0;
    #####:  540:	return dst;
        -:  541:}
        -:  542:
        -:  543:/*
        -:  544: * Convert src to raw unescaped utf-8 string.
        -:  545: * Returns NULL if error with errmsg in errbuf.
        -:  546: */
    #####:  547:static char* norm_basic_str(const char* src, int srclen, int multiline,
        -:  548:			    char* errbuf, int errbufsz)
        -:  549:{
    #####:  550:	char* dst = 0; /* will write to dst[] and return it */
    #####:  551:	int max = 0;   /* max size of dst[] */
    #####:  552:	int off = 0;   /* cur offset in dst[] */
    #####:  553:	const char* sp = src;
    #####:  554:	const char* sq = src + srclen;
        -:  555:	int ch;
        -:  556:
        -:  557:	/* scan forward on src */
        -:  558:	for (;;)
        -:  559:	{
    #####:  560:		if (off >= max - 10)
        -:  561:		{ /* have some slack for misc stuff */
    #####:  562:			int newmax = max + 50;
    #####:  563:			char* x = expand(dst, max, newmax);
    #####:  564:			if (!x)
        -:  565:			{
    #####:  566:				xfree(dst);
    #####:  567:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  568:				return 0;
        -:  569:			}
    #####:  570:			dst = x;
    #####:  571:			max = newmax;
        -:  572:		}
        -:  573:
        -:  574:		/* finished? */
    #####:  575:		if (sp >= sq)
    #####:  576:			break;
        -:  577:
    #####:  578:		ch = *sp++;
    #####:  579:		if (ch != '\\')
        -:  580:		{
        -:  581:			/* these chars must be escaped: U+0000 to U+0008, U+000A
        -:  582:			 * to U+001F, U+007F
        -:  583:			 */
    #####:  584:			if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f))
        -:  585:			{
    #####:  586:				if (!(multiline && (ch == '\r' || ch == '\n')))
        -:  587:				{
    #####:  588:					xfree(dst);
    #####:  589:					snprintf(errbuf, errbufsz,
        -:  590:						 "invalid char U+%04x", ch);
    #####:  591:					return 0;
        -:  592:				}
        -:  593:			}
        -:  594:
        -:  595:			// a plain copy suffice
    #####:  596:			dst[off++] = ch;
    #####:  597:			continue;
        -:  598:		}
        -:  599:
        -:  600:		/* ch was backslash. we expect the escape char. */
    #####:  601:		if (sp >= sq)
        -:  602:		{
    #####:  603:			snprintf(errbuf, errbufsz, "last backslash is invalid");
    #####:  604:			xfree(dst);
    #####:  605:			return 0;
        -:  606:		}
        -:  607:
        -:  608:		/* for multi-line, we want to kill line-ending-backslash ... */
    #####:  609:		if (multiline)
        -:  610:		{
        -:  611:
        -:  612:			// if there is only whitespace after the backslash ...
    #####:  613:			if (sp[strspn(sp, " \t\r")] == '\n')
        -:  614:			{
        -:  615:				/* skip all the following whitespaces */
    #####:  616:				sp += strspn(sp, " \t\r\n");
    #####:  617:				continue;
        -:  618:			}
        -:  619:		}
        -:  620:
        -:  621:		/* get the escaped char */
    #####:  622:		ch = *sp++;
    #####:  623:		switch (ch)
        -:  624:		{
    #####:  625:		case 'u':
        -:  626:		case 'U':
        -:  627:		{
    #####:  628:			int64_t ucs = 0;
    #####:  629:			int nhex = (ch == 'u' ? 4 : 8);
    #####:  630:			for (int i = 0; i < nhex; i++)
        -:  631:			{
    #####:  632:				if (sp >= sq)
        -:  633:				{
    #####:  634:					snprintf(errbuf, errbufsz,
        -:  635:						 "\\%c expects %d hex chars",
        -:  636:						 ch, nhex);
    #####:  637:					xfree(dst);
    #####:  638:					return 0;
        -:  639:				}
    #####:  640:				ch = *sp++;
    #####:  641:				int v = ('0' <= ch && ch <= '9')
        -:  642:					    ? ch - '0'
    #####:  643:					    : (('A' <= ch && ch <= 'F')
        -:  644:						   ? ch - 'A' + 10
    #####:  645:						   : -1);
    #####:  646:				if (-1 == v)
        -:  647:				{
    #####:  648:					snprintf(
        -:  649:					    errbuf, errbufsz,
        -:  650:					    "invalid hex chars for \\u or \\U");
    #####:  651:					xfree(dst);
    #####:  652:					return 0;
        -:  653:				}
    #####:  654:				ucs = ucs * 16 + v;
        -:  655:			}
    #####:  656:			int n = toml_ucs_to_utf8(ucs, &dst[off]);
    #####:  657:			if (-1 == n)
        -:  658:			{
    #####:  659:				snprintf(errbuf, errbufsz,
        -:  660:					 "illegal ucs code in \\u or \\U");
    #####:  661:				xfree(dst);
    #####:  662:				return 0;
        -:  663:			}
    #####:  664:			off += n;
        -:  665:		}
    #####:  666:			continue;
        -:  667:
    #####:  668:		case 'b':
    #####:  669:			ch = '\b';
    #####:  670:			break;
    #####:  671:		case 't':
    #####:  672:			ch = '\t';
    #####:  673:			break;
    #####:  674:		case 'n':
    #####:  675:			ch = '\n';
    #####:  676:			break;
    #####:  677:		case 'f':
    #####:  678:			ch = '\f';
    #####:  679:			break;
    #####:  680:		case 'r':
    #####:  681:			ch = '\r';
    #####:  682:			break;
    #####:  683:		case '"':
    #####:  684:			ch = '"';
    #####:  685:			break;
    #####:  686:		case '\\':
    #####:  687:			ch = '\\';
    #####:  688:			break;
    #####:  689:		default:
    #####:  690:			snprintf(errbuf, errbufsz, "illegal escape char \\%c",
        -:  691:				 ch);
    #####:  692:			xfree(dst);
    #####:  693:			return 0;
        -:  694:		}
        -:  695:
    #####:  696:		dst[off++] = ch;
        -:  697:	}
        -:  698:
        -:  699:	// Cap with NUL and return it.
    #####:  700:	dst[off++] = 0;
    #####:  701:	return dst;
        -:  702:}
        -:  703:
        -:  704:/* Normalize a key. Convert all special chars to raw unescaped utf-8 chars. */
    #####:  705:static char* normalize_key(context_t* ctx, token_t strtok)
        -:  706:{
    #####:  707:	const char* sp = strtok.ptr;
    #####:  708:	const char* sq = strtok.ptr + strtok.len;
    #####:  709:	int lineno = strtok.lineno;
        -:  710:	char* ret;
    #####:  711:	int ch = *sp;
        -:  712:	char ebuf[80];
        -:  713:
        -:  714:	/* handle quoted string */
    #####:  715:	if (ch == '\'' || ch == '\"')
        -:  716:	{
        -:  717:		/* if ''' or """, take 3 chars off front and back. Else, take 1
        -:  718:		 * char off. */
    #####:  719:		int multiline = 0;
    #####:  720:		if (sp[1] == ch && sp[2] == ch)
        -:  721:		{
    #####:  722:			sp += 3, sq -= 3;
    #####:  723:			multiline = 1;
        -:  724:		}
        -:  725:		else
    #####:  726:			sp++, sq--;
        -:  727:
    #####:  728:		if (ch == '\'')
        -:  729:		{
        -:  730:			/* for single quote, take it verbatim. */
    #####:  731:			if (!(ret = STRNDUP(sp, sq - sp)))
        -:  732:			{
    #####:  733:				e_outofmemory(ctx, FLINE);
    #####:  734:				return 0;
        -:  735:			}
        -:  736:		}
        -:  737:		else
        -:  738:		{
        -:  739:			/* for double quote, we need to normalize */
    #####:  740:			ret = norm_basic_str(sp, sq - sp, multiline, ebuf,
        -:  741:					     sizeof(ebuf));
    #####:  742:			if (!ret)
        -:  743:			{
    #####:  744:				e_syntax(ctx, lineno, ebuf);
    #####:  745:				return 0;
        -:  746:			}
        -:  747:		}
        -:  748:
        -:  749:		/* newlines are not allowed in keys */
    #####:  750:		if (strchr(ret, '\n'))
        -:  751:		{
    #####:  752:			xfree(ret);
    #####:  753:			e_badkey(ctx, lineno);
    #####:  754:			return 0;
        -:  755:		}
    #####:  756:		return ret;
        -:  757:	}
        -:  758:
        -:  759:	/* for bare-key allow only this regex: [A-Za-z0-9_-]+ */
        -:  760:	const char* xp;
    #####:  761:	for (xp = sp; xp != sq; xp++)
        -:  762:	{
    #####:  763:		int k = *xp;
    #####:  764:		if (isalnum(k))
    #####:  765:			continue;
    #####:  766:		if (k == '_' || k == '-')
    #####:  767:			continue;
    #####:  768:		e_badkey(ctx, lineno);
    #####:  769:		return 0;
        -:  770:	}
        -:  771:
        -:  772:	/* dup and return it */
    #####:  773:	if (!(ret = STRNDUP(sp, sq - sp)))
        -:  774:	{
    #####:  775:		e_outofmemory(ctx, FLINE);
    #####:  776:		return 0;
        -:  777:	}
    #####:  778:	return ret;
        -:  779:}
        -:  780:
        -:  781:/*
        -:  782: * Look up key in tab. Return 0 if not found, or
        -:  783: * 'v'alue, 'a'rray or 't'able depending on the element.
        -:  784: */
    #####:  785:static int check_key(toml_table_t* tab, const char* key,
        -:  786:		     toml_keyval_t** ret_val, toml_array_t** ret_arr,
        -:  787:		     toml_table_t** ret_tab)
        -:  788:{
        -:  789:	int i;
        -:  790:	void* dummy;
        -:  791:
    #####:  792:	if (!ret_tab)
    #####:  793:		ret_tab = (toml_table_t**)&dummy;
    #####:  794:	if (!ret_arr)
    #####:  795:		ret_arr = (toml_array_t**)&dummy;
    #####:  796:	if (!ret_val)
    #####:  797:		ret_val = (toml_keyval_t**)&dummy;
        -:  798:
    #####:  799:	*ret_tab = 0;
    #####:  800:	*ret_arr = 0;
    #####:  801:	*ret_val = 0;
        -:  802:
    #####:  803:	for (i = 0; i < tab->nkval; i++)
        -:  804:	{
    #####:  805:		if (0 == strcmp(key, tab->kval[i]->key))
        -:  806:		{
    #####:  807:			*ret_val = tab->kval[i];
    #####:  808:			return 'v';
        -:  809:		}
        -:  810:	}
    #####:  811:	for (i = 0; i < tab->narr; i++)
        -:  812:	{
    #####:  813:		if (0 == strcmp(key, tab->arr[i]->key))
        -:  814:		{
    #####:  815:			*ret_arr = tab->arr[i];
    #####:  816:			return 'a';
        -:  817:		}
        -:  818:	}
    #####:  819:	for (i = 0; i < tab->ntab; i++)
        -:  820:	{
    #####:  821:		if (0 == strcmp(key, tab->tab[i]->key))
        -:  822:		{
    #####:  823:			*ret_tab = tab->tab[i];
    #####:  824:			return 't';
        -:  825:		}
        -:  826:	}
    #####:  827:	return 0;
        -:  828:}
        -:  829:
    #####:  830:static int key_kind(toml_table_t* tab, const char* key)
        -:  831:{
    #####:  832:	return check_key(tab, key, 0, 0, 0);
        -:  833:}
        -:  834:
        -:  835:/* Create a keyval in the table.
        -:  836: */
    #####:  837:static toml_keyval_t* create_keyval_in_table(context_t* ctx, toml_table_t* tab,
        -:  838:					     token_t keytok)
        -:  839:{
        -:  840:	/* first, normalize the key to be used for lookup.
        -:  841:	 * remember to free it if we error out.
        -:  842:	 */
    #####:  843:	char* newkey = normalize_key(ctx, keytok);
    #####:  844:	if (!newkey)
    #####:  845:		return 0;
        -:  846:
        -:  847:	/* if key exists: error out. */
    #####:  848:	toml_keyval_t* dest = 0;
    #####:  849:	if (key_kind(tab, newkey))
        -:  850:	{
    #####:  851:		xfree(newkey);
    #####:  852:		e_keyexists(ctx, keytok.lineno);
    #####:  853:		return 0;
        -:  854:	}
        -:  855:
        -:  856:	/* make a new entry */
    #####:  857:	int n = tab->nkval;
        -:  858:	toml_keyval_t** base;
    #####:  859:	if (0 == (base = (toml_keyval_t**)expand_ptrarr((void**)tab->kval, n)))
        -:  860:	{
    #####:  861:		xfree(newkey);
    #####:  862:		e_outofmemory(ctx, FLINE);
    #####:  863:		return 0;
        -:  864:	}
    #####:  865:	tab->kval = base;
        -:  866:
    #####:  867:	if (0 == (base[n] = (toml_keyval_t*)CALLOC(1, sizeof(*base[n]))))
        -:  868:	{
    #####:  869:		xfree(newkey);
    #####:  870:		e_outofmemory(ctx, FLINE);
    #####:  871:		return 0;
        -:  872:	}
    #####:  873:	dest = tab->kval[tab->nkval++];
        -:  874:
        -:  875:	/* save the key in the new value struct */
    #####:  876:	dest->key = newkey;
    #####:  877:	return dest;
        -:  878:}
        -:  879:
        -:  880:/* Create a table in the table.
        -:  881: */
    #####:  882:static toml_table_t* create_keytable_in_table(context_t* ctx, toml_table_t* tab,
        -:  883:					      token_t keytok)
        -:  884:{
        -:  885:	/* first, normalize the key to be used for lookup.
        -:  886:	 * remember to free it if we error out.
        -:  887:	 */
    #####:  888:	char* newkey = normalize_key(ctx, keytok);
    #####:  889:	if (!newkey)
    #####:  890:		return 0;
        -:  891:
        -:  892:	/* if key exists: error out */
    #####:  893:	toml_table_t* dest = 0;
    #####:  894:	if (check_key(tab, newkey, 0, 0, &dest))
        -:  895:	{
    #####:  896:		xfree(newkey); /* don't need this anymore */
        -:  897:
        -:  898:		/* special case: if table exists, but was created implicitly ...
        -:  899:		 */
    #####:  900:		if (dest && dest->implicit)
        -:  901:		{
        -:  902:			/* we make it explicit now, and simply return it. */
    #####:  903:			dest->implicit = false;
    #####:  904:			return dest;
        -:  905:		}
    #####:  906:		e_keyexists(ctx, keytok.lineno);
    #####:  907:		return 0;
        -:  908:	}
        -:  909:
        -:  910:	/* create a new table entry */
    #####:  911:	int n = tab->ntab;
        -:  912:	toml_table_t** base;
    #####:  913:	if (0 == (base = (toml_table_t**)expand_ptrarr((void**)tab->tab, n)))
        -:  914:	{
    #####:  915:		xfree(newkey);
    #####:  916:		e_outofmemory(ctx, FLINE);
    #####:  917:		return 0;
        -:  918:	}
    #####:  919:	tab->tab = base;
        -:  920:
    #####:  921:	if (0 == (base[n] = (toml_table_t*)CALLOC(1, sizeof(*base[n]))))
        -:  922:	{
    #####:  923:		xfree(newkey);
    #####:  924:		e_outofmemory(ctx, FLINE);
    #####:  925:		return 0;
        -:  926:	}
    #####:  927:	dest = tab->tab[tab->ntab++];
        -:  928:
        -:  929:	/* save the key in the new table struct */
    #####:  930:	dest->key = newkey;
    #####:  931:	return dest;
        -:  932:}
        -:  933:
        -:  934:/* Create an array in the table.
        -:  935: */
    #####:  936:static toml_array_t* create_keyarray_in_table(context_t* ctx, toml_table_t* tab,
        -:  937:					      token_t keytok, char kind)
        -:  938:{
        -:  939:	/* first, normalize the key to be used for lookup.
        -:  940:	 * remember to free it if we error out.
        -:  941:	 */
    #####:  942:	char* newkey = normalize_key(ctx, keytok);
    #####:  943:	if (!newkey)
    #####:  944:		return 0;
        -:  945:
        -:  946:	/* if key exists: error out */
    #####:  947:	if (key_kind(tab, newkey))
        -:  948:	{
    #####:  949:		xfree(newkey); /* don't need this anymore */
    #####:  950:		e_keyexists(ctx, keytok.lineno);
    #####:  951:		return 0;
        -:  952:	}
        -:  953:
        -:  954:	/* make a new array entry */
    #####:  955:	int n = tab->narr;
        -:  956:	toml_array_t** base;
    #####:  957:	if (0 == (base = (toml_array_t**)expand_ptrarr((void**)tab->arr, n)))
        -:  958:	{
    #####:  959:		xfree(newkey);
    #####:  960:		e_outofmemory(ctx, FLINE);
    #####:  961:		return 0;
        -:  962:	}
    #####:  963:	tab->arr = base;
        -:  964:
    #####:  965:	if (0 == (base[n] = (toml_array_t*)CALLOC(1, sizeof(*base[n]))))
        -:  966:	{
    #####:  967:		xfree(newkey);
    #####:  968:		e_outofmemory(ctx, FLINE);
    #####:  969:		return 0;
        -:  970:	}
    #####:  971:	toml_array_t* dest = tab->arr[tab->narr++];
        -:  972:
        -:  973:	/* save the key in the new array struct */
    #####:  974:	dest->key = newkey;
    #####:  975:	dest->kind = kind;
    #####:  976:	return dest;
        -:  977:}
        -:  978:
    #####:  979:static toml_arritem_t* create_value_in_array(context_t* ctx,
        -:  980:					     toml_array_t* parent)
        -:  981:{
    #####:  982:	const int n = parent->nitem;
    #####:  983:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####:  984:	if (!base)
        -:  985:	{
    #####:  986:		e_outofmemory(ctx, FLINE);
    #####:  987:		return 0;
        -:  988:	}
    #####:  989:	parent->item = base;
    #####:  990:	parent->nitem++;
    #####:  991:	return &parent->item[n];
        -:  992:}
        -:  993:
        -:  994:/* Create an array in an array
        -:  995: */
    #####:  996:static toml_array_t* create_array_in_array(context_t* ctx, toml_array_t* parent)
        -:  997:{
    #####:  998:	const int n = parent->nitem;
    #####:  999:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####: 1000:	if (!base)
        -: 1001:	{
    #####: 1002:		e_outofmemory(ctx, FLINE);
    #####: 1003:		return 0;
        -: 1004:	}
    #####: 1005:	toml_array_t* ret = (toml_array_t*)CALLOC(1, sizeof(toml_array_t));
    #####: 1006:	if (!ret)
        -: 1007:	{
    #####: 1008:		e_outofmemory(ctx, FLINE);
    #####: 1009:		return 0;
        -: 1010:	}
    #####: 1011:	base[n].arr = ret;
    #####: 1012:	parent->item = base;
    #####: 1013:	parent->nitem++;
    #####: 1014:	return ret;
        -: 1015:}
        -: 1016:
        -: 1017:/* Create a table in an array
        -: 1018: */
    #####: 1019:static toml_table_t* create_table_in_array(context_t* ctx, toml_array_t* parent)
        -: 1020:{
    #####: 1021:	int n = parent->nitem;
    #####: 1022:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####: 1023:	if (!base)
        -: 1024:	{
    #####: 1025:		e_outofmemory(ctx, FLINE);
    #####: 1026:		return 0;
        -: 1027:	}
    #####: 1028:	toml_table_t* ret = (toml_table_t*)CALLOC(1, sizeof(toml_table_t));
    #####: 1029:	if (!ret)
        -: 1030:	{
    #####: 1031:		e_outofmemory(ctx, FLINE);
    #####: 1032:		return 0;
        -: 1033:	}
    #####: 1034:	base[n].tab = ret;
    #####: 1035:	parent->item = base;
    #####: 1036:	parent->nitem++;
    #####: 1037:	return ret;
        -: 1038:}
        -: 1039:
    #####: 1040:static int skip_newlines(context_t* ctx, int isdotspecial)
        -: 1041:{
    #####: 1042:	while (ctx->tok.tok == NEWLINE)
        -: 1043:	{
    #####: 1044:		if (next_token(ctx, isdotspecial))
    #####: 1045:			return -1;
    #####: 1046:		if (ctx->tok.eof)
    #####: 1047:			break;
        -: 1048:	}
    #####: 1049:	return 0;
        -: 1050:}
        -: 1051:
        -: 1052:static int parse_keyval(context_t* ctx, toml_table_t* tab);
        -: 1053:
    #####: 1054:static inline int eat_token(context_t* ctx, tokentype_t typ, int isdotspecial,
        -: 1055:			    const char* fline)
        -: 1056:{
    #####: 1057:	if (ctx->tok.tok != typ)
    #####: 1058:		return e_internal(ctx, fline);
        -: 1059:
    #####: 1060:	if (next_token(ctx, isdotspecial))
    #####: 1061:		return -1;
        -: 1062:
    #####: 1063:	return 0;
        -: 1064:}
        -: 1065:
        -: 1066:/* We are at '{ ... }'.
        -: 1067: * Parse the table.
        -: 1068: */
    #####: 1069:static int parse_inline_table(context_t* ctx, toml_table_t* tab)
        -: 1070:{
    #####: 1071:	if (eat_token(ctx, LBRACE, 1, FLINE))
    #####: 1072:		return -1;
        -: 1073:
        -: 1074:	for (;;)
        -: 1075:	{
    #####: 1076:		if (ctx->tok.tok == NEWLINE)
    #####: 1077:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1078:					"newline not allowed in inline table");
        -: 1079:
        -: 1080:		/* until } */
    #####: 1081:		if (ctx->tok.tok == RBRACE)
    #####: 1082:			break;
        -: 1083:
    #####: 1084:		if (ctx->tok.tok != STRING)
    #####: 1085:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1086:					"expect a string");
        -: 1087:
    #####: 1088:		if (parse_keyval(ctx, tab))
    #####: 1089:			return -1;
        -: 1090:
    #####: 1091:		if (ctx->tok.tok == NEWLINE)
    #####: 1092:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1093:					"newline not allowed in inline table");
        -: 1094:
        -: 1095:		/* on comma, continue to scan for next keyval */
    #####: 1096:		if (ctx->tok.tok == COMMA)
        -: 1097:		{
    #####: 1098:			if (eat_token(ctx, COMMA, 1, FLINE))
    #####: 1099:				return -1;
    #####: 1100:			continue;
        -: 1101:		}
    #####: 1102:		break;
        -: 1103:	}
        -: 1104:
    #####: 1105:	if (eat_token(ctx, RBRACE, 1, FLINE))
    #####: 1106:		return -1;
        -: 1107:
    #####: 1108:	tab->readonly = 1;
        -: 1109:
    #####: 1110:	return 0;
        -: 1111:}
        -: 1112:
    #####: 1113:static int valtype(const char* val)
        -: 1114:{
        -: 1115:	toml_timestamp_t ts;
    #####: 1116:	if (*val == '\'' || *val == '"')
    #####: 1117:		return 's';
    #####: 1118:	if (0 == toml_rtob(val, 0))
    #####: 1119:		return 'b';
    #####: 1120:	if (0 == toml_rtoi(val, 0))
    #####: 1121:		return 'i';
    #####: 1122:	if (0 == toml_rtod(val, 0))
    #####: 1123:		return 'd';
    #####: 1124:	if (0 == toml_rtots(val, &ts))
        -: 1125:	{
    #####: 1126:		if (ts.year && ts.hour)
    #####: 1127:			return 'T'; /* timestamp */
    #####: 1128:		if (ts.year)
    #####: 1129:			return 'D'; /* date */
    #####: 1130:		return 't';	    /* time */
        -: 1131:	}
    #####: 1132:	return 'u'; /* unknown */
        -: 1133:}
        -: 1134:
        -: 1135:/* We are at '[...]' */
    #####: 1136:static int parse_array(context_t* ctx, toml_array_t* arr)
        -: 1137:{
    #####: 1138:	if (eat_token(ctx, LBRACKET, 0, FLINE))
    #####: 1139:		return -1;
        -: 1140:
        -: 1141:	for (;;)
        -: 1142:	{
    #####: 1143:		if (skip_newlines(ctx, 0))
    #####: 1144:			return -1;
        -: 1145:
        -: 1146:		/* until ] */
    #####: 1147:		if (ctx->tok.tok == RBRACKET)
    #####: 1148:			break;
        -: 1149:
    #####: 1150:		switch (ctx->tok.tok)
        -: 1151:		{
    #####: 1152:		case STRING:
        -: 1153:		{
        -: 1154:			/* set array kind if this will be the first entry */
    #####: 1155:			if (arr->kind == 0)
    #####: 1156:				arr->kind = 'v';
    #####: 1157:			else if (arr->kind != 'v')
    #####: 1158:				arr->kind = 'm';
        -: 1159:
    #####: 1160:			char* val = ctx->tok.ptr;
    #####: 1161:			int vlen = ctx->tok.len;
        -: 1162:
        -: 1163:			/* make a new value in array */
        -: 1164:			toml_arritem_t* newval =
    #####: 1165:			    create_value_in_array(ctx, arr);
    #####: 1166:			if (!newval)
    #####: 1167:				return e_outofmemory(ctx, FLINE);
        -: 1168:
    #####: 1169:			if (!(newval->val = STRNDUP(val, vlen)))
    #####: 1170:				return e_outofmemory(ctx, FLINE);
        -: 1171:
    #####: 1172:			newval->valtype = valtype(newval->val);
        -: 1173:
        -: 1174:			/* set array type if this is the first entry */
    #####: 1175:			if (arr->nitem == 1)
    #####: 1176:				arr->type = newval->valtype;
    #####: 1177:			else if (arr->type != newval->valtype)
    #####: 1178:				arr->type = 'm'; /* mixed */
        -: 1179:
    #####: 1180:			if (eat_token(ctx, STRING, 0, FLINE))
    #####: 1181:				return -1;
    #####: 1182:			break;
        -: 1183:		}
        -: 1184:
    #####: 1185:		case LBRACKET:
        -: 1186:		{ /* [ [array], [array] ... ] */
        -: 1187:			/* set the array kind if this will be the first entry */
    #####: 1188:			if (arr->kind == 0)
    #####: 1189:				arr->kind = 'a';
    #####: 1190:			else if (arr->kind != 'a')
    #####: 1191:				arr->kind = 'm';
        -: 1192:
    #####: 1193:			toml_array_t* subarr = create_array_in_array(ctx, arr);
    #####: 1194:			if (!subarr)
    #####: 1195:				return -1;
    #####: 1196:			if (parse_array(ctx, subarr))
    #####: 1197:				return -1;
    #####: 1198:			break;
        -: 1199:		}
        -: 1200:
    #####: 1201:		case LBRACE:
        -: 1202:		{ /* [ {table}, {table} ... ] */
        -: 1203:			/* set the array kind if this will be the first entry */
    #####: 1204:			if (arr->kind == 0)
    #####: 1205:				arr->kind = 't';
    #####: 1206:			else if (arr->kind != 't')
    #####: 1207:				arr->kind = 'm';
        -: 1208:
    #####: 1209:			toml_table_t* subtab = create_table_in_array(ctx, arr);
    #####: 1210:			if (!subtab)
    #####: 1211:				return -1;
    #####: 1212:			if (parse_inline_table(ctx, subtab))
    #####: 1213:				return -1;
    #####: 1214:			break;
        -: 1215:		}
        -: 1216:
    #####: 1217:		default:
    #####: 1218:			return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1219:		}
        -: 1220:
    #####: 1221:		if (skip_newlines(ctx, 0))
    #####: 1222:			return -1;
        -: 1223:
        -: 1224:		/* on comma, continue to scan for next element */
    #####: 1225:		if (ctx->tok.tok == COMMA)
        -: 1226:		{
    #####: 1227:			if (eat_token(ctx, COMMA, 0, FLINE))
    #####: 1228:				return -1;
    #####: 1229:			continue;
        -: 1230:		}
    #####: 1231:		break;
        -: 1232:	}
        -: 1233:
    #####: 1234:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1235:		return -1;
    #####: 1236:	return 0;
        -: 1237:}
        -: 1238:
        -: 1239:/* handle lines like these:
        -: 1240:   key = "value"
        -: 1241:   key = [ array ]
        -: 1242:   key = { table }
        -: 1243:*/
    #####: 1244:static int parse_keyval(context_t* ctx, toml_table_t* tab)
        -: 1245:{
    #####: 1246:	if (tab->readonly)
        -: 1247:	{
    #####: 1248:		return e_forbid(ctx, ctx->tok.lineno,
        -: 1249:				"cannot insert new entry into existing table");
        -: 1250:	}
        -: 1251:
    #####: 1252:	token_t key = ctx->tok;
    #####: 1253:	if (eat_token(ctx, STRING, 1, FLINE))
    #####: 1254:		return -1;
        -: 1255:
    #####: 1256:	if (ctx->tok.tok == DOT)
        -: 1257:	{
        -: 1258:		/* handle inline dotted key.
        -: 1259:		   e.g.
        -: 1260:		   physical.color = "orange"
        -: 1261:		   physical.shape = "round"
        -: 1262:		*/
    #####: 1263:		toml_table_t* subtab = 0;
        -: 1264:		{
    #####: 1265:			char* subtabstr = normalize_key(ctx, key);
    #####: 1266:			if (!subtabstr)
    #####: 1267:				return -1;
        -: 1268:
    #####: 1269:			subtab = toml_table_in(tab, subtabstr);
    #####: 1270:			xfree(subtabstr);
        -: 1271:		}
    #####: 1272:		if (!subtab)
        -: 1273:		{
    #####: 1274:			subtab = create_keytable_in_table(ctx, tab, key);
    #####: 1275:			if (!subtab)
    #####: 1276:				return -1;
        -: 1277:		}
    #####: 1278:		if (next_token(ctx, 1))
    #####: 1279:			return -1;
    #####: 1280:		if (parse_keyval(ctx, subtab))
    #####: 1281:			return -1;
    #####: 1282:		return 0;
        -: 1283:	}
        -: 1284:
    #####: 1285:	if (ctx->tok.tok != EQUAL)
        -: 1286:	{
    #####: 1287:		return e_syntax(ctx, ctx->tok.lineno, "missing =");
        -: 1288:	}
        -: 1289:
    #####: 1290:	if (next_token(ctx, 0))
    #####: 1291:		return -1;
        -: 1292:
    #####: 1293:	switch (ctx->tok.tok)
        -: 1294:	{
    #####: 1295:	case STRING:
        -: 1296:	{ /* key = "value" */
    #####: 1297:		toml_keyval_t* keyval = create_keyval_in_table(ctx, tab, key);
    #####: 1298:		if (!keyval)
    #####: 1299:			return -1;
    #####: 1300:		token_t val = ctx->tok;
        -: 1301:
    #####: 1302:		assert(keyval->val == 0);
    #####: 1303:		if (!(keyval->val = STRNDUP(val.ptr, val.len)))
    #####: 1304:			return e_outofmemory(ctx, FLINE);
        -: 1305:
    #####: 1306:		if (next_token(ctx, 1))
    #####: 1307:			return -1;
        -: 1308:
    #####: 1309:		return 0;
        -: 1310:	}
        -: 1311:
    #####: 1312:	case LBRACKET:
        -: 1313:	{ /* key = [ array ] */
    #####: 1314:		toml_array_t* arr = create_keyarray_in_table(ctx, tab, key, 0);
    #####: 1315:		if (!arr)
    #####: 1316:			return -1;
    #####: 1317:		if (parse_array(ctx, arr))
    #####: 1318:			return -1;
    #####: 1319:		return 0;
        -: 1320:	}
        -: 1321:
    #####: 1322:	case LBRACE:
        -: 1323:	{ /* key = { table } */
    #####: 1324:		toml_table_t* nxttab = create_keytable_in_table(ctx, tab, key);
    #####: 1325:		if (!nxttab)
    #####: 1326:			return -1;
    #####: 1327:		if (parse_inline_table(ctx, nxttab))
    #####: 1328:			return -1;
    #####: 1329:		return 0;
        -: 1330:	}
        -: 1331:
    #####: 1332:	default:
    #####: 1333:		return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1334:	}
        -: 1335:	return 0;
        -: 1336:}
        -: 1337:
        -: 1338:typedef struct tabpath_t tabpath_t;
        -: 1339:struct tabpath_t
        -: 1340:{
        -: 1341:	int cnt;
        -: 1342:	token_t key[10];
        -: 1343:};
        -: 1344:
        -: 1345:/* at [x.y.z] or [[x.y.z]]
        -: 1346: * Scan forward and fill tabpath until it enters ] or ]]
        -: 1347: * There will be at least one entry on return.
        -: 1348: */
    #####: 1349:static int fill_tabpath(context_t* ctx)
        -: 1350:{
    #####: 1351:	int lineno = ctx->tok.lineno;
        -: 1352:	int i;
        -: 1353:
        -: 1354:	/* clear tpath */
    #####: 1355:	for (i = 0; i < ctx->tpath.top; i++)
        -: 1356:	{
    #####: 1357:		char** p = &ctx->tpath.key[i];
    #####: 1358:		xfree(*p);
    #####: 1359:		*p = 0;
        -: 1360:	}
    #####: 1361:	ctx->tpath.top = 0;
        -: 1362:
        -: 1363:	for (;;)
    #####: 1364:	{
    #####: 1365:		if (ctx->tpath.top >= 10)
    #####: 1366:			return e_syntax(
        -: 1367:			    ctx, lineno,
        -: 1368:			    "table path is too deep; max allowed is 10.");
        -: 1369:
    #####: 1370:		if (ctx->tok.tok != STRING)
    #####: 1371:			return e_syntax(ctx, lineno, "invalid or missing key");
        -: 1372:
    #####: 1373:		char* key = normalize_key(ctx, ctx->tok);
    #####: 1374:		if (!key)
    #####: 1375:			return -1;
    #####: 1376:		ctx->tpath.tok[ctx->tpath.top] = ctx->tok;
    #####: 1377:		ctx->tpath.key[ctx->tpath.top] = key;
    #####: 1378:		ctx->tpath.top++;
        -: 1379:
    #####: 1380:		if (next_token(ctx, 1))
    #####: 1381:			return -1;
        -: 1382:
    #####: 1383:		if (ctx->tok.tok == RBRACKET)
    #####: 1384:			break;
        -: 1385:
    #####: 1386:		if (ctx->tok.tok != DOT)
    #####: 1387:			return e_syntax(ctx, lineno, "invalid key");
        -: 1388:
    #####: 1389:		if (next_token(ctx, 1))
    #####: 1390:			return -1;
        -: 1391:	}
        -: 1392:
    #####: 1393:	if (ctx->tpath.top <= 0)
    #####: 1394:		return e_syntax(ctx, lineno, "empty table selector");
        -: 1395:
    #####: 1396:	return 0;
        -: 1397:}
        -: 1398:
        -: 1399:/* Walk tabpath from the root, and create new tables on the way.
        -: 1400: * Sets ctx->curtab to the final table.
        -: 1401: */
    #####: 1402:static int walk_tabpath(context_t* ctx)
        -: 1403:{
        -: 1404:	/* start from root */
    #####: 1405:	toml_table_t* curtab = ctx->root;
        -: 1406:
    #####: 1407:	for (int i = 0; i < ctx->tpath.top; i++)
        -: 1408:	{
    #####: 1409:		const char* key = ctx->tpath.key[i];
        -: 1410:
    #####: 1411:		toml_keyval_t* nextval = 0;
    #####: 1412:		toml_array_t* nextarr = 0;
    #####: 1413:		toml_table_t* nexttab = 0;
    #####: 1414:		switch (check_key(curtab, key, &nextval, &nextarr, &nexttab))
        -: 1415:		{
    #####: 1416:		case 't':
        -: 1417:			/* found a table. nexttab is where we will go next. */
    #####: 1418:			break;
        -: 1419:
    #####: 1420:		case 'a':
        -: 1421:			/* found an array. nexttab is the last table in the
        -: 1422:			 * array. */
    #####: 1423:			if (nextarr->kind != 't')
    #####: 1424:				return e_internal(ctx, FLINE);
        -: 1425:
    #####: 1426:			if (nextarr->nitem == 0)
    #####: 1427:				return e_internal(ctx, FLINE);
        -: 1428:
    #####: 1429:			nexttab = nextarr->item[nextarr->nitem - 1].tab;
    #####: 1430:			break;
        -: 1431:
    #####: 1432:		case 'v':
    #####: 1433:			return e_keyexists(ctx, ctx->tpath.tok[i].lineno);
        -: 1434:
    #####: 1435:		default:
        -: 1436:		{ /* Not found. Let's create an implicit table. */
    #####: 1437:			int n = curtab->ntab;
    #####: 1438:			toml_table_t** base = (toml_table_t**)expand_ptrarr(
    #####: 1439:			    (void**)curtab->tab, n);
    #####: 1440:			if (0 == base)
    #####: 1441:				return e_outofmemory(ctx, FLINE);
        -: 1442:
    #####: 1443:			curtab->tab = base;
        -: 1444:
    #####: 1445:			if (0 == (base[n] = (toml_table_t*)CALLOC(1, sizeof(*base[n]))))
    #####: 1446:				return e_outofmemory(ctx, FLINE);
        -: 1447:
    #####: 1448:			if (0 == (base[n]->key = STRDUP(key)))
    #####: 1449:				return e_outofmemory(ctx, FLINE);
        -: 1450:
    #####: 1451:			nexttab = curtab->tab[curtab->ntab++];
        -: 1452:
        -: 1453:			/* tabs created by walk_tabpath are considered implicit
        -: 1454:			 */
    #####: 1455:			nexttab->implicit = true;
        -: 1456:		}
    #####: 1457:		break;
        -: 1458:		}
        -: 1459:
        -: 1460:		/* switch to next tab */
    #####: 1461:		curtab = nexttab;
        -: 1462:	}
        -: 1463:
        -: 1464:	/* save it */
    #####: 1465:	ctx->curtab = curtab;
        -: 1466:
    #####: 1467:	return 0;
        -: 1468:}
        -: 1469:
        -: 1470:/* handle lines like [x.y.z] or [[x.y.z]] */
    #####: 1471:static int parse_select(context_t* ctx)
        -: 1472:{
    #####: 1473:	assert(ctx->tok.tok == LBRACKET);
        -: 1474:
        -: 1475:	/* true if [[ */
    #####: 1476:	int llb = (ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == '[');
        -: 1477:	/* need to detect '[[' on our own because next_token() will skip
        -: 1478:	   whitespace, and '[ [' would be taken as '[[', which is wrong. */
        -: 1479:
        -: 1480:	/* eat [ or [[ */
    #####: 1481:	if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1482:		return -1;
    #####: 1483:	if (llb)
        -: 1484:	{
    #####: 1485:		assert(ctx->tok.tok == LBRACKET);
    #####: 1486:		if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1487:			return -1;
        -: 1488:	}
        -: 1489:
    #####: 1490:	if (fill_tabpath(ctx))
    #####: 1491:		return -1;
        -: 1492:
        -: 1493:	/* For [x.y.z] or [[x.y.z]], remove z from tpath.
        -: 1494:	 */
    #####: 1495:	token_t z = ctx->tpath.tok[ctx->tpath.top - 1];
    #####: 1496:	xfree(ctx->tpath.key[ctx->tpath.top - 1]);
    #####: 1497:	ctx->tpath.top--;
        -: 1498:
        -: 1499:	/* set up ctx->curtab */
    #####: 1500:	if (walk_tabpath(ctx))
    #####: 1501:		return -1;
        -: 1502:
    #####: 1503:	if (!llb)
        -: 1504:	{
        -: 1505:		/* [x.y.z] -> create z = {} in x.y */
        -: 1506:		toml_table_t* curtab =
    #####: 1507:		    create_keytable_in_table(ctx, ctx->curtab, z);
    #####: 1508:		if (!curtab)
    #####: 1509:			return -1;
    #####: 1510:		ctx->curtab = curtab;
        -: 1511:	}
        -: 1512:	else
        -: 1513:	{
        -: 1514:		/* [[x.y.z]] -> create z = [] in x.y */
    #####: 1515:		toml_array_t* arr = 0;
        -: 1516:		{
    #####: 1517:			char* zstr = normalize_key(ctx, z);
    #####: 1518:			if (!zstr)
    #####: 1519:				return -1;
    #####: 1520:			arr = toml_array_in(ctx->curtab, zstr);
    #####: 1521:			xfree(zstr);
        -: 1522:		}
    #####: 1523:		if (!arr)
        -: 1524:		{
        -: 1525:			arr =
    #####: 1526:			    create_keyarray_in_table(ctx, ctx->curtab, z, 't');
    #####: 1527:			if (!arr)
    #####: 1528:				return -1;
        -: 1529:		}
    #####: 1530:		if (arr->kind != 't')
    #####: 1531:			return e_syntax(ctx, z.lineno, "array mismatch");
        -: 1532:
        -: 1533:		/* add to z[] */
        -: 1534:		toml_table_t* dest;
        -: 1535:		{
    #####: 1536:			toml_table_t* t = create_table_in_array(ctx, arr);
    #####: 1537:			if (!t)
    #####: 1538:				return -1;
        -: 1539:
    #####: 1540:			if (0 == (t->key = STRDUP("__anon__")))
    #####: 1541:				return e_outofmemory(ctx, FLINE);
        -: 1542:
    #####: 1543:			dest = t;
        -: 1544:		}
        -: 1545:
    #####: 1546:		ctx->curtab = dest;
        -: 1547:	}
        -: 1548:
    #####: 1549:	if (ctx->tok.tok != RBRACKET)
        -: 1550:	{
    #####: 1551:		return e_syntax(ctx, ctx->tok.lineno, "expects ]");
        -: 1552:	}
    #####: 1553:	if (llb)
        -: 1554:	{
    #####: 1555:		if (!(ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == ']'))
        -: 1556:		{
    #####: 1557:			return e_syntax(ctx, ctx->tok.lineno, "expects ]]");
        -: 1558:		}
    #####: 1559:		if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1560:			return -1;
        -: 1561:	}
        -: 1562:
    #####: 1563:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1564:		return -1;
        -: 1565:
    #####: 1566:	if (ctx->tok.tok != NEWLINE)
    #####: 1567:		return e_syntax(ctx, ctx->tok.lineno,
        -: 1568:				"extra chars after ] or ]]");
        -: 1569:
    #####: 1570:	return 0;
        -: 1571:}
        -: 1572:
    #####: 1573:toml_table_t* toml_parse(char* conf, char* errbuf, int errbufsz)
        -: 1574:{
        -: 1575:	context_t ctx;
        -: 1576:
        -: 1577:	// clear errbuf
    #####: 1578:	if (errbufsz <= 0)
    #####: 1579:		errbufsz = 0;
    #####: 1580:	if (errbufsz > 0)
    #####: 1581:		errbuf[0] = 0;
        -: 1582:
        -: 1583:	// init context
    #####: 1584:	memset(&ctx, 0, sizeof(ctx));
    #####: 1585:	ctx.start = conf;
    #####: 1586:	ctx.stop = ctx.start + strlen(conf);
    #####: 1587:	ctx.errbuf = errbuf;
    #####: 1588:	ctx.errbufsz = errbufsz;
        -: 1589:
        -: 1590:	// start with an artificial newline of length 0
    #####: 1591:	ctx.tok.tok = NEWLINE;
    #####: 1592:	ctx.tok.lineno = 1;
    #####: 1593:	ctx.tok.ptr = conf;
    #####: 1594:	ctx.tok.len = 0;
        -: 1595:
        -: 1596:	// make a root table
    #####: 1597:	if (0 == (ctx.root = CALLOC(1, sizeof(*ctx.root))))
        -: 1598:	{
    #####: 1599:		e_outofmemory(&ctx, FLINE);
        -: 1600:		// Do not goto fail, root table not set up yet
    #####: 1601:		return 0;
        -: 1602:	}
        -: 1603:
        -: 1604:	// set root as default table
    #####: 1605:	ctx.curtab = ctx.root;
        -: 1606:
        -: 1607:	/* Scan forward until EOF */
    #####: 1608:	for (token_t tok = ctx.tok; !tok.eof; tok = ctx.tok)
        -: 1609:	{
    #####: 1610:		switch (tok.tok)
        -: 1611:		{
        -: 1612:
    #####: 1613:		case NEWLINE:
    #####: 1614:			if (next_token(&ctx, 1))
    #####: 1615:				goto fail;
    #####: 1616:			break;
        -: 1617:
    #####: 1618:		case STRING:
    #####: 1619:			if (parse_keyval(&ctx, ctx.curtab))
    #####: 1620:				goto fail;
        -: 1621:
    #####: 1622:			if (ctx.tok.tok != NEWLINE)
        -: 1623:			{
    #####: 1624:				e_syntax(&ctx, ctx.tok.lineno,
        -: 1625:					 "extra chars after value");
    #####: 1626:				goto fail;
        -: 1627:			}
        -: 1628:
    #####: 1629:			if (eat_token(&ctx, NEWLINE, 1, FLINE))
    #####: 1630:				goto fail;
    #####: 1631:			break;
        -: 1632:
    #####: 1633:		case LBRACKET: /* [ x.y.z ] or [[ x.y.z ]] */
    #####: 1634:			if (parse_select(&ctx))
    #####: 1635:				goto fail;
    #####: 1636:			break;
        -: 1637:
    #####: 1638:		default:
    #####: 1639:			e_syntax(&ctx, tok.lineno, "syntax error");
    #####: 1640:			goto fail;
        -: 1641:		}
        -: 1642:	}
        -: 1643:
        -: 1644:	/* success */
    #####: 1645:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1646:		xfree(ctx.tpath.key[i]);
    #####: 1647:	return ctx.root;
        -: 1648:
    #####: 1649:fail:
        -: 1650:	// Something bad has happened. Free resources and return error.
    #####: 1651:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1652:		xfree(ctx.tpath.key[i]);
    #####: 1653:	toml_free(ctx.root);
    #####: 1654:	return 0;
        -: 1655:}
        -: 1656:
    #####: 1657:toml_table_t* toml_parse_file(FILE* fp, char* errbuf, int errbufsz)
        -: 1658:{
    #####: 1659:	int bufsz = 0;
    #####: 1660:	char* buf = 0;
    #####: 1661:	int off = 0;
        -: 1662:
        -: 1663:	/* read from fp into buf */
    #####: 1664:	while (!feof(fp))
        -: 1665:	{
        -: 1666:
    #####: 1667:		if (off == bufsz)
        -: 1668:		{
    #####: 1669:			int xsz = bufsz + 1000;
    #####: 1670:			char* x = expand(buf, bufsz, xsz);
    #####: 1671:			if (!x)
        -: 1672:			{
    #####: 1673:				snprintf(errbuf, errbufsz, "out of memory");
    #####: 1674:				xfree(buf);
    #####: 1675:				return 0;
        -: 1676:			}
    #####: 1677:			buf = x;
    #####: 1678:			bufsz = xsz;
        -: 1679:		}
        -: 1680:
    #####: 1681:		errno = 0;
    #####: 1682:		int n = fread(buf + off, 1, bufsz - off, fp);
    #####: 1683:		if (ferror(fp))
        -: 1684:		{
    #####: 1685:			snprintf(errbuf, errbufsz, "%s",
    #####: 1686:				 errno ? strerror(errno)
        -: 1687:				       : "Error reading file");
    #####: 1688:			xfree(buf);
    #####: 1689:			return 0;
        -: 1690:		}
    #####: 1691:		off += n;
        -: 1692:	}
        -: 1693:
        -: 1694:	/* tag on a NUL to cap the string */
    #####: 1695:	if (off == bufsz)
        -: 1696:	{
    #####: 1697:		int xsz = bufsz + 1;
    #####: 1698:		char* x = expand(buf, bufsz, xsz);
    #####: 1699:		if (!x)
        -: 1700:		{
    #####: 1701:			snprintf(errbuf, errbufsz, "out of memory");
    #####: 1702:			xfree(buf);
    #####: 1703:			return 0;
        -: 1704:		}
    #####: 1705:		buf = x;
    #####: 1706:		bufsz = xsz;
        -: 1707:	}
    #####: 1708:	buf[off] = 0;
        -: 1709:
        -: 1710:	/* parse it, cleanup and finish */
    #####: 1711:	toml_table_t* ret = toml_parse(buf, errbuf, errbufsz);
    #####: 1712:	xfree(buf);
    #####: 1713:	return ret;
        -: 1714:}
        -: 1715:
    #####: 1716:static void xfree_kval(toml_keyval_t* p)
        -: 1717:{
    #####: 1718:	if (!p)
    #####: 1719:		return;
    #####: 1720:	xfree(p->key);
    #####: 1721:	xfree(p->val);
    #####: 1722:	xfree(p);
        -: 1723:}
        -: 1724:
        -: 1725:static void xfree_tab(toml_table_t* p);
        -: 1726:
    #####: 1727:static void xfree_arr(toml_array_t* p)
        -: 1728:{
    #####: 1729:	if (!p)
    #####: 1730:		return;
        -: 1731:
    #####: 1732:	xfree(p->key);
    #####: 1733:	const int n = p->nitem;
    #####: 1734:	for (int i = 0; i < n; i++)
        -: 1735:	{
    #####: 1736:		toml_arritem_t* a = &p->item[i];
    #####: 1737:		if (a->val)
    #####: 1738:			xfree(a->val);
    #####: 1739:		else if (a->arr)
    #####: 1740:			xfree_arr(a->arr);
    #####: 1741:		else if (a->tab)
    #####: 1742:			xfree_tab(a->tab);
        -: 1743:	}
    #####: 1744:	xfree(p->item);
    #####: 1745:	xfree(p);
        -: 1746:}
        -: 1747:
    #####: 1748:static void xfree_tab(toml_table_t* p)
        -: 1749:{
        -: 1750:	int i;
        -: 1751:
    #####: 1752:	if (!p)
    #####: 1753:		return;
        -: 1754:
    #####: 1755:	xfree(p->key);
        -: 1756:
    #####: 1757:	for (i = 0; i < p->nkval; i++)
    #####: 1758:		xfree_kval(p->kval[i]);
    #####: 1759:	xfree(p->kval);
        -: 1760:
    #####: 1761:	for (i = 0; i < p->narr; i++)
    #####: 1762:		xfree_arr(p->arr[i]);
    #####: 1763:	xfree(p->arr);
        -: 1764:
    #####: 1765:	for (i = 0; i < p->ntab; i++)
    #####: 1766:		xfree_tab(p->tab[i]);
    #####: 1767:	xfree(p->tab);
        -: 1768:
    #####: 1769:	xfree(p);
        -: 1770:}
        -: 1771:
    #####: 1772:void toml_free(toml_table_t* tab) { xfree_tab(tab); }
        -: 1773:
    #####: 1774:static void set_token(context_t* ctx, tokentype_t tok, int lineno, char* ptr,
        -: 1775:		      int len)
        -: 1776:{
        -: 1777:	token_t t;
    #####: 1778:	t.tok = tok;
    #####: 1779:	t.lineno = lineno;
    #####: 1780:	t.ptr = ptr;
    #####: 1781:	t.len = len;
    #####: 1782:	t.eof = 0;
    #####: 1783:	ctx->tok = t;
    #####: 1784:}
        -: 1785:
    #####: 1786:static void set_eof(context_t* ctx, int lineno)
        -: 1787:{
    #####: 1788:	set_token(ctx, NEWLINE, lineno, ctx->stop, 0);
    #####: 1789:	ctx->tok.eof = 1;
    #####: 1790:}
        -: 1791:
        -: 1792:/* Scan p for n digits compositing entirely of [0-9] */
    #####: 1793:static int scan_digits(const char* p, int n)
        -: 1794:{
    #####: 1795:	int ret = 0;
    #####: 1796:	for (; n > 0 && isdigit(*p); n--, p++)
        -: 1797:	{
    #####: 1798:		ret = 10 * ret + (*p - '0');
        -: 1799:	}
    #####: 1800:	return n ? -1 : ret;
        -: 1801:}
        -: 1802:
    #####: 1803:static int scan_date(const char* p, int* YY, int* MM, int* DD)
        -: 1804:{
        -: 1805:	int year, month, day;
    #####: 1806:	year = scan_digits(p, 4);
    #####: 1807:	month = (year >= 0 && p[4] == '-') ? scan_digits(p + 5, 2) : -1;
    #####: 1808:	day = (month >= 0 && p[7] == '-') ? scan_digits(p + 8, 2) : -1;
    #####: 1809:	if (YY)
    #####: 1810:		*YY = year;
    #####: 1811:	if (MM)
    #####: 1812:		*MM = month;
    #####: 1813:	if (DD)
    #####: 1814:		*DD = day;
    #####: 1815:	return (year >= 0 && month >= 0 && day >= 0) ? 0 : -1;
        -: 1816:}
        -: 1817:
    #####: 1818:static int scan_time(const char* p, int* hh, int* mm, int* ss)
        -: 1819:{
        -: 1820:	int hour, minute, second;
    #####: 1821:	hour = scan_digits(p, 2);
    #####: 1822:	minute = (hour >= 0 && p[2] == ':') ? scan_digits(p + 3, 2) : -1;
    #####: 1823:	second = (minute >= 0 && p[5] == ':') ? scan_digits(p + 6, 2) : -1;
    #####: 1824:	if (hh)
    #####: 1825:		*hh = hour;
    #####: 1826:	if (mm)
    #####: 1827:		*mm = minute;
    #####: 1828:	if (ss)
    #####: 1829:		*ss = second;
    #####: 1830:	return (hour >= 0 && minute >= 0 && second >= 0) ? 0 : -1;
        -: 1831:}
        -: 1832:
    #####: 1833:static int scan_string(context_t* ctx, char* p, int lineno, int dotisspecial)
        -: 1834:{
    #####: 1835:	char* orig = p;
    #####: 1836:	if (0 == strncmp(p, "'''", 3))
        -: 1837:	{
    #####: 1838:		char* q = p + 3;
        -: 1839:
        -: 1840:		while (1)
        -: 1841:		{
    #####: 1842:			q = strstr(q, "'''");
    #####: 1843:			if (0 == q)
        -: 1844:			{
    #####: 1845:				return e_syntax(ctx, lineno,
        -: 1846:						"unterminated triple-s-quote");
        -: 1847:			}
    #####: 1848:			while (q[3] == '\'')
    #####: 1849:				q++;
    #####: 1850:			break;
        -: 1851:		}
        -: 1852:
    #####: 1853:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1854:		return 0;
        -: 1855:	}
        -: 1856:
    #####: 1857:	if (0 == strncmp(p, "\"\"\"", 3))
        -: 1858:	{
    #####: 1859:		char* q = p + 3;
        -: 1860:
        -: 1861:		while (1)
        -: 1862:		{
    #####: 1863:			q = strstr(q, "\"\"\"");
    #####: 1864:			if (0 == q)
        -: 1865:			{
    #####: 1866:				return e_syntax(ctx, lineno,
        -: 1867:						"unterminated triple-d-quote");
        -: 1868:			}
    #####: 1869:			if (q[-1] == '\\')
        -: 1870:			{
    #####: 1871:				q++;
    #####: 1872:				continue;
        -: 1873:			}
    #####: 1874:			while (q[3] == '\"')
    #####: 1875:				q++;
    #####: 1876:			break;
        -: 1877:		}
        -: 1878:
        -: 1879:		// the string is [p+3, q-1]
        -: 1880:
    #####: 1881:		int hexreq = 0; /* #hex required */
    #####: 1882:		int escape = 0;
    #####: 1883:		for (p += 3; p < q; p++)
        -: 1884:		{
    #####: 1885:			if (escape)
        -: 1886:			{
    #####: 1887:				escape = 0;
    #####: 1888:				if (strchr("btnfr\"\\", *p))
    #####: 1889:					continue;
    #####: 1890:				if (*p == 'u')
        -: 1891:				{
    #####: 1892:					hexreq = 4;
    #####: 1893:					continue;
        -: 1894:				}
    #####: 1895:				if (*p == 'U')
        -: 1896:				{
    #####: 1897:					hexreq = 8;
    #####: 1898:					continue;
        -: 1899:				}
    #####: 1900:				if (p[strspn(p, " \t\r")] == '\n')
    #####: 1901:					continue; /* allow for line ending
        -: 1902:						     backslash */
    #####: 1903:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1904:			}
    #####: 1905:			if (hexreq)
        -: 1906:			{
    #####: 1907:				hexreq--;
    #####: 1908:				if (strchr("0123456789ABCDEF", *p))
    #####: 1909:					continue;
    #####: 1910:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1911:			}
    #####: 1912:			if (*p == '\\')
        -: 1913:			{
    #####: 1914:				escape = 1;
    #####: 1915:				continue;
        -: 1916:			}
        -: 1917:		}
    #####: 1918:		if (escape)
    #####: 1919:			return e_syntax(ctx, lineno, "expect an escape char");
    #####: 1920:		if (hexreq)
    #####: 1921:			return e_syntax(ctx, lineno, "expected more hex char");
        -: 1922:
    #####: 1923:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1924:		return 0;
        -: 1925:	}
        -: 1926:
    #####: 1927:	if ('\'' == *p)
        -: 1928:	{
    #####: 1929:		for (p++; *p && *p != '\n' && *p != '\''; p++)
        -: 1930:			;
    #####: 1931:		if (*p != '\'')
        -: 1932:		{
    #####: 1933:			return e_syntax(ctx, lineno, "unterminated s-quote");
        -: 1934:		}
        -: 1935:
    #####: 1936:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1937:		return 0;
        -: 1938:	}
        -: 1939:
    #####: 1940:	if ('\"' == *p)
        -: 1941:	{
    #####: 1942:		int hexreq = 0; /* #hex required */
    #####: 1943:		int escape = 0;
    #####: 1944:		for (p++; *p; p++)
        -: 1945:		{
    #####: 1946:			if (escape)
        -: 1947:			{
    #####: 1948:				escape = 0;
    #####: 1949:				if (strchr("btnfr\"\\", *p))
    #####: 1950:					continue;
    #####: 1951:				if (*p == 'u')
        -: 1952:				{
    #####: 1953:					hexreq = 4;
    #####: 1954:					continue;
        -: 1955:				}
    #####: 1956:				if (*p == 'U')
        -: 1957:				{
    #####: 1958:					hexreq = 8;
    #####: 1959:					continue;
        -: 1960:				}
    #####: 1961:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1962:			}
    #####: 1963:			if (hexreq)
        -: 1964:			{
    #####: 1965:				hexreq--;
    #####: 1966:				if (strchr("0123456789ABCDEF", *p))
    #####: 1967:					continue;
    #####: 1968:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1969:			}
    #####: 1970:			if (*p == '\\')
        -: 1971:			{
    #####: 1972:				escape = 1;
    #####: 1973:				continue;
        -: 1974:			}
    #####: 1975:			if (*p == '\'')
        -: 1976:			{
    #####: 1977:				if (p[1] == '\'' && p[2] == '\'')
        -: 1978:				{
    #####: 1979:					return e_syntax(
        -: 1980:					    ctx, lineno,
        -: 1981:					    "triple-s-quote inside string lit");
        -: 1982:				}
    #####: 1983:				continue;
        -: 1984:			}
    #####: 1985:			if (*p == '\n')
    #####: 1986:				break;
    #####: 1987:			if (*p == '"')
    #####: 1988:				break;
        -: 1989:		}
    #####: 1990:		if (*p != '"')
        -: 1991:		{
    #####: 1992:			return e_syntax(ctx, lineno, "unterminated quote");
        -: 1993:		}
        -: 1994:
    #####: 1995:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1996:		return 0;
        -: 1997:	}
        -: 1998:
        -: 1999:	/* check for timestamp without quotes */
    #####: 2000:	if (0 == scan_date(p, 0, 0, 0) || 0 == scan_time(p, 0, 0, 0))
        -: 2001:	{
        -: 2002:		// forward thru the timestamp
    #####: 2003:		p += strspn(p, "0123456789.:+-Tt Zz");
        -: 2004:		// squeeze out any spaces at end of string
    #####: 2005:		for (; p[-1] == ' '; p--)
        -: 2006:			;
        -: 2007:		// tokenize
    #####: 2008:		set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 2009:		return 0;
        -: 2010:	}
        -: 2011:
        -: 2012:	/* literals */
    #####: 2013:	for (; *p && *p != '\n'; p++)
        -: 2014:	{
    #####: 2015:		int ch = *p;
    #####: 2016:		if (ch == '.' && dotisspecial)
    #####: 2017:			break;
    #####: 2018:		if ('A' <= ch && ch <= 'Z')
    #####: 2019:			continue;
    #####: 2020:		if ('a' <= ch && ch <= 'z')
    #####: 2021:			continue;
    #####: 2022:		if (strchr("0123456789+-_.", ch))
    #####: 2023:			continue;
    #####: 2024:		break;
        -: 2025:	}
        -: 2026:
    #####: 2027:	set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 2028:	return 0;
        -: 2029:}
        -: 2030:
    #####: 2031:static int next_token(context_t* ctx, int dotisspecial)
        -: 2032:{
    #####: 2033:	int lineno = ctx->tok.lineno;
    #####: 2034:	char* p = ctx->tok.ptr;
        -: 2035:	int i;
        -: 2036:
        -: 2037:	/* eat this tok */
    #####: 2038:	for (i = 0; i < ctx->tok.len; i++)
        -: 2039:	{
    #####: 2040:		if (*p++ == '\n')
    #####: 2041:			lineno++;
        -: 2042:	}
        -: 2043:
        -: 2044:	/* make next tok */
    #####: 2045:	while (p < ctx->stop)
        -: 2046:	{
        -: 2047:		/* skip comment. stop just before the \n. */
    #####: 2048:		if (*p == '#')
        -: 2049:		{
    #####: 2050:			for (p++; p < ctx->stop && *p != '\n'; p++)
        -: 2051:				;
    #####: 2052:			continue;
        -: 2053:		}
        -: 2054:
    #####: 2055:		if (dotisspecial && *p == '.')
        -: 2056:		{
    #####: 2057:			set_token(ctx, DOT, lineno, p, 1);
    #####: 2058:			return 0;
        -: 2059:		}
        -: 2060:
    #####: 2061:		switch (*p)
        -: 2062:		{
    #####: 2063:		case ',':
    #####: 2064:			set_token(ctx, COMMA, lineno, p, 1);
    #####: 2065:			return 0;
    #####: 2066:		case '=':
    #####: 2067:			set_token(ctx, EQUAL, lineno, p, 1);
    #####: 2068:			return 0;
    #####: 2069:		case '{':
    #####: 2070:			set_token(ctx, LBRACE, lineno, p, 1);
    #####: 2071:			return 0;
    #####: 2072:		case '}':
    #####: 2073:			set_token(ctx, RBRACE, lineno, p, 1);
    #####: 2074:			return 0;
    #####: 2075:		case '[':
    #####: 2076:			set_token(ctx, LBRACKET, lineno, p, 1);
    #####: 2077:			return 0;
    #####: 2078:		case ']':
    #####: 2079:			set_token(ctx, RBRACKET, lineno, p, 1);
    #####: 2080:			return 0;
    #####: 2081:		case '\n':
    #####: 2082:			set_token(ctx, NEWLINE, lineno, p, 1);
    #####: 2083:			return 0;
    #####: 2084:		case '\r':
        -: 2085:		case ' ':
        -: 2086:		case '\t':
        -: 2087:			/* ignore white spaces */
    #####: 2088:			p++;
    #####: 2089:			continue;
        -: 2090:		}
        -: 2091:
    #####: 2092:		return scan_string(ctx, p, lineno, dotisspecial);
        -: 2093:	}
        -: 2094:
    #####: 2095:	set_eof(ctx, lineno);
    #####: 2096:	return 0;
        -: 2097:}
        -: 2098:
    #####: 2099:const char* toml_key_in(const toml_table_t* tab, int keyidx)
        -: 2100:{
    #####: 2101:	if (keyidx < tab->nkval)
    #####: 2102:		return tab->kval[keyidx]->key;
        -: 2103:
    #####: 2104:	keyidx -= tab->nkval;
    #####: 2105:	if (keyidx < tab->narr)
    #####: 2106:		return tab->arr[keyidx]->key;
        -: 2107:
    #####: 2108:	keyidx -= tab->narr;
    #####: 2109:	if (keyidx < tab->ntab)
    #####: 2110:		return tab->tab[keyidx]->key;
        -: 2111:
    #####: 2112:	return 0;
        -: 2113:}
        -: 2114:
    #####: 2115:int toml_key_exists(const toml_table_t* tab, const char* key)
        -: 2116:{
        -: 2117:	int i;
    #####: 2118:	for (i = 0; i < tab->nkval; i++)
        -: 2119:	{
    #####: 2120:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 2121:			return 1;
        -: 2122:	}
    #####: 2123:	for (i = 0; i < tab->narr; i++)
        -: 2124:	{
    #####: 2125:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 2126:			return 1;
        -: 2127:	}
    #####: 2128:	for (i = 0; i < tab->ntab; i++)
        -: 2129:	{
    #####: 2130:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 2131:			return 1;
        -: 2132:	}
    #####: 2133:	return 0;
        -: 2134:}
        -: 2135:
    #####: 2136:toml_raw_t toml_raw_in(const toml_table_t* tab, const char* key)
        -: 2137:{
        -: 2138:	int i;
    #####: 2139:	for (i = 0; i < tab->nkval; i++)
        -: 2140:	{
    #####: 2141:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 2142:			return tab->kval[i]->val;
        -: 2143:	}
    #####: 2144:	return 0;
        -: 2145:}
        -: 2146:
    #####: 2147:toml_array_t* toml_array_in(const toml_table_t* tab, const char* key)
        -: 2148:{
        -: 2149:	int i;
    #####: 2150:	for (i = 0; i < tab->narr; i++)
        -: 2151:	{
    #####: 2152:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 2153:			return tab->arr[i];
        -: 2154:	}
    #####: 2155:	return 0;
        -: 2156:}
        -: 2157:
    #####: 2158:toml_table_t* toml_table_in(const toml_table_t* tab, const char* key)
        -: 2159:{
        -: 2160:	int i;
    #####: 2161:	for (i = 0; i < tab->ntab; i++)
        -: 2162:	{
    #####: 2163:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 2164:			return tab->tab[i];
        -: 2165:	}
    #####: 2166:	return 0;
        -: 2167:}
        -: 2168:
    #####: 2169:toml_raw_t toml_raw_at(const toml_array_t* arr, int idx)
        -: 2170:{
    #####: 2171:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].val : 0;
        -: 2172:}
        -: 2173:
    #####: 2174:char toml_array_kind(const toml_array_t* arr) { return arr->kind; }
        -: 2175:
    #####: 2176:char toml_array_type(const toml_array_t* arr)
        -: 2177:{
    #####: 2178:	if (arr->kind != 'v')
    #####: 2179:		return 0;
        -: 2180:
    #####: 2181:	if (arr->nitem == 0)
    #####: 2182:		return 0;
        -: 2183:
    #####: 2184:	return arr->type;
        -: 2185:}
        -: 2186:
    #####: 2187:int toml_array_nelem(const toml_array_t* arr) { return arr->nitem; }
        -: 2188:
    #####: 2189:const char* toml_array_key(const toml_array_t* arr)
        -: 2190:{
    #####: 2191:	return arr ? arr->key : (const char*)NULL;
        -: 2192:}
        -: 2193:
    #####: 2194:int toml_table_nkval(const toml_table_t* tab) { return tab->nkval; }
        -: 2195:
    #####: 2196:int toml_table_narr(const toml_table_t* tab) { return tab->narr; }
        -: 2197:
    #####: 2198:int toml_table_ntab(const toml_table_t* tab) { return tab->ntab; }
        -: 2199:
    #####: 2200:const char* toml_table_key(const toml_table_t* tab)
        -: 2201:{
    #####: 2202:	return tab ? tab->key : (const char*)NULL;
        -: 2203:}
        -: 2204:
    #####: 2205:toml_array_t* toml_array_at(const toml_array_t* arr, int idx)
        -: 2206:{
    #####: 2207:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].arr : 0;
        -: 2208:}
        -: 2209:
    #####: 2210:toml_table_t* toml_table_at(const toml_array_t* arr, int idx)
        -: 2211:{
    #####: 2212:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].tab : 0;
        -: 2213:}
        -: 2214:
        -: 2215:static int parse_millisec(const char* p, const char** endp);
        -: 2216:
    #####: 2217:int toml_rtots(toml_raw_t src_, toml_timestamp_t* ret)
        -: 2218:{
    #####: 2219:	if (!src_)
    #####: 2220:		return -1;
        -: 2221:
    #####: 2222:	const char* p = src_;
    #####: 2223:	int must_parse_time = 0;
        -: 2224:
    #####: 2225:	memset(ret, 0, sizeof(*ret));
        -: 2226:
    #####: 2227:	int* year = &ret->__buffer.year;
    #####: 2228:	int* month = &ret->__buffer.month;
    #####: 2229:	int* day = &ret->__buffer.day;
    #####: 2230:	int* hour = &ret->__buffer.hour;
    #####: 2231:	int* minute = &ret->__buffer.minute;
    #####: 2232:	int* second = &ret->__buffer.second;
    #####: 2233:	int* millisec = &ret->__buffer.millisec;
        -: 2234:
        -: 2235:	/* parse date YYYY-MM-DD */
    #####: 2236:	if (0 == scan_date(p, year, month, day))
        -: 2237:	{
    #####: 2238:		ret->year = year;
    #####: 2239:		ret->month = month;
    #####: 2240:		ret->day = day;
        -: 2241:
    #####: 2242:		p += 10;
    #####: 2243:		if (*p)
        -: 2244:		{
        -: 2245:			// parse the T or space separator
    #####: 2246:			if (*p != 'T' && *p != 't' && *p != ' ')
    #####: 2247:				return -1;
    #####: 2248:			must_parse_time = 1;
    #####: 2249:			p++;
        -: 2250:		}
        -: 2251:	}
        -: 2252:
        -: 2253:	/* parse time HH:MM:SS */
    #####: 2254:	if (0 == scan_time(p, hour, minute, second))
        -: 2255:	{
    #####: 2256:		ret->hour = hour;
    #####: 2257:		ret->minute = minute;
    #####: 2258:		ret->second = second;
        -: 2259:
        -: 2260:		/* optionally, parse millisec */
    #####: 2261:		p += 8;
    #####: 2262:		if (*p == '.')
        -: 2263:		{
    #####: 2264:			p++; /* skip '.' */
        -: 2265:			const char* qq;
    #####: 2266:			*millisec = parse_millisec(p, &qq);
    #####: 2267:			ret->millisec = millisec;
    #####: 2268:			p = qq;
        -: 2269:		}
        -: 2270:
    #####: 2271:		if (*p)
        -: 2272:		{
        -: 2273:			/* parse and copy Z */
    #####: 2274:			char* z = ret->__buffer.z;
    #####: 2275:			ret->z = z;
    #####: 2276:			if (*p == 'Z' || *p == 'z')
        -: 2277:			{
    #####: 2278:				*z++ = 'Z';
    #####: 2279:				p++;
    #####: 2280:				*z = 0;
        -: 2281:			}
    #####: 2282:			else if (*p == '+' || *p == '-')
        -: 2283:			{
    #####: 2284:				*z++ = *p++;
        -: 2285:
    #####: 2286:				if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2287:					return -1;
    #####: 2288:				*z++ = *p++;
    #####: 2289:				*z++ = *p++;
        -: 2290:
    #####: 2291:				if (*p == ':')
        -: 2292:				{
    #####: 2293:					*z++ = *p++;
        -: 2294:
    #####: 2295:					if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2296:						return -1;
    #####: 2297:					*z++ = *p++;
    #####: 2298:					*z++ = *p++;
        -: 2299:				}
        -: 2300:
    #####: 2301:				*z = 0;
        -: 2302:			}
        -: 2303:		}
        -: 2304:	}
    #####: 2305:	if (*p != 0)
    #####: 2306:		return -1;
        -: 2307:
    #####: 2308:	if (must_parse_time && !ret->hour)
    #####: 2309:		return -1;
        -: 2310:
    #####: 2311:	return 0;
        -: 2312:}
        -: 2313:
        -: 2314:/* Raw to boolean */
    #####: 2315:int toml_rtob(toml_raw_t src, int* ret_)
        -: 2316:{
    #####: 2317:	if (!src)
    #####: 2318:		return -1;
        -: 2319:	int dummy;
    #####: 2320:	int* ret = ret_ ? ret_ : &dummy;
        -: 2321:
    #####: 2322:	if (0 == strcmp(src, "true"))
        -: 2323:	{
    #####: 2324:		*ret = 1;
    #####: 2325:		return 0;
        -: 2326:	}
    #####: 2327:	if (0 == strcmp(src, "false"))
        -: 2328:	{
    #####: 2329:		*ret = 0;
    #####: 2330:		return 0;
        -: 2331:	}
    #####: 2332:	return -1;
        -: 2333:}
        -: 2334:
        -: 2335:/* Raw to integer */
    #####: 2336:int toml_rtoi(toml_raw_t src, int64_t* ret_)
        -: 2337:{
    #####: 2338:	if (!src)
    #####: 2339:		return -1;
        -: 2340:
        -: 2341:	char buf[100];
    #####: 2342:	char* p = buf;
    #####: 2343:	char* q = p + sizeof(buf);
    #####: 2344:	const char* s = src;
    #####: 2345:	int base = 0;
        -: 2346:	int64_t dummy;
    #####: 2347:	int64_t* ret = ret_ ? ret_ : &dummy;
        -: 2348:
        -: 2349:	/* allow +/- */
    #####: 2350:	if (s[0] == '+' || s[0] == '-')
    #####: 2351:		*p++ = *s++;
        -: 2352:
        -: 2353:	/* disallow +_100 */
    #####: 2354:	if (s[0] == '_')
    #####: 2355:		return -1;
        -: 2356:
        -: 2357:	/* if 0* ... */
    #####: 2358:	if ('0' == s[0])
        -: 2359:	{
    #####: 2360:		switch (s[1])
        -: 2361:		{
    #####: 2362:		case 'x':
    #####: 2363:			base = 16;
    #####: 2364:			s += 2;
    #####: 2365:			break;
    #####: 2366:		case 'o':
    #####: 2367:			base = 8;
    #####: 2368:			s += 2;
    #####: 2369:			break;
    #####: 2370:		case 'b':
    #####: 2371:			base = 2;
    #####: 2372:			s += 2;
    #####: 2373:			break;
    #####: 2374:		case '\0':
    #####: 2375:			return *ret = 0, 0;
    #####: 2376:		default:
        -: 2377:			/* ensure no other digits after it */
    #####: 2378:			if (s[1])
    #####: 2379:				return -1;
        -: 2380:		}
        -: 2381:	}
        -: 2382:
        -: 2383:	/* just strip underscores and pass to strtoll */
    #####: 2384:	while (*s && p < q)
        -: 2385:	{
    #####: 2386:		int ch = *s++;
    #####: 2387:		if (ch == '_')
        -: 2388:		{
        -: 2389:			// disallow '__'
    #####: 2390:			if (s[0] == '_')
    #####: 2391:				return -1;
        -: 2392:			// numbers cannot end with '_'
    #####: 2393:			if (s[0] == '\0')
    #####: 2394:				return -1;
    #####: 2395:			continue; /* skip _ */
        -: 2396:		}
    #####: 2397:		*p++ = ch;
        -: 2398:	}
        -: 2399:
        -: 2400:	// if not at end-of-string or we ran out of buffer ...
    #####: 2401:	if (*s || p == q)
    #####: 2402:		return -1;
        -: 2403:
        -: 2404:	/* cap with NUL */
    #####: 2405:	*p = 0;
        -: 2406:
        -: 2407:	/* Run strtoll on buf to get the integer */
        -: 2408:	char* endp;
    #####: 2409:	errno = 0;
    #####: 2410:	*ret = strtoll(buf, &endp, base);
    #####: 2411:	return (errno || *endp) ? -1 : 0;
        -: 2412:}
        -: 2413:
    #####: 2414:int toml_rtod_ex(toml_raw_t src, double* ret_, char* buf, int buflen)
        -: 2415:{
    #####: 2416:	if (!src)
    #####: 2417:		return -1;
        -: 2418:
    #####: 2419:	char* p = buf;
    #####: 2420:	char* q = p + buflen;
    #####: 2421:	const char* s = src;
        -: 2422:	double dummy;
    #####: 2423:	double* ret = ret_ ? ret_ : &dummy;
        -: 2424:
        -: 2425:	/* allow +/- */
    #####: 2426:	if (s[0] == '+' || s[0] == '-')
    #####: 2427:		*p++ = *s++;
        -: 2428:
        -: 2429:	/* disallow +_1.00 */
    #####: 2430:	if (s[0] == '_')
    #####: 2431:		return -1;
        -: 2432:
        -: 2433:	/* decimal point, if used, must be surrounded by at least one digit on
        -: 2434:	 * each side */
        -: 2435:	{
    #####: 2436:		char* dot = strchr(s, '.');
    #####: 2437:		if (dot)
        -: 2438:		{
    #####: 2439:			if (dot == s || !isdigit(dot[-1]) || !isdigit(dot[1]))
    #####: 2440:				return -1;
        -: 2441:		}
        -: 2442:	}
        -: 2443:
        -: 2444:	/* zero must be followed by . or 'e', or NUL */
    #####: 2445:	if (s[0] == '0' && s[1] && !strchr("eE.", s[1]))
    #####: 2446:		return -1;
        -: 2447:
        -: 2448:	/* just strip underscores and pass to strtod */
    #####: 2449:	while (*s && p < q)
        -: 2450:	{
    #####: 2451:		int ch = *s++;
    #####: 2452:		if (ch == '_')
        -: 2453:		{
        -: 2454:			// disallow '__'
    #####: 2455:			if (s[0] == '_')
    #####: 2456:				return -1;
        -: 2457:			// disallow last char '_'
    #####: 2458:			if (s[0] == 0)
    #####: 2459:				return -1;
    #####: 2460:			continue; /* skip _ */
        -: 2461:		}
    #####: 2462:		*p++ = ch;
        -: 2463:	}
    #####: 2464:	if (*s || p == q)
    #####: 2465:		return -1; /* reached end of string or buffer is full? */
        -: 2466:
        -: 2467:	/* cap with NUL */
    #####: 2468:	*p = 0;
        -: 2469:
        -: 2470:	/* Run strtod on buf to get the value */
        -: 2471:	char* endp;
    #####: 2472:	errno = 0;
    #####: 2473:	*ret = strtod(buf, &endp);
    #####: 2474:	return (errno || *endp) ? -1 : 0;
        -: 2475:}
        -: 2476:
    #####: 2477:int toml_rtod(toml_raw_t src, double* ret_)
        -: 2478:{
        -: 2479:	char buf[100];
    #####: 2480:	return toml_rtod_ex(src, ret_, buf, sizeof(buf));
        -: 2481:}
        -: 2482:
    #####: 2483:int toml_rtos(toml_raw_t src, char** ret)
        -: 2484:{
    #####: 2485:	int multiline = 0;
        -: 2486:	const char* sp;
        -: 2487:	const char* sq;
        -: 2488:
    #####: 2489:	*ret = 0;
    #####: 2490:	if (!src)
    #####: 2491:		return -1;
        -: 2492:
        -: 2493:	// for strings, first char must be a s-quote or d-quote
    #####: 2494:	int qchar = src[0];
    #####: 2495:	int srclen = strlen(src);
    #####: 2496:	if (!(qchar == '\'' || qchar == '"'))
        -: 2497:	{
    #####: 2498:		return -1;
        -: 2499:	}
        -: 2500:
        -: 2501:	// triple quotes?
    #####: 2502:	if (qchar == src[1] && qchar == src[2])
        -: 2503:	{
    #####: 2504:		multiline = 1;	       // triple-quote implies multiline
    #####: 2505:		sp = src + 3;	       // first char after quote
    #####: 2506:		sq = src + srclen - 3; // first char of ending quote
        -: 2507:
    #####: 2508:		if (!(sp <= sq && sq[0] == qchar && sq[1] == qchar && sq[2] == qchar))
        -: 2509:		{
        -: 2510:			// last 3 chars in src must be qchar
    #####: 2511:			return -1;
        -: 2512:		}
        -: 2513:
        -: 2514:		/* skip new line immediate after qchar */
    #####: 2515:		if (sp[0] == '\n')
    #####: 2516:			sp++;
    #####: 2517:		else if (sp[0] == '\r' && sp[1] == '\n')
    #####: 2518:			sp += 2;
        -: 2519:	}
        -: 2520:	else
        -: 2521:	{
    #####: 2522:		sp = src + 1;	       // first char after quote
    #####: 2523:		sq = src + srclen - 1; // ending quote
    #####: 2524:		if (!(sp <= sq && *sq == qchar))
        -: 2525:		{
        -: 2526:			/* last char in src must be qchar */
    #####: 2527:			return -1;
        -: 2528:		}
        -: 2529:	}
        -: 2530:
        -: 2531:	// at this point:
        -: 2532:	//     sp points to first valid char after quote.
        -: 2533:	//     sq points to one char beyond last valid char.
        -: 2534:	//     string len is (sq - sp).
    #####: 2535:	if (qchar == '\'')
        -: 2536:	{
    #####: 2537:		*ret = norm_lit_str(sp, sq - sp, multiline, 0, 0);
        -: 2538:	}
        -: 2539:	else
        -: 2540:	{
    #####: 2541:		*ret = norm_basic_str(sp, sq - sp, multiline, 0, 0);
        -: 2542:	}
        -: 2543:
    #####: 2544:	return *ret ? 0 : -1;
        -: 2545:}
        -: 2546:
    #####: 2547:toml_datum_t toml_string_at(const toml_array_t* arr, int idx)
        -: 2548:{
        -: 2549:	toml_datum_t ret;
    #####: 2550:	memset(&ret, 0, sizeof(ret));
    #####: 2551:	ret.ok = (0 == toml_rtos(toml_raw_at(arr, idx), &ret.u.s));
    #####: 2552:	return ret;
        -: 2553:}
        -: 2554:
    #####: 2555:toml_datum_t toml_bool_at(const toml_array_t* arr, int idx)
        -: 2556:{
        -: 2557:	toml_datum_t ret;
    #####: 2558:	memset(&ret, 0, sizeof(ret));
    #####: 2559:	ret.ok = (0 == toml_rtob(toml_raw_at(arr, idx), &ret.u.b));
    #####: 2560:	return ret;
        -: 2561:}
        -: 2562:
    #####: 2563:toml_datum_t toml_int_at(const toml_array_t* arr, int idx)
        -: 2564:{
        -: 2565:	toml_datum_t ret;
    #####: 2566:	memset(&ret, 0, sizeof(ret));
    #####: 2567:	ret.ok = (0 == toml_rtoi(toml_raw_at(arr, idx), &ret.u.i));
    #####: 2568:	return ret;
        -: 2569:}
        -: 2570:
    #####: 2571:toml_datum_t toml_double_at(const toml_array_t* arr, int idx)
        -: 2572:{
        -: 2573:	toml_datum_t ret;
    #####: 2574:	memset(&ret, 0, sizeof(ret));
    #####: 2575:	ret.ok = (0 == toml_rtod(toml_raw_at(arr, idx), &ret.u.d));
    #####: 2576:	return ret;
        -: 2577:}
        -: 2578:
    #####: 2579:toml_datum_t toml_timestamp_at(const toml_array_t* arr, int idx)
        -: 2580:{
        -: 2581:	toml_timestamp_t ts;
        -: 2582:	toml_datum_t ret;
    #####: 2583:	memset(&ret, 0, sizeof(ret));
    #####: 2584:	ret.ok = (0 == toml_rtots(toml_raw_at(arr, idx), &ts));
    #####: 2585:	if (ret.ok)
        -: 2586:	{
    #####: 2587:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2588:		if (ret.ok)
        -: 2589:		{
    #####: 2590:			*ret.u.ts = ts;
    #####: 2591:			if (ret.u.ts->year)
    #####: 2592:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2593:			if (ret.u.ts->month)
    #####: 2594:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2595:			if (ret.u.ts->day)
    #####: 2596:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2597:			if (ret.u.ts->hour)
    #####: 2598:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2599:			if (ret.u.ts->minute)
    #####: 2600:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2601:			if (ret.u.ts->second)
    #####: 2602:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2603:			if (ret.u.ts->millisec)
    #####: 2604:				ret.u.ts->millisec =
    #####: 2605:				    &ret.u.ts->__buffer.millisec;
    #####: 2606:			if (ret.u.ts->z)
    #####: 2607:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2608:		}
        -: 2609:	}
    #####: 2610:	return ret;
        -: 2611:}
        -: 2612:
    #####: 2613:toml_datum_t toml_string_in(const toml_table_t* arr, const char* key)
        -: 2614:{
        -: 2615:	toml_datum_t ret;
    #####: 2616:	memset(&ret, 0, sizeof(ret));
    #####: 2617:	toml_raw_t raw = toml_raw_in(arr, key);
    #####: 2618:	if (raw)
        -: 2619:	{
    #####: 2620:		ret.ok = (0 == toml_rtos(raw, &ret.u.s));
        -: 2621:	}
    #####: 2622:	return ret;
        -: 2623:}
        -: 2624:
    #####: 2625:toml_datum_t toml_bool_in(const toml_table_t* arr, const char* key)
        -: 2626:{
        -: 2627:	toml_datum_t ret;
    #####: 2628:	memset(&ret, 0, sizeof(ret));
    #####: 2629:	ret.ok = (0 == toml_rtob(toml_raw_in(arr, key), &ret.u.b));
    #####: 2630:	return ret;
        -: 2631:}
        -: 2632:
    #####: 2633:toml_datum_t toml_int_in(const toml_table_t* arr, const char* key)
        -: 2634:{
        -: 2635:	toml_datum_t ret;
    #####: 2636:	memset(&ret, 0, sizeof(ret));
    #####: 2637:	ret.ok = (0 == toml_rtoi(toml_raw_in(arr, key), &ret.u.i));
    #####: 2638:	return ret;
        -: 2639:}
        -: 2640:
    #####: 2641:toml_datum_t toml_double_in(const toml_table_t* arr, const char* key)
        -: 2642:{
        -: 2643:	toml_datum_t ret;
    #####: 2644:	memset(&ret, 0, sizeof(ret));
    #####: 2645:	ret.ok = (0 == toml_rtod(toml_raw_in(arr, key), &ret.u.d));
    #####: 2646:	return ret;
        -: 2647:}
        -: 2648:
    #####: 2649:toml_datum_t toml_timestamp_in(const toml_table_t* arr, const char* key)
        -: 2650:{
        -: 2651:	toml_timestamp_t ts;
        -: 2652:	toml_datum_t ret;
    #####: 2653:	memset(&ret, 0, sizeof(ret));
    #####: 2654:	ret.ok = (0 == toml_rtots(toml_raw_in(arr, key), &ts));
    #####: 2655:	if (ret.ok)
        -: 2656:	{
    #####: 2657:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2658:		if (ret.ok)
        -: 2659:		{
    #####: 2660:			*ret.u.ts = ts;
    #####: 2661:			if (ret.u.ts->year)
    #####: 2662:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2663:			if (ret.u.ts->month)
    #####: 2664:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2665:			if (ret.u.ts->day)
    #####: 2666:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2667:			if (ret.u.ts->hour)
    #####: 2668:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2669:			if (ret.u.ts->minute)
    #####: 2670:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2671:			if (ret.u.ts->second)
    #####: 2672:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2673:			if (ret.u.ts->millisec)
    #####: 2674:				ret.u.ts->millisec =
    #####: 2675:				    &ret.u.ts->__buffer.millisec;
    #####: 2676:			if (ret.u.ts->z)
    #####: 2677:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2678:		}
        -: 2679:	}
    #####: 2680:	return ret;
        -: 2681:}
        -: 2682:
    #####: 2683:static int parse_millisec(const char* p, const char** endp)
        -: 2684:{
    #####: 2685:	int ret = 0;
    #####: 2686:	int unit = 100; /* unit in millisec */
    #####: 2687:	for (; '0' <= *p && *p <= '9'; p++, unit /= 10)
        -: 2688:	{
    #####: 2689:		ret += (*p - '0') * unit;
        -: 2690:	}
    #####: 2691:	*endp = p;
    #####: 2692:	return ret;
        -: 2693:}
        -:    0:Source:prim.c
        -:    0:Graph:prim.gcno
        -:    0:Data:prim.gcda
        -:    0:Runs:52
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/prim.h>
        -:   16:
        -:   17:#define DEFINE_PRIM(lower, upper, bits)                               \
        -:   18:	Type(upper##bits, Field(lower##bits, value));                 \
        -:   19:	void upper##bits##_build(const upper##bits##Config* config)   \
        -:   20:	{                                                             \
        -:   21:		$Var(value) = config->value;                          \
        -:   22:	}                                                             \
        -:   23:	void upper##bits##_value_of(void* buf)                        \
        -:   24:	{                                                             \
        -:   25:		*(lower##bits*)buf = $(value);                        \
        -:   26:	}                                                             \
        -:   27:	bool upper##bits##_equal(const Obj* rhs)                      \
        -:   28:	{                                                             \
        -:   29:		return $(value) == $Context(rhs, upper##bits, value); \
        -:   30:	}
        -:   31:
        -:   32:#define IMPL U8
      64*:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_equal:
    #####:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_value_of:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_build:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
__add_impls_U8_vtable:
       52:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_drop_internal:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_build_internal:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_size:
        4:   33:DEFINE_PRIM(u, U, 8);
------------------
        -:   34:#undef IMPL
        -:   35:
        -:   36:#define IMPL U16
      64*:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_equal:
    #####:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_value_of:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_build:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
__add_impls_U16_vtable:
       52:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_drop_internal:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_build_internal:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_size:
        4:   37:DEFINE_PRIM(u, U, 16);
------------------
        -:   38:#undef IMPL
        -:   39:
        -:   40:#define IMPL U32
      82*:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_equal:
    #####:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_value_of:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_build:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
__add_impls_U32_vtable:
       52:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_drop_internal:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_build_internal:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_size:
       10:   41:DEFINE_PRIM(u, U, 32);
------------------
        -:   42:#undef IMPL
        -:   43:
        -:   44:#define IMPL U64
       94:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_equal:
        2:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_value_of:
        4:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_build:
        8:   45:DEFINE_PRIM(u, U, 64);
------------------
__add_impls_U64_vtable:
       52:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_drop_internal:
        4:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_build_internal:
        8:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_size:
       16:   45:DEFINE_PRIM(u, U, 64);
------------------
        -:   46:#undef IMPL
        -:   47:
        -:   48:#define IMPL U128
      64*:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_equal:
    #####:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_value_of:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_build:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
__add_impls_U128_vtable:
       52:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_drop_internal:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_build_internal:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_size:
        4:   49:DEFINE_PRIM(u, U, 128);
------------------
        -:   50:#undef IMPL
        -:   51:
        -:   52:#define IMPL I8
      64*:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_equal:
    #####:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_value_of:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_build:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
__add_impls_I8_vtable:
       52:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_drop_internal:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_build_internal:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_size:
        4:   53:DEFINE_PRIM(i, I, 8);
------------------
        -:   54:#undef IMPL
        -:   55:
        -:   56:#define IMPL I16
      64*:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_equal:
    #####:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_value_of:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_build:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
__add_impls_I16_vtable:
       52:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_drop_internal:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_build_internal:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_size:
        4:   57:DEFINE_PRIM(i, I, 16);
------------------
        -:   58:#undef IMPL
        -:   59:
        -:   60:#define IMPL I32
      101:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_equal:
        4:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_value_of:
        3:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_build:
        9:   61:DEFINE_PRIM(i, I, 32);
------------------
__add_impls_I32_vtable:
       52:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_drop_internal:
        6:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_build_internal:
        9:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_size:
       18:   61:DEFINE_PRIM(i, I, 32);
------------------
        -:   62:#undef IMPL
        -:   63:
        -:   64:#define IMPL I64
      64*:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_equal:
    #####:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_value_of:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_build:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
__add_impls_I64_vtable:
       52:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_drop_internal:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_build_internal:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_size:
        4:   65:DEFINE_PRIM(i, I, 64);
------------------
        -:   66:#undef IMPL
        -:   67:
        -:   68:#define IMPL I128
      64*:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_equal:
    #####:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_value_of:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_build:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
__add_impls_I128_vtable:
       52:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_drop_internal:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_build_internal:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_size:
        4:   69:DEFINE_PRIM(i, I, 128);
------------------
        -:   70:#undef IMPL
        -:   71:
        -:   72:#define IMPL F32
      64*:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_equal:
    #####:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_value_of:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_build:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
__add_impls_F32_vtable:
       52:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_drop_internal:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_build_internal:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_size:
        4:   73:DEFINE_PRIM(f, F, 32);
------------------
        -:   74:#undef IMPL
        -:   75:
        -:   76:#define IMPL F64
      64*:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_equal:
    #####:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_value_of:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_build:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
__add_impls_F64_vtable:
       52:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_drop_internal:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_build_internal:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_size:
        4:   77:DEFINE_PRIM(f, F, 64);
------------------
        -:   78:#undef IMPL
        -:   79:
        -:   80:#define IMPL Bool
       84:   81:Type(Bool, Field(bool, value));
------------------
__add_impls_Bool_vtable:
       52:   81:Type(Bool, Field(bool, value));
------------------
Bool_drop_internal:
        8:   81:Type(Bool, Field(bool, value));
------------------
Bool_build_internal:
        8:   81:Type(Bool, Field(bool, value));
------------------
Bool_size:
       16:   81:Type(Bool, Field(bool, value));
------------------
        8:   82:void Bool_build(const BoolConfig* config)
        -:   83:{
        8:   84:	$Var(value) = config->value;
        8:   85:}
        8:   86:void Bool_value_of(void* buf)
        -:   87:{
        8:   88:	*(bool*)buf = $(value);
        8:   89:}
    #####:   90:bool Bool_equal(const Obj* rhs)
        -:   91:{
    #####:   92:	return $(value) == $Context(rhs, Bool, value);
        -:   93:}
        -:   94:#undef IMPL
        -:    0:Source:rc.c
        -:    0:Graph:rc.gcno
        -:    0:Data:rc.gcda
        -:    0:Runs:52
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/prim.h>
        -:   16:#include <core/rc.h>
        -:   17:
        -:   18:// Rc has two 'FatPtr's The first is a counter and the second is holds the value. The value
        -:   19:// can be any object (Obj).
      164:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
__add_impls_Rc_vtable:
       52:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_drop_internal:
       16:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_build_internal:
       32:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_size:
       64:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
        -:   21:
        -:   22:#define IMPL Rc
        -:   23:// Build an Rc.
       32:   24:void Rc_build(const RcConfig* config)
        -:   25:{
        -:   26:	// Allocate memory for both the counter and the value. The value is an Obj regardless of
        -:   27:	// what type. It's data is held in the Object's own FatPtr.
       32:   28:	chain_malloc(&($Var(value)), sizeof(Obj));
       32:   29:	if ($(value).data == NULL)
    #####:   30:		panic("Could not allocate sufficient memory");
       32:   31:	chain_malloc(&($Var(counter)), sizeof(u64));
       32:   32:	if ($(counter).data == NULL)
        -:   33:	{
    #####:   34:		chain_free(&($Var(value)));
    #####:   35:		panic("Could not allocate sufficient memory");
        -:   36:	}
        -:   37:	// pointer to the internal data location
       32:   38:	Obj* obj = $Var(value).data;
        -:   39:	// initialize the object
       32:   40:	*obj = OBJECT_INIT;
        -:   41:	// if a value is passed in (which will be the case generally if the user is calling new,
        -:   42:	// we move the Object into the shared memory location.
       32:   43:	if (config->value)
      14*:   44:		Move(obj, config->value);
        -:   45:	// Initialize the counter to 1.
       32:   46:	*(u64*)$Var(counter).data = 1;
       32:   47:}
        -:   48:// Drop an Rc.
       32:   49:void Rc_drop()
        -:   50:{
        -:   51:	// When an instance of Rc is dropped, we decrement our counter and check if it is 0
        -:   52:	// indicating that no more references remain.
       32:   53:	(*(u64*)$Var(counter).data)--;
       32:   54:	if ((*(u64*)$Var(counter).data) == 0)
        -:   55:	{
        -:   56:		// No other references remain.
       14:   57:		Obj* value = $(value).data;
        -:   58:		// If the Object is not yet consumed, drop it.
       14:   59:		if ((value->flags & OBJECT_FLAGS_CONSUMED) == 0)
       13:   60:			drop(value);
        -:   61:		// Free the allocated memory for this Rc.
       14:   62:		if (chain_free(&($Var(counter))))
    #####:   63:			panic("Unexpected return from a chain_free!");
       14:   64:		if (chain_free(&($Var(value))))
    #####:   65:			panic("Unexpeted return from a chain_free!");
        -:   66:	}
       32:   67:}
        -:   68:
        -:   69:// Unwrap an Rc.
       16:   70:Obj Rc_unwrap()
        -:   71:{
        -:   72:	Obj ret;
        -:   73:	// If there are additional references, the returned object (acting as a reference to the shared data)
        -:   74:	// should not be cleaned up. We merely copy the data and marked the returned reference as 'no cleanup'.
       16:   75:	if (*(u64*)($(counter).data) > 1)
        -:   76:	{
       15:   77:		ret = *(Obj*)$(value).data;
       15:   78:		ret.flags |= OBJECT_FLAGS_NO_CLEANUP;
        -:   79:	}
        -:   80:	else
        -:   81:	{
        -:   82:		// This is the final reference so we move out the Object
        1:   83:		ret = OBJECT_INIT;
       1*:   84:		Move(&ret, (Obj*)$(value).data);
        -:   85:	}
        -:   86:	// Drop this instance of the Rc
       16:   87:	drop($Var());
        -:   88:	// return the objecct.
       16:   89:	return ret;
        -:   90:}
        -:   91:
        -:   92:// Clone the Rc.
       18:   93:Obj Rc_klone()
        -:   94:{
        -:   95:	// Update the counter by incrementing
       18:   96:	u64* counter = $(counter).data;
       18:   97:	(*counter)++;
        -:   98:
        -:   99:	// Create an Rc without a value
       18:  100:	var ret = new (Rc);
        -:  101:	// Set both the value and the counter to the appropriate values
       18:  102:	$ContextVar((&ret), Rc, value).data = ((Obj*)$(value).data);
       18:  103:	$ContextVar((&ret), Rc, counter).data = counter;
        -:  104:	// Safely return the Object
       18:  105:	ReturnObj(ret);
        -:  106:}
        -:  107:#undef IMPL
        -:    0:Source:test_encapsulation.c
        -:    0:Graph:test_encapsulation.gcno
        -:    0:Data:test_encapsulation.gcda
        -:    0:Runs:51
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/test_encapsulation.h>
        -:   16:#include <core/traits.h>
        -:   17:#include <core/type.h>
        -:   18:
       58:   19:Type(HiddenDrop);
------------------
__add_impls_HiddenDrop_vtable:
       51:   19:Type(HiddenDrop);
------------------
HiddenDrop_drop_internal:
        1:   19:Type(HiddenDrop);
------------------
HiddenDrop_build_internal:
        2:   19:Type(HiddenDrop);
------------------
HiddenDrop_size:
        4:   19:Type(HiddenDrop);
------------------
        -:   20:Builder(HiddenDrop);
      102:   21:Impl(HiddenDrop, Drop);
------------------
vtable_add_trait_impl_HiddenDrop_Drop:
       51:   21:Impl(HiddenDrop, Drop);
------------------
__required_add__HiddenDrop_drop:
       51:   21:Impl(HiddenDrop, Drop);
------------------
        -:   22:
        -:   23:#define IMPL HiddenDrop
        1:   24:void HiddenDrop_drop() {}
        -:   25:#undef IMPL
        -:   26:
     162*:   27:Type(
------------------
__add_impls_Hidden_vtable:
       51:   27:Type(
------------------
Hidden_drop_internal:
        1:   27:Type(
------------------
Hidden_build_internal:
       4*:   27:Type(
------------------
__add_where_Hidden_T_vtable:
      102:   27:Type(
------------------
Hidden_size:
        4:   27:Type(
------------------
        -:   28:    Hidden,
        -:   29:    Where(T, TraitBound(Drop)),
        -:   30:    Field(u64, value),
        -:   31:    Field(HiddenConfig, config),
        -:   32:    Generic(T, v2),
        -:   33:    Object(HiddenDrop, dd));
        -:   34:
        -:   35:#define IMPL Hidden
        2:   36:void Hidden_build(const HiddenConfig* config)
        -:   37:{
        2:   38:	printf("building hidden: capacity = %" PRIu64 "\n", config->capacity);
        2:   39:	$Var(config) = *config;
        2:   40:	let hd = new (HiddenDrop);
       4*:   41:	Move(&$Var(v2), &hd);
        2:   42:}
        -:   43:
        2:   44:void Hidden_drop()
        -:   45:{
        2:   46:	printf("drop value=%" PRIu64 "\n", $(value));
        2:   47:}
        4:   48:u64 Hidden_get_value()
        -:   49:{
        4:   50:	return $(value);
        -:   51:}
        1:   52:u64 Hidden_get_capacity_impl()
        -:   53:{
        1:   54:	return $(config).capacity;
        -:   55:}
        3:   56:void Hidden_set_value(u64 v)
        -:   57:{
        3:   58:	$Var(value) = v;
        3:   59:}
        -:   60:#undef IMPL
        -:   61:
      76*:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_as_ref:
        5:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_variant_id:
        5:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_build:
       3*:   62:EnumImpl(HiddenEnum);
------------------
__add_impls_HiddenEnum_vtable:
       51:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_drop_internal:
        3:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_build_internal:
       3*:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_size:
        6:   62:EnumImpl(HiddenEnum);
------------------
        -:    0:Source:test_server.c
        -:    0:Graph:test_server.gcno
        -:    0:Data:test_server.gcda
        -:    0:Runs:51
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/test_server.h>
        -:   16:
        -:   17:// In this file we implement the HttpServer type along with some other types that are
        -:   18:// used by HttpServer. This is a .c file so the implementation details are hidden
        -:   19:// from the user providing encapsulation of the data within the HttpServer type.
        -:   20:
        -:   21:// We create a type that implements the 'Drop' trait. This is needed to satisfy
        -:   22:// the trait bound of HttpServer in our example. We also call the required macros
        -:   23:// to minimally intialize this type and declare that the Drop trait will be
        -:   24:// implemented.
       55:   25:Type(CanDrop);
------------------
__add_impls_CanDrop_vtable:
       51:   25:Type(CanDrop);
------------------
CanDrop_drop_internal:
        1:   25:Type(CanDrop);
------------------
CanDrop_build_internal:
        1:   25:Type(CanDrop);
------------------
CanDrop_size:
        2:   25:Type(CanDrop);
------------------
        -:   26:Builder(CanDrop);
      102:   27:Impl(CanDrop, Drop);
------------------
vtable_add_trait_impl_CanDrop_Drop:
       51:   27:Impl(CanDrop, Drop);
------------------
__required_add__CanDrop_drop:
       51:   27:Impl(CanDrop, Drop);
------------------
        -:   28:
        -:   29:// Do the drop implementation for this type. By defining 'IMPL', we have access
        -:   30:// to the $() macro which allows for self operations and access to the data types.
        -:   31:#define IMPL CanDrop
        1:   32:void CanDrop_drop() { printf("dropping can drop\n"); }
        -:   33:#undef IMPL
        -:   34:
        -:   35:// Now we declare a second type which will demonstrate concrete types. This type
        -:   36:// also has some data fields which are used and a Builder which allows configuration.
       55:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
__add_impls_HttpServerComponent_vtable:
       51:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_drop_internal:
        1:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_build_internal:
        1:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_size:
        2:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
        -:   38:Builder(HttpServerComponent, Config(u64, state));
        -:   39:
        -:   40:// Implement Drop and Build for this type.
      102:   41:Impl(HttpServerComponent, Drop);
------------------
vtable_add_trait_impl_HttpServerComponent_Drop:
       51:   41:Impl(HttpServerComponent, Drop);
------------------
__required_add__HttpServerComponent_drop:
       51:   41:Impl(HttpServerComponent, Drop);
------------------
      102:   42:Impl(HttpServerComponent, Build);
------------------
vtable_add_trait_impl_HttpServerComponent_Build:
       51:   42:Impl(HttpServerComponent, Build);
------------------
__required_add__HttpServerComponent_build:
       51:   42:Impl(HttpServerComponent, Build);
------------------
        -:   43:
        -:   44:// Here we implement drop and build, the required methods for our traits.
        -:   45:#define IMPL HttpServerComponent
        1:   46:void HttpServerComponent_drop()
        -:   47:{
        -:   48:	// The $() macro allows us to access data fields in our type. In this case
        -:   49:	// We print out $(alloc_mem) and free it.
        1:   50:	printf("dropping http server component. Free %p\n", $(alloc_mem));
        1:   51:	free($(alloc_mem));
        1:   52:}
        1:   53:void HttpServerComponent_build(const HttpServerComponentConfig* config_in)
        -:   54:{
        -:   55:	// In contrast to the drop implementation, here we use the $Var macro.
        -:   56:	// The difference from the $ macro is that the $Var macro is mutable.
        -:   57:	// If the $Var macro is used in an immutable function, a thread panic
        -:   58:	// will occur.
        1:   59:	const HttpServerComponentConfig* config = config_in;
        -:   60:	// Set the 'state' data member of this type using the config.
        1:   61:	$Var(state) = config->state;
        -:   62:	// allocate memory to our void pointer type to demonstrate the usage of build/drop.
        1:   63:	$Var(alloc_mem) = malloc(100);
        1:   64:	printf("building http server component. Alloc %p\n", $(alloc_mem));
        1:   65:}
        -:   66:#undef IMPL
        -:   67:
        -:   68:// Now we define the main type. This type information is hidden from the user as this
        -:   69:// data is defined in our .c file and treated as an opaque pointer.
        -:   70:// The HttpServer type demonstrates the 'Where' clause for defining generics and the usage
        -:   71:// of all three types of data members (Generic, Object, and Field).
     158*:   72:Type(
------------------
__add_impls_HttpServer_vtable:
       51:   72:Type(
------------------
HttpServer_drop_internal:
        1:   72:Type(
------------------
HttpServer_build_internal:
       2*:   72:Type(
------------------
__add_where_HttpServer_T_vtable:
      102:   72:Type(
------------------
HttpServer_size:
        2:   72:Type(
------------------
        -:   73:    HttpServer,
        -:   74:    Where(T, TraitBound(Drop)),
        -:   75:    Field(HttpServerConfig, config),
        -:   76:    Field(bool, is_started),
        -:   77:    Object(HttpServerComponent, hsc),
        -:   78:    Generic(T, droppable));
        -:   79:
        -:   80:// Finally, we implement the HttpServer type.
        -:   81:#define IMPL HttpServer
        -:   82:// This function is not defined by any traits. It serves as a private method within our type.
        -:   83:// Since it is within the IMPL block, we can access both the $Var and $ variables and mutability
        -:   84:// is maintained based on what function calls this function.
        1:   85:void HttpServer_validate_input(const HttpServerConfig* config)
        -:   86:{
        -:   87:	// First set the config to the passed in configuration.
        1:   88:	$Var(config) = *config;
        -:   89:	// check threads and panic if they are not configured. memset is called on all
        -:   90:	// data of the type so everything will be set to 0 initially including this parameter. So,
        -:   91:	// here we effectively force the user to configure threads or a thread panic will occur.
        1:   92:	if ($(config).threads == 0)
    #####:   93:		panic("Threads must be greater than 0. Halting!");
        -:   94:
        -:   95:	// For port and host, we set default values keeping in mind the fact that everything is
        -:   96:	// initialized to 0.
        1:   97:	if ($(config).port == 0)
        1:   98:		$Var(config).port = 8080;
        1:   99:	if ($(config).host == NULL)
        1:  100:		$Var(config).host = "127.0.0.1";
        1:  101:}
        1:  102:void HttpServer_build(const HttpServerConfig* config)
        -:  103:{
        -:  104:	// The build function is automatically called by the system when an Object is instantiated.
        1:  105:	HttpServer_validate_input(config);
        -:  106:	// set is_started to false.
        1:  107:	$Var(is_started) = false;
        -:  108:	// create a 'CanDrop' object which will fulfil the trait bounds of 'droppable'.
        2:  109:	let can_drop = new (CanDrop);
        -:  110:	// Always use Move to move Objects as it will enforce all trait bounds and set the cleanup
        -:  111:	// and other flags appropriately for all types.
       2*:  112:	Move(&$Var(droppable), &can_drop);
        -:  113:	// create an immutable HttpServerComponent instance with state initialized to 1.
        1:  114:	let hsc = new (HttpServerComponent, With(state, 1));
        -:  115:	// Once again use the Move macro to move the instance into the proper memory location.
       1*:  116:	Move(&$Var(hsc), &hsc);
        1:  117:}
        -:  118:// Implement a drop method which just prints out the message below.
        1:  119:void HttpServer_drop() { printf("dropping http server\n"); }
        -:  120:// Return the is_started status of the server using the immutable self macro '$'.
        2:  121:bool HttpServer_is_started() { return $(is_started); }
        -:  122:// Implement the start_server Required function.
        2:  123:bool HttpServer_start_server()
        -:  124:{
        -:  125:	// Do error checking.
        2:  126:	if ($(is_started))
        1:  127:		return false;
        -:  128:	// Set is_started to appropriate value.
        1:  129:	$Var(is_started) = true;
        -:  130:	// Print the configuration
        1:  131:	printf(
        -:  132:	    "Server started on %s:%" PRIu16 " with %" PRIu32 " threads\n",
        1:  133:	    $(config).host, $(config).port, $(config).threads);
        -:  134:	// Call the format_print_stats function. This function will execute the provided format_print_stats
        -:  135:	// function. Note that we use the $() which refers to the pointer whose context we are currently in.
        -:  136:	// This can be used to call any trait member functions.
        1:  137:	format_print_stats($());
        1:  138:	return true;
        -:  139:}
        -:  140:// Implement a basic printing of the stats.
        1:  141:void HttpServer_print_stats()
        -:  142:{
        1:  143:	printf("Current stats: is_started: %i\n", $(is_started));
        1:  144:}
    #####:  145:void HttpServer_blorp(u64 v) {}
        -:  146:#undef IMPL
        -:  147:
        -:  148:// This is the default implementation for the format_print_stats function. Note that we can still access
        -:  149:// the $ and $Var macros as a sort of a self operator, but since this is not part of any implementation,
        -:  150:// fields cannot be specified.
        1:  151:void format_print_stats_impl()
        -:  152:{
        1:  153:	printf("-----------------------------------------------------\n");
        1:  154:	print_stats($());
        1:  155:	printf("-----------------------------------------------------\n");
        1:  156:}
        -:    0:Source:thread.c
        -:    0:Graph:thread.gcno
        -:    0:Data:thread.gcda
        -:    0:Runs:52
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <base/chain_allocator.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <core/thread.h>
        -:   19:#include <errno.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:int PANIC_TRUE = 1;
        -:   24:int PANIC_FALSE = 0;
        -:   25:
        -:   26:typedef struct ThreadArgsWrapper {
        -:   27:	void (*start_routine)(void *);
        -:   28:	void *args;
        -:   29:	FatPtr self;
        -:   30:} ThreadArgsWrapper;
        -:   31:
        -:   32:typedef struct ThreadImpl {
        -:   33:	pthread_t pth;
        -:   34:	u64 tid;
        -:   35:	FatPtr self;
        -:   36:} ThreadImpl;
        -:   37:
        4:   38:void Thread_cleanup(Thread *ptr) {
        4:   39:	if (chain_free(&ptr->impl))
    #####:   40:		panic("Could not free Thread");
        4:   41:}
        -:   42:
        4:   43:void *Thread_proc_start(void *arg) {
        -:   44:	// set jmp return point for panics
        4:   45:	if (PANIC_RETURN()) {
        1:   46:		pthread_exit(&PANIC_TRUE);
        -:   47:	}
        -:   48:
        4:   49:	ThreadArgsWrapper *taw = arg;
        4:   50:	(taw->start_routine)(taw->args);
        -:   51:
       3*:   52:	ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        3:   53:	if (chain_free(&taw->self))
    #####:   54:		panic("Could not free ThreadArgsWrapper");
        -:   55:
        3:   56:	if (__default_tl_heap_allocator != NULL) {
    #####:   57:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   58:	}
        -:   59:
        3:   60:	pthread_exit(&PANIC_FALSE);
        -:   61:}
        -:   62:
        4:   63:int Thread_start(Thread *th, void (*start_routine)(void *), void *args) {
        4:   64:	int ret = 0;
        4:   65:	ret = chain_malloc(&th->impl, sizeof(ThreadImpl));
        -:   66:
        4:   67:	if (!ret) {
        -:   68:
        8:   69:		ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        4:   70:		ThreadImpl *ti = th->impl.data;
        -:   71:
        -:   72:		FatPtr tawptr;
        4:   73:		ret = chain_malloc(&tawptr, sizeof(ThreadArgsWrapper));
        -:   74:
        4:   75:		if (!ret) {
        4:   76:			ThreadArgsWrapper *data = tawptr.data;
        4:   77:			data->start_routine = start_routine;
        4:   78:			data->args = args;
        4:   79:			data->self = tawptr;
        -:   80:
        4:   81:			ret = pthread_create(&ti->pth, NULL, Thread_proc_start, data);
        -:   82:		}
        -:   83:	}
        4:   84:	return ret;
        -:   85:}
        -:   86:
        4:   87:JoinResult Thread_join(Thread *ptr) {
        4:   88:	int result = -1;
        4:   89:	int *status = &PANIC_FALSE;
        -:   90:
        4:   91:	if (ptr == NULL)
    #####:   92:		errno = EINVAL;
        -:   93:	else {
        4:   94:		ThreadImpl *ti = ptr->impl.data;
        4:   95:		result = pthread_join(ti->pth, (void *)&status);
        -:   96:	}
        4:   97:	JoinResult jr = {*status == PANIC_TRUE, result != 0};
        4:   98:	return jr;
        -:   99:}
        -:  100:
        4:  101:bool JoinResult_is_panic(JoinResult *jr) {
        4:  102:	return jr->is_panic;
        -:  103:}
        -:  104:
        4:  105:bool JoinResult_is_error(JoinResult *jr) {
        4:  106:	return jr->is_error;
        -:  107:}
        -:    0:Source:traits.c
        -:    0:Graph:traits.gcno
        -:    0:Data:traits.gcda
        -:    0:Runs:52
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/traits.h>
        -:   16:
    #####:   17:u64 size(const Obj* self)
        -:   18:{
    #####:   19:	if (self->flags & OBJECT_FLAGS_CONSUMED)
    #####:   20:		panic("Runtime error: Obj [%s@%" PRIu64
        -:   21:		      "] has already been consumed!",
    #####:   22:		      self->vtable->name, self->ptr.id);
    #####:   23:	u64 (*impl)() = find_fn(self, "size");
    #####:   24:	if (!impl)
    #####:   25:		panic("Runtime error: Trait bound violation! "
        -:   26:		      "Type "
        -:   27:		      "'%s' does "
        -:   28:		      "not implement the "
        -:   29:		      "required function [%s]",
    #####:   30:		      TypeName((*self)), "size");
    #####:   31:	SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};
    #####:   32:	__thread_local_self_Const = self;
    #####:   33:	__thread_local_self_Var = NULL;
        -:   34:
    #####:   35:	return impl();
        -:   36:}
        -:   37:
       30:   38:void drop(Obj* self)
        -:   39:{
       30:   40:	if (self->flags & OBJECT_FLAGS_CONSUMED)
    #####:   41:		panic("Runtime error: Obj [%s@%" PRIu64
        -:   42:		      "] has already been consumed!",
    #####:   43:		      self->vtable->name, self->ptr.id);
       30:   44:	void (*impl)() = find_fn(self, "drop");
       30:   45:	SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};
       30:   46:	__thread_local_self_Const = self;
       30:   47:	__thread_local_self_Var = self;
        -:   48:
        -:   49:	// custom code here (set no cleanup since we're already done and consume
        -:   50:	// the object):
       30:   51:	self->flags |= OBJECT_FLAGS_NO_CLEANUP | OBJECT_FLAGS_CONSUMED;
        -:   52:	// free the pointer here as well since cleanup will not be called
       30:   53:	if (fat_ptr_data(&self->ptr))
        -:   54:	{
       30:   55:		chain_free(&self->ptr);
        -:   56:	}
        -:   57:	// in the case of no drop existing we just return
       30:   58:	if (impl)
       20:   59:		impl();
       30:   60:}
        -:   61:
        -:   62:// default implementation of clone_from
        1:   63:void clone_from_impl(Obj* to_clone)
        -:   64:{
        -:   65:	// call the type specific 'klone' required method.
        1:   66:	let v = klone(to_clone);
        -:   67:	// move the result to $Var() internal self reference.
        -:   68:	// cleanup handled by Move.
       1*:   69:	Move($Var(), &v);
        1:   70:}
        -:    0:Source:type.c
        -:    0:Graph:type.gcno
        -:    0:Data:type.gcda
        -:    0:Runs:52
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/panic.h>
        -:   16:#include <core/type.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        -:   20:_Thread_local const Obj *__thread_local_self_Const = NULL;
        -:   21:_Thread_local Obj *__thread_local_self_Var = NULL;
        -:   22:
        -:   23:atomic_ullong __global_counter__;
       52:   24:void __attribute__((constructor)) init_global_counter() {
       52:   25:	atomic_init(&__global_counter__, 1);
       52:   26:}
        -:   27:
    #####:   28:u64 unique_id() {
    #####:   29:	u64 ret = atomic_fetch_add(&__global_counter__, 1);
    #####:   30:	return ret;
        -:   31:}
        -:   32:
      152:   33:FatPtr build_fat_ptr(u64 size) {
        -:   34:	FatPtr ret;
      152:   35:	if (chain_malloc(&ret, size)) {
        -:   36:		// if chain_malloc is an error we set data to NULL and caller to
        -:   37:		// handle
    #####:   38:		ret.data = NULL;
        -:   39:	}
      152:   40:	return ret;
        -:   41:}
        -:   42:
   126486:   43:int compare_vtable_entry(const void *ent1, const void *ent2) {
   126486:   44:	const VtableEntry *vtent1 = ent1;
   126486:   45:	const VtableEntry *vtent2 = ent2;
   126486:   46:	return strcmp(vtent1->name, vtent2->name);
        -:   47:}
        -:   48:
    16474:   49:void sort_vtable(Vtable *table) {
    16474:   50:	qsort(table->entries, table->len, sizeof(VtableEntry), compare_vtable_entry);
    16474:   51:}
        -:   52:
    16474:   53:void vtable_add_entry(Vtable *table, VtableEntry entry) {
    16474:   54:	if (table->entries == NULL) {
     1998:   55:		table->entries = malloc(sizeof(VtableEntry) * (table->len + 1));
     1998:   56:		if (table->entries == NULL)
    #####:   57:			panic("Couldn't allocate memory for vtable");
        -:   58:	} else {
    14476:   59:		void *tmp = realloc(table->entries, sizeof(VtableEntry) * (table->len + 1));
    14476:   60:		if (tmp == NULL)
    #####:   61:			panic("Couldn't allocate memory for vtable");
    14476:   62:		table->entries = tmp;
        -:   63:	}
        -:   64:
    16474:   65:	memcpy(&table->entries[table->len], &entry, sizeof(VtableEntry));
    16474:   66:	table->len += 1;
    16474:   67:	sort_vtable(table);
    16474:   68:}
        -:   69:
       38:   70:void vtable_override(Vtable *table, VtableEntry entry) {
      228:   71:	for (int i = 0; i < table->len; i++) {
      190:   72:		if (!strcmp(entry.name, table->entries[i].name)) {
       38:   73:			table->entries[i].fn_ptr = entry.fn_ptr;
        -:   74:		}
        -:   75:	}
       38:   76:}
        -:   77:
      330:   78:bool vtable_check_impl_trait(const Vtable *table, const char *trait) {
      330:   79:	bool ret = false;
        -:   80:
      546:   81:	for (u64 i = 0; i < table->trait_len; i++) {
      546:   82:		if (!strcmp(table->trait_entries[i].trait_name, trait)) {
      330:   83:			ret = true;
      330:   84:			break;
        -:   85:		}
        -:   86:	}
        -:   87:
      330:   88:	return ret;
        -:   89:}
        -:   90:
     9578:   91:void vtable_add_trait(Vtable *table, char *trait) {
     9578:   92:	if (table->trait_entries == NULL) {
     2010:   93:		table->trait_entries = malloc(sizeof(VtableTraitEntry) * (table->trait_len + 1));
     2010:   94:		if (table->trait_entries == NULL)
    #####:   95:			panic("Couldn't allocate memory for vtable");
        -:   96:	} else {
        -:   97:		void *tmp =
     7568:   98:			realloc(table->trait_entries, sizeof(VtableTraitEntry) * (table->trait_len + 1));
     7568:   99:		if (tmp == NULL)
    #####:  100:			panic("Couldn't allocate memory for vtable");
     7568:  101:		table->trait_entries = tmp;
        -:  102:	}
        -:  103:
        -:  104:	VtableTraitEntry entry;
     9578:  105:	if (strlen(trait) >= MAX_TRAIT_NAME_LEN)
    #####:  106:		panic("trait name [%s] is too long. MAX_TRAIT_NAME_LEN = %i\n", trait,
        -:  107:			  MAX_TRAIT_NAME_LEN - 1);
     9578:  108:	strcpy(entry.trait_name, trait);
        -:  109:
     9578:  110:	memcpy(&table->trait_entries[table->trait_len], &entry, sizeof(VtableTraitEntry));
     9578:  111:	table->trait_len += 1;
     9578:  112:}
        -:  113:
      795:  114:void *find_fn(const Obj *obj, const char *name) {
      795:  115:	int left = 0;
      795:  116:	int right = obj->vtable->len - 1;
     2138:  117:	while (left <= right) {
     2048:  118:		int mid = left + (right - left) / 2;
     2048:  119:		int cmp = strcmp(name, obj->vtable->entries[mid].name);
        -:  120:
     2048:  121:		if (cmp == 0) {
      705:  122:			return obj->vtable->entries[mid].fn_ptr;
     1343:  123:		} else if (cmp < 0) {
      643:  124:			right = mid - 1;
        -:  125:		} else {
      700:  126:			left = mid + 1;
        -:  127:		}
        -:  128:	}
       90:  129:	return NULL;
        -:  130:}
        -:  131:
      247:  132:void SelfCleanupImpl_update(SelfCleanupImpl *ptr) {
      247:  133:	__thread_local_self_Const = ptr->prev_tl_self_Const;
      247:  134:	__thread_local_self_Var = ptr->prev_tl_self_Var;
      247:  135:}
        -:  136:
       69:  137:void Obj_check_param(const Obj *obj) {
       69:  138:	if (obj && (obj->flags & OBJECT_FLAGS_CONSUMED) != 0)
    #####:  139:		panic("Passing a consumed object as a function "
        -:  140:			  "parameter!");
       69:  141:}
        -:  142:
       17:  143:bool Obj_is_type(const Obj *ptr, char *ref) {
       17:  144:	if (!strcmp(TypeName((*ptr)), ref))
       17:  145:		return true;
    #####:  146:	return false;
        -:  147:}
        -:  148:
      152:  149:void Obj_build_int(Obj *ptr) {
        -:  150:	// call internal build handler
      152:  151:	void (*build_int)(Obj *ptr) = find_fn(ptr, "build_internal");
      152:  152:	if (!build_int)
    #####:  153:		panic("no internal build handler found");
      152:  154:	build_int(ptr);
      152:  155:}
        -:  156:
      152:  157:void Obj_build(Obj *ptr, const void *config) {
      152:  158:	void (*do_build)(const void *config) = find_fn(ptr, "build");
      152:  159:	if (do_build) {
        -:  160:		// setup self references
      148:  161:		Obj *tmp_Var = __thread_local_self_Var;
      148:  162:		const Obj *tmp_Const = __thread_local_self_Const;
      148:  163:		__thread_local_self_Const = ptr;
      148:  164:		__thread_local_self_Var = ptr;
      148:  165:		do_build(config);
        -:  166:		// revert
      148:  167:		__thread_local_self_Var = tmp_Var;
      148:  168:		__thread_local_self_Const = tmp_Const;
        -:  169:	}
      152:  170:}
        -:  171:
        -:  172:#if defined(__clang__)
        -:  173:// Clang-specific pragma
        -:  174:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  175:#elif defined(__GNUC__) && !defined(__clang__)
        -:  176:// GCC-specific pragma
        -:  177:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  178:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  179:#else
        -:  180:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  181:#endif
      236:  182:void Obj_cleanup(const Obj *ptr) {
      236:  183:	Obj *unconst = ptr;
      236:  184:	if ((unconst->flags & OBJECT_FLAGS_NO_CLEANUP) == 0) {
        -:  185:		// call internal drop handler
      122:  186:		void (*drop_int)(Obj *ptr) = find_fn(ptr, "drop_internal");
      122:  187:		if (!drop_int)
    #####:  188:			panic("no internal drop handler found");
      122:  189:		drop_int(unconst);
        -:  190:
        -:  191:		// call defined drop handler
      122:  192:		void (*drop)(Obj *ptr) = find_fn(ptr, "drop");
      122:  193:		if (drop) {
        -:  194:			// setup self references
       46:  195:			Obj *tmp_Var = __thread_local_self_Var;
       46:  196:			Obj *tmp_Const = __thread_local_self_Const;
       46:  197:			__thread_local_self_Const = unconst;
       46:  198:			__thread_local_self_Var = unconst;
       46:  199:			drop(ptr);
        -:  200:			// revert
       46:  201:			__thread_local_self_Var = tmp_Var;
       46:  202:			__thread_local_self_Const = tmp_Const;
        -:  203:		}
      122:  204:		if (fat_ptr_data(&unconst->ptr)) {
      122:  205:			chain_free(&unconst->ptr);
        -:  206:		}
        -:  207:	}
      236:  208:}
        -:  209:
        -:  210:#if defined(__clang__)
        -:  211:// Clang-specific pragma
        -:  212:#pragma GCC diagnostic push
        -:  213:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  214:#elif defined(__GNUC__) && !defined(__clang__)
        -:  215:// GCC-specific pragma
        -:  216:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  217:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  218:#else
        -:  219:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  220:#endif
       45:  221:void Obj_mark_consumed(const Obj *ptr) {
       45:  222:	Obj *unconst = ptr;
       45:  223:	unconst->flags |= OBJECT_FLAGS_NO_CLEANUP | OBJECT_FLAGS_CONSUMED;
       45:  224:}
        -:  225:#pragma GCC diagnostic pop
        -:    0:Source:unit.c
        -:    0:Graph:unit.gcno
        -:    0:Data:unit.gcda
        -:    0:Runs:52
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/unit.h>
        -:   16:
      52*:   17:Type(Unit);
------------------
__add_impls_Unit_vtable:
       52:   17:Type(Unit);
------------------
Unit_drop_internal:
    #####:   17:Type(Unit);
------------------
Unit_build_internal:
    #####:   17:Type(Unit);
------------------
Unit_size:
    #####:   17:Type(Unit);
------------------
        -:    0:Source:chain_allocator.c
        -:    0:Graph:chain_allocator.gcno
        -:    0:Data:chain_allocator.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <errno.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:
        -:   22:// the default heap allocator for the current thread
        -:   23:_Thread_local HeapAllocator *__default_tl_heap_allocator = NULL;
        -:   24:
        -:   25:// the global heap allocator (used when the memory will potentially be
        -:   26:// deallocated in a different thread than it was created in
        -:   27:HeapAllocator *__global_sync_allocator = NULL;
        -:   28:// lock for the global heap allocator
        -:   29:Lock *__global_sync_allocator_lock = NULL;
        -:   30:
        -:   31:// default heap allocator config (no_malloc and zeroed are disabled)
        -:   32:HeapAllocatorConfig __default_hconfig_ = { false, false };
        -:   33:
        -:   34:// create default slab sizes for the heap allocator with alignment in mind
        -:   35:#define HD_CFG(size) { size, 10, 0, UINT32_MAX }
        -:   36:HeapDataParamsConfig __default_hdpc_arr_value[] = { HD_CFG(8), HD_CFG(16), HD_CFG(32), HD_CFG(48),
        -:   37:	HD_CFG(64), HD_CFG(80), HD_CFG(96), HD_CFG(112), HD_CFG(128), HD_CFG(144), HD_CFG(160),
        -:   38:	HD_CFG(176), HD_CFG(192), HD_CFG(208), HD_CFG(224), HD_CFG(240), HD_CFG(256), HD_CFG(272),
        -:   39:	HD_CFG(288), HD_CFG(304), HD_CFG(320), HD_CFG(336), HD_CFG(352), HD_CFG(368), HD_CFG(384),
        -:   40:	HD_CFG(400), HD_CFG(416), HD_CFG(432), HD_CFG(448), HD_CFG(464), HD_CFG(480), HD_CFG(496),
        -:   41:	HD_CFG(512), HD_CFG(1024), HD_CFG(2048), HD_CFG(4096), HD_CFG(8192),
        -:   42:	{ 16384, 5, 0, UINT32_MAX }, { 32768, 5, 0, UINT32_MAX }, { 65536, 2, 0, UINT32_MAX } };
        -:   43:
        -:   44:// heap allocator config
        -:   45:HeapDataParamsConfig *__default_hdpc_arr_ = __default_hdpc_arr_value;
        -:   46:
        -:   47:// the size of the default array
        -:   48:u64 __default_hdpc_arr_size
        -:   49:	= sizeof(__default_hdpc_arr_value) / sizeof(__default_hdpc_arr_value[0]);
        -:   50:
        -:   51:// allows for overwriting the hconfig
    #####:   52:void set_default_hconfig(HeapAllocatorConfig *hconfig)
        -:   53:{
    #####:   54:	__default_hconfig_ = *hconfig;
    #####:   55:}
        -:   56:
        -:   57:// allows for overwriting of the default hdpc array
        2:   58:void set_default_hdpc_arr(HeapDataParamsConfig arr[], u64 size)
        -:   59:{
        2:   60:	__default_hdpc_arr_ = arr;
        2:   61:	__default_hdpc_arr_size = size;
        2:   62:}
        -:   63:
        -:   64:// build the using the default heap allocator config
       53:   65:int build_default_heap_allocator(HeapAllocator *ptr)
        -:   66:{
       53:   67:	return heap_allocator_build_arr(
        -:   68:		ptr, &__default_hconfig_, __default_hdpc_arr_, __default_hdpc_arr_size);
        -:   69:}
        -:   70:
        -:   71:// init the global sync allocator
        4:   72:void global_sync_allocator_init()
        -:   73:{
        -:   74:	// allocate for the data structure
        4:   75:	__global_sync_allocator = mymalloc(sizeof(HeapAllocator));
        4:   76:	__global_sync_allocator_lock = mymalloc(sizeof(Lock));
        -:   77:
        -:   78:	// check for failures
        4:   79:	if (__global_sync_allocator_lock == NULL || __global_sync_allocator == NULL) {
        -:   80:		// deallocate and panic
    #####:   81:		if (__global_sync_allocator_lock != NULL)
    #####:   82:			myfree(__global_sync_allocator_lock);
    #####:   83:		if (__global_sync_allocator != NULL)
    #####:   84:			myfree(__global_sync_allocator);
    #####:   85:		panic("Could not initialize the global sync HeapAllocator");
        -:   86:	}
        -:   87:
        -:   88:	// setup the lock
        4:   89:	*__global_sync_allocator_lock = LOCK();
        -:   90:
        -:   91:	// build with the default configurations
        4:   92:	if (build_default_heap_allocator(__global_sync_allocator)) {
    #####:   93:		myfree(__global_sync_allocator);
    #####:   94:		panic("Could not initialize the global sync HeapAllocator");
        -:   95:	}
        4:   96:}
        -:   97:
        -:   98:// Entry for the chain allocator stack.
        -:   99:typedef struct ChainGuardEntry {
        -:  100:	HeapAllocator *ha;
        -:  101:	bool is_sync;
        -:  102:	Lock *lock;
        -:  103:} ChainGuardEntry;
        -:  104:
        -:  105:// stack for chain allocators
        -:  106:_Thread_local ChainGuardEntry __thread_local_chain_allocator[MAX_CHAIN_ALLOCATOR_DEPTH];
        -:  107:_Thread_local u64 __thread_local_chain_allocator_index = 0;
        -:  108:
        -:  109:// cleanup the local thread allocator (used when threads terminate)
        1:  110:void thread_local_allocator_cleanup()
        -:  111:{
        1:  112:	if (__thread_local_chain_allocator_index > 0)
        1:  113:		heap_allocator_cleanup(
        -:  114:			__thread_local_chain_allocator[__thread_local_chain_allocator_index].ha);
        1:  115:}
        -:  116:
        1:  117:void global_sync_allocator_cleanup()
        -:  118:{
        1:  119:	if (__global_sync_allocator != NULL)
        1:  120:		heap_allocator_cleanup(__global_sync_allocator);
        1:  121:}
        -:  122:
       31:  123:void chain_guard_cleanup(ChainGuard *ptr)
        -:  124:{
       31:  125:	__thread_local_chain_allocator_index--;
       31:  126:}
        -:  127:
       34:  128:ChainGuard chain_guard(ChainConfig *config)
        -:  129:{
       34:  130:	if (__thread_local_chain_allocator_index >= MAX_CHAIN_ALLOCATOR_DEPTH)
    #####:  131:		panic("too many chain allocators");
        -:  132:
       34:  133:	ChainGuardPtr ret
       34:  134:		= { __thread_local_chain_allocator_index, config->ha, config->is_sync, config->lock };
        -:  135:
       34:  136:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].ha = config->ha;
       34:  137:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].is_sync = config->is_sync;
       34:  138:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].lock = config->lock;
        -:  139:
       34:  140:	__thread_local_chain_allocator_index++;
       34:  141:	return ret;
        -:  142:}
        -:  143:
      276:  144:int chain_malloc(FatPtr *ptr, u64 size)
        -:  145:{
      276:  146:	if (__thread_local_chain_allocator_index == 0) {
        -:  147:		// thread local allocator has not been initialized. Create it
        -:  148:		// now.
       25:  149:		HeapAllocator *ha = mymalloc(sizeof(HeapAllocator));
       25:  150:		if (!ha)
    #####:  151:			return -1;
        -:  152:
       25:  153:		if (build_default_heap_allocator(ha)) {
    #####:  154:			myfree(ha);
    #####:  155:			return -1;
        -:  156:		};
        -:  157:
       25:  158:		__default_tl_heap_allocator = ha;
       25:  159:		__thread_local_chain_allocator[0].ha = ha;
       25:  160:		__thread_local_chain_allocator[0].is_sync = false;
       25:  161:		__thread_local_chain_allocator_index++;
        -:  162:	}
      276:  163:	if (size == 0)
    #####:  164:		return -1;
        -:  165:
      276:  166:	u64 index = __thread_local_chain_allocator_index - 1;
      276:  167:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  168:
        -:  169:	int ret;
        -:  170:	{
      276:  171:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
      276:  172:		if (is_sync)
        5:  173:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  174:
      276:  175:		ret = heap_allocator_allocate(__thread_local_chain_allocator[index].ha, size, ptr);
        -:  176:	}
        -:  177:
      276:  178:	return ret;
        -:  179:}
       32:  180:int chain_realloc(FatPtr *dst, FatPtr *src, u64 size)
        -:  181:{
       32:  182:	if (__thread_local_chain_allocator_index == 0) {
    #####:  183:		return -1;
        -:  184:	}
       32:  185:	if (size == 0) {
    #####:  186:		errno = EINVAL;
    #####:  187:		return -1;
        -:  188:	}
       32:  189:	u64 index = __thread_local_chain_allocator_index - 1;
       32:  190:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  191:
        -:  192:	int ret;
        -:  193:	{
       32:  194:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
       32:  195:		if (is_sync)
    #####:  196:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  197:
       32:  198:		ret = heap_allocator_allocate(__thread_local_chain_allocator[index].ha, size, dst);
       32:  199:		if (!ret) {
       32:  200:			void *src_data = fat_ptr_data(src);
       32:  201:			void *dst_data = fat_ptr_data(dst);
       32:  202:			u64 len = fat_ptr_len(src);
       32:  203:			memcpy(dst_data, src_data, len);
       32:  204:			ret = chain_free(src);
        -:  205:		}
        -:  206:	}
        -:  207:
       32:  208:	return ret;
        -:  209:}
      271:  210:int chain_free(FatPtr *ptr)
        -:  211:{
      271:  212:	if (__thread_local_chain_allocator_index == 0) {
    #####:  213:		errno = ERANGE;
    #####:  214:		return -1;
        -:  215:	}
      271:  216:	u64 index = __thread_local_chain_allocator_index - 1;
      271:  217:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  218:
        -:  219:	int ret;
        -:  220:	{
      271:  221:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
      271:  222:		if (is_sync)
        4:  223:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  224:
      271:  225:		ret = heap_allocator_free(__thread_local_chain_allocator[index].ha, ptr);
        -:  226:	}
      271:  227:	return ret;
        -:  228:}
        -:    0:Source:heap.c
        -:    0:Graph:heap.gcno
        -:    0:Data:heap.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/heap.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        -:   20:// internal representation of the HeapDataParamsConfig with the required
        -:   21:// free_list_head value.
        -:   22:typedef struct HeapDataParams {
        -:   23:	HeapDataParamsConfig config;
        -:   24:	u32 free_list_head; // The next slab that is free
        -:   25:} HeapDataParams;
        -:   26:
        -:   27:// The data associated with each slab_size.
        -:   28:typedef struct HeapData {
        -:   29:	void **data; // pointers to each chunk of data
        -:   30:	u32 *free_list; // the pointers for free slabs.
        -:   31:	u32 count; // the number of chunks currently allocated
        -:   32:	u32 cur_slabs; // the number of slabs currently allocated
        -:   33:	u32 cur_slabs_allocated; // the number of slabs currently allocated;
        -:   34:	HeapDataParams hdp; // The heap data params for this HeapData
        -:   35:} HeapData;
        -:   36:
        -:   37:// The opaque pointer type which is stored in the HeapAllocator data structure
        -:   38:// which is used to access a HeapAllocator.
        -:   39:typedef struct HeapAllocatorImpl {
        -:   40:	u32 hd_size; // number of sizes available
        -:   41:	HeapAllocatorConfig config; // the configuration
        -:   42:	HeapData *hd_arr; // The array of heap data.
        -:   43:	u32 cur_malloc_slabs_allocated; // the number of slabs currently allocated directly via malloc
        -:   44:} HeapAllocatorImpl;
        -:   45:
        -:   46:// debugging options/counters
        -:   47:u64 __malloc_count = 0;
        -:   48:u64 __free_count = 0;
        -:   49:bool __debug_build_allocator_malloc_fail1 = false;
        -:   50:bool __debug_build_allocator_malloc_fail2 = false;
        -:   51:bool __debug_build_allocator_malloc_fail3 = false;
        -:   52:bool __debug_build_allocator_malloc_fail4 = false;
        -:   53:bool __debug_build_allocator_malloc_fail5 = false;
        -:   54:bool __debug_build_allocator_malloc_fail6 = false;
        -:   55:bool __debug_build_allocator_malloc_fail7 = false;
        -:   56:bool __debug_build_allocator_malloc_fail8 = false;
        -:   57:
      557:   58:void *do_malloc(size_t size)
        -:   59:{
      557:   60:	__malloc_count += 1;
      557:   61:	void *ret = malloc(size);
        -:   62:	// printf("malloc %zu [%p (%llu)]\n", size, ret, __malloc_count);
      557:   63:	return ret;
        -:   64:}
        -:   65:
      365:   66:void do_free(void *ptr)
        -:   67:{
      365:   68:	__free_count += 1;
        -:   69:	// printf("free %p (%llu)\n", ptr, __free_count);
      365:   70:	free(ptr);
      365:   71:}
        -:   72:
       35:   73:void *do_realloc(void *ptr, size_t size)
        -:   74:{
       35:   75:	void *ret = realloc(ptr, size);
        -:   76:	// printf("realloc %zu [old=%p,new=%p]\n", size, ptr, ret);
       35:   77:	return ret;
        -:   78:}
        -:   79:
      224:   80:void *fat_ptr_data(const FatPtr *ptr)
        -:   81:{
      224:   82:	return ptr->data;
        -:   83:}
        -:   84:
       44:   85:u64 fat_ptr_len(const FatPtr *ptr)
        -:   86:{
       44:   87:	return ptr->len;
        -:   88:}
        -:   89:
        5:   90:u64 fat_ptr_id(const FatPtr *ptr)
        -:   91:{
        5:   92:	return ptr->id;
        -:   93:}
        -:   94:
      144:   95:int heap_allocator_init_free_list(HeapData *hd, u64 index, u32 slabs, bool last_is_uint_max)
        -:   96:{
      144:   97:	hd->data[index] = NULL; // set to NULL for cleanup consistency
        -:   98:
        -:   99:	// allocate memory for slabs
      144:  100:	if (!__debug_build_allocator_malloc_fail4)
      142:  101:		hd->data[index] = do_malloc(hd->hdp.config.slab_size * slabs);
      144:  102:	if (hd->data[index] == NULL)
        2:  103:		return -1;
        -:  104:
      142:  105:	void *tmp = NULL;
        -:  106:
        -:  107:	// allocate / or reallocate the freelist
      142:  108:	if (!__debug_build_allocator_malloc_fail5) {
      140:  109:		if (index == 0)
      123:  110:			tmp = do_malloc(sizeof(u32) * slabs);
        -:  111:		else {
       17:  112:			tmp = do_realloc(hd->free_list, sizeof(u32) * (hd->cur_slabs + slabs));
        -:  113:		}
        -:  114:	}
        -:  115:
      142:  116:	if (!tmp) {
        2:  117:		do_free(hd->data[index]);
        2:  118:		return -1;
        -:  119:	}
        -:  120:
      140:  121:	hd->free_list = tmp;
        -:  122:
        -:  123:	// initialize the values of the free list.
      140:  124:	u32 offset = index * hd->hdp.config.slabs_per_resize;
     1653:  125:	for (u64 i = 0; i < slabs; i++) {
     1513:  126:		if ((i == (slabs - 1)) && last_is_uint_max)
      139:  127:			hd->free_list[i + offset] = UINT32_MAX;
        -:  128:		else
     1374:  129:			hd->free_list[i + offset] = offset + i + 1;
        -:  130:	}
        -:  131:
      140:  132:	return 0;
        -:  133:}
        -:  134:
        -:  135:// compare function used for sorting.
     5115:  136:int heap_data_compare(const void *p1, const void *p2)
        -:  137:{
     5115:  138:	int ret = 0;
        -:  139:
     5115:  140:	HeapData d1 = *(HeapData *)p1;
     5115:  141:	HeapData d2 = *(HeapData *)p2;
        -:  142:
     5115:  143:	if (d1.hdp.config.slab_size > d2.hdp.config.slab_size)
        1:  144:		ret = 1;
     5114:  145:	else if (d1.hdp.config.slab_size < d2.hdp.config.slab_size)
     5113:  146:		ret = -1;
        -:  147:
     5115:  148:	return ret;
        -:  149:}
        -:  150:
        -:  151:// initialize the heap data params
     2075:  152:int heap_allocator_init_hdp(HeapAllocator *ptr, HeapDataParamsConfig *hdp, u64 index)
        -:  153:{
        -:  154:
        -:  155:	// set some value in case of a failure below such that cleanup can
        -:  156:	// succeed
     2075:  157:	int ret = 0;
     2075:  158:	ptr->impl->hd_arr[index].hdp.config = *hdp;
     2075:  159:	ptr->impl->hd_arr[index].hdp.free_list_head = 0;
     2075:  160:	ptr->impl->hd_arr[index].cur_slabs = 0;
     2075:  161:	ptr->impl->hd_arr[index].cur_slabs_allocated = 0;
     2075:  162:	ptr->impl->hd_arr[index].count = ptr->impl->hd_arr[index].hdp.config.initial_chunks;
        -:  163:
        -:  164:	// if we have initial chunks, initialize them
     2075:  165:	if (ptr->impl->hd_arr[index].hdp.config.initial_chunks) {
       23:  166:		ptr->impl->hd_arr[index].data = NULL;
        -:  167:
        -:  168:		// try to allocate space for the data for this size
       23:  169:		if (!__debug_build_allocator_malloc_fail8)
       22:  170:			ptr->impl->hd_arr[index].data
       22:  171:				= do_malloc(ptr->impl->hd_arr[index].hdp.config.initial_chunks * sizeof(void *));
        -:  172:
        -:  173:		// if NULL return error
       23:  174:		if (ptr->impl->hd_arr[index].data == NULL)
        1:  175:			return -1;
        -:  176:
        -:  177:		// set cur_slabs value
       22:  178:		ptr->impl->hd_arr[index].cur_slabs = ptr->impl->hd_arr[index].hdp.config.initial_chunks
       22:  179:			* ptr->impl->hd_arr[index].hdp.config.slabs_per_resize;
        -:  180:
        -:  181:		// initialize the initial_chunks of the free list
       22:  182:		bool last_is_uint_max = false;
       22:  183:		ptr->impl->hd_arr[index].free_list = NULL;
       45:  184:		for (u64 i = 0; i < ptr->impl->hd_arr[index].hdp.config.initial_chunks; i++) {
        -:  185:
       23:  186:			if (i == ptr->impl->hd_arr[index].hdp.config.initial_chunks - 1)
       22:  187:				last_is_uint_max = true;
       23:  188:			if (heap_allocator_init_free_list(&ptr->impl->hd_arr[index], i,
       23:  189:					ptr->impl->hd_arr[index].hdp.config.slabs_per_resize, last_is_uint_max))
        2:  190:				ret = -1;
        -:  191:		}
        -:  192:	} else
     2052:  193:		ptr->impl->hd_arr[index].data = NULL;
     2074:  194:	return ret;
        -:  195:}
        -:  196:
       79:  197:int heap_allocator_build_arr(HeapAllocator *ptr, HeapAllocatorConfig *config,
        -:  198:	HeapDataParamsConfig arr[], u64 heap_data_params_count)
        -:  199:{
        -:  200:	// check inputs
       79:  201:	if (ptr == NULL || config == NULL || heap_data_params_count >= 256) {
        1:  202:		errno = EINVAL;
        1:  203:		return -1;
        -:  204:	}
        -:  205:
        -:  206:	// allocate the HeapAllocatorImpl
       78:  207:	if (!__debug_build_allocator_malloc_fail1)
       77:  208:		ptr->impl = do_malloc(sizeof(HeapAllocatorImpl));
       78:  209:	if (ptr->impl == NULL || __debug_build_allocator_malloc_fail1)
        1:  210:		return -1;
        -:  211:
       77:  212:	ptr->impl->cur_malloc_slabs_allocated = 0;
       77:  213:	ptr->impl->hd_size = 0;
        -:  214:
        -:  215:	// copy the config
       77:  216:	ptr->impl->config = *config;
        -:  217:
        -:  218:	// allocate heap data array
       77:  219:	ptr->impl->hd_arr = NULL;
       77:  220:	if (!__debug_build_allocator_malloc_fail2)
       76:  221:		ptr->impl->hd_arr = do_malloc(sizeof(HeapData) * heap_data_params_count);
       77:  222:	if (ptr->impl->hd_arr == NULL || __debug_build_allocator_malloc_fail2) {
        1:  223:		heap_allocator_cleanup(ptr);
        1:  224:		return -1;
        -:  225:	}
       76:  226:	ptr->impl->hd_size = heap_data_params_count;
        -:  227:
        -:  228:	// iterate through specified heap data params
     2148:  229:	for (u64 i = 0; i < heap_data_params_count; i++) {
     2076:  230:		HeapDataParamsConfig hdp = arr[i];
     2076:  231:		ptr->impl->hd_arr[i].count = 0; // init to 0 for safe cleanup
     2076:  232:		ptr->impl->hd_arr[i].data = NULL;
     2076:  233:		if ((__debug_build_allocator_malloc_fail3 && i > 0)
     2075:  234:			|| heap_allocator_init_hdp(ptr, &hdp, i)) {
        4:  235:			ptr->impl->hd_size = i; // update for cleanup, others
        -:  236:									// did not get allocated
        4:  237:			if (ptr->impl->hd_arr[i].data) {
        2:  238:				do_free(ptr->impl->hd_arr[i].data);
        -:  239:			}
        4:  240:			heap_allocator_cleanup(ptr);
        4:  241:			return -1;
        -:  242:		}
        -:  243:	}
        -:  244:
       72:  245:	if (heap_data_params_count) {
       70:  246:		qsort(ptr->impl->hd_arr, heap_data_params_count, sizeof(HeapData), heap_data_compare);
        -:  247:	}
        -:  248:
        -:  249:	// check invalid configurations
       72:  250:	u64 last_size = 0;
     2141:  251:	for (u64 i = 0; i < heap_data_params_count; i++) {
     2071:  252:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == 0) {
        -:  253:			// no 0 sized slabs allowed
        1:  254:			errno = EINVAL;
        1:  255:			heap_allocator_cleanup(ptr);
        1:  256:			return -1;
        -:  257:		}
        -:  258:		// note: logic correct because array is sorted.
     2070:  259:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == last_size) {
        -:  260:			// Duplicate slab_size
        1:  261:			errno = EEXIST;
        1:  262:			heap_allocator_cleanup(ptr);
        1:  263:			return -1;
        -:  264:		}
     2069:  265:		last_size = ptr->impl->hd_arr[i].hdp.config.slab_size;
        -:  266:	}
        -:  267:
       70:  268:	return 0;
        -:  269:}
        -:  270:
       26:  271:int heap_allocator_build(
        -:  272:	HeapAllocator *ptr, HeapAllocatorConfig *config, int heap_data_params_count, ...)
       26:  273:{
       26:  274:	int arr_size = heap_data_params_count;
        -:  275:
        -:  276:	// 0 size is allowed, so we update to address sanitizer warning.
       26:  277:	if (arr_size <= 0) {
        5:  278:		arr_size = 1;
        -:  279:	}
       26:  280:	HeapDataParamsConfig arr[arr_size];
        -:  281:	va_list hdps;
       26:  282:	va_start(hdps, heap_data_params_count);
        -:  283:	// build the array to pass to heap_allocator_build_arr
       55:  284:	for (u64 i = 0; i < heap_data_params_count; i++) {
       29:  285:		HeapDataParamsConfig hdp = va_arg(hdps, HeapDataParamsConfig);
       29:  286:		arr[i] = hdp;
        -:  287:	}
        -:  288:
       26:  289:	va_end(hdps);
        -:  290:	// call the array version of the function
       26:  291:	return heap_allocator_build_arr(ptr, config, arr, heap_data_params_count);
        -:  292:}
        -:  293:
        -:  294:// binary search for the correct slab size
      698:  295:int heap_allocator_index(HeapAllocator *ptr, u64 size)
        -:  296:{
      698:  297:	int ret = -1;
      698:  298:	if (ptr->impl->hd_size == 0)
        2:  299:		return ret;
        -:  300:
      696:  301:	int left = 0;
      696:  302:	int right = ptr->impl->hd_size - 1;
        -:  303:
     2248:  304:	while (left <= right) {
     2043:  305:		int mid = left + (right - left) / 2;
     2043:  306:		u64 slab_size = ptr->impl->hd_arr[mid].hdp.config.slab_size;
     2043:  307:		if (slab_size == size) {
      491:  308:			ret = mid;
      491:  309:			break;
     1552:  310:		} else if (slab_size > size)
     1178:  311:			right = mid - 1;
        -:  312:		else
      374:  313:			left = mid + 1;
        -:  314:	}
        -:  315:
      696:  316:	if (ret == -1 && right + 1 <= ptr->impl->hd_size - 1) {
      193:  317:		return right + 1;
        -:  318:	}
        -:  319:
      503:  320:	return ret;
        -:  321:}
        -:  322:
      129:  323:int heap_data_resize(u64 index, HeapData *hd)
        -:  324:{
        -:  325:	// check that we can resize this hdp
      129:  326:	if (hd->cur_slabs < hd->hdp.config.max_slabs) {
        -:  327:		// calculate the new slabs
      122:  328:		u32 nslabs_count = hd->hdp.config.slabs_per_resize + hd->cur_slabs;
      122:  329:		if (nslabs_count > hd->hdp.config.max_slabs)
        2:  330:			nslabs_count = hd->hdp.config.max_slabs;
        -:  331:
        -:  332:		// determine slabs to allocate
      122:  333:		u32 slabs_to_alloc = nslabs_count - hd->cur_slabs;
        -:  334:
        -:  335:		// attempt to allocate
      122:  336:		void *tmp = NULL;
      122:  337:		if (!__debug_build_allocator_malloc_fail7) {
      121:  338:			if (hd->data)
       18:  339:				tmp = do_realloc(hd->data, (hd->count + 1) * sizeof(void *));
        -:  340:			else
      103:  341:				tmp = do_malloc((hd->count + 1) * sizeof(void **));
        -:  342:		}
        -:  343:
      122:  344:		if (tmp == NULL)
        1:  345:			return -1;
      121:  346:		hd->data = tmp;
        -:  347:
        -:  348:		// initialize the new part of the free list
      121:  349:		if (heap_allocator_init_free_list(hd, hd->count, slabs_to_alloc, true))
        2:  350:			return -1;
      119:  351:		hd->hdp.free_list_head = hd->cur_slabs;
      119:  352:		hd->cur_slabs = nslabs_count;
      119:  353:		hd->count += 1;
      119:  354:		return 0;
        -:  355:	}
        7:  356:	return -1;
        -:  357:}
        -:  358:
      700:  359:int heap_data_allocate(u64 index, HeapData *hd, FatPtr *fptr)
        -:  360:{
      700:  361:	if (hd->cur_slabs == 0) {
        -:  362:		// this hd initially had 0 slabs
        -:  363:		// resize it
      104:  364:		if (heap_data_resize(index, hd))
        1:  365:			return -1;
        -:  366:	}
        -:  367:
        -:  368:	// no more slabs, return error
      699:  369:	if (hd->hdp.free_list_head == UINT32_MAX)
       24:  370:		return -1;
        -:  371:
        -:  372:	// get next free slab
      675:  373:	u64 id = hd->hdp.free_list_head;
        -:  374:
        -:  375:	// update free list head
      675:  376:	hd->hdp.free_list_head = hd->free_list[id];
        -:  377:
        -:  378:	// update with the specific index (differing slab sizes)
      675:  379:	fptr->id = id | (index << 56);
      675:  380:	fptr->len = hd->hdp.config.slab_size;
        -:  381:
      675:  382:	u64 heap_data_index = id / hd->hdp.config.slabs_per_resize;
      675:  383:	u64 offset_mod = id % hd->hdp.config.slabs_per_resize;
        -:  384:
        -:  385:	// set the data of the fptr
      675:  386:	fptr->data = hd->data[heap_data_index] + offset_mod * hd->hdp.config.slab_size;
      675:  387:	hd->cur_slabs_allocated++;
        -:  388:
      675:  389:	return 0;
        -:  390:}
        -:  391:
        -:  392:// free data in this HeapData
      388:  393:int heap_data_free(u64 index, HeapData *hd, FatPtr *fptr)
        -:  394:{
      388:  395:	u64 rel = fptr->id & 0x00FFFFFFFFFFFFFF; // Extract the relative ID
        -:  396:
        -:  397:	// if this is invalid return an error
      388:  398:	if (rel >= hd->cur_slabs)
        1:  399:		return -1;
        -:  400:
        -:  401:	// update head and rest of the list
      387:  402:	u64 head = hd->hdp.free_list_head;
      387:  403:	hd->hdp.free_list_head = rel;
      387:  404:	hd->free_list[rel] = head;
        -:  405:
      387:  406:	hd->cur_slabs_allocated--;
        -:  407:
      387:  408:	return 0;
        -:  409:}
        -:  410:
       24:  411:u64 heap_allocator_cur_slabs_allocated(HeapAllocator *ptr)
        -:  412:{
       24:  413:	u64 ret = ptr->impl->cur_malloc_slabs_allocated;
      984:  414:	for (int i = 0; i < ptr->impl->hd_size; i++) {
      960:  415:		ret += ptr->impl->hd_arr[i].cur_slabs_allocated;
        -:  416:	}
       24:  417:	return ret;
        -:  418:}
        -:  419:
        -:  420:// main allocation function
      698:  421:int heap_allocator_allocate(HeapAllocator *ptr, u64 size, FatPtr *fptr)
        -:  422:{
      698:  423:	int ret = -1;
        -:  424:	// determine the index via binary search
      698:  425:	int index = heap_allocator_index(ptr, size);
        -:  426:
        -:  427:	// if this index is not found (too big) fall back to malloc
      698:  428:	if (index < 0) {
       14:  429:		if (!ptr->impl->config.no_malloc) {
       12:  430:			fptr->data = NULL;
       12:  431:			if (!__debug_build_allocator_malloc_fail6) {
       11:  432:				ptr->impl->cur_malloc_slabs_allocated++;
       11:  433:				fptr->data = do_malloc(size);
        -:  434:			}
       12:  435:			if (fptr->data == NULL) {
        1:  436:				fptr->len = 0;
        1:  437:				ret = -1;
        -:  438:			} else {
       11:  439:				fptr->len = size;
       11:  440:				fptr->id = UINT64_MAX;
       11:  441:				ret = 0;
        -:  442:			}
        -:  443:		}
        -:  444:	} else {
      684:  445:		HeapData *hd = &ptr->impl->hd_arr[index];
      684:  446:		ret = heap_data_allocate(index, hd, fptr);
      684:  447:		if (ret) {
        -:  448:			// there are no more slabs. Try to resize
       25:  449:			if (!heap_data_resize(index, hd)) {
        -:  450:				// successful resize, allocate should always
        -:  451:				// succeed here
       16:  452:				ret = heap_data_allocate(index, hd, fptr);
        9:  453:			} else if (!ptr->impl->config.no_malloc) {
        -:  454:				// could not allocate, so we fall back to malloc
        -:  455:				// if configured
        4:  456:				fptr->data = NULL;
        4:  457:				if (!__debug_build_allocator_malloc_fail6)
        3:  458:					fptr->data = do_malloc(size);
        4:  459:				if (fptr->data == NULL) {
        1:  460:					fptr->len = 0;
        1:  461:					ret = -1;
        -:  462:				} else {
        3:  463:					fptr->len = size;
        3:  464:					fptr->id = UINT64_MAX;
        3:  465:					ret = 0;
        -:  466:				}
        -:  467:			}
        -:  468:		}
        -:  469:	}
        -:  470:
        -:  471:	// if zeroed is configured set all memory of allocated slabs to 0.
      698:  472:	if (!ret && ptr->impl->config.zeroed) {
       44:  473:		memset(fptr->data, 0, fptr->len);
        -:  474:	}
        -:  475:
      698:  476:	return ret;
        -:  477:}
        -:  478:
      403:  479:int heap_allocator_free(HeapAllocator *ptr, FatPtr *fptr)
        -:  480:{
      403:  481:	int ret = 0;
      403:  482:	if (fptr->id == UINT64_MAX) {
        -:  483:		// malloc allocated
        -:  484:
       14:  485:		if (fptr->data) {
       14:  486:			ptr->impl->cur_malloc_slabs_allocated--;
       14:  487:			do_free(fptr->data);
       14:  488:			fptr->data = NULL;
        -:  489:		}
        -:  490:
       14:  491:		ret = 0;
        -:  492:	} else {
        -:  493:
      389:  494:		u64 index = (fptr->id >> 56) & 0xFF; // Extract the index
        -:  495:
      389:  496:		if (index >= ptr->impl->hd_size) {
        1:  497:			errno = EINVAL;
        1:  498:			ret = -1; // invalid index
        -:  499:		} else {
      388:  500:			HeapData *hd = &ptr->impl->hd_arr[index];
      388:  501:			ret = heap_data_free(index, hd, fptr);
        -:  502:		}
        -:  503:	}
        -:  504:
      403:  505:	if (!ret && ptr->impl->config.zeroed) {
        1:  506:		memset(fptr->data, 0, fptr->len);
        -:  507:	}
        -:  508:
      403:  509:	return ret;
        -:  510:}
        -:  511:
       53:  512:int heap_allocator_cleanup(HeapAllocator *ptr)
        -:  513:{
        -:  514:	// check for impl and deallocate
       53:  515:	if (ptr->impl) {
     1037:  516:		for (u32 i = 0; i < ptr->impl->hd_size; i++) {
      988:  517:			if (ptr->impl->hd_arr[i].count) {
        -:  518:				// check that it's not an unallocated heap data
       80:  519:				if (ptr->impl->hd_arr[i].free_list) {
       80:  520:					do_free(ptr->impl->hd_arr[i].free_list);
       80:  521:					ptr->impl->hd_arr[i].free_list = NULL;
        -:  522:				}
      170:  523:				for (u64 j = 0; j < ptr->impl->hd_arr[i].count; j++) {
       90:  524:					do_free(ptr->impl->hd_arr[i].data[j]);
        -:  525:				}
       80:  526:				if (ptr->impl->hd_arr[i].data) {
       80:  527:					do_free(ptr->impl->hd_arr[i].data);
       80:  528:					ptr->impl->hd_arr[i].data = NULL;
        -:  529:				}
        -:  530:			}
        -:  531:		}
        -:  532:
       49:  533:		if (ptr->impl->hd_arr) {
       48:  534:			do_free(ptr->impl->hd_arr);
       48:  535:			ptr->impl->hd_arr = NULL;
        -:  536:		}
       49:  537:		do_free(ptr->impl);
       49:  538:		ptr->impl = NULL;
        -:  539:	}
       53:  540:	return 0;
        -:  541:}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/lock.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <stdio.h>
        -:   18:#include <unistd.h>
        -:   19:
        -:   20:#define MAX_LOCKS 100
        -:   21:_Thread_local Lock *__active_locks_[MAX_LOCKS];
        -:   22:_Thread_local u64 __active_lock_count_ = 0;
        -:   23:
       15:   24:void insert_active_lock(Lock *ptr) {
       15:   25:	if (__active_lock_count_ >= MAX_LOCKS)
    #####:   26:		panic("too many locks!");
       15:   27:	__active_locks_[__active_lock_count_] = ptr;
       15:   28:	__active_lock_count_++;
       15:   29:}
       14:   30:void delete_active_lock(Lock *ptr) {
        -:   31:	// note: locks are removed in reverse order
        -:   32:	// It's possible that cleanup occurs in slightly different order
        -:   33:	// but the effect is the same each lock would be invalidated at the end
        -:   34:	// of a scope. For simplicity we just decrement here.
       14:   35:	if (__active_lock_count_ == 0)
    #####:   36:		panic("active lock stack underflow. Unexpected error!");
       14:   37:	__active_lock_count_--;
       14:   38:}
        -:   39:
        8:   40:Lock Lock_build() {
        -:   41:	LockPtr ret;
        8:   42:	pthread_mutex_init(&ret.lock, NULL);
        8:   43:	pthread_cond_init(&ret.cond, NULL);
        8:   44:	atomic_init(&ret.poison, false);
        8:   45:	atomic_init(&ret.is_locked, false);
        8:   46:	atomic_init(&ret.tid, 0);
        8:   47:	return ret;
        -:   48:}
        -:   49:
        4:   50:void Lock_cleanup(LockPtr *ptr) {
        4:   51:	pthread_mutex_destroy(&ptr->lock);
        4:   52:	pthread_cond_destroy(&ptr->cond);
        4:   53:}
        -:   54:
        1:   55:void Lock_set_poison(Lock *ptr) {
        1:   56:	atomic_exchange(&ptr->poison, true);
        1:   57:}
        1:   58:bool Lock_is_poisoned(Lock *ptr) {
        1:   59:	return atomic_load(&ptr->poison);
        -:   60:}
    #####:   61:void Lock_clear_poison(Lock *ptr) {
    #####:   62:	atomic_exchange(&ptr->poison, false);
    #####:   63:}
       15:   64:u64 Lock_get_tid() {
        -:   65:	u64 tid;
        -:   66:#ifdef __APPLE__
        -:   67:	pthread_threadid_np(NULL, &tid);
        -:   68:#else
       15:   69:	tid = gettid();
        -:   70:#endif // tid code
       15:   71:	return tid;
        -:   72:}
        -:   73:
       15:   74:LockGuard lock(Lock *ptr) {
       15:   75:	if (atomic_load(&ptr->poison))
    #####:   76:		panic("Lock %p: poisoned!", ptr);
        -:   77:
       15:   78:	u64 tid = Lock_get_tid();
        -:   79:
        -:   80:	// check if this would be a deadlock
      15*:   81:	if (atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid)
    #####:   82:		panic("Lock %p: attempt to lock would deadlock!", lock);
        -:   83:
        -:   84:	// obtain lock
       15:   85:	pthread_mutex_lock(&ptr->lock);
       15:   86:	if (atomic_load(&ptr->poison))
    #####:   87:		panic("Lock %p: poisoned!", ptr);
        -:   88:
       15:   89:	insert_active_lock(ptr);
        -:   90:
        -:   91:	// set tid/is_locked and return
       15:   92:	atomic_exchange(&ptr->tid, tid);
       15:   93:	atomic_exchange(&ptr->is_locked, true);
       15:   94:	LockGuardPtr ret = {ptr};
       15:   95:	return ret;
        -:   96:}
        -:   97:
      584:   98:void Lockguard_cleanup(LockGuardPtr *ptr) {
      584:   99:	if (ptr && ptr->ref) {
       14:  100:		atomic_exchange(&ptr->ref->is_locked, false);
       14:  101:		pthread_mutex_unlock(&ptr->ref->lock);
       14:  102:		delete_active_lock(ptr->ref);
        -:  103:	}
      584:  104:}
        -:  105:
        3:  106:void Lock_mark_poisoned() {
        3:  107:	if (__active_lock_count_) {
        1:  108:		u64 i = __active_lock_count_ - 1;
        -:  109:		while (true) {
        1:  110:			Lock_set_poison(__active_locks_[i]);
        1:  111:			atomic_exchange(&__active_locks_[i]->is_locked, false);
        1:  112:			pthread_mutex_unlock(&__active_locks_[i]->lock);
        1:  113:			if (i == 0)
        1:  114:				break;
    #####:  115:			i--;
        -:  116:		}
        -:  117:	}
        3:  118:}
        -:  119:
    #####:  120:void Lock_wait(Lock *ptr, u64 nanoseconds) {
    #####:  121:	u64 tid = Lock_get_tid();
    #####:  122:	if (!(atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid))
    #####:  123:		panic("Attempt to wait on lock %p without first obtaining the "
        -:  124:			  "lock!",
        -:  125:			  ptr);
    #####:  126:	if (nanoseconds == 0) {
    #####:  127:		pthread_cond_wait(&ptr->cond, &ptr->lock);
        -:  128:	} else {
        -:  129:		struct timespec ts;
    #####:  130:		clock_gettime(CLOCK_REALTIME, &ts);
        -:  131:
        -:  132:		// Convert the wait time into seconds and nanoseconds
    #####:  133:		ts.tv_sec += nanoseconds / 1000000000;
    #####:  134:		ts.tv_nsec += nanoseconds % 1000000000;
        -:  135:
        -:  136:		// Normalize the timespec structure in case of overflow in
        -:  137:		// nanoseconds
    #####:  138:		if (ts.tv_nsec >= 1000000000) {
    #####:  139:			ts.tv_sec += ts.tv_nsec / 1000000000;
    #####:  140:			ts.tv_nsec %= 1000000000;
        -:  141:		}
    #####:  142:		pthread_cond_timedwait(&ptr->cond, &ptr->lock, &ts);
        -:  143:	}
    #####:  144:}
        -:  145:
        2:  146:void Lock_notify(Lock *ptr) {
        2:  147:	pthread_cond_signal(&ptr->cond);
        2:  148:}
        -:  149:
    #####:  150:void Lock_notify_all(Lock *ptr) {
    #####:  151:	pthread_cond_broadcast(&ptr->cond);
    #####:  152:}
        -:    0:Source:misc.c
        -:    0:Graph:misc.gcno
        -:    0:Data:misc.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/resources.h>
        -:   17:#include <dirent.h>
        -:   18:#include <limits.h>
        -:   19:#include <stdio.h>
        -:   20:#include <stdlib.h>
        -:   21:#include <string.h>
        -:   22:#include <sys/stat.h>
        -:   23:#include <unistd.h>
        -:   24:
        3:   25:const char *rstrstr(const char *s1, const char *s2)
        -:   26:{
        3:   27:	size_t s1len = strlen(s1);
        3:   28:	size_t s2len = strlen(s2);
        -:   29:	const char *s;
        -:   30:
        3:   31:	if (s2len > s1len)
    #####:   32:		return NULL;
       25:   33:	for (s = s1 + s1len - s2len; s >= s1; --s)
       25:   34:		if (strncmp(s, s2, s2len) == 0)
        3:   35:			return s;
    #####:   36:	return NULL;
        -:   37:}
        -:   38:
        1:   39:size_t read_all(void *buffer, size_t size, size_t count, FILE *stream)
        -:   40:{
        1:   41:	size_t total_read = 0;
        1:   42:	size_t bytes_to_read = size * count;
        -:   43:	size_t bytes_read;
        -:   44:
        2:   45:	while (total_read < bytes_to_read) {
        1:   46:		bytes_read = fread((char *)buffer + total_read, 1, bytes_to_read - total_read, stream);
        1:   47:		if (bytes_read == 0) {
        -:   48:			// Check for EOF or error
    #####:   49:			if (feof(stream)) {
    #####:   50:				break; // End of file reached
    #####:   51:			} else if (ferror(stream)) {
    #####:   52:				perror("Read error");
    #####:   53:				break; // Error occurred
        -:   54:			}
        -:   55:		}
        1:   56:		total_read += bytes_read;
        -:   57:	}
        -:   58:
        1:   59:	return total_read;
        -:   60:}
        -:   61:
    #####:   62:int copy_file(const char *dst, const char *src)
    #####:   63:{
        -:   64:	FILE *source_file, *dest_file;
        -:   65:	size_t bytes;
        -:   66:
        -:   67:	// Open the source file in binary read mode
    #####:   68:	source_file = myfopen(src, "rb");
    #####:   69:	if (source_file == NULL) {
    #####:   70:		perror("Error opening source file");
    #####:   71:		return -1;
        -:   72:	}
        -:   73:
        -:   74:	// Determine the file size
    #####:   75:	fseek(source_file, 0, SEEK_END);
    #####:   76:	long file_size = ftell(source_file);
    #####:   77:	fseek(source_file, 0, SEEK_SET);
    #####:   78:	char buffer[file_size];
        -:   79:
        -:   80:	// Open the destination file in binary write mode
    #####:   81:	dest_file = myfopen(dst, "wb");
    #####:   82:	if (dest_file == NULL) {
    #####:   83:		perror("Error opening destination file");
    #####:   84:		fclose(source_file);
    #####:   85:		return -1;
        -:   86:	}
        -:   87:
        -:   88:	// Copy the file content
    #####:   89:	while ((bytes = fread(buffer, 1, file_size, source_file)) > 0) {
    #####:   90:		if (fwrite(buffer, 1, bytes, dest_file) != bytes) {
    #####:   91:			perror("Error writing to destination file");
    #####:   92:			fclose(source_file);
    #####:   93:			fclose(dest_file);
    #####:   94:			return -1;
        -:   95:		}
        -:   96:	}
        -:   97:
        -:   98:	// Close both files
    #####:   99:	myfclose(source_file);
    #####:  100:	myfclose(dest_file);
        -:  101:
    #####:  102:	return 0;
        -:  103:}
        -:  104:
        -:  105:// Function to recursively remove a directory and its contents
       48:  106:int remove_directory(const char *path, bool preserve_dir)
        -:  107:{
        -:  108:	struct dirent *entry;
       48:  109:	DIR *dir = opendir(path);
        -:  110:
       48:  111:	if (dir == NULL) {
       24:  112:		return -1;
        -:  113:	}
        -:  114:
       73:  115:	while ((entry = readdir(dir)) != NULL) {
        -:  116:		char full_path[PATH_MAX];
        -:  117:
        -:  118:		// Skip the special entries "." and ".."
       49:  119:		if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
       48:  120:			continue;
        -:  121:		}
        -:  122:
        -:  123:		// Construct the full path to the file/directory
        1:  124:		snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        -:  125:
        -:  126:		struct stat statbuf;
        1:  127:		if (stat(full_path, &statbuf) == -1) {
    #####:  128:			perror("stat");
    #####:  129:			closedir(dir);
    #####:  130:			return -1;
        -:  131:		}
        -:  132:
        1:  133:		if (S_ISDIR(statbuf.st_mode)) {
        -:  134:			// It's a directory, recurse into it
    #####:  135:			if (remove_directory(full_path, false) == -1) {
    #####:  136:				closedir(dir);
    #####:  137:				return -1;
        -:  138:			}
        -:  139:		} else {
        -:  140:			// It's a file, unlink (delete) it
        1:  141:			if (unlink(full_path) == -1) {
    #####:  142:				perror("unlink");
    #####:  143:				closedir(dir);
    #####:  144:				return -1;
        -:  145:			}
        -:  146:		}
        -:  147:	}
        -:  148:
       24:  149:	closedir(dir);
        -:  150:
        -:  151:	// Now the directory is empty, so we can remove it
       24:  152:	if (!preserve_dir) {
       24:  153:		if (rmdir(path) == -1) {
    #####:  154:			perror("rmdir");
    #####:  155:			return -1;
        -:  156:		}
        -:  157:	}
        -:  158:
       24:  159:	return 0;
        -:  160:}
        -:  161:
    #####:  162:void exit_error(char *format, ...)
        -:  163:{
        -:  164:	va_list va_args;
    #####:  165:	va_start(va_args, format);
    #####:  166:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
    #####:  167:	vfprintf(stderr, format, va_args);
    #####:  168:	fprintf(stderr, "\n");
    #####:  169:	va_end(va_args);
    #####:  170:	exit(-1);
        -:  171:}
        -:    0:Source:panic.c
        -:    0:Graph:panic.gcno
        -:    0:Data:panic.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <base/lock.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <setjmp.h>
        -:   19:#include <stdarg.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <stdnoreturn.h>
        -:   23:
        -:   24:_Thread_local jmp_buf return_jmp;
        -:   25:_Thread_local bool jmp_return_set = false;
        -:   26:
        3:   27:void panic(const char *fmt, ...) {
        -:   28:	va_list args;
        -:   29:
        3:   30:	fprintf(stderr, "thread panicked: ");
        3:   31:	va_start(args, fmt);
        3:   32:	vfprintf(stderr, fmt, args);
        3:   33:	va_end(args);
        3:   34:	fprintf(stderr, "\n");
        -:   35:
        3:   36:	Lock_mark_poisoned();
        -:   37:
        3:   38:	if (__default_tl_heap_allocator != NULL) {
    #####:   39:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   40:	}
        -:   41:
        -:   42:	// If jump return has not been set, we resort to an exit with an error
        -:   43:	// status.
        3:   44:	if (!jmp_return_set)
    #####:   45:		exit(-1);
        3:   46:	longjmp(return_jmp, THREAD_PANIC);
        -:   47:}
        -:    0:Source:path.c
        -:    0:Graph:path.gcno
        -:    0:Data:path.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <errno.h>
        -:   18:#include <limits.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:#include <sys/stat.h>
        -:   22:
       32:   23:void path_cleanup(PathImpl *ptr) {
       32:   24:	chain_free(&ptr->ptr);
       32:   25:}
        -:   26:
       32:   27:int path_for(Path *p, const char *path) {
       32:   28:	if (path == NULL) {
    #####:   29:		errno = EINVAL;
    #####:   30:		return -1;
        -:   31:	}
       32:   32:	int len = strlen(path);
       32:   33:	if (len == 0) {
    #####:   34:		errno = EINVAL;
    #####:   35:		return -1;
        -:   36:	}
       32:   37:	if (chain_malloc(&p->ptr, len + 1))
    #####:   38:		return -1;
       32:   39:	strcpy(p->ptr.data, path);
       32:   40:	return 0;
        -:   41:}
        -:   42:
       31:   43:int path_replace_home(Path *p) {
       31:   44:	const char *home_dir = getenv("HOME");
       31:   45:	if (home_dir == NULL) {
    #####:   46:		errno = EINVAL;
    #####:   47:		return -1;
        -:   48:	}
       31:   49:	if (((char *)(p->ptr.data))[0] == '~') {
    #####:   50:		int nlen = strlen(home_dir) + strlen(PATH_SEPARATOR) + strlen(p->ptr.data);
    #####:   51:		if (nlen >= PATH_MAX) {
    #####:   52:			errno = E2BIG;
    #####:   53:			return -1;
        -:   54:		}
    #####:   55:		if (nlen >= p->ptr.len) {
        -:   56:			FatPtr nptr;
    #####:   57:			if (chain_realloc(&nptr, &p->ptr, nlen + 1))
    #####:   58:				return -1;
    #####:   59:			p->ptr = nptr;
        -:   60:		}
        -:   61:		char buf[PATH_MAX + 1];
    #####:   62:		snprintf(buf, PATH_MAX, "%s%s%s", home_dir, PATH_SEPARATOR, (char *)(p->ptr.data + 1));
    #####:   63:		strcpy(p->ptr.data, buf);
        -:   64:	}
       31:   65:	return 0;
        -:   66:}
        -:   67:
       31:   68:int path_canonicalize(Path *p) {
       31:   69:	if (path_replace_home(p))
    #####:   70:		return -1;
        -:   71:	char buf[PATH_MAX];
       31:   72:	errno = 0;
       31:   73:	if (realpath(p->ptr.data, buf) == NULL) {
        2:   74:		return -1;
        -:   75:	}
       29:   76:	int nlen = strlen(buf);
       29:   77:	if (nlen == 0) {
    #####:   78:		errno = EFAULT;
    #####:   79:		return -1;
        -:   80:	}
       29:   81:	if (nlen >= p->ptr.len) {
        -:   82:		FatPtr nptr;
       28:   83:		if (chain_realloc(&nptr, &p->ptr, nlen + 1))
    #####:   84:			return -1;
       28:   85:		p->ptr = nptr;
        -:   86:	}
       29:   87:	strcpy(p->ptr.data, buf);
       29:   88:	return 0;
        -:   89:}
        5:   90:int path_push(Path *p, const char *next) {
        5:   91:	if (next == NULL) {
    #####:   92:		errno = EINVAL;
    #####:   93:		return -1;
        -:   94:	}
        5:   95:	int slen = strlen(p->ptr.data);
        5:   96:	if (slen <= 0) {
    #####:   97:		errno = EFAULT;
    #####:   98:		return -1;
        -:   99:	}
        5:  100:	bool need_sep = false;
        5:  101:	if (((char *)p->ptr.data)[slen - 1] != PATH_SEPARATOR_CHAR) {
        4:  102:		need_sep = true;
        -:  103:	}
        -:  104:
        5:  105:	int nlen = slen + strlen(next);
        5:  106:	if (need_sep)
        4:  107:		nlen += strlen(PATH_SEPARATOR);
        -:  108:
        5:  109:	if (nlen >= p->ptr.len) {
        -:  110:		FatPtr nptr;
        3:  111:		if (chain_realloc(&nptr, &p->ptr, nlen + 1))
    #####:  112:			return -1;
        3:  113:		p->ptr = nptr;
        -:  114:	}
        -:  115:
        5:  116:	if (need_sep)
        4:  117:		strcat(p->ptr.data, PATH_SEPARATOR);
        5:  118:	strcat(p->ptr.data, next);
        5:  119:	return 0;
        -:  120:}
        2:  121:int path_pop(Path *p) {
        2:  122:	char *res = rstrstr(p->ptr.data, PATH_SEPARATOR);
        2:  123:	if (res) {
        2:  124:		int index = res - (char *)p->ptr.data;
        2:  125:		((char *)(p->ptr.data))[index] = 0;
        -:  126:	} else {
    #####:  127:		((char *)(p->ptr.data))[0] = '.';
    #####:  128:		((char *)(p->ptr.data))[1] = 0;
        -:  129:	}
        2:  130:	return 0;
        -:  131:}
        -:  132:
        8:  133:char *path_to_string(const Path *p) {
        8:  134:	return p->ptr.data;
        -:  135:}
        -:  136:
    #####:  137:char *path_file_name(const Path *p) {
    #####:  138:	char *ret = rstrstr(p->ptr.data, PATH_SEPARATOR);
    #####:  139:	if (ret != NULL && strlen(ret) > 0)
    #####:  140:		return ret + 1;
        -:  141:
    #####:  142:	return ret;
        -:  143:}
        -:  144:
    #####:  145:bool path_exists(const Path *p) {
    #####:  146:	if (p->ptr.data == NULL && p->ptr.len == 0) {
    #####:  147:		errno = EINVAL;
    #####:  148:		return false;
        -:  149:	}
    #####:  150:	return access(p->ptr.data, F_OK) == 0;
        -:  151:}
    #####:  152:bool path_is_dir(const Path *p) {
    #####:  153:	if (p->ptr.data == NULL && p->ptr.len == 0) {
    #####:  154:		errno = EINVAL;
    #####:  155:		return false;
        -:  156:	}
        -:  157:	struct stat s;
    #####:  158:	if (stat(p->ptr.data, &s) == 0) {
    #####:  159:		return s.st_mode & S_IFDIR;
        -:  160:	}
    #####:  161:	return false;
        -:  162:}
        -:  163:
    #####:  164:bool path_mkdir(Path *p, mode_t mode, bool parent) {
    #####:  165:	if (p->ptr.data == NULL && p->ptr.len == 0) {
    #####:  166:		errno = EINVAL;
    #####:  167:		return false;
        -:  168:	}
        -:  169:
        -:  170:	struct stat s;
        -:  171:
        -:  172:	// Check if the path exists
    #####:  173:	if (stat(p->ptr.data, &s) == 0) {
        -:  174:		// If the path exists and it's a directory, return success
    #####:  175:		if (s.st_mode & S_IFDIR) {
    #####:  176:			return true;
        -:  177:		} else {
        -:  178:			// Path exists but it's not a directory
    #####:  179:			errno = ENOTDIR;
    #####:  180:			return false;
        -:  181:		}
        -:  182:	}
        -:  183:
        -:  184:	// If parent is false, attempt to create only the target directory
    #####:  185:	if (!parent) {
    #####:  186:		if (mkdir(p->ptr.data, mode) != 0) {
    #####:  187:			return false;
        -:  188:		}
    #####:  189:		return true;
        -:  190:	}
        -:  191:
        -:  192:	// Create the directory structure (parent is true)
    #####:  193:	Path temp_path;
    #####:  194:	if (path_copy(&temp_path, p) != 0) {
    #####:  195:		return false;
        -:  196:	}
        -:  197:
    #####:  198:	char *dir_part = strtok(temp_path.ptr.data, PATH_SEPARATOR);
    #####:  199:	Path current_path;
    #####:  200:	path_for(&current_path, PATH_SEPARATOR);
        -:  201:
        -:  202:	// Iterate through each part of the path and create directories as needed
    #####:  203:	while (dir_part != NULL) {
    #####:  204:		if (path_push(&current_path, dir_part) != 0) {
    #####:  205:			return false;
        -:  206:		}
        -:  207:
        -:  208:		// Check if the current part of the path exists, and if not, create it
    #####:  209:		if (stat(current_path.ptr.data, &s) != 0) {
        -:  210:			// Directory does not exist, so create it
    #####:  211:			if (mkdir(current_path.ptr.data, mode) != 0) {
    #####:  212:				return false;
        -:  213:			}
    #####:  214:		} else if (!(s.st_mode & S_IFDIR)) {
        -:  215:			// Path exists but is not a directory
    #####:  216:			errno = ENOTDIR;
    #####:  217:			return false;
        -:  218:		}
        -:  219:
    #####:  220:		dir_part = strtok(NULL, PATH_SEPARATOR);
        -:  221:	}
        -:  222:
    #####:  223:	return true;
        -:  224:}
        -:  225:
    #####:  226:int path_copy(Path *dst, const Path *src) {
    #####:  227:	return path_for(dst, path_to_string(src));
        -:  228:}
        -:  229:
    #####:  230:int path_file_stem(const Path *p, char *buf, u64 limit) {
        -:  231:	// Copy the file name into the buffer, ensuring proper null termination
    #####:  232:	strncpy(buf, path_file_name(p), limit - 1);
    #####:  233:	buf[limit - 1] = '\0'; // Manually ensure null-termination
        -:  234:
    #####:  235:	u64 buflen = strlen(buf); // Compute length once
    #####:  236:	for (ssize_t i = buflen - 1; i >= 0; i--) {
    #####:  237:		if (buf[i] == '.') {
    #####:  238:			buf[i] = '\0'; // Null-terminate at the dot
    #####:  239:			break;
    #####:  240:		} else if (buf[i] == '/') {
    #####:  241:			break; // Stop if we encounter a directory separator
        -:  242:		}
        -:  243:	}
    #####:  244:	return 0;
        -:  245:}
        -:    0:Source:rand.c
        -:    0:Graph:rand.gcno
        -:    0:Data:rand.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <base/types.h>
        -:   17:#include <sys/random.h>
        -:   18:
    #####:   19:int rand_i8(i8 *v) {
    #####:   20:	return getentropy(v, sizeof(i8));
        -:   21:}
        -:   22:
    #####:   23:int rand_u8(u8 *v) {
    #####:   24:	return getentropy(v, sizeof(u8));
        -:   25:}
        -:   26:
    #####:   27:int rand_i16(i16 *v) {
    #####:   28:	return getentropy(v, sizeof(i16));
        -:   29:}
        -:   30:
    32350:   31:int rand_u16(u16 *v) {
    32350:   32:	return getentropy(v, sizeof(u16));
        -:   33:}
        -:   34:
    #####:   35:int rand_i32(i32 *v) {
    #####:   36:	return getentropy(v, sizeof(i32));
        -:   37:}
        -:   38:
    #####:   39:int rand_u32(u32 *v) {
    #####:   40:	return getentropy(v, sizeof(u32));
        -:   41:}
        -:   42:
    #####:   43:int rand_i64(i64 *v) {
    #####:   44:	return getentropy(v, sizeof(i64));
        -:   45:}
        -:   46:
    #####:   47:int rand_u64(u64 *v) {
    #####:   48:	return getentropy(v, sizeof(u64));
        -:   49:}
        -:   50:
    #####:   51:int rand_i128(i128 *v) {
    #####:   52:	return getentropy(v, sizeof(i128));
        -:   53:}
        -:   54:
    #####:   55:int rand_u128(u128 *v) {
    #####:   56:	return getentropy(v, sizeof(u128));
        -:   57:}
        -:   58:
    #####:   59:int rand_bytes(void *buf, u64 length) {
    #####:   60:	return getentropy(buf, length);
        -:   61:}
        -:    0:Source:resources.c
        -:    0:Graph:resources.gcno
        -:    0:Data:resources.gcda
        -:    0:Runs:69
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = { 0, 0, 0, 0, 0 };
        -:   19:
    66174:   20:void *mymalloc(usize size)
        -:   21:{
        -:   22:	void *ret;
    66174:   23:	ret = malloc(size);
        -:   24:
    66174:   25:	if (ret) {
    66174:   26:		THREAD_LOCAL_RESOURCE_STATS.malloc_sum += 1;
        -:   27:	}
    66174:   28:	return ret;
        -:   29:}
    62352:   30:void *myrealloc(void *ptr, usize size)
        -:   31:{
        -:   32:	void *ret;
    62352:   33:	ret = realloc(ptr, size);
        -:   34:
    62352:   35:	if (ret) {
    62352:   36:		THREAD_LOCAL_RESOURCE_STATS.realloc_sum += 1;
        -:   37:	}
    62352:   38:	return ret;
        -:   39:}
    66141:   40:void myfree(void *ptr)
        -:   41:{
    66141:   42:	THREAD_LOCAL_RESOURCE_STATS.free_sum += 1;
    66141:   43:	free(ptr);
    66141:   44:}
        9:   45:FILE *myfopen(const char *path, const char *mode)
        -:   46:{
        9:   47:	FILE *ret = fopen(path, mode);
        -:   48:
        9:   49:	if (ret) {
        9:   50:		THREAD_LOCAL_RESOURCE_STATS.fopen_sum += 1;
        -:   51:	}
        9:   52:	return ret;
        -:   53:}
        9:   54:void myfclose(FILE *ptr)
        -:   55:{
        9:   56:	THREAD_LOCAL_RESOURCE_STATS.fclose_sum += 1;
        9:   57:	fclose(ptr);
        9:   58:}
       51:   59:u64 mymalloc_sum()
        -:   60:{
       51:   61:	return THREAD_LOCAL_RESOURCE_STATS.malloc_sum;
        -:   62:}
    #####:   63:u64 myrealloc_sum()
        -:   64:{
    #####:   65:	return THREAD_LOCAL_RESOURCE_STATS.realloc_sum;
        -:   66:}
       51:   67:u64 myfree_sum()
        -:   68:{
       51:   69:	return THREAD_LOCAL_RESOURCE_STATS.free_sum;
        -:   70:}
       72:   71:u64 myfopen_sum()
        -:   72:{
       72:   73:	return THREAD_LOCAL_RESOURCE_STATS.fopen_sum;
        -:   74:}
       72:   75:u64 myfclose_sum()
        -:   76:{
       72:   77:	return THREAD_LOCAL_RESOURCE_STATS.fclose_sum;
        -:   78:}
        -:    0:Source:sha256.c
        -:    0:Graph:sha256.gcno
        -:    0:Data:sha256.gcda
        -:    0:Runs:69
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:
        -:    5:#define uchar unsigned char
        -:    6:#define uint unsigned int
        -:    7:
        -:    8:#define DBL_INT_ADD(a, b, c)                                                                       \
        -:    9:	if (a > 0xffffffff - (c))                                                                      \
        -:   10:		++b;                                                                                       \
        -:   11:	a += c;
        -:   12:#define ROTLEFT(a, b) (((a) << (b)) | ((a) >> (32 - (b))))
        -:   13:#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
        -:   14:
        -:   15:#define CH(x, y, z) (((x) & (y)) ^ (~(x) & (z)))
        -:   16:#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
        -:   17:#define EP0(x) (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
        -:   18:#define EP1(x) (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
        -:   19:#define SIG0(x) (ROTRIGHT(x, 7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
        -:   20:#define SIG1(x) (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))
        -:   21:
        -:   22:typedef struct {
        -:   23:	uchar data[64];
        -:   24:	uint datalen;
        -:   25:	uint bitlen[2];
        -:   26:	uint state[8];
        -:   27:} SHA256_CTX;
        -:   28:
        -:   29:uint k[64] = {
        -:   30:	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        -:   31:	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        -:   32:	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        -:   33:	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        -:   34:	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        -:   35:	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        -:   36:	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        -:   37:	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
        -:   38:
   144820:   39:void SHA256Transform(SHA256_CTX *ctx, uchar data[]) {
        -:   40:	uint a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
        -:   41:
  2461940:   42:	for (i = 0, j = 0; i < 16; ++i, j += 4)
  2317120:   43:		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
  7096180:   44:	for (; i < 64; ++i)
  6951360:   45:		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
        -:   46:
   144820:   47:	a = ctx->state[0];
   144820:   48:	b = ctx->state[1];
   144820:   49:	c = ctx->state[2];
   144820:   50:	d = ctx->state[3];
   144820:   51:	e = ctx->state[4];
   144820:   52:	f = ctx->state[5];
   144820:   53:	g = ctx->state[6];
   144820:   54:	h = ctx->state[7];
        -:   55:
  9413300:   56:	for (i = 0; i < 64; ++i) {
  9268480:   57:		t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
  9268480:   58:		t2 = EP0(a) + MAJ(a, b, c);
  9268480:   59:		h = g;
  9268480:   60:		g = f;
  9268480:   61:		f = e;
  9268480:   62:		e = d + t1;
  9268480:   63:		d = c;
  9268480:   64:		c = b;
  9268480:   65:		b = a;
  9268480:   66:		a = t1 + t2;
        -:   67:	}
        -:   68:
   144820:   69:	ctx->state[0] += a;
   144820:   70:	ctx->state[1] += b;
   144820:   71:	ctx->state[2] += c;
   144820:   72:	ctx->state[3] += d;
   144820:   73:	ctx->state[4] += e;
   144820:   74:	ctx->state[5] += f;
   144820:   75:	ctx->state[6] += g;
   144820:   76:	ctx->state[7] += h;
   144820:   77:}
        -:   78:
        2:   79:void SHA256Init(SHA256_CTX *ctx) {
        2:   80:	ctx->datalen = 0;
        2:   81:	ctx->bitlen[0] = 0;
        2:   82:	ctx->bitlen[1] = 0;
        2:   83:	ctx->state[0] = 0x6a09e667;
        2:   84:	ctx->state[1] = 0xbb67ae85;
        2:   85:	ctx->state[2] = 0x3c6ef372;
        2:   86:	ctx->state[3] = 0xa54ff53a;
        2:   87:	ctx->state[4] = 0x510e527f;
        2:   88:	ctx->state[5] = 0x9b05688c;
        2:   89:	ctx->state[6] = 0x1f83d9ab;
        2:   90:	ctx->state[7] = 0x5be0cd19;
        2:   91:}
        -:   92:
        2:   93:void SHA256Update(SHA256_CTX *ctx, uchar data[], uint len) {
  9268460:   94:	for (uint i = 0; i < len; ++i) {
  9268458:   95:		ctx->data[ctx->datalen] = data[i];
  9268458:   96:		ctx->datalen++;
  9268458:   97:		if (ctx->datalen == 64) {
   144818:   98:			SHA256Transform(ctx, ctx->data);
  144818*:   99:			DBL_INT_ADD(ctx->bitlen[0], ctx->bitlen[1], 512);
   144818:  100:			ctx->datalen = 0;
        -:  101:		}
        -:  102:	}
        2:  103:}
        -:  104:
        2:  105:void SHA256Final(SHA256_CTX *ctx, uchar hash[]) {
        2:  106:	uint i = ctx->datalen;
        -:  107:
        2:  108:	if (ctx->datalen < 56) {
        2:  109:		ctx->data[i++] = 0x80;
        6:  110:		while (i < 56)
        4:  111:			ctx->data[i++] = 0x00;
        -:  112:	} else {
    #####:  113:		ctx->data[i++] = 0x80;
    #####:  114:		while (i < 64)
    #####:  115:			ctx->data[i++] = 0x00;
    #####:  116:		SHA256Transform(ctx, ctx->data);
    #####:  117:		memset(ctx->data, 0, 56);
        -:  118:	}
        -:  119:
       2*:  120:	DBL_INT_ADD(ctx->bitlen[0], ctx->bitlen[1], ctx->datalen * 8);
        2:  121:	ctx->data[63] = ctx->bitlen[0];
        2:  122:	ctx->data[62] = ctx->bitlen[0] >> 8;
        2:  123:	ctx->data[61] = ctx->bitlen[0] >> 16;
        2:  124:	ctx->data[60] = ctx->bitlen[0] >> 24;
        2:  125:	ctx->data[59] = ctx->bitlen[1];
        2:  126:	ctx->data[58] = ctx->bitlen[1] >> 8;
        2:  127:	ctx->data[57] = ctx->bitlen[1] >> 16;
        2:  128:	ctx->data[56] = ctx->bitlen[1] >> 24;
        2:  129:	SHA256Transform(ctx, ctx->data);
        -:  130:
       10:  131:	for (i = 0; i < 4; ++i) {
        8:  132:		hash[i] = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
        8:  133:		hash[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
        8:  134:		hash[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
        8:  135:		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
        8:  136:		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
        8:  137:		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
        8:  138:		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
        8:  139:		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
        -:  140:	}
        2:  141:}
        -:  142:
        2:  143:int SHA256(unsigned char *data, char hashStr[65]) {
        2:  144:	if (hashStr == NULL || data == NULL)
    #####:  145:		return -1;
        2:  146:	int strLen = strlen((const char *)data);
        -:  147:	SHA256_CTX ctx;
        -:  148:	unsigned char hash[32];
        2:  149:	strcpy(hashStr, "");
        -:  150:
        2:  151:	SHA256Init(&ctx);
        2:  152:	SHA256Update(&ctx, data, strLen);
        2:  153:	SHA256Final(&ctx, hash);
        -:  154:
        -:  155:	char s[3];
       66:  156:	for (int i = 0; i < 32; i++) {
       64:  157:		snprintf(s, 3, "%02x", hash[i]);
       64:  158:		strcat(hashStr, s);
        -:  159:	}
        -:  160:
        2:  161:	return 0;
        -:  162:}
        -:    0:Source:build.c
        -:    0:Graph:build.gcno
        -:    0:Data:build.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <build/build.h>
        -:   19:#include <build/parser.h>
        -:   20:#include <glob.h>
        -:   21:#include <stdio.h>
        -:   22:#include <stdlib.h>
        -:   23:#include <string.h>
        -:   24:#include <toml/toml.h>
        -:   25:#include <util/proc_executor.h>
        -:   26:
        -:   27:typedef struct FamTomlInfo {
        -:   28:	char name[MAX_NAME_LEN];
        -:   29:	char version[MAX_NAME_LEN];
        -:   30:} FamTomlInfo;
        -:   31:
    #####:   32:FamTomlInfo extract_toml_info(const char *base_dir) {
    #####:   33:	Path toml;
    #####:   34:	path_for(&toml, base_dir);
    #####:   35:	path_push(&toml, "fam.toml");
        -:   36:
    #####:   37:	if (path_canonicalize(&toml)) {
    #####:   38:		exit_error("fam.toml file ('%s') not found.", path_to_string(&toml));
        -:   39:	}
        -:   40:
    #####:   41:	FILE *toml_fp = myfopen(path_to_string(&toml), "r");
        -:   42:	char errbuf[1024];
    #####:   43:	toml_table_t *table = toml_parse_file(toml_fp, errbuf, sizeof(errbuf));
        -:   44:
    #####:   45:	if (table == NULL) {
    #####:   46:		exit_error("Could not parse toml file due to '%s'", errbuf);
        -:   47:	}
        -:   48:
        -:   49:	FamTomlInfo ret;
        -:   50:
    #####:   51:	myfclose(toml_fp);
        -:   52:
    #####:   53:	toml_raw_t raw_fam_version = toml_raw_in(table, "fam_version");
        -:   54:	char *fam_version;
    #####:   55:	if (raw_fam_version) {
    #####:   56:		toml_rtos(raw_fam_version, &fam_version);
    #####:   57:		strcpy(ret.version, fam_version);
    #####:   58:		free((void *)fam_version); // Clean up after toml_rtos
        -:   59:	} else {
    #####:   60:		exit_error("fam_version not specified in '%s'", path_to_string(&toml));
        -:   61:	}
        -:   62:
    #####:   63:	toml_table_t *package_table = toml_table_in(table, "package");
    #####:   64:	if (package_table) {
    #####:   65:		toml_raw_t raw_name = toml_raw_in(package_table, "name");
        -:   66:		char *name;
    #####:   67:		if (raw_name) {
    #####:   68:			toml_rtos(raw_name, &name);
    #####:   69:			strcpy(ret.name, name);
        -:   70:		} else {
    #####:   71:			exit_error("name not specified in fam.toml!");
        -:   72:		}
        -:   73:	} else {
    #####:   74:		exit_error("package not found in fam.toml");
        -:   75:	}
        -:   76:
    #####:   77:	return ret;
        -:   78:}
        -:   79:
    #####:   80:void ensure_target_structure(const char *base_dir) {
    #####:   81:	Path target;
    #####:   82:	path_for(&target, base_dir);
    #####:   83:	path_push(&target, "target");
    #####:   84:	if (!path_exists(&target)) {
    #####:   85:		if (!path_mkdir(&target, 0700, false))
    #####:   86:			exit_error("Could not create directory '%s'.", path_to_string(&target));
    #####:   87:		path_push(&target, "objs");
    #####:   88:		if (!path_mkdir(&target, 0700, false))
    #####:   89:			exit_error("Could not create directory '%s'.", path_to_string(&target));
    #####:   90:		path_pop(&target);
    #####:   91:		path_push(&target, "build");
    #####:   92:		if (!path_mkdir(&target, 0700, false))
    #####:   93:			exit_error("Could not create directory '%s'.", path_to_string(&target));
    #####:   94:		path_pop(&target);
    #####:   95:		path_push(&target, "include");
    #####:   96:		if (!path_mkdir(&target, 0700, false))
    #####:   97:			exit_error("Could not create directory '%s'.", path_to_string(&target));
    #####:   98:		path_pop(&target);
    #####:   99:		path_push(&target, "args");
    #####:  100:		if (!path_mkdir(&target, 0700, false))
    #####:  101:			exit_error("Could not create directory '%s'.", path_to_string(&target));
        -:  102:	}
        -:  103:
    #####:  104:	if (path_canonicalize(&target)) {
    #####:  105:		exit_error("Could not create path: %s\n", path_to_string(&target));
        -:  106:	}
    #####:  107:}
        -:  108:
    #####:  109:u64 module_to_string(const ModuleInfo *module_info, char *buf, u64 limit) {
    #####:  110:	u64 itt = 0;
    #####:  111:	strncpy(buf, "", limit);
    #####:  112:	for (u64 i = 0; i < module_info->sub_module_count; i++) {
    #####:  113:		if (itt < limit)
    #####:  114:			strncat(buf, module_info->module_list[i].name, limit - itt);
    #####:  115:		itt += strlen(module_info->module_list[i].name);
    #####:  116:		if (i != module_info->sub_module_count - 1) {
    #####:  117:			if (itt < limit)
    #####:  118:				strncat(buf, "/", limit - itt);
    #####:  119:			itt += 1;
        -:  120:		}
        -:  121:	}
        -:  122:
    #####:  123:	return itt;
        -:  124:}
        -:  125:
    #####:  126:u64 module_to_type_string(const ModuleInfo *type_info, char *buf, u64 limit) {
    #####:  127:	u64 itt = 0;
    #####:  128:	strncpy(buf, "type_____", limit);
    #####:  129:	itt += 10;
    #####:  130:	for (u64 i = 0; i < type_info->sub_module_count; i++) {
    #####:  131:		if (itt < limit)
    #####:  132:			strncat(buf, type_info->module_list[i].name, limit - itt);
    #####:  133:		itt += strlen(type_info->module_list[i].name);
    #####:  134:		if (1 + i < type_info->sub_module_count) {
    #####:  135:			if (itt < limit)
    #####:  136:				strncat(buf, "_____", limit - itt);
    #####:  137:			itt += 5;
        -:  138:		}
        -:  139:	}
        -:  140:
    #####:  141:	return itt;
        -:  142:}
        -:  143:
    #####:  144:u64 type_info_to_string(const TypeInfo *type_info, char *buf, u64 limit) {
    #####:  145:	u64 itt = 0;
    #####:  146:	strncpy(buf, "type_____", limit);
    #####:  147:	itt += 10;
    #####:  148:	for (u64 i = 0; i < type_info->mi.sub_module_count; i++) {
    #####:  149:		if (itt < limit)
    #####:  150:			strncat(buf, type_info->mi.module_list[i].name, limit - itt);
    #####:  151:		itt += strlen(type_info->mi.module_list[i].name);
    #####:  152:		if (itt < limit)
    #####:  153:			strncat(buf, "_____", limit - itt);
    #####:  154:		itt += 5;
        -:  155:	}
    #####:  156:	if (itt < limit)
    #####:  157:		strncat(buf, type_info->type_name, limit - itt);
    #####:  158:	itt += strlen(type_info->type_name);
        -:  159:
    #####:  160:	return itt;
        -:  161:}
        -:  162:
    #####:  163:u64 type_info_to_path(const TypeInfo *type_info, char *buf, u64 limit) {
    #####:  164:	u64 itt = 0;
    #####:  165:	strncpy(buf, "", limit);
    #####:  166:	for (u64 i = 0; i < type_info->mi.sub_module_count; i++) {
    #####:  167:		if (itt < limit)
    #####:  168:			strncat(buf, type_info->mi.module_list[i].name, limit - itt);
    #####:  169:		itt += strlen(type_info->mi.module_list[i].name);
    #####:  170:		if (itt < limit)
    #####:  171:			strncat(buf, "/", limit - itt);
    #####:  172:		itt += 1;
        -:  173:	}
    #####:  174:	if (itt < limit)
    #####:  175:		strncat(buf, type_info->type_name, limit - itt);
    #####:  176:	itt += strlen(type_info->type_name);
        -:  177:
    #####:  178:	return itt;
        -:  179:}
        -:  180:
    #####:  181:u64 type_info_module_file(const char *base_dir, const TypeInfo *type_info, char *buf, u64 limit) {
    #####:  182:	Path p;
    #####:  183:	path_for(&p, base_dir);
    #####:  184:	if (type_info->mi.sub_module_count) {
    #####:  185:		for (u64 i = 0; i < type_info->mi.sub_module_count - 1; i++) {
    #####:  186:			path_push(&p, type_info->mi.module_list[i].name);
        -:  187:		}
        -:  188:	}
    #####:  189:	if (type_info->mi.sub_module_count) {
        -:  190:		char header_name[PATH_MAX];
    #####:  191:		strcpy(header_name, type_info->mi.module_list[type_info->mi.sub_module_count - 1].name);
    #####:  192:		strcat(header_name, ".h");
    #####:  193:		path_push(&p, header_name);
        -:  194:
    #####:  195:		if (path_exists(&p)) {
    #####:  196:			strncpy(buf, path_to_string(&p), limit);
    #####:  197:			return strlen(path_to_string(&p));
        -:  198:		} else {
    #####:  199:			path_pop(&p);
    #####:  200:			path_push(&p, type_info->mi.module_list[type_info->mi.sub_module_count - 1].name);
    #####:  201:			path_push(&p, "mod.h");
    #####:  202:			if (path_exists(&p)) {
    #####:  203:				strncpy(buf, path_to_string(&p), limit);
    #####:  204:				return strlen(path_to_string(&p));
        -:  205:			} else {
    #####:  206:				exit_error("header file did not exist at path '%s'", path_to_string(&p));
        -:  207:			}
        -:  208:		}
        -:  209:	} else {
    #####:  210:		path_push(&p, "mod.h");
    #####:  211:		strncpy(buf, path_to_string(&p), limit);
    #####:  212:		return strlen(path_to_string(&p));
        -:  213:	}
        -:  214:
        -:  215:	// should never get here
    #####:  216:	return 0;
        -:  217:}
        -:  218:
    #####:  219:void build_obj(const char *cc, const char *include_dir, const char *obj_dir, const char *src_dir,
        -:  220:			   const TypeInfo *type_info, const char *obj_prefix, const char *config_include,
    #####:  221:			   const char *impl_def, const char *implconfig_def, const char *args_path) {
    #####:  222:	Path obj_path;
    #####:  223:	path_for(&obj_path, obj_dir);
        -:  224:
    #####:  225:	u64 obj_prefix_len = 0;
    #####:  226:	if (obj_prefix)
    #####:  227:		obj_prefix_len = strlen(obj_prefix);
    #####:  228:	char obj_file_name[obj_prefix_len + strlen(type_info->type_name) + 5];
    #####:  229:	if (obj_prefix) {
    #####:  230:		strcpy(obj_file_name, obj_prefix);
    #####:  231:		strcat(obj_file_name, type_info->type_name);
    #####:  232:		strcat(obj_file_name, ".o");
        -:  233:	} else {
    #####:  234:		strcpy(obj_file_name, type_info->type_name);
    #####:  235:		strcat(obj_file_name, ".o");
        -:  236:	}
        -:  237:
    #####:  238:	path_push(&obj_path, obj_file_name);
        -:  239:
    #####:  240:	u64 needed = type_info_to_path(type_info, NULL, 0);
    #####:  241:	char file_name[needed + 3];
    #####:  242:	type_info_to_path(type_info, file_name, needed);
    #####:  243:	strcat(file_name, ".c");
        -:  244:
    #####:  245:	Path src_path;
    #####:  246:	path_for(&src_path, src_dir);
    #####:  247:	path_push(&src_path, file_name);
        -:  248:
    #####:  249:	char include_param[strlen(include_dir) + 5];
    #####:  250:	strcpy(include_param, "-I");
    #####:  251:	strcat(include_param, include_dir);
        -:  252:
    #####:  253:	char args_path_with_at[strlen(args_path) + 2];
    #####:  254:	strcpy(args_path_with_at, "@");
    #####:  255:	strcat(args_path_with_at, args_path);
        -:  256:
    #####:  257:	if (config_include) {
    #####:  258:		char config_include_param[strlen(config_include) + 5];
    #####:  259:		strcpy(config_include_param, "-I");
    #####:  260:		strcat(config_include_param, config_include);
    #####:  261:		const char *args[] = {cc,
        -:  262:							  "-Wno-attributes",
        -:  263:							  "-Wno-ignored-attributes",
        -:  264:							  "-Werror=incompatible-pointer-types-discards-qualifiers",
        -:  265:							  include_param,
        -:  266:							  config_include_param,
        -:  267:							  "-c",
        -:  268:							  "-o",
    #####:  269:							  path_to_string(&obj_path),
    #####:  270:							  path_to_string(&src_path),
        -:  271:							  impl_def,
        -:  272:							  implconfig_def,
        -:  273:							  args_path_with_at,
        -:  274:							  NULL};
    #####:  275:		if (execute_process(args)) {
    #####:  276:			exit_error("execution of process '%s' failed", args[0]);
        -:  277:		}
        -:  278:	} else {
    #####:  279:		const char *args[] = {cc,
        -:  280:							  "-Wno-attributes",
        -:  281:							  "-Wno-ignored-attributes",
        -:  282:							  "-Werror=incompatible-pointer-types-discards-qualifiers",
        -:  283:							  include_param,
        -:  284:							  "-c",
        -:  285:							  "-o",
    #####:  286:							  path_to_string(&obj_path),
    #####:  287:							  path_to_string(&src_path),
        -:  288:							  impl_def,
        -:  289:							  implconfig_def,
        -:  290:							  args_path_with_at,
        -:  291:							  NULL};
    #####:  292:		if (execute_process(args)) {
    #####:  293:			exit_error("execution of process '%s' failed", args[0]);
        -:  294:		}
        -:  295:	}
    #####:  296:}
        -:  297:
    #####:  298:void link_objs(const char *objs_path, const char *base_dir, const char *name) {
        -:  299:	glob_t glob_result;
    #####:  300:	Path objs_dir;
    #####:  301:	path_for(&objs_dir, base_dir);
    #####:  302:	path_push(&objs_dir, "target/objs/*.o");
        -:  303:
    #####:  304:	glob(path_to_string(&objs_dir), 0, NULL, &glob_result);
        -:  305:
        -:  306:	// Construct the argument array for exec
    #####:  307:	char *link[5 + glob_result.gl_pathc + 1];
    #####:  308:	Path output_file;
    #####:  309:	path_for(&output_file, base_dir);
    #####:  310:	path_push(&output_file, "target");
    #####:  311:	path_push(&output_file, name);
    #####:  312:	link[0] = "cc";
    #####:  313:	link[1] = "-o";
    #####:  314:	link[2] = path_to_string(&output_file);
        -:  315:
        -:  316:	// Add all the .o files from glob to the argument list
    #####:  317:	for (size_t i = 0; i < glob_result.gl_pathc; i++) {
    #####:  318:		link[3 + i] = glob_result.gl_pathv[i];
        -:  319:	}
    #####:  320:	link[3 + glob_result.gl_pathc] = NULL; // Terminate the argument list
        -:  321:
    #####:  322:	const char **link_const = (const char **)&link;
        -:  323:
    #####:  324:	if (execute_process(link_const)) {
    #####:  325:		exit_error("execution of process '%s' failed", link[0]);
        -:  326:	}
    #####:  327:}
        -:  328:
    #####:  329:void build_internal(const char *base_dir, const char *config_dir) {
    #####:  330:	Path build_path;
    #####:  331:	path_for(&build_path, base_dir);
    #####:  332:	path_push(&build_path, "target");
    #####:  333:	path_push(&build_path, "build");
    #####:  334:	remove_directory(path_to_string(&build_path), true);
        -:  335:
    #####:  336:	Path objs_path;
    #####:  337:	path_for(&objs_path, base_dir);
    #####:  338:	path_push(&objs_path, "target");
    #####:  339:	path_push(&objs_path, "objs");
        -:  340:
    #####:  341:	Path config_src;
    #####:  342:	path_for(&config_src, config_dir);
    #####:  343:	path_push(&config_src, "resources");
    #####:  344:	path_push(&config_src, "src");
    #####:  345:	path_push(&config_src, "*.c");
        -:  346:
    #####:  347:	Path args_path;
    #####:  348:	path_for(&args_path, base_dir);
    #####:  349:	path_push(&args_path, "target");
    #####:  350:	path_push(&args_path, "args");
    #####:  351:	path_push(&args_path, "args.txt");
        -:  352:
    #####:  353:	Path include_dir;
    #####:  354:	path_for(&include_dir, config_dir);
    #####:  355:	path_push(&include_dir, "resources");
    #####:  356:	path_push(&include_dir, "include");
        -:  357:
        -:  358:	glob_t glob_result;
    #####:  359:	glob(path_to_string(&config_src), 0, NULL, &glob_result);
        -:  360:
    #####:  361:	Path config_dir_src_path;
    #####:  362:	path_for(&config_dir_src_path, config_dir);
    #####:  363:	path_push(&config_dir_src_path, "resources");
    #####:  364:	path_push(&config_dir_src_path, "src");
        -:  365:
    #####:  366:	for (u64 i = 0; i < glob_result.gl_pathc; i++) {
        -:  367:		TypeInfo ti;
    #####:  368:		ti.mi.sub_module_count = 0;
    #####:  369:		if (strlen(glob_result.gl_pathv[i]) >= MAX_NAME_LEN) {
    #####:  370:			exit_error("name too long! [%s]", glob_result.gl_pathv[i]);
        -:  371:		}
    #####:  372:		Path glob_path;
    #####:  373:		path_for(&glob_path, glob_result.gl_pathv[i]);
    #####:  374:		char path_stem[strlen(path_file_name(&glob_path)) + 1];
    #####:  375:		path_file_stem(&glob_path, path_stem, strlen(path_file_name(&glob_path)));
    #####:  376:		strcpy(ti.type_name, path_stem);
    #####:  377:		build_obj("cc", path_to_string(&include_dir), path_to_string(&objs_path),
    #####:  378:				  path_to_string(&config_dir_src_path), &ti, "___internal_objs_", NULL,
    #####:  379:				  "-DIMPL=", "-DIMPLCONFIG=", path_to_string(&args_path));
        -:  380:	}
    #####:  381:}
        -:  382:
    #####:  383:int proc_build(const char *base_dir, const char *config_dir) {
    #####:  384:	fprintf(stderr, "proc build %s %s\n", base_dir, config_dir);
    #####:  385:	FamTomlInfo fti = extract_toml_info(base_dir);
    #####:  386:	fprintf(stderr, "building project %s. fam.toml generated by %s.\n", fti.name, fti.version);
    #####:  387:	ensure_target_structure(base_dir);
        -:  388:
    #####:  389:	Path args_dir;
    #####:  390:	path_for(&args_dir, base_dir);
    #####:  391:	path_push(&args_dir, "target");
    #####:  392:	path_push(&args_dir, "args");
    #####:  393:	remove_directory(path_to_string(&args_dir), true);
    #####:  394:	path_push(&args_dir, "args.txt");
        -:  395:	// create empty file
    #####:  396:	FILE *fp = myfopen(path_to_string(&args_dir), "a");
    #####:  397:	myfclose(fp);
        -:  398:
    #####:  399:	Path config_include_dir;
    #####:  400:	path_for(&config_include_dir, config_dir);
    #####:  401:	path_push(&config_include_dir, "resources");
    #####:  402:	path_push(&config_include_dir, "include");
        -:  403:
    #####:  404:	Path include_dir;
    #####:  405:	path_for(&include_dir, base_dir);
    #####:  406:	path_push(&include_dir, "target");
    #####:  407:	path_push(&include_dir, "include");
        -:  408:
    #####:  409:	Path objs_path;
    #####:  410:	path_for(&objs_path, base_dir);
    #####:  411:	path_push(&objs_path, "target");
    #####:  412:	path_push(&objs_path, "objs");
        -:  413:
    #####:  414:	Path args_path;
    #####:  415:	path_for(&args_path, base_dir);
    #####:  416:	path_push(&args_path, "target");
    #####:  417:	path_push(&args_path, "args");
    #####:  418:	path_push(&args_path, "args.txt");
        -:  419:
    #####:  420:	build_internal(base_dir, config_dir);
    #####:  421:	Path modh;
    #####:  422:	path_for(&modh, base_dir);
    #####:  423:	path_push(&modh, "mod.h");
        -:  424:
    #####:  425:	Vec headers;
    #####:  426:	vec_init(&headers, 10, sizeof(ModuleInfo));
    #####:  427:	Vec types;
    #####:  428:	vec_init(&types, 10, sizeof(TypeInfo));
    #####:  429:	Vec module_list;
    #####:  430:	vec_init(&module_list, 10, sizeof(ModuleInfo));
        -:  431:
    #####:  432:	path_canonicalize(&modh);
        -:  433:
    #####:  434:	const char *args_file = path_to_string(&args_path);
    #####:  435:	init_parser(args_file);
        -:  436:
        -:  437:	ModuleInfo self_info;
    #####:  438:	self_info.sub_module_count = 0;
    #####:  439:	parse_header(config_dir, base_dir, &headers, &types, &self_info);
        -:  440:
    #####:  441:	while (vec_size(&headers)) {
    #####:  442:		ModuleInfo *next = vec_pop(&headers);
        -:  443:		ModuleInfo n;
    #####:  444:		n.sub_module_count = next->sub_module_count;
    #####:  445:		for (u64 i = 0; i < n.sub_module_count; i++) {
    #####:  446:			strcpy(n.module_list[i].name, next->module_list[i].name);
        -:  447:		}
    #####:  448:		parse_header(config_dir, base_dir, &headers, &types, &n);
        -:  449:	}
        -:  450:
    #####:  451:	while (vec_size(&types)) {
    #####:  452:		TypeInfo *next = vec_pop(&types);
        -:  453:		char type_prefix[PATH_MAX];
    #####:  454:		type_info_to_string(next, type_prefix, PATH_MAX);
    #####:  455:		strcat(type_prefix, "_");
        -:  456:		char gen_header_bs_dir[PATH_MAX];
    #####:  457:		snprintf(gen_header_bs_dir, PATH_MAX, "f%" PRIu64, next->gen_file_counter);
        -:  458:
    #####:  459:		path_push(&include_dir, gen_header_bs_dir);
        -:  460:
        -:  461:		char type_str[PATH_MAX * 2];
    #####:  462:		type_info_to_string(next, type_str, PATH_MAX * 2);
        -:  463:
        -:  464:		char dimpl[(PATH_MAX * 2) + 30];
    #####:  465:		strcpy(dimpl, "-DIMPL=");
    #####:  466:		strcat(dimpl, type_str);
        -:  467:
        -:  468:		char dimplconfig[(PATH_MAX * 2) + 30];
    #####:  469:		strcpy(dimplconfig, "-DIMPLCONFIG=");
    #####:  470:		strcat(dimplconfig, type_str);
    #####:  471:		strcat(dimplconfig, "Config");
        -:  472:
    #####:  473:		build_obj("cc", path_to_string(&include_dir), path_to_string(&objs_path), base_dir, next,
    #####:  474:				  type_prefix, path_to_string(&config_include_dir), dimpl, dimplconfig,
    #####:  475:				  path_to_string(&args_path));
        -:  476:
    #####:  477:		path_pop(&include_dir);
        -:  478:	}
        -:  479:
    #####:  480:	path_push(&include_dir, "f0");
        -:  481:	TypeInfo main_ti;
    #####:  482:	strcpy(main_ti.type_name, "main");
    #####:  483:	main_ti.mi.sub_module_count = 0;
    #####:  484:	main_ti.gen_file_counter = 0;
        -:  485:
        -:  486:	// build main
    #####:  487:	build_obj("cc", path_to_string(&include_dir), path_to_string(&objs_path), base_dir, &main_ti,
    #####:  488:			  "type_____", path_to_string(&config_include_dir),
    #####:  489:			  "-DIMPL=", "-DIMPLCONFIG=", path_to_string(&args_path));
        -:  490:
        -:  491:	// link objects
    #####:  492:	link_objs(path_to_string(&objs_path), base_dir, fti.name);
        -:  493:
    #####:  494:	return 0;
        -:  495:}
        -:    0:Source:init.c
        -:    0:Graph:init.gcno
        -:    0:Data:init.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/path.h>
        -:   17:#include <base/version.h>
        -:   18:#include <build/build.h>
        -:   19:#include <stdio.h>
        -:   20:#include <stdlib.h>
        -:   21:#include <string.h>
        -:   22:#include <util/replace.h>
        -:   23:
    #####:   24:int proc_build_init(const char *config_dir, const char *proj_name, const char *proj_path,
    #####:   25:					char authors[11][1024], int author_count, bool lib, char *description) {
    #####:   26:	int author_len = 1;
    #####:   27:	for (int i = 0; i < author_count; i++) {
    #####:   28:		author_len += strlen(authors[i]) + 10;
        -:   29:	}
    #####:   30:	char author_replace[author_len];
    #####:   31:	strcpy(author_replace, "");
    #####:   32:	for (int i = 0; i < author_count; i++) {
    #####:   33:		strcat(author_replace, "\"");
    #####:   34:		strcat(author_replace, authors[i]);
    #####:   35:		if (i == author_count - 1)
    #####:   36:			strcat(author_replace, "\"");
        -:   37:		else
    #####:   38:			strcat(author_replace, "\", ");
        -:   39:	}
    #####:   40:	Path path;
    #####:   41:	path_for(&path, proj_path);
    #####:   42:	if (path_exists(&path)) {
    #####:   43:		path_canonicalize(&path);
    #####:   44:		fprintf(stderr, "Path: '%s' already exists!\n", path_to_string(&path));
    #####:   45:		exit(-1);
        -:   46:	}
    #####:   47:	if (!path_mkdir(&path, 0700, false)) {
    #####:   48:		perror("Error: could not create directory for project");
    #####:   49:		exit(-1);
        -:   50:	}
        -:   51:
    #####:   52:	path_push(&path, "fam.toml");
    #####:   53:	Path template;
    #####:   54:	path_for(&template, config_dir);
    #####:   55:	path_push(&template, "resources");
    #####:   56:	if (lib)
    #####:   57:		path_push(&template, "fam.lib.toml");
        -:   58:	else
    #####:   59:		path_push(&template, "fam.toml");
    #####:   60:	path_canonicalize(&template);
    #####:   61:	if (copy_file(path_to_string(&path), path_to_string(&template)) != 0) {
    #####:   62:		perror("Error: copying file");
    #####:   63:		exit(-1);
        -:   64:	}
        -:   65:
    #####:   66:	const char *patterns_in[] = {"REPLACE_FAM_VERSION", "REPLACE_NAME", "REPLACE_AUTHORS",
        -:   67:								 "REPLACE_DESCRIPTION"};
    #####:   68:	const bool is_case_sensitive[] = {true, true, true};
        -:   69:	char desc[1024];
    #####:   70:	if (strlen(description) > 0)
    #####:   71:		strcpy(desc, description);
        -:   72:	else
    #####:   73:		strcpy(desc, proj_name);
    #####:   74:	const char *replace[] = {FAM_VERSION, proj_name, author_replace, desc};
    #####:   75:	replace_file(&path, &path, patterns_in, is_case_sensitive, replace, 4);
        -:   76:
    #####:   77:	Path main_c;
    #####:   78:	path_for(&main_c, proj_path);
    #####:   79:	path_push(&main_c, "main.c");
        -:   80:
    #####:   81:	Path main_c_src;
    #####:   82:	path_for(&main_c_src, config_dir);
    #####:   83:	path_push(&main_c_src, "resources");
    #####:   84:	path_push(&main_c_src, "main.c");
    #####:   85:	if (copy_file(path_to_string(&main_c), path_to_string(&main_c_src)) != 0) {
    #####:   86:		perror("Error: copying file");
    #####:   87:		exit(-1);
        -:   88:	}
        -:   89:
    #####:   90:	Path mod_h;
    #####:   91:	path_for(&mod_h, proj_path);
    #####:   92:	path_push(&mod_h, "mod.h");
        -:   93:
    #####:   94:	Path mod_h_src;
    #####:   95:	path_for(&mod_h_src, config_dir);
    #####:   96:	path_push(&mod_h_src, "resources");
    #####:   97:	path_push(&mod_h_src, "mod.h");
    #####:   98:	if (copy_file(path_to_string(&mod_h), path_to_string(&mod_h_src)) != 0) {
    #####:   99:		perror("Error: copying file");
    #####:  100:		exit(-1);
        -:  101:	}
        -:  102:
    #####:  103:	Path proj_dir;
    #####:  104:	path_for(&proj_dir, proj_path);
    #####:  105:	path_canonicalize(&proj_dir);
    #####:  106:	printf("Project successfully created in '%s'.\n", path_to_string(&proj_dir));
        -:  107:
    #####:  108:	return 0;
        -:  109:}
        -:    0:Source:parser.c
        -:    0:Graph:parser.gcno
        -:    0:Data:parser.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <build/parser.h>
        -:   19:#include <lexer/lexer.h>
        -:   20:#include <limits.h>
        -:   21:#include <stdio.h>
        -:   22:#include <stdlib.h>
        -:   23:#include <string.h>
        -:   24:
        -:   25:#define INITIAL_HEADER_CAPACITY (1024 * 25)
        -:   26:
        -:   27:u64 gen_file_counter = 0;
        -:   28:
        -:   29:typedef struct HeaderTypeInfo {
        -:   30:	char type[MAX_NAME_LEN];
        -:   31:	bool is_arr;
        -:   32:	u64 arr_size;
        -:   33:} HeaderTypeInfo;
        -:   34:
        -:   35:typedef struct HeaderNameInfo {
        -:   36:	char name[MAX_NAME_LEN];
        -:   37:} HeaderNameInfo;
        -:   38:
        -:   39:typedef struct HeaderTypes {
        -:   40:	Vec types;
        -:   41:	Vec names;
        -:   42:} HeaderTypes;
        -:   43:
        -:   44:typedef struct ConfigType {
        -:   45:	char type_name[MAX_NAME_LEN];
        -:   46:} ConfigType;
        -:   47:
        -:   48:typedef struct ConfigName {
        -:   49:	char name[MAX_NAME_LEN];
        -:   50:} ConfigName;
        -:   51:
        -:   52:typedef struct FnParam {
        -:   53:	bool is_mut;
        -:   54:	char type[MAX_NAME_LEN];
        -:   55:	char name[MAX_NAME_LEN];
        -:   56:} FnParam;
        -:   57:
        -:   58:typedef struct IncompleteFn {
        -:   59:	char name[MAX_NAME_LEN];
        -:   60:	bool is_mut;
        -:   61:	Vec params;
        -:   62:	char return_type[MAX_NAME_LEN];
        -:   63:	bool has_impl;
        -:   64:} IncompleteFn;
        -:   65:
        -:   66:typedef struct SuperTraitInfo {
        -:   67:	char name[MAX_NAME_LEN];
        -:   68:} SuperTraitInfo;
        -:   69:
        -:   70:typedef struct IncompleteType {
        -:   71:	u64 count;
        -:   72:	IncompleteFn *fns;
        -:   73:	char name[MAX_NAME_LEN];
        -:   74:	char path_name[PATH_MAX];
        -:   75:	SuperTraitInfo *si;
        -:   76:	u64 si_count;
        -:   77:} IncompleteType;
        -:   78:
        -:   79:typedef struct GlobalIncompleteList {
        -:   80:	u64 count;
        -:   81:	IncompleteType *types;
        -:   82:} GlobalIncompleteList;
        -:   83:
        -:   84:typedef struct ImplPair {
        -:   85:	char type[MAX_NAME_LEN];
        -:   86:	char trait[MAX_NAME_LEN];
        -:   87:} ImplPair;
        -:   88:
        -:   89:typedef struct GlobalImplList {
        -:   90:	u64 count;
        -:   91:	ImplPair *impls;
        -:   92:} GlobalImplList;
        -:   93:
        -:   94:GlobalImplList global_impl_list = {0, NULL};
        -:   95:GlobalIncompleteList global_incomplete_list = {0, NULL};
        -:   96:
        -:   97:// TODO: these functions work, but use linear search. Move to something like an RB Tree.
    #####:   98:void add_super_trait_list(const char *trait_name, const Vec *super_traits) {
    #####:   99:	for (u64 i = 0; i < vec_size(super_traits); i++) {
    #####:  100:		SuperTraitInfo *si = vec_element_at(super_traits, i);
        -:  101:	}
    #####:  102:}
        -:  103:
    #####:  104:void add_trait_impl(const char *trait_name, const char *type_name) {
    #####:  105:	if (global_impl_list.count == 0) {
    #####:  106:		global_impl_list.impls = mymalloc(sizeof(ImplPair));
    #####:  107:		if (global_impl_list.impls == NULL)
    #####:  108:			panic("Could not allocate sufficient memory");
        -:  109:
        -:  110:	} else {
    #####:  111:		global_impl_list.impls =
    #####:  112:			myrealloc(global_impl_list.impls, sizeof(ImplPair) * (global_impl_list.count + 1));
    #####:  113:		if (global_impl_list.impls == NULL)
    #####:  114:			panic("Could not allocate sufficient memory");
        -:  115:	}
    #####:  116:	strcpy(global_impl_list.impls[global_impl_list.count].type, type_name);
    #####:  117:	strcpy(global_impl_list.impls[global_impl_list.count].trait, trait_name);
    #####:  118:	global_impl_list.count++;
    #####:  119:}
        -:  120:
    #####:  121:bool check_super_traits(const char *type_name, const char *trait_name, char *buf, u64 limit) {
    #####:  122:	for (u64 i = 0; i < global_incomplete_list.count; i++) {
    #####:  123:		if (!strcmp(global_incomplete_list.types[i].path_name, trait_name)) {
    #####:  124:			for (u64 j = 0; j < global_incomplete_list.types[i].si_count; j++) {
    #####:  125:				char *required_trait = global_incomplete_list.types[i].si[j].name;
    #####:  126:				bool impl = false;
    #####:  127:				for (u64 k = 0; k < global_impl_list.count; k++) {
    #####:  128:					if (!strcmp(global_impl_list.impls[k].trait, required_trait) &&
    #####:  129:						!strcmp(global_impl_list.impls[k].type, type_name)) {
    #####:  130:						impl = true;
    #####:  131:						break;
        -:  132:					}
        -:  133:				}
    #####:  134:				if (!impl) {
    #####:  135:					strncpy(buf, required_trait, limit);
    #####:  136:					return false;
        -:  137:				}
        -:  138:			}
        -:  139:		}
        -:  140:	}
    #####:  141:	return true;
        -:  142:}
        -:  143:
    #####:  144:void add_to_global_incomplete_list(const char *type_name, const Vec *incomplete_fns,
        -:  145:								   const char *args_file, Vec *super_traits,
        -:  146:								   const char *trait_full_name) {
    #####:  147:	if (super_traits != NULL)
    #####:  148:		add_super_trait_list(trait_full_name, super_traits);
    #####:  149:	if (global_incomplete_list.count == 0) {
    #####:  150:		global_incomplete_list.types = mymalloc(sizeof(IncompleteType));
        -:  151:	} else {
    #####:  152:		global_incomplete_list.types =
    #####:  153:			myrealloc(global_incomplete_list.types,
    #####:  154:					  sizeof(IncompleteType) * (global_incomplete_list.count + 1));
        -:  155:	}
        -:  156:
    #####:  157:	IncompleteType *next = &global_incomplete_list.types[global_incomplete_list.count];
    #####:  158:	strcpy(next->name, type_name);
    #####:  159:	if (trait_full_name)
    #####:  160:		strcpy(next->path_name, trait_full_name);
        -:  161:	else
    #####:  162:		strcpy(next->path_name, "");
    #####:  163:	next->count = vec_size(incomplete_fns);
    #####:  164:	next->fns = mymalloc(sizeof(IncompleteFn) * next->count);
    #####:  165:	if (super_traits) {
    #####:  166:		next->si = mymalloc(sizeof(SuperTraitInfo) * vec_size(super_traits));
    #####:  167:		next->si_count = vec_size(super_traits);
    #####:  168:		for (u64 i = 0; i < vec_size(super_traits); i++) {
    #####:  169:			SuperTraitInfo *sti = vec_element_at(super_traits, i);
    #####:  170:			strcpy(next->si[i].name, sti->name);
        -:  171:		}
        -:  172:	} else {
    #####:  173:		next->si = NULL;
        -:  174:	}
        -:  175:
    #####:  176:	for (u64 i = 0; i < next->count; i++) {
    #####:  177:		IncompleteFn *fn = vec_element_at(incomplete_fns, i);
    #####:  178:		next->fns[i].has_impl = fn->has_impl;
    #####:  179:		strcpy(next->fns[i].name, fn->name);
    #####:  180:		strcpy(next->fns[i].return_type, fn->return_type);
    #####:  181:		vec_init(&next->fns[i].params, 3, sizeof(FnParam));
    #####:  182:		FILE *fp = myfopen(args_file, "a");
        -:  183:
    #####:  184:		fprintf(fp, "-DFn_override_%s_return=\"%s\"\n", fn->name, fn->return_type);
    #####:  185:		if (next->fns[i].is_mut) {
    #####:  186:			fprintf(fp, "-DFn_override_%s_params=\"_%s(Obj *self", fn->name, fn->name);
        -:  187:		} else {
    #####:  188:			fprintf(fp, "-DFn_override_%s_params=\"_%s(const Obj *self", fn->name, fn->name);
        -:  189:		}
    #####:  190:		if (vec_size(&fn->params))
    #####:  191:			fprintf(fp, ",");
    #####:  192:		for (u64 j = 0; j < vec_size(&fn->params); j++) {
    #####:  193:			FnParam *param = vec_element_at(&fn->params, j);
    #####:  194:			vec_push(&next->fns[i].params, param);
        -:  195:			char *comma;
    #####:  196:			if (j != vec_size(&fn->params) - 1)
    #####:  197:				comma = ",";
        -:  198:			else
    #####:  199:				comma = "";
    #####:  200:			if (!strcmp(param->type, "__config__")) {
    #####:  201:				fprintf(fp, " void *__selfconfig__%s", comma);
        -:  202:			} else {
    #####:  203:				if (param->is_mut) {
    #####:  204:					fprintf(fp, " %s %s%s", param->type, param->name, comma);
        -:  205:				} else {
    #####:  206:					fprintf(fp, " const %s %s%s", param->type, param->name, comma);
        -:  207:				}
        -:  208:			}
        -:  209:		}
    #####:  210:		fprintf(fp, ")\"\n");
        -:  211:
    #####:  212:		fprintf(fp, "-DFn_expand_%s_return=\"%s\"\n", fn->name, fn->return_type);
    #####:  213:		if (next->fns[i].is_mut) {
    #####:  214:			fprintf(fp, "-DFn_expand_%s_params=\"_%s(Obj *self", fn->name, fn->name);
        -:  215:		} else {
    #####:  216:			fprintf(fp, "-DFn_expand_%s_params=\"_%s(const Obj *self", fn->name, fn->name);
        -:  217:		}
    #####:  218:		if (vec_size(&fn->params))
    #####:  219:			fprintf(fp, ",");
    #####:  220:		for (u64 j = 0; j < vec_size(&fn->params); j++) {
    #####:  221:			FnParam *param = vec_element_at(&fn->params, j);
        -:  222:			char *comma;
    #####:  223:			if (j != vec_size(&fn->params) - 1)
    #####:  224:				comma = ",";
        -:  225:			else
    #####:  226:				comma = "";
    #####:  227:			if (!strcmp(param->type, "__config__")) {
    #####:  228:				fprintf(fp, " void *__selfconfig__%s", comma);
        -:  229:			} else {
    #####:  230:				if (param->is_mut) {
    #####:  231:					fprintf(fp, " %s %s%s", param->type, param->name, comma);
        -:  232:				} else {
    #####:  233:					fprintf(fp, " const %s %s%s", param->type, param->name, comma);
        -:  234:				}
        -:  235:			}
        -:  236:		}
    #####:  237:		fprintf(fp, ")\"\n");
    #####:  238:		myfclose(fp);
        -:  239:	}
        -:  240:
    #####:  241:	global_incomplete_list.count++;
    #####:  242:}
        -:  243:
    #####:  244:void incomplete_fns_cleanup(Vec *incomplete_fns) {
    #####:  245:	while (vec_size(incomplete_fns)) {
    #####:  246:		IncompleteFn *next = vec_pop(incomplete_fns);
    #####:  247:		vec_cleanup(&next->params);
        -:  248:	}
    #####:  249:}
        -:  250:
        -:  251:typedef enum ParserStateEnum {
        -:  252:	ParserStateBeginStatement,
        -:  253:	ParserStateExpectModuleName,
        -:  254:	ParserStateExpectBrace,
        -:  255:	ParserStateExpectType,
        -:  256:	ParserStateExpectName,
        -:  257:	ParserStateInTypeExpectSemi,
        -:  258:	ParserStateInImportListExpectModuleName,
        -:  259:	ParserStateInImportListExpectSeparator,
        -:  260:	ParserStateExpectParenBuildDefn,
        -:  261:	ParserStateExpectConfigParen,
        -:  262:	ParserStateExpectConfigType,
        -:  263:	ParserStateExpectConfigComma,
        -:  264:	ParserStateExpectConfigName,
        -:  265:	ParserStateIncompleteName,
        -:  266:	ParserIncompleteExpectBrace,
        -:  267:	ParserStateExpectAt,
        -:  268:	ParserStateExpectIncompleteFnName,
        -:  269:	ParserStateExpectIncompleteFnParenStart,
        -:  270:	ParserStateExpectIncompleteFnMutOrType,
        -:  271:	ParserStateExpectIncompleteFnType,
        -:  272:	ParserStateExpectIncompleteFnParamName,
        -:  273:	ParserStateExpectIncompleteFnParamCommaOrEnd,
        -:  274:	ParserStateIncompleteExpectSemi,
        -:  275:	ParserStateIncompleteExpectSemiOrTypeArrow,
        -:  276:	ParserStateIncompleteExpectReturnType,
        -:  277:	ParserStateExpectIncompleteNameForImpl,
        -:  278:	ParserStateImplExpectSemi,
        -:  279:	ParserStateExpectIncompleteMutFnName,
        -:  280:	ParserStateExpectPipe,
        -:  281:	ParserStateExpectArraySize,
        -:  282:	ParserStateExpectEndArray,
        -:  283:	ParserStateExpectConfigKeyword,
        -:  284:	ParserStateExpectIncompleteMutFnNameWithDefaultImpl,
        -:  285:	ParserStateExpectSuperTrait,
        -:  286:	ParserStateExpectPlusOrBrace,
        -:  287:	ParserStateOther,
        -:  288:} ParserStateEnum;
        -:  289:
        -:  290:typedef struct ParserState {
        -:  291:	ParserStateEnum state;
        -:  292:	const ModuleInfo *cur;
        -:  293:	char *gen_header;
        -:  294:	u64 header_capacity;
        -:  295:	Vec *modules;
        -:  296:	Vec *types;
        -:  297:	char type_name[MAX_NAME_LEN + 1];
        -:  298:	HeaderTypes ht;
        -:  299:	ModuleInfo import_module_info;
        -:  300:	Vec import_list;
        -:  301:	u64 gen_file_counter;
        -:  302:	Vec config_types;
        -:  303:	Vec config_names;
        -:  304:	Vec incomplete_fns;
        -:  305:	bool has_errors;
        -:  306:	bool cur_is_array;
        -:  307:	Vec super_traits;
        -:  308:} ParserState;
        -:  309:
    #####:  310:void append_to_header(ParserState *state, const char *text, ...) {
        -:  311:	u64 length;
        -:  312:	va_list args;
        -:  313:
    #####:  314:	va_start(args, text);
    #####:  315:	length = vsnprintf(NULL, 0, text, args);
    #####:  316:	va_end(args);
        -:  317:
    #####:  318:	if (state->header_capacity == 0) {
    #####:  319:		u64 size = sizeof(char) * INITIAL_HEADER_CAPACITY;
    #####:  320:		if (length >= size)
    #####:  321:			size = length + 1;
    #####:  322:		state->gen_header = mymalloc(size);
    #####:  323:		if (state->gen_header == NULL)
    #####:  324:			exit_error("Could not allocate sufficient memory to continue!");
    #####:  325:		va_start(args, text);
    #####:  326:		char text_with_nl[strlen(text) + 2];
    #####:  327:		strcpy(text_with_nl, text);
    #####:  328:		strcat(text_with_nl, "\n");
    #####:  329:		vsnprintf(state->gen_header, size, text_with_nl, args);
    #####:  330:		va_end(args);
        -:  331:
    #####:  332:	} else {
    #####:  333:		u64 size = state->header_capacity;
    #####:  334:		if (length + strlen(state->gen_header) + 1 >= state->header_capacity) {
    #####:  335:			size = state->header_capacity + INITIAL_HEADER_CAPACITY;
    #####:  336:			if (length + strlen(state->gen_header) + 1 >=
    #####:  337:				state->header_capacity + INITIAL_HEADER_CAPACITY) {
    #####:  338:				size = length + strlen(state->gen_header) + 1;
        -:  339:			}
    #####:  340:			state->gen_header = myrealloc(state->gen_header, sizeof(char) * (size));
    #####:  341:			if (state->gen_header == NULL)
    #####:  342:				exit_error("Could not allocate sufficient memory to continue!");
        -:  343:		}
        -:  344:
    #####:  345:		va_start(args, text);
    #####:  346:		char text_with_nl[strlen(text) + 2];
    #####:  347:		strcpy(text_with_nl, text);
    #####:  348:		strcat(text_with_nl, "\n");
    #####:  349:		vsnprintf(state->gen_header + strlen(state->gen_header), size - strlen(state->gen_header),
        -:  350:				  text_with_nl, args);
    #####:  351:		va_end(args);
        -:  352:	}
        -:  353:
    #####:  354:	state->header_capacity += INITIAL_HEADER_CAPACITY;
    #####:  355:}
        -:  356:
    #####:  357:void free_gen_header(ParserState *state) {
    #####:  358:	if (state->gen_header)
    #####:  359:		myfree(state->gen_header);
    #####:  360:}
        -:  361:
    #####:  362:void proc_ParserStateBeginStatement(ParserState *state, Token *tk) {
    #####:  363:	if (tk->type == TokenTypeIdent) {
    #####:  364:		if (!strcmp(tk->token, "mod")) {
    #####:  365:			state->state = ParserStateExpectModuleName;
        -:  366:		} else {
    #####:  367:			if (strlen(tk->token) > MAX_NAME_LEN) {
    #####:  368:				state->has_errors = true;
    #####:  369:				token_display_error(tk, "token name is longer than MAX_NAME_LEN (%i)",
        -:  370:									MAX_NAME_LEN);
        -:  371:			} else {
    #####:  372:				strcpy(state->type_name, tk->token);
        -:  373:			}
    #####:  374:			state->state = ParserStateExpectBrace;
        -:  375:		}
    #####:  376:	} else if (tk->type == TokenTypePunct) {
    #####:  377:		if (!strcmp(tk->token, "}"))
    #####:  378:			state->state = ParserStateBeginStatement;
    #####:  379:		else if (!strcmp(tk->token, "$")) {
    #####:  380:			state->import_module_info.sub_module_count = 0;
    #####:  381:			state->state = ParserStateInImportListExpectModuleName;
    #####:  382:		} else if (!strcmp(tk->token, "@")) {
    #####:  383:			state->state = ParserStateIncompleteName;
        -:  384:		} else
    #####:  385:			state->state = ParserStateOther;
        -:  386:	} else
    #####:  387:		state->state = ParserStateOther;
    #####:  388:}
        -:  389:
    #####:  390:void proc_ParserStateInImportListExpectModuleName(ParserState *state, Token *tk) {
    #####:  391:	if (tk->type != TokenTypeIdent) {
    #####:  392:		state->has_errors = true;
    #####:  393:		token_display_error(tk, "Expected module name. Found [%s]", tk->token);
        -:  394:	} else {
        -:  395:		SubModuleInfo mi;
    #####:  396:		strcpy(mi.name, tk->token);
    #####:  397:		strcpy(
    #####:  398:			state->import_module_info.module_list[state->import_module_info.sub_module_count].name,
    #####:  399:			tk->token);
    #####:  400:		state->import_module_info.sub_module_count++;
    #####:  401:		state->state = ParserStateInImportListExpectSeparator;
        -:  402:	}
    #####:  403:}
        -:  404:
    #####:  405:void proc_ParserStateInImportListExpectSeparator(ParserState *state, Token *tk) {
    #####:  406:	if (!strcmp(tk->token, "::")) {
    #####:  407:		state->state = ParserStateInImportListExpectModuleName;
    #####:  408:	} else if (!strcmp(tk->token, ";")) {
    #####:  409:		u64 import_list_size = state->import_module_info.sub_module_count;
    #####:  410:		if (import_list_size == 0) {
    #####:  411:			state->has_errors = true;
    #####:  412:			token_display_error(tk, "Expected at least one module name here");
        -:  413:		} else {
        -:  414:			char type_name[PATH_MAX + 1];
    #####:  415:			module_to_type_string(&state->import_module_info, type_name, PATH_MAX);
    #####:  416:			char *last = state->import_module_info.module_list[import_list_size - 1].name;
    #####:  417:			append_to_header(state, "typedef struct %s %s;", type_name, type_name);
    #####:  418:			append_to_header(state, "#define %s %s", last, type_name);
    #####:  419:			append_to_header(state, "Type_Import_Expand_%s_", type_name);
    #####:  420:			state->state = ParserStateBeginStatement;
        -:  421:		}
        -:  422:	} else {
    #####:  423:		state->has_errors = true;
    #####:  424:		token_display_error(tk, "Expected one of [';', '::']. Found [%s]", tk->token);
        -:  425:	}
    #####:  426:}
        -:  427:
    #####:  428:void proc_ParserStateExpectConfigKeyword(ParserState *state, Token *tk) {
    #####:  429:	if (!strcmp(tk->token, "Options")) {
    #####:  430:		state->state = ParserStateExpectParenBuildDefn;
        -:  431:	} else {
    #####:  432:		state->has_errors = true;
    #####:  433:		token_display_error(tk, "Expected ['Options']. Found [%s]", tk->token);
    #####:  434:		state->state = ParserStateBeginStatement;
        -:  435:	}
    #####:  436:}
        -:  437:
    #####:  438:void proc_ParserStateExpectParenBuildDefn(ParserState *state, Token *tk) {
    #####:  439:	if (!strcmp(tk->token, "("))
    #####:  440:		state->state = ParserStateExpectConfigType;
        -:  441:	else {
    #####:  442:		state->has_errors = true;
    #####:  443:		token_display_error(tk, "Expected ['(']. Found [%s]", tk->token);
    #####:  444:		state->state = ParserStateBeginStatement;
        -:  445:	}
    #####:  446:}
        -:  447:
    #####:  448:void proc_ParserStateExpectConfigType(ParserState *state, Token *tk) {
    #####:  449:	if (tk->type != TokenTypeIdent) {
    #####:  450:		state->has_errors = true;
    #####:  451:		token_display_error(tk, "Expected Type name. Found [%s]", tk->token);
    #####:  452:		state->state = ParserStateBeginStatement;
        -:  453:	} else {
    #####:  454:		if (strcmp(tk->token, "u8") && strcmp(tk->token, "u16") && strcmp(tk->token, "u32") &&
    #####:  455:			strcmp(tk->token, "u64") && strcmp(tk->token, "u128") && strcmp(tk->token, "bool") &&
    #####:  456:			strcmp(tk->token, "String")) {
    #####:  457:			state->has_errors = true;
    #####:  458:			token_display_error(
        -:  459:				tk, "Expected one of [u8, u16, u32, u64, u128, bool, String]. Found [%s]",
        -:  460:				tk->token);
        -:  461:		} else {
        -:  462:			ConfigType ct;
    #####:  463:			if (!strcmp(tk->token, "String"))
    #####:  464:				strcpy(ct.type_name, "char *");
        -:  465:			else
    #####:  466:				strcpy(ct.type_name, tk->token);
    #####:  467:			vec_push(&state->config_types, &ct);
        -:  468:		}
        -:  469:
    #####:  470:		state->state = ParserStateExpectConfigName;
        -:  471:	}
    #####:  472:}
        -:  473:
    #####:  474:void proc_ParserStateExpectConfigComma(ParserState *state, Token *tk) {
    #####:  475:	if (!strcmp(tk->token, ",")) {
    #####:  476:		state->state = ParserStateExpectConfigType;
    #####:  477:	} else if (!strcmp(tk->token, ")")) {
    #####:  478:		state->state = ParserStateInTypeExpectSemi;
        -:  479:	} else {
    #####:  480:		state->state = ParserStateBeginStatement;
    #####:  481:		state->has_errors = true;
    #####:  482:		token_display_error(tk, "Expected ','. Found [%s]", tk->token);
        -:  483:	}
    #####:  484:}
        -:  485:
    #####:  486:void proc_ParserStateExpectConfigName(ParserState *state, Token *tk) {
    #####:  487:	if (tk->type != TokenTypeIdent) {
    #####:  488:		state->has_errors = true;
    #####:  489:		token_display_error(tk, "Expected config name. Found [%s]", tk->token);
    #####:  490:		state->state = ParserStateBeginStatement;
        -:  491:	} else {
        -:  492:		ConfigName cn;
    #####:  493:		strcpy(cn.name, tk->token);
    #####:  494:		vec_push(&state->config_names, &cn);
        -:  495:
    #####:  496:		state->state = ParserStateExpectConfigComma;
        -:  497:	}
    #####:  498:}
        -:  499:
    #####:  500:void proc_ParserStateExpectType(ParserState *state, Token *tk, const char *args_file) {
    #####:  501:	if (!strcmp(tk->token, "$")) {
        -:  502:		// Config definition
    #####:  503:		vec_clear(&state->config_names);
    #####:  504:		vec_clear(&state->config_types);
    #####:  505:		state->state = ParserStateExpectConfigKeyword;
    #####:  506:	} else if (!strcmp(tk->token, "[")) {
        -:  507:		// array
    #####:  508:		state->cur_is_array = true;
    #####:  509:		state->state = ParserStateExpectType;
    #####:  510:	} else if (tk->type != TokenTypeIdent) {
    #####:  511:		if (!strcmp(tk->token, "}")) {
    #####:  512:			u64 count = vec_size(&(state->ht.types));
        -:  513:			char type_name[PATH_MAX];
    #####:  514:			TypeInfo *ti = vec_element_at(state->types, vec_size(state->types) - 1);
    #####:  515:			type_info_to_string(ti, type_name, PATH_MAX);
    #####:  516:			append_to_header(state, "typedef struct %s %s;", type_name, type_name);
    #####:  517:			append_to_header(state, "typedef struct %s {", type_name);
    #####:  518:			for (u64 i = 0; i < count; i++) {
        -:  519:				HeaderNameInfo *ni;
        -:  520:				HeaderTypeInfo *ti;
    #####:  521:				ti = vec_element_at(&(state->ht.types), i);
    #####:  522:				ni = vec_element_at(&(state->ht.names), i);
    #####:  523:				if (ti->is_arr) {
    #####:  524:					if (ti->arr_size == UINT64_MAX) {
        -:  525:						// dynamic array
    #####:  526:						append_to_header(state, "%s *%s; FatPtr %s_fat_ptr__;", ti->type, ni->name,
    #####:  527:										 ni->name);
        -:  528:					} else {
        -:  529:						// static array
    #####:  530:						append_to_header(state, "%s %s[%" PRIu64 "];", ti->type, ni->name,
        -:  531:										 ti->arr_size);
        -:  532:					}
        -:  533:				} else {
    #####:  534:					if (!strcmp(ti->type, "u8") || !strcmp(ti->type, "u16") ||
    #####:  535:						!strcmp(ti->type, "u32") || !strcmp(ti->type, "u64") ||
    #####:  536:						!strcmp(ti->type, "u128") || !strcmp(ti->type, "i8") ||
    #####:  537:						!strcmp(ti->type, "i16") || !strcmp(ti->type, "i32") ||
    #####:  538:						!strcmp(ti->type, "i64") || !strcmp(ti->type, "i128") ||
    #####:  539:						!strcmp(ti->type, "f32") || !strcmp(ti->type, "f64") ||
    #####:  540:						!strcmp(ti->type, "bool"))
    #####:  541:						append_to_header(state, "%s %s;", ti->type, ni->name);
        -:  542:					else
    #####:  543:						append_to_header(state, "Obj %s;", ni->name);
        -:  544:				}
        -:  545:			}
    #####:  546:			if (count == 0) {
    #####:  547:				append_to_header(state, "char dummy;");
        -:  548:			}
    #####:  549:			append_to_header(state, "} %s;\n", type_name);
        -:  550:
    #####:  551:			append_to_header(state, "extern Vtable %s_Vtable__;", type_name);
    #####:  552:			append_to_header(state, "u64 %s_size();", type_name);
    #####:  553:			append_to_header(state, "void %s_drop_internal(Obj *ptr);", type_name);
    #####:  554:			append_to_header(state, "void %s_build_internal(Obj *ptr);", type_name);
        -:  555:
        -:  556:			// add to args
    #####:  557:			FILE *fp = myfopen(args_file, "a");
    #####:  558:			fprintf(fp, "-DType_Expand_%s_=\"", type_name);
    #####:  559:			fprintf(fp, "Vtable %s_Vtable__ = {\\\"%s\\\", 0, NULL, 0, NULL, false};\
        -:  560:				u64 %s_size() {return sizeof(%s); }\
        -:  561:				void %s_drop_internal(Obj *ptr) { ",
        -:  562:					type_name, type_name, type_name, type_name, type_name);
    #####:  563:			for (u64 i = 0; i < count; i++) {
        -:  564:				HeaderNameInfo *ni;
        -:  565:				HeaderTypeInfo *ti;
    #####:  566:				ti = vec_element_at(&(state->ht.types), i);
    #####:  567:				ni = vec_element_at(&(state->ht.names), i);
    #####:  568:				if (ti->is_arr && ti->arr_size == UINT64_MAX) {
    #####:  569:					fprintf(fp, "$Free(%s);", ni->name);
    #####:  570:				} else if (!ti->is_arr) {
    #####:  571:					if (!(!strcmp(ti->type, "u8") || !strcmp(ti->type, "u16") ||
    #####:  572:						  !strcmp(ti->type, "u32") || !strcmp(ti->type, "u64") ||
    #####:  573:						  !strcmp(ti->type, "u128") || !strcmp(ti->type, "i8") ||
    #####:  574:						  !strcmp(ti->type, "i16") || !strcmp(ti->type, "i32") ||
    #####:  575:						  !strcmp(ti->type, "i64") || !strcmp(ti->type, "i128") ||
    #####:  576:						  !strcmp(ti->type, "f32") || !strcmp(ti->type, "f64") ||
    #####:  577:						  !strcmp(ti->type, "bool"))) {
        -:  578:						// not a prim
    #####:  579:						fprintf(fp, "Obj_cleanup(&$Mut(%s));", ni->name);
        -:  580:					}
        -:  581:				}
        -:  582:			}
    #####:  583:			fprintf(fp, "}\
        -:  584:				void %s_build_internal(Obj *ptr) {\
        -:  585:				u64 size = %s_size();                     \
        -:  586:				memset(ptr->ptr.data, 0, size);           \
        -:  587:				",
        -:  588:					type_name, type_name);
        -:  589:
    #####:  590:			for (u64 i = 0; i < count; i++) {
        -:  591:				HeaderNameInfo *ni;
        -:  592:				HeaderTypeInfo *ti;
    #####:  593:				ti = vec_element_at(&(state->ht.types), i);
    #####:  594:				ni = vec_element_at(&(state->ht.names), i);
    #####:  595:				if (ti->is_arr) {
        -:  596:				} else {
    #####:  597:					if (!(!strcmp(ti->type, "u8") || !strcmp(ti->type, "u16") ||
    #####:  598:						  !strcmp(ti->type, "u32") || !strcmp(ti->type, "u64") ||
    #####:  599:						  !strcmp(ti->type, "u128") || !strcmp(ti->type, "i8") ||
    #####:  600:						  !strcmp(ti->type, "i16") || !strcmp(ti->type, "i32") ||
    #####:  601:						  !strcmp(ti->type, "i64") || !strcmp(ti->type, "i128") ||
    #####:  602:						  !strcmp(ti->type, "f32") || !strcmp(ti->type, "f64") ||
    #####:  603:						  !strcmp(ti->type, "bool"))) {
    #####:  604:						fprintf(fp, "$Mut(%s) = OBJECT_INIT;", ni->name);
        -:  605:					}
        -:  606:				}
        -:  607:			}
        -:  608:
    #####:  609:			fprintf(fp, "}");
    #####:  610:			fprintf(fp, "\"\n");
    #####:  611:			append_to_header(
        -:  612:				state, "static void __attribute__((constructor)) __add_impls_%s_vtable() {\
        -:  613:				\nVtableEntry size =\
        -:  614:				{\
        -:  615:				\"size\", %s_size}; \
        -:  616:				\nvtable_add_entry(&%s_Vtable__, size); \
        -:  617:				\nVtableEntry build_internal = {\"build_internal\", %s_build_internal};\
        -:  618:				\nvtable_add_entry(& % s_Vtable__, build_internal);\
        -:  619:				\nVtableEntry drop_internal = {\"drop_internal\", %s_drop_internal}; \
        -:  620:				\nvtable_add_entry(&%s_Vtable__, drop_internal);  \n}",
        -:  621:				type_name, type_name, type_name, type_name, type_name, type_name, type_name);
        -:  622:
    #####:  623:			u64 count_configs = vec_size(&state->config_types);
    #####:  624:			u64 count_config_names = vec_size(&state->config_names);
    #####:  625:			append_to_header(state, "typedef struct %sConfig {", type_name);
    #####:  626:			fprintf(fp, "-DType_Import_Expand_%s_=\"", type_name);
    #####:  627:			fprintf(fp, "u64 %s_size();", type_name);
    #####:  628:			fprintf(fp, "extern Vtable %s_Vtable__;", type_name);
    #####:  629:			fprintf(fp, "typedef struct %sConfig {", type_name);
        -:  630:
    #####:  631:			if (count_configs == count_config_names && count_configs > 0) {
    #####:  632:				for (u64 i = 0; i < count_configs; i++) {
    #####:  633:					ConfigType *t = vec_element_at(&state->config_types, i);
    #####:  634:					ConfigName *n = vec_element_at(&state->config_names, i);
    #####:  635:					append_to_header(state, "%s %s; bool %s_is_set__;", t->type_name, n->name,
    #####:  636:									 n->name);
    #####:  637:					fprintf(fp, "%s %s; bool %s_is_set__;", t->type_name, n->name, n->name);
        -:  638:				}
        -:  639:			} else {
    #####:  640:				append_to_header(state, "char dummy;");
    #####:  641:				fprintf(fp, "char dummy;");
        -:  642:			}
    #####:  643:			append_to_header(state, "} %sConfig;", type_name);
    #####:  644:			fprintf(fp, "} %sConfig;", type_name);
    #####:  645:			fprintf(fp, "\"\n");
        -:  646:
    #####:  647:			myfclose(fp);
        -:  648:
    #####:  649:			append_to_header(state, "#define %s %s\n", state->type_name, type_name);
    #####:  650:			vec_clear(&(state->ht.types));
    #####:  651:			vec_clear(&(state->ht.names));
    #####:  652:			state->state = ParserStateBeginStatement;
        -:  653:		} else {
    #####:  654:			state->has_errors = true;
    #####:  655:			token_display_error(tk, "Expected type name. Found [%s]", tk->token);
    #####:  656:			state->state = ParserStateOther;
        -:  657:		}
        -:  658:	} else {
    #####:  659:		if (strlen(tk->token) > MAX_NAME_LEN) {
    #####:  660:			state->has_errors = true;
    #####:  661:			token_display_error(tk, "Name [%s] is too long.", tk->token);
    #####:  662:			state->state = ParserStateOther;
        -:  663:		} else {
        -:  664:			HeaderTypeInfo hti;
    #####:  665:			hti.is_arr = state->cur_is_array;
    #####:  666:			strcpy(hti.type, tk->token);
    #####:  667:			vec_push(&(state->ht.types), &hti);
    #####:  668:			if (state->cur_is_array) {
    #####:  669:				state->state = ParserStateExpectPipe;
        -:  670:			} else {
    #####:  671:				state->state = ParserStateExpectName;
        -:  672:			}
        -:  673:		}
        -:  674:	}
    #####:  675:}
        -:  676:
    #####:  677:void proc_ParserStateExpectPipe(ParserState *state, Token *tk) {
    #####:  678:	if (!strcmp(tk->token, "|")) {
    #####:  679:		state->state = ParserStateExpectArraySize;
    #####:  680:	} else if (!strcmp(tk->token, "]")) {
        -:  681:		// dynamic array
        -:  682:		HeaderTypeInfo *hti;
    #####:  683:		hti = vec_element_at(&(state->ht.types), vec_size(&(state->ht.types)) - 1);
        -:  684:		// use UINT64_MAX to indicate dynamic array
    #####:  685:		hti->arr_size = UINT64_MAX;
    #####:  686:		state->state = ParserStateExpectName;
        -:  687:	} else {
    #####:  688:		state->has_errors = true;
    #####:  689:		token_display_error(tk, "Expected ['|']. Found [%s]", tk->token);
        -:  690:	}
    #####:  691:}
        -:  692:
    #####:  693:void proc_ParserStateExpectArraySize(ParserState *state, Token *tk) {
    #####:  694:	if (tk->type == TokenTypeLiteral) {
    #####:  695:		char first = tk->token[0];
    #####:  696:		if (!(first >= '0' && first <= '9')) {
    #####:  697:			state->has_errors = true;
    #####:  698:			token_display_error(tk, "Expected number literal. Found [%s]", tk->token);
    #####:  699:			state->state = ParserStateBeginStatement;
        -:  700:		} else {
        -:  701:			char *endptr;
        -:  702:			HeaderTypeInfo *hti;
    #####:  703:			hti = vec_element_at(&(state->ht.types), vec_size(&(state->ht.types)) - 1);
    #####:  704:			hti->arr_size = strtoull(tk->token, &endptr, 10);
        -:  705:
    #####:  706:			state->state = ParserStateExpectEndArray;
        -:  707:		}
        -:  708:	} else {
    #####:  709:		state->has_errors = true;
    #####:  710:		token_display_error(tk, "Expected number literal. Found [%s]", tk->token);
    #####:  711:		state->state = ParserStateBeginStatement;
        -:  712:	}
    #####:  713:}
        -:  714:
    #####:  715:void proc_ParserStateExpectEndArray(ParserState *state, Token *tk) {
    #####:  716:	if (!strcmp(tk->token, "]")) {
    #####:  717:		state->state = ParserStateExpectName;
        -:  718:	} else {
    #####:  719:		state->has_errors = true;
    #####:  720:		token_display_error(tk, "Expected [']']. Found [%s]", tk->token);
    #####:  721:		state->state = ParserStateBeginStatement;
        -:  722:	}
    #####:  723:}
        -:  724:
    #####:  725:void proc_ParserStateExpectName(ParserState *state, Token *tk) {
    #####:  726:	if (tk->type != TokenTypeIdent) {
    #####:  727:		state->has_errors = true;
    #####:  728:		token_display_error(tk, "Expected name. Found [%s]", tk->token);
    #####:  729:		state->state = ParserStateOther;
        -:  730:	} else {
    #####:  731:		if (strlen(tk->token) > MAX_NAME_LEN) {
    #####:  732:			state->has_errors = true;
    #####:  733:			token_display_error(tk, "Name [%s] is too long.", tk->token);
    #####:  734:			state->state = ParserStateOther;
        -:  735:		} else {
        -:  736:			HeaderNameInfo hti;
    #####:  737:			strcpy(hti.name, tk->token);
    #####:  738:			vec_push(&(state->ht.names), &hti);
    #####:  739:			state->state = ParserStateInTypeExpectSemi;
        -:  740:		}
        -:  741:	}
    #####:  742:}
        -:  743:
    #####:  744:void proc_ParserStateInTypeExpectSemi(ParserState *state, Token *tk) {
    #####:  745:	if (strcmp(tk->token, ";")) {
    #####:  746:		state->has_errors = true;
    #####:  747:		token_display_error(tk, "Expected ';'. Found [%s]", tk->token);
        -:  748:	}
    #####:  749:	state->state = ParserStateExpectType;
    #####:  750:	state->cur_is_array = false;
    #####:  751:}
        -:  752:
    #####:  753:void proc_ParserStateExpectModuleName(ParserState *state, Token *tk) {
    #####:  754:	if (tk->type != TokenTypeIdent) {
    #####:  755:		state->has_errors = true;
    #####:  756:		token_display_error(tk, "Expected module name, Found [%s]", tk->token);
        -:  757:	} else {
    #####:  758:		if (strlen(tk->token) >= PATH_MAX) {
    #####:  759:			state->has_errors = true;
    #####:  760:			token_display_error(tk, "Path is longer than max path (%i)", PATH_MAX);
        -:  761:		} else {
        -:  762:			ModuleInfo mi;
    #####:  763:			mi.sub_module_count = state->cur->sub_module_count + 1;
    #####:  764:			for (u64 i = 0; i < state->cur->sub_module_count; i++) {
    #####:  765:				strcpy(mi.module_list[i].name, state->cur->module_list[i].name);
        -:  766:			}
    #####:  767:			strcpy(mi.module_list[state->cur->sub_module_count].name, tk->token);
    #####:  768:			vec_push(state->modules, &mi);
        -:  769:		}
    #####:  770:		state->state = ParserStateOther;
        -:  771:	}
    #####:  772:}
        -:  773:
    #####:  774:void proc_ParserStateIncompleteName(ParserState *state, Token *tk) {
    #####:  775:	if (tk->type != TokenTypeIdent) {
    #####:  776:		state->state = ParserStateBeginStatement;
    #####:  777:		state->has_errors = true;
    #####:  778:		token_display_error(tk, "Expected incomplete type name. Found [%s]", tk->token);
        -:  779:	} else {
    #####:  780:		state->state = ParserIncompleteExpectBrace;
    #####:  781:		strcpy(state->type_name, tk->token);
        -:  782:	}
    #####:  783:}
        -:  784:
    #####:  785:void proc_ParserStateExpectPlusOrBrace(ParserState *state, Token *tk) {
    #####:  786:	if (!strcmp(tk->token, "+"))
    #####:  787:		state->state = ParserStateExpectSuperTrait;
    #####:  788:	else if (!strcmp(tk->token, "{"))
    #####:  789:		state->state = ParserStateExpectAt;
        -:  790:	else {
    #####:  791:		state->state = ParserStateBeginStatement;
    #####:  792:		state->has_errors = true;
    #####:  793:		token_display_error(tk, "Expected '+' or '{'. Found [%s]", tk->token);
        -:  794:	}
    #####:  795:}
        -:  796:
    #####:  797:void proc_ParserStateExpectSuperTrait(ParserState *state, Token *tk) {
    #####:  798:	if (tk->type != TokenTypeIdent) {
    #####:  799:		state->state = ParserStateBeginStatement;
    #####:  800:		state->has_errors = true;
    #####:  801:		token_display_error(tk, "Expected super trait name. Found [%s]", tk->token);
        -:  802:	} else {
    #####:  803:		state->state = ParserStateExpectPlusOrBrace;
        -:  804:		SuperTraitInfo si;
        -:  805:		TypeInfo ti;
    #####:  806:		ti.mi = *state->cur;
    #####:  807:		strcpy(ti.type_name, tk->token);
        -:  808:
    #####:  809:		type_info_to_string(&ti, si.name, MAX_NAME_LEN);
    #####:  810:		vec_push(&state->super_traits, &si);
        -:  811:	}
    #####:  812:}
        -:  813:
    #####:  814:void proc_ParserIncompleteExpectBrace(ParserState *state, Token *tk) {
    #####:  815:	if (!strcmp(tk->token, "{")) {
    #####:  816:		state->state = ParserStateExpectAt;
    #####:  817:	} else if (!strcmp(tk->token, ":")) {
    #####:  818:		vec_clear(&state->super_traits);
    #####:  819:		state->state = ParserStateExpectSuperTrait;
        -:  820:	} else {
    #####:  821:		state->state = ParserStateBeginStatement;
    #####:  822:		state->has_errors = true;
    #####:  823:		token_display_error(tk, "Expected '{'. Found [%s]", tk->token);
        -:  824:	}
    #####:  825:}
        -:  826:
    #####:  827:void expand_params(ParserState *state, IncompleteFn *fn, FILE *fp) {
    #####:  828:	u64 param_count = vec_size(&fn->params);
    #####:  829:	if (param_count) {
    #####:  830:		append_to_header(state, ",");
    #####:  831:		if (fp) {
    #####:  832:			fprintf(fp, ",");
        -:  833:		}
        -:  834:	}
    #####:  835:	for (u64 i = 0; i < param_count; i++) {
    #####:  836:		FnParam *fparam = vec_element_at(&fn->params, i);
        -:  837:		char *comma;
    #####:  838:		if (i != param_count - 1)
    #####:  839:			comma = ", ";
        -:  840:		else
    #####:  841:			comma = "";
        -:  842:		// handle special case for __config__ (in build)
    #####:  843:		if (!strcmp("__config__", fparam->type)) {
    #####:  844:			append_to_header(state, "void *%s%s", fparam->name, comma);
    #####:  845:			if (fp) {
    #####:  846:				fprintf(fp, "void *%s%s", fparam->name, comma);
        -:  847:			}
        -:  848:		} else {
    #####:  849:			if (fparam->is_mut) {
    #####:  850:				append_to_header(state, "%s %s%s", fparam->type, fparam->name, comma);
    #####:  851:				if (fp) {
    #####:  852:					fprintf(fp, "%s %s%s", fparam->type, fparam->name, comma);
        -:  853:				}
        -:  854:			} else {
    #####:  855:				append_to_header(state, "const %s %s%s", fparam->type, fparam->name, comma);
    #####:  856:				if (fp) {
    #####:  857:					fprintf(fp, "const %s %s%s", fparam->type, fparam->name, comma);
        -:  858:				}
        -:  859:			}
        -:  860:		}
        -:  861:	}
    #####:  862:}
        -:  863:
    #####:  864:void expand_vars(ParserState *state, IncompleteFn *fn, FILE *fp) {
    #####:  865:	u64 param_count = vec_size(&fn->params);
    #####:  866:	if (param_count) {
    #####:  867:		append_to_header(state, ",");
    #####:  868:		if (fp) {
    #####:  869:			fprintf(fp, ",");
        -:  870:		}
        -:  871:	}
    #####:  872:	for (u64 i = 0; i < param_count; i++) {
    #####:  873:		FnParam *fparam = vec_element_at(&fn->params, i);
        -:  874:		char *comma;
    #####:  875:		if (i != param_count - 1)
    #####:  876:			comma = ", ";
        -:  877:		else
    #####:  878:			comma = "";
    #####:  879:		append_to_header(state, "%s%s", fparam->name, comma);
    #####:  880:		if (fp)
    #####:  881:			fprintf(fp, "%s%s", fparam->name, comma);
        -:  882:	}
    #####:  883:}
        -:  884:
    #####:  885:void proc_ParserStateExpectAt(ParserState *state, Token *tk, const char *args_file) {
    #####:  886:	if (!strcmp(tk->token, "@")) {
    #####:  887:		state->state = ParserStateExpectIncompleteFnName;
    #####:  888:	} else if (!strcmp(tk->token, "}")) {
        -:  889:		// end incomplete type
    #####:  890:		state->state = ParserStateBeginStatement;
    #####:  891:		u64 fn_count = vec_size(&state->incomplete_fns);
        -:  892:
    #####:  893:		FILE *fp = myfopen(args_file, "a");
        -:  894:		TypeInfo ti;
    #####:  895:		ti.mi = *state->cur;
    #####:  896:		strcpy(ti.type_name, state->type_name);
        -:  897:
        -:  898:		char incomplete_type[PATH_MAX + 1];
    #####:  899:		type_info_to_string(&ti, incomplete_type, PATH_MAX);
    #####:  900:		fprintf(fp, "-DType_Import_Expand_%s_=\"", incomplete_type);
    #####:  901:		for (u64 i = 0; i < fn_count; i++) {
    #####:  902:			IncompleteFn *fn = vec_element_at(&state->incomplete_fns, i);
        -:  903:
    #####:  904:			if (fn->is_mut) {
    #####:  905:				append_to_header(state, "static %s %s(Obj *self", fn->return_type, fn->name);
    #####:  906:				fprintf(fp, "static %s %s(Obj *self ", fn->return_type, fn->name);
        -:  907:			} else {
    #####:  908:				append_to_header(state, "static %s %s(const Obj *self", fn->return_type, fn->name);
    #####:  909:				fprintf(fp, "static %s %s(const Obj *self ", fn->return_type, fn->name);
        -:  910:			}
    #####:  911:			expand_params(state, fn, fp);
    #####:  912:			append_to_header(state, ") {");
    #####:  913:			fprintf(fp, ") {");
        -:  914:
    #####:  915:			if (fn->is_mut) {
    #####:  916:				append_to_header(state, "%s (*impl)(Obj *self", fn->return_type);
    #####:  917:				fprintf(fp, "%s (*impl)(Obj *self", fn->return_type);
        -:  918:			} else {
    #####:  919:				append_to_header(state, "%s (*impl)(const Obj *self", fn->return_type);
    #####:  920:				fprintf(fp, "%s (*impl)(const Obj *self", fn->return_type);
        -:  921:			}
    #####:  922:			expand_params(state, fn, fp);
    #####:  923:			append_to_header(state, ") = find_fn(self, \"%s\");", fn->name);
    #####:  924:			fprintf(fp, ") = find_fn(self, \\\"%s\\\");", fn->name);
    #####:  925:			append_to_header(
    #####:  926:				state, "if(impl == NULL) panic(\"Implementation for [%s] not found!\");", fn->name);
        -:  927:
    #####:  928:			fprintf(fp, "if(impl == NULL) panic(\\\"Implementation for [%s] not found!\\\");",
    #####:  929:					fn->name);
    #####:  930:			append_to_header(
        -:  931:				state, "SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};");
    #####:  932:			fprintf(fp, "SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};");
    #####:  933:			append_to_header(state, "__thread_local_self_Const = self;");
    #####:  934:			fprintf(fp, "__thread_local_self_Const = self;");
    #####:  935:			if (fn->is_mut) {
    #####:  936:				append_to_header(state, "__thread_local_self_Var = self;");
    #####:  937:				fprintf(fp, "__thread_local_self_Var = self;");
        -:  938:			} else {
    #####:  939:				append_to_header(state, "__thread_local_self_Var = NULL;");
    #####:  940:				fprintf(fp, "__thread_local_self_Var = NULL;");
        -:  941:			}
        -:  942:
    #####:  943:			append_to_header(state, "return impl(self");
    #####:  944:			fprintf(fp, "return impl(self");
    #####:  945:			expand_vars(state, fn, fp);
    #####:  946:			append_to_header(state, ");");
    #####:  947:			fprintf(fp, ");");
    #####:  948:			append_to_header(state, "}");
    #####:  949:			fprintf(fp, "}");
        -:  950:		}
        -:  951:
    #####:  952:		fprintf(fp, "\"\n");
    #####:  953:		myfclose(fp);
        -:  954:
    #####:  955:		add_to_global_incomplete_list(state->type_name, &state->incomplete_fns, args_file,
        -:  956:									  &state->super_traits, incomplete_type);
    #####:  957:		vec_clear(&state->super_traits);
        -:  958:
    #####:  959:		incomplete_fns_cleanup(&state->incomplete_fns);
        -:  960:
    #####:  961:	} else if (tk->type == TokenTypeIdent) {
        -:  962:		// required method with an implementation.
    #####:  963:		if (!strcmp(tk->token, "mut")) {
    #####:  964:			state->state = ParserStateExpectIncompleteMutFnNameWithDefaultImpl;
        -:  965:		} else {
        -:  966:			IncompleteFn fn;
    #####:  967:			fn.has_impl = true;
    #####:  968:			fn.is_mut = false;
    #####:  969:			strcpy(fn.name, tk->token);
    #####:  970:			vec_init(&fn.params, 3, sizeof(FnParam));
    #####:  971:			strcpy(fn.return_type, "void");
    #####:  972:			vec_push(&state->incomplete_fns, &fn);
    #####:  973:			state->state = ParserStateExpectIncompleteFnParenStart;
        -:  974:		}
        -:  975:	} else {
    #####:  976:		state->state = ParserStateBeginStatement;
    #####:  977:		state->has_errors = true;
    #####:  978:		token_display_error(tk, "Expected '@'. Found [%s]", tk->token);
        -:  979:	}
    #####:  980:}
        -:  981:
    #####:  982:void proc_ParserStateExpectIncompleteMutFnNameWithDefaultImpl(ParserState *state, Token *tk) {
    #####:  983:	if (tk->type != TokenTypeIdent) {
    #####:  984:		state->state = ParserStateBeginStatement;
    #####:  985:		state->has_errors = true;
    #####:  986:		token_display_error(tk, "Expected required function name. Found [%s]", tk->token);
        -:  987:	} else {
        -:  988:		IncompleteFn fn;
    #####:  989:		fn.has_impl = true;
    #####:  990:		fn.is_mut = true;
    #####:  991:		strcpy(fn.name, tk->token);
    #####:  992:		vec_init(&fn.params, 3, sizeof(FnParam));
    #####:  993:		strcpy(fn.return_type, "void");
    #####:  994:		vec_push(&state->incomplete_fns, &fn);
    #####:  995:		state->state = ParserStateExpectIncompleteFnParenStart;
        -:  996:	}
    #####:  997:}
        -:  998:
    #####:  999:void proc_ParserStateExpectIncompleteMutFnName(ParserState *state, Token *tk) {
    #####: 1000:	if (tk->type != TokenTypeIdent) {
    #####: 1001:		state->state = ParserStateBeginStatement;
    #####: 1002:		state->has_errors = true;
    #####: 1003:		token_display_error(tk, "Expected required function name. Found [%s]", tk->token);
        -: 1004:	} else {
        -: 1005:		IncompleteFn fn;
    #####: 1006:		fn.has_impl = false;
    #####: 1007:		fn.is_mut = true;
    #####: 1008:		strcpy(fn.name, tk->token);
    #####: 1009:		vec_init(&fn.params, 3, sizeof(FnParam));
    #####: 1010:		strcpy(fn.return_type, "void");
    #####: 1011:		vec_push(&state->incomplete_fns, &fn);
    #####: 1012:		state->state = ParserStateExpectIncompleteFnParenStart;
        -: 1013:	}
    #####: 1014:}
        -: 1015:
    #####: 1016:void proc_ParserStateExpectIncompleteFnName(ParserState *state, Token *tk) {
    #####: 1017:	if (tk->type != TokenTypeIdent) {
    #####: 1018:		state->state = ParserStateBeginStatement;
    #####: 1019:		state->has_errors = true;
    #####: 1020:		token_display_error(tk, "Expected required function name. Found [%s]", tk->token);
        -: 1021:	} else {
    #####: 1022:		if (!strcmp(tk->token, "mut")) {
    #####: 1023:			state->state = ParserStateExpectIncompleteMutFnName;
        -: 1024:		} else {
        -: 1025:			IncompleteFn fn;
    #####: 1026:			fn.has_impl = false;
    #####: 1027:			fn.is_mut = false;
    #####: 1028:			strcpy(fn.name, tk->token);
    #####: 1029:			vec_init(&fn.params, 3, sizeof(FnParam));
    #####: 1030:			strcpy(fn.return_type, "void");
    #####: 1031:			vec_push(&state->incomplete_fns, &fn);
    #####: 1032:			state->state = ParserStateExpectIncompleteFnParenStart;
        -: 1033:		}
        -: 1034:	}
    #####: 1035:}
        -: 1036:
    #####: 1037:void proc_ParserStateExpectIncompleteFnParenStart(ParserState *state, Token *tk) {
    #####: 1038:	if (!strcmp(tk->token, "(")) {
    #####: 1039:		state->state = ParserStateExpectIncompleteFnMutOrType;
        -: 1040:	} else {
    #####: 1041:		state->state = ParserStateBeginStatement;
    #####: 1042:		state->has_errors = true;
    #####: 1043:		token_display_error(tk, "Expected ['(']. Found [%s]", tk->token);
        -: 1044:	}
    #####: 1045:}
        -: 1046:
    #####: 1047:void proc_ParserStateExpectIncompleteFnType(ParserState *state, Token *tk) {
    #####: 1048:	if (tk->type == TokenTypeIdent) {
    #####: 1049:		u64 last = vec_size(&state->incomplete_fns);
    #####: 1050:		if (last == 0) {
    #####: 1051:			state->has_errors = true;
    #####: 1052:			token_display_error(tk, "internal error: Expected type here!");
    #####: 1053:			state->state = ParserStateBeginStatement;
        -: 1054:		} else {
    #####: 1055:			last--;
    #####: 1056:			IncompleteFn *fn = vec_element_at(&state->incomplete_fns, last);
    #####: 1057:			u64 last_param = vec_size(&fn->params);
    #####: 1058:			if (last_param == 0) {
    #####: 1059:				state->has_errors = true;
    #####: 1060:				token_display_error(tk, "internal error: Expected a param here!");
    #####: 1061:				state->state = ParserStateBeginStatement;
        -: 1062:			} else {
    #####: 1063:				last_param--;
    #####: 1064:				FnParam *p = vec_element_at(&fn->params, last_param);
    #####: 1065:				strcpy(p->type, tk->token);
    #####: 1066:				state->state = ParserStateExpectIncompleteFnParamName;
        -: 1067:			}
        -: 1068:		}
        -: 1069:	} else {
        -: 1070:		// unexpected - error
    #####: 1071:		state->state = ParserStateBeginStatement;
    #####: 1072:		state->has_errors = true;
    #####: 1073:		token_display_error(tk, "Expected type name. Found [%s]", tk->token);
        -: 1074:	}
    #####: 1075:}
        -: 1076:
    #####: 1077:void proc_ParserStateExpectIncompleteFnParamName(ParserState *state, Token *tk) {
    #####: 1078:	if (tk->type == TokenTypeIdent) {
    #####: 1079:		u64 last = vec_size(&state->incomplete_fns);
    #####: 1080:		if (last == 0) {
    #####: 1081:			state->has_errors = true;
    #####: 1082:			token_display_error(tk, "internal error: Expected a name here!");
    #####: 1083:			state->state = ParserStateBeginStatement;
        -: 1084:		} else {
    #####: 1085:			last--;
    #####: 1086:			IncompleteFn *fn = vec_element_at(&state->incomplete_fns, last);
    #####: 1087:			u64 last_param = vec_size(&fn->params);
    #####: 1088:			if (last_param == 0) {
    #####: 1089:				state->has_errors = true;
    #####: 1090:				token_display_error(tk, "internal error: Expected a param here!");
    #####: 1091:				state->state = ParserStateBeginStatement;
        -: 1092:			} else {
    #####: 1093:				last_param--;
    #####: 1094:				FnParam *p = vec_element_at(&fn->params, last_param);
    #####: 1095:				strcpy(p->name, tk->token);
    #####: 1096:				state->state = ParserStateExpectIncompleteFnParamCommaOrEnd;
        -: 1097:			}
        -: 1098:		}
        -: 1099:	} else {
        -: 1100:		// unexpected - error
    #####: 1101:		state->state = ParserStateBeginStatement;
    #####: 1102:		state->has_errors = true;
    #####: 1103:		token_display_error(tk, "Expected param name. Found [%s]", tk->token);
        -: 1104:	}
    #####: 1105:}
        -: 1106:
    #####: 1107:void proc_ParserStateExpectIncompleteFnParamCommaOrEnd(ParserState *state, Token *tk) {
    #####: 1108:	if (!strcmp(tk->token, ",")) {
        -: 1109:		// look for the next param
    #####: 1110:		state->state = ParserStateExpectIncompleteFnMutOrType;
    #####: 1111:	} else if (!strcmp(tk->token, ")")) {
    #####: 1112:		state->state = ParserStateIncompleteExpectSemiOrTypeArrow;
        -: 1113:	} else {
    #####: 1114:		state->state = ParserStateBeginStatement;
    #####: 1115:		state->has_errors = true;
    #####: 1116:		token_display_error(tk, "Expected [',' or ')']. Found [%s]", tk->token);
        -: 1117:	}
    #####: 1118:}
        -: 1119:
    #####: 1120:void proc_ParserStateIncompleteExpectSemi(ParserState *state, Token *tk) {
    #####: 1121:	if (!strcmp(tk->token, ";")) {
    #####: 1122:		state->state = ParserStateExpectAt;
        -: 1123:	} else {
    #####: 1124:		state->state = ParserStateBeginStatement;
    #####: 1125:		state->has_errors = true;
    #####: 1126:		token_display_error(tk, "Expected ';'. Found [%s]", tk->token);
        -: 1127:	}
    #####: 1128:}
        -: 1129:
    #####: 1130:void proc_ParserStateIncompleteExpectSemiOrTypeArrow(ParserState *state, Token *tk) {
    #####: 1131:	if (!strcmp(tk->token, "->")) {
    #####: 1132:		state->state = ParserStateIncompleteExpectReturnType;
    #####: 1133:	} else if (!strcmp(tk->token, ";")) {
    #####: 1134:		state->state = ParserStateExpectAt;
        -: 1135:	} else {
    #####: 1136:		state->state = ParserStateBeginStatement;
    #####: 1137:		state->has_errors = true;
    #####: 1138:		token_display_error(tk, "Expected [';' or '->']. Found [%s]", tk->token);
        -: 1139:	}
    #####: 1140:}
        -: 1141:
    #####: 1142:void proc_ParserStateIncompleteExpectReturnType(ParserState *state, Token *tk) {
    #####: 1143:	if (tk->type == TokenTypeIdent) {
    #####: 1144:		u64 last = vec_size(&state->incomplete_fns);
    #####: 1145:		if (last == 0) {
    #####: 1146:			state->has_errors = true;
    #####: 1147:			token_display_error(tk, "internal error: Expected return type here!");
    #####: 1148:			state->state = ParserStateBeginStatement;
        -: 1149:		} else {
    #####: 1150:			last--;
    #####: 1151:			IncompleteFn *fn = vec_element_at(&state->incomplete_fns, last);
    #####: 1152:			strcpy(fn->return_type, tk->token);
    #####: 1153:			state->state = ParserStateIncompleteExpectSemi;
        -: 1154:		}
        -: 1155:	} else {
        -: 1156:		// unexpected - error
    #####: 1157:		state->state = ParserStateBeginStatement;
    #####: 1158:		state->has_errors = true;
    #####: 1159:		token_display_error(tk, "Expected return type. Found [%s]", tk->token);
        -: 1160:	}
    #####: 1161:}
        -: 1162:
    #####: 1163:void proc_ParserStateExpectIncompleteFnMutOrType(ParserState *state, Token *tk) {
    #####: 1164:	if (!strcmp(tk->token, "mut")) {
    #####: 1165:		u64 last = vec_size(&state->incomplete_fns);
    #####: 1166:		if (last == 0) {
    #####: 1167:			state->has_errors = true;
    #####: 1168:			token_display_error(tk, "internal error: Expected an incomplete function here!");
    #####: 1169:			state->state = ParserStateBeginStatement;
        -: 1170:		} else {
    #####: 1171:			last--;
    #####: 1172:			IncompleteFn *fn = vec_element_at(&state->incomplete_fns, last);
        -: 1173:			FnParam param;
    #####: 1174:			param.is_mut = true;
    #####: 1175:			vec_push(&fn->params, &param);
    #####: 1176:			state->state = ParserStateExpectIncompleteFnType;
        -: 1177:		}
    #####: 1178:	} else if (tk->type == TokenTypeIdent) {
        -: 1179:		// It's a type name pass on to Type fn
    #####: 1180:		u64 last = vec_size(&state->incomplete_fns);
    #####: 1181:		if (last == 0) {
    #####: 1182:			state->has_errors = true;
    #####: 1183:			token_display_error(tk, "internal error: Expected an incomplete function here!");
    #####: 1184:			state->state = ParserStateBeginStatement;
        -: 1185:		} else {
    #####: 1186:			last--;
    #####: 1187:			IncompleteFn *fn = vec_element_at(&state->incomplete_fns, last);
        -: 1188:			FnParam param;
    #####: 1189:			param.is_mut = false;
    #####: 1190:			vec_push(&fn->params, &param);
    #####: 1191:			proc_ParserStateExpectIncompleteFnType(state, tk);
        -: 1192:		}
    #####: 1193:	} else if (!strcmp(tk->token, ")")) {
        -: 1194:		// this is a parameterless function
    #####: 1195:		state->state = ParserStateIncompleteExpectSemiOrTypeArrow;
        -: 1196:	} else {
        -: 1197:		// unexpected - error
    #####: 1198:		state->state = ParserStateBeginStatement;
    #####: 1199:		state->has_errors = true;
    #####: 1200:		token_display_error(tk, "Expected 'mut' or type name. Found [%s]", tk->token);
        -: 1201:	}
    #####: 1202:}
        -: 1203:
    #####: 1204:void proc_ParserStateExpectIncompleteNameForImpl(ParserState *state, Token *tk,
        -: 1205:												 const char *args_file) {
    #####: 1206:	if (tk->type == TokenTypeIdent) {
        -: 1207:		TypeInfo ti;
    #####: 1208:		ti.mi = *state->cur;
    #####: 1209:		strcpy(ti.type_name, state->type_name);
        -: 1210:
        -: 1211:		TypeInfo ti_inc;
    #####: 1212:		ti_inc.mi = *state->cur;
    #####: 1213:		strcpy(ti_inc.type_name, tk->token);
        -: 1214:		char incomplete_full_type[PATH_MAX + 1];
    #####: 1215:		type_info_to_string(&ti_inc, incomplete_full_type, PATH_MAX);
        -: 1216:
        -: 1217:		char complete_type[PATH_MAX + 1];
    #####: 1218:		type_info_to_string(&ti, complete_type, PATH_MAX);
    #####: 1219:		char *incomplete_type = tk->token;
    #####: 1220:		bool found = false;
    #####: 1221:		bool has_impl = false;
        -: 1222:		char required_trait[PATH_MAX + 1];
        -: 1223:		bool ret =
    #####: 1224:			check_super_traits(complete_type, incomplete_full_type, required_trait, PATH_MAX);
    #####: 1225:		if (!ret) {
    #####: 1226:			state->has_errors = true;
        -: 1227:			// TODO: switch to path version of missing trait mod1::mod2::MyTrait
    #####: 1228:			token_display_error(
        -: 1229:				tk, "All super traits not implemented for type [%s]. Missing trait [%s]",
    #####: 1230:				state->type_name, required_trait);
        -: 1231:		}
    #####: 1232:		add_trait_impl(incomplete_full_type, complete_type);
    #####: 1233:		for (u64 i = 0; i < global_incomplete_list.count; i++) {
    #####: 1234:			if (!strcmp(incomplete_type, global_incomplete_list.types[i].name)) {
    #####: 1235:				IncompleteType *inc = &global_incomplete_list.types[i];
    #####: 1236:				for (u64 j = 0; j < inc->count; j++) {
    #####: 1237:					if (inc->fns[j].has_impl)
    #####: 1238:						has_impl = true;
    #####: 1239:					if (inc->fns[j].has_impl) {
    #####: 1240:						if (inc->fns[j].is_mut) {
    #####: 1241:							append_to_header(state, "%s %s_%s(Obj *self", inc->fns[j].return_type,
    #####: 1242:											 incomplete_full_type, inc->fns[j].name);
        -: 1243:						} else {
    #####: 1244:							append_to_header(state, "%s %s_%s(const Obj *self",
    #####: 1245:											 inc->fns[j].return_type, incomplete_full_type,
    #####: 1246:											 inc->fns[j].name);
        -: 1247:						}
        -: 1248:					} else {
    #####: 1249:						if (inc->fns[j].is_mut) {
    #####: 1250:							append_to_header(state, "%s %s_%s(Obj *self", inc->fns[j].return_type,
    #####: 1251:											 complete_type, inc->fns[j].name);
        -: 1252:						} else {
    #####: 1253:							append_to_header(state, "%s %s_%s(const Obj *self",
    #####: 1254:											 inc->fns[j].return_type, complete_type,
    #####: 1255:											 inc->fns[j].name);
        -: 1256:						}
        -: 1257:					}
        -: 1258:
    #####: 1259:					expand_params(state, &inc->fns[j], NULL);
    #####: 1260:					append_to_header(state, ");");
        -: 1261:				}
    #####: 1262:				append_to_header(state, "extern Vtable %s_Vtable__;", complete_type);
    #####: 1263:				append_to_header(
        -: 1264:					state, "static void __attribute__((constructor)) vtable_add_inc_impl_%s_%s() {",
        -: 1265:					complete_type, incomplete_type);
    #####: 1266:				for (u64 j = 0; j < inc->count; j++) {
    #####: 1267:					if (inc->fns[j].has_impl) {
    #####: 1268:						append_to_header(
        -: 1269:							state,
        -: 1270:							"VtableEntry "
        -: 1271:							"next_%" PRIu64
        -: 1272:							" = {\"%s\", %s_%s}; vtable_add_entry(&%s_Vtable__, next_%" PRIu64 ");",
    #####: 1273:							j, inc->fns[j].name, incomplete_full_type, inc->fns[j].name,
        -: 1274:							complete_type, j);
        -: 1275:					} else {
    #####: 1276:						append_to_header(
        -: 1277:							state,
        -: 1278:							"VtableEntry next_%" PRIu64
        -: 1279:							" = {\"%s\", %s_%s}; vtable_add_entry(&%s_Vtable__, next_%" PRIu64 ");",
    #####: 1280:							j, inc->fns[j].name, complete_type, inc->fns[j].name, complete_type, j);
        -: 1281:					}
        -: 1282:				}
    #####: 1283:				append_to_header(state, "}");
    #####: 1284:				found = true;
        -: 1285:			}
        -: 1286:		}
        -: 1287:
    #####: 1288:		if (has_impl) {
        -: 1289:			TypeInfo ti;
    #####: 1290:			ti.mi = *(state->cur);
    #####: 1291:			strcpy(ti.type_name, incomplete_type);
    #####: 1292:			ti.gen_file_counter = state->gen_file_counter;
    #####: 1293:			vec_push(state->types, &ti);
        -: 1294:
    #####: 1295:			FILE *fp = myfopen(args_file, "a");
    #####: 1296:			fprintf(fp, "-DType_Expand_%s_=\"\"\n", incomplete_full_type);
    #####: 1297:			myfclose(fp);
        -: 1298:		}
        -: 1299:
    #####: 1300:		if (!found) {
    #####: 1301:			state->has_errors = true;
    #####: 1302:			token_display_error(tk, "Attempt to complete an unknown incomplete type [%s]",
        -: 1303:								incomplete_type);
        -: 1304:		}
    #####: 1305:		state->state = ParserStateImplExpectSemi;
        -: 1306:	} else {
    #####: 1307:		state->state = ParserStateBeginStatement;
    #####: 1308:		state->has_errors = true;
    #####: 1309:		token_display_error(tk, "Expected type name. Found [%s]", tk->token);
        -: 1310:	}
    #####: 1311:}
        -: 1312:
    #####: 1313:void proc_ParserStateImplExpectSemi(ParserState *state, Token *tk) {
    #####: 1314:	if (!strcmp(tk->token, ";")) {
    #####: 1315:		state->state = ParserStateBeginStatement;
        -: 1316:	} else {
    #####: 1317:		state->state = ParserStateBeginStatement;
    #####: 1318:		state->has_errors = true;
    #####: 1319:		token_display_error(tk, "Expected ';'. Found [%s]", tk->token);
        -: 1320:	}
    #####: 1321:}
        -: 1322:
    #####: 1323:void file_for(const char *base_dir, const ModuleInfo *self_info, char buf[PATH_MAX]) {
    #####: 1324:	Path ret;
    #####: 1325:	path_for(&ret, base_dir);
    #####: 1326:	for (u64 i = 0; self_info->sub_module_count != 0 && i < self_info->sub_module_count; i++) {
    #####: 1327:		path_push(&ret, self_info->module_list[i].name);
        -: 1328:	}
    #####: 1329:	if (self_info->sub_module_count == 0) {
    #####: 1330:		path_push(&ret, "mod.h");
        -: 1331:	} else {
        -: 1332:		char module_file_f[PATH_MAX];
    #####: 1333:		strcpy(module_file_f, path_to_string(&ret));
    #####: 1334:		strcat(module_file_f, ".h");
        -: 1335:
    #####: 1336:		Path test_f;
    #####: 1337:		path_for(&test_f, module_file_f);
    #####: 1338:		if (path_exists(&test_f)) {
    #####: 1339:			path_cleanup(&ret);
    #####: 1340:			path_copy(&ret, &test_f);
        -: 1341:		} else {
    #####: 1342:			path_pop(&ret);
    #####: 1343:			path_push(&ret, self_info->module_list[self_info->sub_module_count - 1].name);
    #####: 1344:			path_push(&ret, "mod.h");
    #####: 1345:			if (!path_exists(&ret)) {
    #####: 1346:				exit_error("Module: [%s] not found!", path_to_string(&ret));
        -: 1347:			}
        -: 1348:		}
        -: 1349:	}
    #####: 1350:	if (path_canonicalize(&ret)) {
    #####: 1351:		exit_error("Path %s does not exist.", path_to_string(&ret));
        -: 1352:	}
    #####: 1353:	strcpy(buf, path_to_string(&ret));
    #####: 1354:}
        -: 1355:
    #####: 1356:void init_parser(const char *args_file) {
    #####: 1357:	Vec build_fns;
    #####: 1358:	vec_init(&build_fns, 1, sizeof(IncompleteFn));
        -: 1359:	IncompleteFn build;
    #####: 1360:	build.has_impl = false;
    #####: 1361:	strcpy(build.name, "build");
    #####: 1362:	strcpy(build.return_type, "void");
    #####: 1363:	vec_init(&build.params, 1, sizeof(FnParam));
    #####: 1364:	FnParam config = {.is_mut = true};
    #####: 1365:	strcpy(config.type, "__config__");
    #####: 1366:	strcpy(config.name, "__selfconfig__");
    #####: 1367:	vec_push(&build.params, &config);
    #####: 1368:	vec_push(&build_fns, &build);
        -: 1369:
    #####: 1370:	add_to_global_incomplete_list("Build", &build_fns, args_file, NULL, NULL);
        -: 1371:
    #####: 1372:	Vec drop_fns;
    #####: 1373:	vec_init(&drop_fns, 1, sizeof(IncompleteFn));
        -: 1374:	IncompleteFn drop;
    #####: 1375:	drop.has_impl = false;
    #####: 1376:	strcpy(drop.name, "drop");
    #####: 1377:	strcpy(drop.return_type, "void");
    #####: 1378:	vec_init(&drop.params, 1, sizeof(FnParam));
    #####: 1379:	vec_push(&drop_fns, &drop);
        -: 1380:
    #####: 1381:	add_to_global_incomplete_list("Drop", &drop_fns, args_file, NULL, NULL);
    #####: 1382:}
        -: 1383:
    #####: 1384:void parse_header(const char *config_dir, const char *base_dir, Vec *modules, Vec *types,
        -: 1385:				  const ModuleInfo *self_info) {
        -: 1386:
    #####: 1387:	Path args_path;
    #####: 1388:	path_for(&args_path, base_dir);
    #####: 1389:	path_push(&args_path, "target");
    #####: 1390:	path_push(&args_path, "args");
    #####: 1391:	path_push(&args_path, "args.txt");
    #####: 1392:	const char *args_file = path_to_string(&args_path);
        -: 1393:	char file[PATH_MAX];
    #####: 1394:	file_for(base_dir, self_info, file);
        -: 1395:	Lexer l;
    #####: 1396:	if (lexer_init(&l, file)) {
    #####: 1397:		exit_error("Could not open module file: '%s'", file);
        -: 1398:	}
        -: 1399:
    #####: 1400:	ParserState state = {
        -: 1401:		.state = ParserStateBeginStatement,
        -: 1402:		.modules = modules,
        -: 1403:		.gen_header = NULL,
        -: 1404:		.header_capacity = 0,
        -: 1405:		.cur = self_info,
        -: 1406:		.types = types,
        -: 1407:		.gen_file_counter = gen_file_counter,
        -: 1408:		.has_errors = false,
        -: 1409:	};
    #####: 1410:	gen_file_counter++;
        -: 1411:
    #####: 1412:	vec_init(&state.config_types, 3, sizeof(ConfigType));
    #####: 1413:	vec_init(&state.config_names, 3, sizeof(ConfigName));
    #####: 1414:	vec_init(&state.ht.names, 3, sizeof(HeaderNameInfo));
    #####: 1415:	vec_init(&state.ht.types, 3, sizeof(HeaderTypeInfo));
    #####: 1416:	vec_init(&state.import_list, 3, sizeof(SubModuleInfo));
    #####: 1417:	vec_init(&state.incomplete_fns, 3, sizeof(IncompleteFn));
    #####: 1418:	vec_init(&state.super_traits, 3, sizeof(SuperTraitInfo));
        -: 1419:
    #####: 1420:	while (true) {
        -: 1421:		Token tk;
    #####: 1422:		int res = lexer_next_token(&l, &tk);
    #####: 1423:		if (res == LexerStateComplete) {
    #####: 1424:			break;
        -: 1425:		}
        -: 1426:		// printf("state=%i,token_type=%i,token_value='%s'\n", state.state, tk.type, tk.token);
    #####: 1427:		if (tk.type != TokenTypeDoc) {
        -: 1428:			// skip over doc comments for these purposes
    #####: 1429:			if (state.state == ParserStateBeginStatement) {
    #####: 1430:				proc_ParserStateBeginStatement(&state, &tk);
    #####: 1431:			} else if (state.state == ParserStateExpectModuleName) {
    #####: 1432:				proc_ParserStateExpectModuleName(&state, &tk);
    #####: 1433:			} else if (state.state == ParserStateExpectType) {
    #####: 1434:				proc_ParserStateExpectType(&state, &tk, args_file);
    #####: 1435:			} else if (state.state == ParserStateExpectName) {
    #####: 1436:				proc_ParserStateExpectName(&state, &tk);
    #####: 1437:			} else if (state.state == ParserStateInTypeExpectSemi) {
    #####: 1438:				proc_ParserStateInTypeExpectSemi(&state, &tk);
    #####: 1439:			} else if (state.state == ParserStateInImportListExpectModuleName) {
    #####: 1440:				proc_ParserStateInImportListExpectModuleName(&state, &tk);
    #####: 1441:			} else if (state.state == ParserStateInImportListExpectSeparator) {
    #####: 1442:				proc_ParserStateInImportListExpectSeparator(&state, &tk);
    #####: 1443:			} else if (state.state == ParserStateExpectParenBuildDefn) {
    #####: 1444:				proc_ParserStateExpectParenBuildDefn(&state, &tk);
    #####: 1445:			} else if (state.state == ParserStateExpectConfigName) {
    #####: 1446:				proc_ParserStateExpectConfigName(&state, &tk);
    #####: 1447:			} else if (state.state == ParserStateExpectConfigComma) {
    #####: 1448:				proc_ParserStateExpectConfigComma(&state, &tk);
    #####: 1449:			} else if (state.state == ParserStateExpectConfigType) {
    #####: 1450:				proc_ParserStateExpectConfigType(&state, &tk);
    #####: 1451:			} else if (state.state == ParserStateIncompleteName) {
    #####: 1452:				proc_ParserStateIncompleteName(&state, &tk);
    #####: 1453:			} else if (state.state == ParserIncompleteExpectBrace) {
    #####: 1454:				proc_ParserIncompleteExpectBrace(&state, &tk);
    #####: 1455:			} else if (state.state == ParserStateExpectAt) {
    #####: 1456:				proc_ParserStateExpectAt(&state, &tk, args_file);
    #####: 1457:			} else if (state.state == ParserStateExpectIncompleteFnMutOrType) {
    #####: 1458:				proc_ParserStateExpectIncompleteFnMutOrType(&state, &tk);
    #####: 1459:			} else if (state.state == ParserStateExpectIncompleteFnName) {
    #####: 1460:				proc_ParserStateExpectIncompleteFnName(&state, &tk);
    #####: 1461:			} else if (state.state == ParserStateExpectIncompleteFnParenStart) {
    #####: 1462:				proc_ParserStateExpectIncompleteFnParenStart(&state, &tk);
    #####: 1463:			} else if (state.state == ParserStateExpectIncompleteFnType) {
    #####: 1464:				proc_ParserStateExpectIncompleteFnType(&state, &tk);
    #####: 1465:			} else if (state.state == ParserStateExpectIncompleteFnParamName) {
    #####: 1466:				proc_ParserStateExpectIncompleteFnParamName(&state, &tk);
    #####: 1467:			} else if (state.state == ParserStateExpectIncompleteFnParamCommaOrEnd) {
    #####: 1468:				proc_ParserStateExpectIncompleteFnParamCommaOrEnd(&state, &tk);
    #####: 1469:			} else if (state.state == ParserStateIncompleteExpectSemi) {
    #####: 1470:				proc_ParserStateIncompleteExpectSemi(&state, &tk);
    #####: 1471:			} else if (state.state == ParserStateIncompleteExpectSemiOrTypeArrow) {
    #####: 1472:				proc_ParserStateIncompleteExpectSemiOrTypeArrow(&state, &tk);
    #####: 1473:			} else if (state.state == ParserStateIncompleteExpectReturnType) {
    #####: 1474:				proc_ParserStateIncompleteExpectReturnType(&state, &tk);
    #####: 1475:			} else if (state.state == ParserStateExpectIncompleteNameForImpl) {
    #####: 1476:				proc_ParserStateExpectIncompleteNameForImpl(&state, &tk, args_file);
    #####: 1477:			} else if (state.state == ParserStateImplExpectSemi) {
    #####: 1478:				proc_ParserStateImplExpectSemi(&state, &tk);
    #####: 1479:			} else if (state.state == ParserStateExpectIncompleteMutFnName) {
    #####: 1480:				proc_ParserStateExpectIncompleteMutFnName(&state, &tk);
    #####: 1481:			} else if (state.state == ParserStateExpectPipe) {
    #####: 1482:				proc_ParserStateExpectPipe(&state, &tk);
    #####: 1483:			} else if (state.state == ParserStateExpectArraySize) {
    #####: 1484:				proc_ParserStateExpectArraySize(&state, &tk);
    #####: 1485:			} else if (state.state == ParserStateExpectEndArray) {
    #####: 1486:				proc_ParserStateExpectEndArray(&state, &tk);
    #####: 1487:			} else if (state.state == ParserStateExpectConfigKeyword) {
    #####: 1488:				proc_ParserStateExpectConfigKeyword(&state, &tk);
    #####: 1489:			} else if (state.state == ParserStateExpectIncompleteMutFnNameWithDefaultImpl) {
    #####: 1490:				proc_ParserStateExpectIncompleteMutFnNameWithDefaultImpl(&state, &tk);
    #####: 1491:			} else if (state.state == ParserStateExpectPlusOrBrace) {
    #####: 1492:				proc_ParserStateExpectPlusOrBrace(&state, &tk);
    #####: 1493:			} else if (state.state == ParserStateExpectSuperTrait) {
    #####: 1494:				proc_ParserStateExpectSuperTrait(&state, &tk);
    #####: 1495:			} else if (tk.type == TokenTypePunct) {
    #####: 1496:				if (!strcmp(tk.token, "}") || !strcmp(tk.token, ";")) {
    #####: 1497:					state.state = ParserStateBeginStatement;
    #####: 1498:				} else if (!strcmp(tk.token, "{") && state.state == ParserStateExpectBrace) {
        -: 1499:					TypeInfo ti;
    #####: 1500:					ti.mi = *state.cur;
    #####: 1501:					strcpy(ti.type_name, state.type_name);
    #####: 1502:					ti.gen_file_counter = state.gen_file_counter;
    #####: 1503:					vec_push(types, &ti);
    #####: 1504:					state.state = ParserStateExpectType;
    #####: 1505:					state.cur_is_array = false;
    #####: 1506:				} else if (!strcmp(tk.token, "::") && state.state == ParserStateExpectBrace) {
        -: 1507:					// This is an implementation statement
    #####: 1508:					state.state = ParserStateExpectIncompleteNameForImpl;
        -: 1509:				} else
    #####: 1510:					state.state = ParserStateOther;
        -: 1511:			}
        -: 1512:		}
        -: 1513:
    #####: 1514:		token_cleanup(&tk);
        -: 1515:	}
        -: 1516:
    #####: 1517:	Path gen_header_name;
        -: 1518:	char header_name[128];
    #####: 1519:	snprintf(header_name, 128, "f%" PRIu64 "", state.gen_file_counter);
    #####: 1520:	path_for(&gen_header_name, base_dir);
    #####: 1521:	path_push(&gen_header_name, "target");
    #####: 1522:	path_push(&gen_header_name, "include");
    #####: 1523:	path_push(&gen_header_name, header_name);
    #####: 1524:	path_mkdir(&gen_header_name, 0700, false);
    #####: 1525:	path_push(&gen_header_name, "build_specific.h");
        -: 1526:
    #####: 1527:	append_to_header(&state, "");
        -: 1528:
    #####: 1529:	FILE *fp = myfopen(path_to_string(&gen_header_name), "w");
    #####: 1530:	if (fprintf(fp, "%s", state.gen_header) < strlen(state.gen_header))
    #####: 1531:		fprintf(stderr, "Partial write of header: %s occurred!\n",
        -: 1532:				path_to_string(&gen_header_name));
        -: 1533:
    #####: 1534:	myfclose(fp);
    #####: 1535:	free_gen_header(&state);
    #####: 1536:	vec_cleanup(&state.ht.names);
    #####: 1537:	vec_cleanup(&state.ht.types);
    #####: 1538:	vec_cleanup(&state.import_list);
    #####: 1539:	vec_cleanup(&state.config_types);
    #####: 1540:	vec_cleanup(&state.config_names);
    #####: 1541:	vec_cleanup(&state.incomplete_fns);
    #####: 1542:	vec_cleanup(&state.super_traits);
        -: 1543:
    #####: 1544:	lexer_cleanup(&l);
        -: 1545:
    #####: 1546:	if (state.has_errors) {
    #####: 1547:		exit_error("Compilation of file: %s failed!", file);
        -: 1548:	}
    #####: 1549:}
        -:    0:Source:args.c
        -:    0:Graph:args.gcno
        -:    0:Data:args.gcda
        -:    0:Runs:4
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        8:   20:int args_param_build(ArgsParam *ap, char *name, char *help, char *short_name, bool takes_value,
        -:   21:	bool multiple, char *default_value)
        -:   22:{
        8:   23:	if (ap == NULL || name == NULL || help == NULL || short_name == NULL) {
    #####:   24:		errno = EINVAL;
    #####:   25:		return -1;
        -:   26:	}
        -:   27:
        8:   28:	if (strlen(short_name) > strlen(name)) {
    #####:   29:		fprintf(stderr, "short_name cannot be longer than name\n");
    #####:   30:		return -1;
        -:   31:	}
        -:   32:
        8:   33:	ap->name = NULL;
        8:   34:	ap->help = NULL;
        8:   35:	ap->short_name = NULL;
        8:   36:	ap->default_value = NULL;
        -:   37:
        8:   38:	ap->name = mymalloc((1 + strlen(name)) * sizeof(char));
        8:   39:	if (ap->name == NULL) {
    #####:   40:		return -1;
        -:   41:	}
        8:   42:	strcpy(ap->name, name);
        -:   43:
        8:   44:	ap->help = mymalloc((1 + strlen(help)) * sizeof(char));
        8:   45:	if (ap->help == NULL) {
    #####:   46:		args_param_cleanup(ap);
    #####:   47:		return -1;
        -:   48:	}
        8:   49:	strcpy(ap->help, help);
        -:   50:
        8:   51:	ap->short_name = mymalloc((1 + strlen(short_name)) * sizeof(char));
        8:   52:	if (ap->short_name == NULL) {
    #####:   53:		args_param_cleanup(ap);
    #####:   54:		return -1;
        -:   55:	}
        8:   56:	strcpy(ap->short_name, short_name);
        -:   57:
        8:   58:	ap->takes_value = takes_value;
        8:   59:	ap->multiple = multiple;
        -:   60:
        8:   61:	if (default_value) {
        5:   62:		ap->default_value = mymalloc((1 + strlen(default_value)) * sizeof(char));
        5:   63:		if (ap->default_value == NULL) {
    #####:   64:			args_param_cleanup(ap);
    #####:   65:			return -1;
        -:   66:		}
        5:   67:		strcpy(ap->default_value, default_value);
        -:   68:	} else
        3:   69:		ap->default_value = NULL;
        -:   70:
        8:   71:	return 0;
        -:   72:}
       15:   73:void args_param_cleanup(ArgsParam *ap)
        -:   74:{
       15:   75:	if (ap->name) {
       15:   76:		myfree(ap->name);
       15:   77:		ap->name = NULL;
        -:   78:	}
       15:   79:	if (ap->short_name) {
       15:   80:		myfree(ap->short_name);
       15:   81:		ap->short_name = NULL;
        -:   82:	}
       15:   83:	if (ap->help) {
       15:   84:		myfree(ap->help);
       15:   85:		ap->help = NULL;
        -:   86:	}
       15:   87:	if (ap->default_value) {
       10:   88:		myfree(ap->default_value);
       10:   89:		ap->default_value = NULL;
        -:   90:	}
       15:   91:}
        7:   92:int sub_command_build(
        -:   93:	SubCommand *sc, char *name, char *help, u32 min_args, u32 max_args, char *arg_doc)
        -:   94:{
        7:   95:	if (name == NULL || help == NULL || min_args > max_args || arg_doc == NULL) {
        2:   96:		errno = EINVAL;
        2:   97:		return -1;
        -:   98:	}
        -:   99:
        5:  100:	sc->name = NULL;
        5:  101:	sc->help = NULL;
        5:  102:	sc->arg_doc = NULL;
        5:  103:	sc->params_count = 0;
        -:  104:
        5:  105:	sc->name = mymalloc((1 + strlen(name)) * sizeof(char));
        5:  106:	if (sc->name == NULL) {
    #####:  107:		sub_command_cleanup(sc);
    #####:  108:		return -1;
        -:  109:	}
        5:  110:	strcpy(sc->name, name);
        -:  111:
        5:  112:	sc->help = mymalloc((1 + strlen(help)) * sizeof(char));
        5:  113:	if (sc->help == NULL) {
    #####:  114:		sub_command_cleanup(sc);
    #####:  115:		return -1;
        -:  116:	}
        5:  117:	strcpy(sc->help, help);
        -:  118:
        5:  119:	sc->arg_doc = mymalloc((1 + strlen(arg_doc)) * sizeof(char));
        5:  120:	if (sc->arg_doc == NULL) {
    #####:  121:		sub_command_cleanup(sc);
    #####:  122:		return -1;
        -:  123:	}
        5:  124:	strcpy(sc->arg_doc, arg_doc);
        -:  125:
        5:  126:	sc->min_args = min_args;
        5:  127:	sc->max_args = max_args;
        5:  128:	return 0;
        -:  129:}
        5:  130:void sub_command_cleanup(SubCommand *sc)
        -:  131:{
        5:  132:	if (sc->name) {
        5:  133:		myfree(sc->name);
        5:  134:		sc->name = NULL;
        -:  135:	}
        -:  136:
        5:  137:	if (sc->help) {
        5:  138:		myfree(sc->help);
        5:  139:		sc->help = NULL;
        -:  140:	}
        -:  141:
        5:  142:	if (sc->arg_doc) {
        5:  143:		myfree(sc->arg_doc);
        5:  144:		sc->arg_doc = NULL;
        -:  145:	}
        -:  146:
        5:  147:	if (sc->params_count != 0) {
       11:  148:		for (u64 i = 0; i < sc->params_count; i++) {
        7:  149:			args_param_cleanup(&sc->params[i]);
        -:  150:		}
        -:  151:
        4:  152:		myfree(sc->params);
        4:  153:		myfree(sc->params_state);
        4:  154:		sc->params = NULL;
        4:  155:		sc->params_state = NULL;
        4:  156:		sc->params_count = 0;
        -:  157:	}
        5:  158:}
        7:  159:int sub_command_add_param(SubCommand *sc, ArgsParam *ap)
        -:  160:{
        7:  161:	if (ap->name == NULL || ap->help == NULL || ap->short_name == NULL) {
    #####:  162:		errno = EINVAL;
    #####:  163:		return -1;
        -:  164:	}
        7:  165:	if (sc->params_count == 0) {
        4:  166:		sc->params = mymalloc(sizeof(ArgsParam));
        4:  167:		sc->params_state = mymalloc(sizeof(ArgsParamState));
        -:  168:
        4:  169:		if (sc->params == NULL || sc->params_state == NULL) {
        -:  170:
    #####:  171:			sub_command_cleanup(sc);
    #####:  172:			return -1;
        -:  173:		}
        4:  174:		sc->params_count = 1;
        -:  175:	} else {
        3:  176:		sc->params_count += 1;
        3:  177:		void *tmp1 = myrealloc(sc->params, sizeof(ArgsParam) * sc->params_count);
        3:  178:		void *tmp2 = myrealloc(sc->params_state, sizeof(ArgsParamState) * sc->params_count);
        -:  179:
        3:  180:		sc->params = tmp1;
        3:  181:		sc->params_state = tmp2;
        -:  182:	}
        7:  183:	u64 index = sc->params_count - 1;
        -:  184:
        7:  185:	sc->params[index].name = mymalloc((strlen(ap->name) + 1) * sizeof(char));
        7:  186:	strcpy(sc->params[index].name, ap->name);
        -:  187:
        7:  188:	sc->params[index].help = mymalloc((strlen(ap->help) + 1) * sizeof(char));
        7:  189:	strcpy(sc->params[index].help, ap->help);
        -:  190:
        7:  191:	sc->params[index].short_name = mymalloc((strlen(ap->short_name) + 1) * sizeof(char));
        7:  192:	strcpy(sc->params[index].short_name, ap->short_name);
        -:  193:
        7:  194:	sc->params[index].takes_value = ap->takes_value;
        7:  195:	sc->params[index].multiple = ap->multiple;
        -:  196:
        7:  197:	if (ap->default_value) {
        5:  198:		sc->params[index].default_value = mymalloc((strlen(ap->default_value) + 1) * sizeof(char));
        5:  199:		if (sc->params[index].default_value == NULL) {
    #####:  200:			sub_command_cleanup(sc);
    #####:  201:			return -1;
        -:  202:		}
        5:  203:		strcpy(sc->params[index].default_value, ap->default_value);
        -:  204:	} else {
        2:  205:		sc->params[index].default_value = NULL;
        -:  206:	}
        -:  207:
        7:  208:	sc->params_state[index].specified = false;
        -:  209:
        7:  210:	if (sc->params[index].name == NULL || sc->params[index].help == NULL
        7:  211:		|| sc->params[index].short_name == NULL) {
    #####:  212:		sub_command_cleanup(sc);
    #####:  213:		return -1;
        -:  214:	}
        -:  215:
        7:  216:	return 0;
        -:  217:}
        -:  218:
        1:  219:int args_build(Args *args, char *prog, char *version, char *author, u32 min_args, u32 max_args,
        -:  220:	u64 debug_flags)
        -:  221:{
       1*:  222:	if (prog == NULL && version == NULL && author == NULL) {
    #####:  223:		errno = EINVAL;
    #####:  224:		return -1;
        -:  225:	}
        1:  226:	args->subs_count = 0;
        1:  227:	args->argc = 0;
        1:  228:	args->debug_flags = debug_flags;
        -:  229:
        1:  230:	args->prog = mymalloc(sizeof(char) * (1 + strlen(prog)));
        1:  231:	args->version = mymalloc(sizeof(char) * (1 + strlen(version)));
        1:  232:	args->author = mymalloc(sizeof(char) * (1 + strlen(author)));
        -:  233:
        1:  234:	if (args->prog == NULL || args->version == NULL || args->author == NULL) {
    #####:  235:		args_cleanup(args);
    #####:  236:		return -1;
        -:  237:	}
        1:  238:	strcpy(args->prog, prog);
        1:  239:	strcpy(args->version, version);
        1:  240:	strcpy(args->author, author);
        -:  241:
        -:  242:	// first subcommand is our params
        -:  243:	SubCommand sc;
        1:  244:	sub_command_build(&sc, "", "", min_args, max_args, "");
        1:  245:	args_add_sub_command(args, &sc);
        1:  246:	sub_command_cleanup(&sc);
        -:  247:
        1:  248:	return 0;
        -:  249:}
        -:  250:
        1:  251:void args_cleanup(Args *args)
        -:  252:{
        1:  253:	if (args->argc) {
        3:  254:		for (u64 i = 0; i < args->argc; i++) {
        2:  255:			myfree(args->argv[i]);
        -:  256:		}
        1:  257:		myfree(args->argv);
        1:  258:		args->argc = 0;
        -:  259:	}
        -:  260:
        1:  261:	if (args->prog) {
        1:  262:		myfree(args->prog);
        1:  263:		args->prog = NULL;
        -:  264:	}
        -:  265:
        1:  266:	if (args->author) {
        1:  267:		myfree(args->author);
        1:  268:		args->author = NULL;
        -:  269:	}
        -:  270:
        1:  271:	if (args->version) {
        1:  272:		myfree(args->version);
        1:  273:		args->version = NULL;
        -:  274:	}
        -:  275:
        1:  276:	if (args->subs_count) {
        3:  277:		for (u64 i = 0; i < args->subs_count; i++) {
        2:  278:			sub_command_cleanup(args->subs[i]);
        2:  279:			myfree(args->subs[i]);
        -:  280:		}
        -:  281:
        1:  282:		myfree(args->subs);
        -:  283:	}
        1:  284:}
        2:  285:int args_add_param(Args *args, ArgsParam *ap)
        -:  286:{
        2:  287:	return sub_command_add_param(args->subs[0], ap);
        -:  288:}
        -:  289:
        2:  290:int args_add_sub_command(Args *args, SubCommand *sc)
        -:  291:{
        2:  292:	if (args->subs_count == 0) {
        1:  293:		args->subs = mymalloc(sizeof(SubCommand *));
        1:  294:		if (args->subs == NULL) {
    #####:  295:			fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  296:			return -1;
        -:  297:		}
        -:  298:	} else {
        1:  299:		SubCommand **tmp = myrealloc(args->subs, sizeof(SubCommand *) * (1 + args->subs_count));
        -:  300:
        1:  301:		if (tmp == NULL) {
    #####:  302:			fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  303:			return -1;
        -:  304:		}
        -:  305:
        1:  306:		args->subs = tmp;
        -:  307:	}
        -:  308:
        2:  309:	args->subs[args->subs_count] = mymalloc(sizeof(SubCommand));
        2:  310:	if (args->subs[args->subs_count] == NULL) {
    #####:  311:		fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  312:		return -1;
        -:  313:	}
        -:  314:
        2:  315:	if (sub_command_build(args->subs[args->subs_count], sc->name, sc->help, sc->min_args,
        -:  316:			sc->max_args, sc->arg_doc)) {
    #####:  317:		fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  318:		myfree(args->subs[args->subs_count]);
    #####:  319:		return -1;
        -:  320:	}
        3:  321:	for (u64 i = 0; i < sc->params_count; i++) {
        1:  322:		if (sub_command_add_param(args->subs[args->subs_count], &sc->params[i])) {
    #####:  323:			fprintf(stderr, "add param [%s] subcommand %s failed!\n", sc->params[i].name, sc->name);
        -:  324:		}
        -:  325:	}
        -:  326:
        2:  327:	args->subs_count += 1;
        2:  328:	return 0;
        -:  329:}
        -:  330:
    #####:  331:bool args_sub_takes_value(Args *args, u64 subi, char *name, bool is_short)
        -:  332:{
    #####:  333:	for (u64 i = 0; i < args->subs[subi]->params_count; i++) {
    #####:  334:		if (is_short && !strcmp(name, args->subs[subi]->params[i].short_name)) {
    #####:  335:			if (args->subs[subi]->params[i].takes_value) {
    #####:  336:				return true;
        -:  337:			} else
    #####:  338:				break;
    #####:  339:		} else if (!strcmp(name, args->subs[subi]->params[i].name)) {
    #####:  340:			if (args->subs[subi]->params[i].takes_value) {
    #####:  341:				return true;
        -:  342:			} else
    #####:  343:				break;
        -:  344:		}
        -:  345:	}
    #####:  346:	return false;
        -:  347:}
        -:  348:
    #####:  349:void args_exit_error(Args *args, char *format, ...)
        -:  350:{
        -:  351:	va_list va_args;
    #####:  352:	va_start(va_args, format);
    #####:  353:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
    #####:  354:	vfprintf(stderr, format, va_args);
    #####:  355:	fprintf(stderr, "\n\n");
    #####:  356:	fprintf(stderr,
        -:  357:		"%sUSAGE%s:\n    %s%s%s [%sOPTIONS%s]\n\nFor more information "
        -:  358:		"try %s--help%s\n",
        -:  359:		DIMMED, RESET, BRIGHT_RED, args->prog, RESET, DIMMED, RESET, GREEN, RESET);
    #####:  360:	va_end(va_args);
    #####:  361:	u64 debug_flags = args->debug_flags;
    #####:  362:	if (!(debug_flags & DEBUG_INIT_NO_EXIT))
    #####:  363:		exit(-1);
    #####:  364:}
        -:  365:
    #####:  366:u64 args_subi_for(Args *args, char *sub)
        -:  367:{
    #####:  368:	u64 subi = 0;
    #####:  369:	for (u64 i = 1; i < args->subs_count; i++) {
    #####:  370:		if (!strcmp(sub, args->subs[i]->name)) {
    #####:  371:			subi = i;
        -:  372:		}
        -:  373:	}
    #####:  374:	return subi;
        -:  375:}
        -:  376:
    #####:  377:bool args_check_option(Args *args, u64 subi, char *name, bool is_short, char *argv)
        -:  378:{
    #####:  379:	bool found = false;
    #####:  380:	for (u64 j = 0; j < args->subs[subi]->params_count; j++) {
    #####:  381:		bool multi = args->subs[subi]->params[j].multiple;
    #####:  382:		if (is_short && !strcmp(args->subs[subi]->params[j].short_name, name)) {
    #####:  383:			found = true;
    #####:  384:			if (args->subs[subi]->params_state[j].specified && !multi)
    #####:  385:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
    #####:  386:			args->subs[subi]->params_state[j].specified = true;
    #####:  387:			break;
    #####:  388:		} else if (!is_short && !strcmp(args->subs[subi]->params[j].name, name)) {
    #####:  389:			found = true;
    #####:  390:			if (args->subs[subi]->params_state[j].specified && !multi)
    #####:  391:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
    #####:  392:			args->subs[subi]->params_state[j].specified = true;
    #####:  393:			break;
        -:  394:		}
        -:  395:	}
    #####:  396:	return found;
        -:  397:}
        -:  398:
        1:  399:void args_check_validity(Args *args, int argc, char **argv)
        -:  400:{
        -:  401:	// check if there's a sub command and check arg count
        1:  402:	char *sub = NULL;
        1:  403:	u32 arg_count = 0;
        1:  404:	u64 subi = 0;
        1:  405:	u64 sub_arg = ULONG_MAX;
        2:  406:	for (u64 i = 1; i < argc; i++) {
        1:  407:		u64 len = strlen(argv[i]);
       1*:  408:		if (len > 0 && argv[i][0] == '-') {
    #####:  409:			char name[len];
        -:  410:			bool is_short;
    #####:  411:			bool found = false;
    #####:  412:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  413:				strcpy(name, args->argv[i] + 2);
    #####:  414:				is_short = false;
        -:  415:			} else {
    #####:  416:				strcpy(name, args->argv[i] + 1);
    #####:  417:				is_short = true;
        -:  418:			}
    #####:  419:			if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  420:				i += 1;
        -:  421:			}
        -:  422:		} else {
        1:  423:			if (!sub && args->subs_count > 1) {
    #####:  424:				sub = argv[i];
    #####:  425:				sub_arg = i;
    #####:  426:				subi = args_subi_for(args, sub);
        -:  427:			} else
        1:  428:				arg_count += 1;
        -:  429:		}
        -:  430:	}
        -:  431:
        1:  432:	u64 sub_index = 0;
        -:  433:
        1:  434:	if (sub) {
        -:  435:		// there's a sub so validate it
    #####:  436:		bool valid = false;
    #####:  437:		for (u64 i = 1; i < args->subs_count; i++) {
    #####:  438:			if (!strcmp(sub, args->subs[i]->name)) {
    #####:  439:				valid = true;
    #####:  440:				if (arg_count > args->subs[i]->max_args || arg_count < args->subs[i]->min_args) {
    #####:  441:					args_exit_error(args,
        -:  442:						"Incorrect number of "
        -:  443:						"arguments for sub command '%s' "
        -:  444:						"(%i specified). "
        -:  445:						"Number of arguments must be "
        -:  446:						"between %i and %i.",
    #####:  447:						args->subs[i]->name, arg_count, args->subs[i]->min_args,
    #####:  448:						args->subs[i]->max_args);
        -:  449:				}
    #####:  450:				sub_index = i;
        -:  451:
    #####:  452:				break;
        -:  453:			}
        -:  454:		}
    #####:  455:		if (!valid) {
    #####:  456:			args_exit_error(args, "Unknown SubCommand \"%s\"", sub);
        -:  457:		}
        1:  458:	} else if (args->subs_count > 1) {
    #####:  459:		args_usage(args, NULL);
        -:  460:	} else {
        -:  461:		// check number of args
        1:  462:		if (arg_count > args->subs[0]->max_args || arg_count < args->subs[0]->min_args) {
    #####:  463:			args_exit_error(args,
        -:  464:				"Incorrect number of arguments "
        -:  465:				"(%i specified). "
        -:  466:				"Number of arguments must be "
        -:  467:				"between %i and %i.",
    #####:  468:				arg_count, args->subs[0]->min_args, args->subs[0]->max_args);
        -:  469:		}
        -:  470:	}
        -:  471:
        -:  472:	// check options
        2:  473:	for (u64 i = 1; i < argc; i++) {
        -:  474:		u64 subi;
        1:  475:		if (i <= sub_arg) {
        1:  476:			subi = 0;
        -:  477:		} else {
    #####:  478:			subi = sub_index;
        -:  479:		}
        -:  480:
        1:  481:		u64 len = strlen(argv[i]);
       1*:  482:		if (len > 0 && argv[i][0] == '-') {
        -:  483:			// option to check
    #####:  484:			char name[len];
        -:  485:			bool is_short;
    #####:  486:			bool found = false;
    #####:  487:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  488:				strcpy(name, args->argv[i] + 2);
    #####:  489:				is_short = false;
        -:  490:			} else {
    #####:  491:				strcpy(name, args->argv[i] + 1);
    #####:  492:				is_short = true;
        -:  493:			}
        -:  494:
    #####:  495:			found = args_check_option(args, subi, name, is_short, argv[i]);
    #####:  496:			if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  497:				i += 1;
        -:  498:			}
    #####:  499:			if (!found) {
    #####:  500:				if (subi == 0) {
    #####:  501:					args_exit_error(args, "Unknown option: %s", argv[i]);
        -:  502:				} else {
    #####:  503:					args_exit_error(args,
        -:  504:						"Unknown option: %s. Not valid for "
        -:  505:						"SubCommand \"%s\".",
    #####:  506:						argv[i], args->subs[subi]->name);
        -:  507:				}
        -:  508:			}
        -:  509:		}
        -:  510:	}
        1:  511:}
        -:  512:
        1:  513:int args_init(Args *args, int argc, char **argv)
        -:  514:{
        1:  515:	args->argc = argc;
        1:  516:	args->argv = mymalloc(sizeof(char *) * argc);
        -:  517:
        1:  518:	if (args->argv == NULL) {
    #####:  519:		args->argc = 0;
    #####:  520:		return -1;
        -:  521:	}
        -:  522:
        3:  523:	for (u64 i = 0; i < argc; i++) {
        2:  524:		args->argv[i] = mymalloc(sizeof(char) * (strlen(argv[i]) + 1));
        2:  525:		if (args->argv[i]) {
        2:  526:			strcpy(args->argv[i], argv[i]);
        -:  527:		} else {
    #####:  528:			for (u64 j = i - 1; j >= 0; j--) {
    #####:  529:				myfree(args->argv[j]);
        -:  530:			}
        -:  531:			myfree(args->argv);
        -:  532:			args->argc = 0;
        -:  533:			return -1;
        -:  534:		}
        -:  535:	}
        -:  536:
        2:  537:	for (u64 i = 1; i < argc; i++) {
        1:  538:		if (!strcmp(argv[i], "--version") || !strcmp(argv[i], "-V")) {
    #####:  539:			args_print_version(args);
        -:  540:		}
        1:  541:		if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
    #####:  542:			char *sub = NULL;
    #####:  543:			for (u64 j = 1; j < i; j++) {
    #####:  544:				u64 len = strlen(argv[j]);
    #####:  545:				if (len > 0) {
    #####:  546:					if (argv[j][0] != '-') {
    #####:  547:						sub = argv[j];
    #####:  548:						break;
    #####:  549:					} else {
    #####:  550:						char name[len];
        -:  551:						bool is_short;
    #####:  552:						if (len > 1 && args->argv[j][1] == '-') {
    #####:  553:							strcpy(name, args->argv[j] + 2);
    #####:  554:							is_short = false;
        -:  555:						} else {
    #####:  556:							strcpy(name, args->argv[j] + 1);
    #####:  557:							is_short = true;
        -:  558:						}
        -:  559:
    #####:  560:						u64 subi = 0;
    #####:  561:						if (sub)
    #####:  562:							subi = args_subi_for(args, sub);
        -:  563:
    #####:  564:						if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  565:							j += 1;
        -:  566:						}
        -:  567:					}
        -:  568:				}
        -:  569:			}
    #####:  570:			args_usage(args, sub);
        -:  571:		}
        -:  572:	}
        -:  573:
        1:  574:	args_check_validity(args, argc, argv);
        -:  575:
        1:  576:	return 0;
        -:  577:}
        -:  578:
    #####:  579:int args_value_of(Args *args, char *param_name, char *value_buf, u64 max_value_len, u64 index)
    #####:  580:{
    #####:  581:	if (args == NULL || param_name == NULL) {
    #####:  582:		errno = EINVAL;
    #####:  583:		return -1;
        -:  584:	}
        -:  585:
    #####:  586:	char param_name_buf[strlen(param_name) + 3];
    #####:  587:	strcpy(param_name_buf, "--");
    #####:  588:	strcat(param_name_buf, param_name);
        -:  589:
    #####:  590:	char short_name_buf[strlen(param_name) + 3];
    #####:  591:	strcpy(short_name_buf, "-");
    #####:  592:	bool found = false;
    #####:  593:	char *default_value = NULL;
    #####:  594:	bool takes_value = false;
    #####:  595:	for (u64 i = 0; i < args->subs_count; i++) {
    #####:  596:		for (u64 j = 0; j < args->subs[i]->params_count; j++) {
    #####:  597:			if (!strcmp(args->subs[i]->params[j].name, param_name)) {
    #####:  598:				found = true;
    #####:  599:				strcat(short_name_buf, args->subs[i]->params[j].short_name);
    #####:  600:				default_value = args->subs[i]->params[j].default_value;
    #####:  601:				takes_value = args->subs[i]->params[j].takes_value;
        -:  602:			}
        -:  603:		}
        -:  604:	}
        -:  605:
    #####:  606:	if (!found) {
    #####:  607:		errno = ENOENT;
    #####:  608:		return -1;
        -:  609:	}
    #####:  610:	u64 itt_index = 0;
    #####:  611:	for (u64 i = 1; i < args->argc; i++) {
    #####:  612:		if (!strcmp(args->argv[i], param_name_buf) || !strcmp(args->argv[i], short_name_buf)) {
    #####:  613:			if (itt_index == index) {
    #####:  614:				if (takes_value && i + 1 < args->argc) {
    #####:  615:					return snprintf(value_buf, max_value_len, "%s", args->argv[i + 1]);
    #####:  616:				} else if (takes_value && max_value_len > 1) {
    #####:  617:					strcpy(value_buf, "");
    #####:  618:					return 0;
        -:  619:				} else {
    #####:  620:					return 0;
        -:  621:				}
        -:  622:			} else {
    #####:  623:				itt_index += 1;
        -:  624:			}
        -:  625:		}
        -:  626:	}
        -:  627:
    #####:  628:	if (default_value != NULL && index == 0) {
    #####:  629:		return snprintf(value_buf, max_value_len, "%s", default_value);
        -:  630:	}
        -:  631:
    #####:  632:	errno = ENOENT;
    #####:  633:	return -1;
        -:  634:}
    #####:  635:int args_get_argument(Args *args, u64 index, char *value_buf, u64 max_value_len)
        -:  636:{
    #####:  637:	u64 index_itt = 0;
    #####:  638:	for (u64 i = 1; i < args->argc; i++) {
    #####:  639:		i32 len = strlen(args->argv[i]);
    #####:  640:		if (len > 1 && args->argv[i][0] == '-') {
    #####:  641:			char name[len];
        -:  642:			bool is_short;
    #####:  643:			bool found = false;
    #####:  644:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  645:				strcpy(name, args->argv[i] + 2);
    #####:  646:				is_short = false;
        -:  647:			} else {
    #####:  648:				strcpy(name, args->argv[i] + 1);
    #####:  649:				is_short = true;
        -:  650:			}
        -:  651:
    #####:  652:			for (u64 k = 0; k < args->subs_count; k++) {
    #####:  653:				for (u64 j = 0; j < args->subs[k]->params_count; j++) {
    #####:  654:					if (is_short && !strcmp(name, args->subs[k]->params[j].short_name)) {
    #####:  655:						if (args->subs[k]->params[j].takes_value) {
    #####:  656:							i += 1;
    #####:  657:							found = true;
    #####:  658:							break;
        -:  659:						}
    #####:  660:					} else if (!strcmp(name, args->subs[k]->params[j].name)) {
    #####:  661:						if (args->subs[k]->params[j].takes_value) {
    #####:  662:							i += 1;
    #####:  663:							found = true;
    #####:  664:							break;
        -:  665:						}
        -:  666:					}
        -:  667:				}
        -:  668:			}
        -:  669:		} else {
    #####:  670:			if (index_itt == index) {
    #####:  671:				snprintf(value_buf, max_value_len, "%s", args->argv[i]);
    #####:  672:				return 1;
        -:  673:			}
    #####:  674:			index_itt += 1;
        -:  675:		}
        -:  676:	}
    #####:  677:	return 0;
        -:  678:}
        -:  679:
    #####:  680:void args_print_version(Args *args)
        -:  681:{
    #####:  682:	char *prog = args->prog;
    #####:  683:	char *version = args->version;
    #####:  684:	fprintf(stderr, "%s%s%s %s%s%s\n", BRIGHT_RED, prog, RESET, CYAN, version, RESET);
    #####:  685:	exit(0);
        -:  686:}
        -:  687:
    #####:  688:void args_usage(Args *args, char *sub_command)
    #####:  689:{
    #####:  690:	bool found = false;
    #####:  691:	u64 subs_count = args->subs_count;
    #####:  692:	u64 sub_index = 0;
        -:  693:
    #####:  694:	if (sub_command) {
    #####:  695:		for (u64 i = 1; i < subs_count; i++) {
    #####:  696:			char *name = args->subs[i]->name;
    #####:  697:			if (!strcmp(name, sub_command)) {
    #####:  698:				sub_index = i;
    #####:  699:				found = true;
        -:  700:			}
        -:  701:		}
        -:  702:	} else // general help displayed
    #####:  703:		found = true;
        -:  704:
    #####:  705:	if (!found) {
    #####:  706:		args_exit_error(args, "Unknown SubCommand \"%s\"", sub_command);
        -:  707:	}
        -:  708:
    #####:  709:	SubCommand **subs = args->subs;
    #####:  710:	ArgsParam *params = args->subs[0]->params;
    #####:  711:	u64 count = args->subs[0]->params_count;
    #####:  712:	u64 max_len = 0;
    #####:  713:	for (u64 i = 0; i < count; i++) {
    #####:  714:		bool takes_value = args->subs[0]->params[i].takes_value;
    #####:  715:		bool multi = args->subs[0]->params[i].multiple;
    #####:  716:		char *name = args->subs[0]->params[i].name;
    #####:  717:		char *short_name = args->subs[0]->params[i].short_name;
        -:  718:		u64 len;
    #####:  719:		if (!takes_value)
    #####:  720:			len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
    #####:  721:		else if (multi)
    #####:  722:			len = snprintf(NULL, 0, "    -%s, --%s (<%s>, ...)", short_name, name, name);
        -:  723:		else
    #####:  724:			len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
    #####:  725:		if (len > max_len)
    #####:  726:			max_len = len;
        -:  727:	}
        -:  728:
    #####:  729:	max_len += 4;
        -:  730:
    #####:  731:	if (max_len < 17)
    #####:  732:		max_len = 17;
        -:  733:
    #####:  734:	char *prog = args->prog;
    #####:  735:	char *author = args->author;
    #####:  736:	char *version = args->version;
        -:  737:	char buffer[1025];
        -:  738:	char buffer2[1025];
        -:  739:	u64 i;
    #####:  740:	for (i = 0; i < max_len - 13 && i < 1024; i++)
    #####:  741:		buffer[i] = ' ';
    #####:  742:	buffer[i] = 0;
        -:  743:
    #####:  744:	for (i = 0; i < max_len - 16 && i < 1024; i++)
    #####:  745:		buffer2[i] = ' ';
    #####:  746:	buffer2[i] = 0;
        -:  747:	u64 sub_command_str_len;
    #####:  748:	if (sub_command)
    #####:  749:		sub_command_str_len = strlen(sub_command);
        -:  750:	else
    #####:  751:		sub_command_str_len = 0;
    #####:  752:	char sub_command_str[sub_command_str_len + 30];
    #####:  753:	char *sub_arg_doc_str = "";
    #####:  754:	if (sub_command) {
    #####:  755:		snprintf(
        -:  756:			sub_command_str, sub_command_str_len + 30, "%s%s%s", BRIGHT_RED, sub_command, RESET);
    #####:  757:		sub_arg_doc_str = args->subs[sub_index]->arg_doc;
        -:  758:	} else {
    #####:  759:		snprintf(sub_command_str, sub_command_str_len + 30, "[%sSUB_COMMAND%s]", DIMMED, RESET);
        -:  760:	}
        -:  761:
    #####:  762:	fprintf(stderr,
        -:  763:		"%s%s%s %s%s%s\n%s%s%s\n\n%sUSAGE%s:\n    %s%s%s "
        -:  764:		"[%sCORE_OPTIONS%s] %s [%sSUB_OPTIONS%s] %s\n\n"
        -:  765:		"%sCORE_FLAGS%s:\n"
        -:  766:		"    %s-h%s, %s--help%s%sPrints help information\n"
        -:  767:		"    %s-V%s, %s--version%s%sPrints version "
        -:  768:		"information\n",
        -:  769:		CYAN, prog, RESET, YELLOW, version, RESET, GREEN, author, RESET, DIMMED, RESET, BRIGHT_RED,
        -:  770:		prog, RESET, DIMMED, RESET, sub_command_str, DIMMED, RESET, sub_arg_doc_str, DIMMED, RESET,
        -:  771:		CYAN, RESET, YELLOW, RESET, buffer, CYAN, RESET, YELLOW, RESET, buffer2);
        -:  772:
    #####:  773:	for (u64 i = 0; i < count; i++) {
    #####:  774:		bool takes_value = params[i].takes_value;
    #####:  775:		if (!takes_value) {
    #####:  776:			char *name = params[i].name;
    #####:  777:			char *short_name = params[i].short_name;
    #####:  778:			char *help = params[i].help;
    #####:  779:			u64 len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
    #####:  780:			if (len > max_len)
    #####:  781:				len = max_len;
        -:  782:			u64 i;
    #####:  783:			for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  784:				buffer[i] = ' ';
    #####:  785:			buffer[i] = 0;
    #####:  786:			fprintf(stderr, "    %s-%s%s, %s--%s%s %s%s\n", CYAN, short_name, RESET, YELLOW, name,
        -:  787:				RESET, buffer, help);
        -:  788:		}
        -:  789:	}
        -:  790:
    #####:  791:	if (count) {
    #####:  792:		fprintf(stderr, "\n%sCORE_OPTIONS%s:\n", DIMMED, RESET);
        -:  793:
    #####:  794:		for (u64 i = 0; i < count; i++) {
    #####:  795:			bool takes_value = params[i].takes_value;
    #####:  796:			if (takes_value) {
    #####:  797:				char *name = params[i].name;
    #####:  798:				char *short_name = params[i].short_name;
    #####:  799:				char *help = params[i].help;
    #####:  800:				bool multi = params[i].multiple;
    #####:  801:				char *default_value = params[i].default_value;
        -:  802:				u64 default_value_str_len;
    #####:  803:				if (default_value == NULL) {
    #####:  804:					default_value_str_len = 1;
        -:  805:				} else {
    #####:  806:					default_value_str_len = strlen(default_value) + 100;
        -:  807:				}
    #####:  808:				char default_value_str[default_value_str_len];
    #####:  809:				if (default_value == NULL)
    #####:  810:					strcpy(default_value_str, "");
        -:  811:				else
    #####:  812:					snprintf(default_value_str, default_value_str_len, " (default value: '%s')",
        -:  813:						default_value);
        -:  814:
    #####:  815:				if (multi) {
    #####:  816:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>, ...", short_name, name, name);
    #####:  817:					if (len > max_len)
    #####:  818:						len = max_len;
        -:  819:					u64 i;
    #####:  820:					for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  821:						buffer[i] = ' ';
    #####:  822:					buffer[i] = 0;
    #####:  823:					fprintf(stderr,
        -:  824:						"    %s-%s%s, %s--%s%s "
        -:  825:						"<%s>, "
        -:  826:						"... %s%s%s\n",
        -:  827:						CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  828:						default_value_str);
        -:  829:				} else {
        -:  830:
    #####:  831:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
    #####:  832:					if (len > max_len)
    #####:  833:						len = max_len;
        -:  834:					u64 i;
    #####:  835:					for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  836:						buffer[i] = ' ';
    #####:  837:					buffer[i] = 0;
        -:  838:
    #####:  839:					fprintf(stderr,
        -:  840:						"    %s-%s%s, %s--%s%s "
        -:  841:						"<%s> "
        -:  842:						"%s%s%s\n",
        -:  843:						CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  844:						default_value_str);
        -:  845:				}
        -:  846:			}
        -:  847:		}
        -:  848:	}
        -:  849:
    #####:  850:	if (subs_count > 1 && sub_command == NULL) {
    #####:  851:		fprintf(stderr, "\n%sSUB_COMMANDS%s:\n", DIMMED, RESET);
    #####:  852:		for (u64 i = 1; i < subs_count; i++) {
        -:  853:
    #####:  854:			char *name = args->subs[i]->name;
    #####:  855:			char *help = args->subs[i]->help;
    #####:  856:			char *arg_doc = args->subs[i]->arg_doc;
        -:  857:
    #####:  858:			u64 len = strlen(name) + strlen(arg_doc) + 4;
    #####:  859:			if (len > max_len)
    #####:  860:				len = max_len;
        -:  861:			char buffer[1025];
        -:  862:			u64 j;
    #####:  863:			for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  864:				buffer[j] = ' ';
    #####:  865:			buffer[j] = 0;
        -:  866:
    #####:  867:			fprintf(stderr, "    %s%s%s %s%s%s\n", CYAN, name, RESET, arg_doc, buffer, help);
        -:  868:		}
        -:  869:	}
        -:  870:
    #####:  871:	if (sub_command) {
    #####:  872:		u64 param_index = 0;
    #####:  873:		for (u64 i = 1; i < subs_count; i++) {
    #####:  874:			char *name = args->subs[i]->name;
    #####:  875:			if (!strcmp(name, sub_command)) {
    #####:  876:				param_index = i;
        -:  877:			}
        -:  878:		}
        -:  879:
    #####:  880:		if (param_index > 0) {
    #####:  881:			params = args->subs[param_index]->params;
        -:  882:
    #####:  883:			count = args->subs[param_index]->params_count;
    #####:  884:			fprintf(stderr, "\n%sSUB_FLAGS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -:  885:				RESET);
        -:  886:
    #####:  887:			for (u64 i = 0; i < count; i++) {
    #####:  888:				char *name = params[i].name;
    #####:  889:				char *short_name = params[i].short_name;
    #####:  890:				bool takes_value = params[i].takes_value;
    #####:  891:				char *help = params[i].help;
        -:  892:
    #####:  893:				if (!takes_value) {
    #####:  894:					u64 len = strlen(name) + 10;
    #####:  895:					if (len > max_len)
    #####:  896:						len = max_len;
        -:  897:					char buffer[1025];
        -:  898:					u64 j;
    #####:  899:					for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  900:						buffer[j] = ' ';
    #####:  901:					buffer[j] = 0;
    #####:  902:					fprintf(stderr,
        -:  903:						"    %s-%s%s, "
        -:  904:						"%s--%s%s%s %s\n",
        -:  905:						CYAN, short_name, RESET, YELLOW, name, RESET, buffer, help);
        -:  906:				}
        -:  907:			}
    #####:  908:			fprintf(stderr, "\n%sSUB_OPTIONS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -:  909:				RESET);
    #####:  910:			for (u64 i = 0; i < count; i++) {
    #####:  911:				char *name = params[i].name;
    #####:  912:				char *short_name = params[i].short_name;
    #####:  913:				bool takes_value = params[i].takes_value;
    #####:  914:				char *help = params[i].help;
    #####:  915:				bool multiple = params[i].multiple;
        -:  916:
    #####:  917:				char *default_value = params[i].default_value;
        -:  918:				u64 default_value_str_len;
    #####:  919:				if (default_value == NULL) {
    #####:  920:					default_value_str_len = 1;
        -:  921:				} else {
    #####:  922:					default_value_str_len = strlen(default_value) + 100;
        -:  923:				}
    #####:  924:				char default_value_str[default_value_str_len];
    #####:  925:				if (default_value == NULL)
    #####:  926:					strcpy(default_value_str, "");
        -:  927:				else
    #####:  928:					snprintf(default_value_str, default_value_str_len, " (default value: %s)",
        -:  929:						default_value);
        -:  930:
    #####:  931:				if (takes_value) {
    #####:  932:					if (multiple) {
    #####:  933:						u64 len = 2 * strlen(name) + 19;
        -:  934:						char buffer[1025];
        -:  935:						u64 j;
    #####:  936:						if (len > max_len)
    #####:  937:							len = max_len;
    #####:  938:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  939:							buffer[j] = ' ';
    #####:  940:						buffer[j] = ' ';
    #####:  941:						buffer[j + 1] = 0;
    #####:  942:						fprintf(stderr,
        -:  943:							"    %s-%s%s, "
        -:  944:							"%s--%s%s "
        -:  945:							"<%s>, ...%s %s"
        -:  946:							"%s\n",
        -:  947:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  948:							default_value_str);
        -:  949:					} else {
    #####:  950:						u64 len = 2 * strlen(name) + 13;
        -:  951:						char buffer[1025];
        -:  952:						u64 j;
    #####:  953:						if (len > max_len)
    #####:  954:							len = max_len;
    #####:  955:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  956:							buffer[j] = ' ';
    #####:  957:						buffer[j] = 0;
    #####:  958:						fprintf(stderr,
        -:  959:							"    %s-%s%s, "
        -:  960:							"%s--%s%s "
        -:  961:							"<%s>%s "
        -:  962:							"%s%s\n",
        -:  963:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  964:							default_value_str);
        -:  965:					}
        -:  966:				}
        -:  967:			}
        -:  968:		}
        -:  969:	}
        -:  970:
    #####:  971:	exit(0);
        -:  972:}
        -:    0:Source:bible.c
        -:    0:Graph:bible.gcno
        -:    0:Data:bible.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <bible/bible.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:
        2:   21:int bible_checksum(char *data) {
        -:   22:	char sha[65];
        2:   23:	SHA256(data, sha);
        -:   24:
        -:   25:	// sha 256 checksum of the akjv bible from
        -:   26:	// https://github.com/bible-hub/Bibles/blob/master/English__American_King_James_Version__akjv__LTR.txt
        2:   27:	if (strcmp(sha, "9fac349223681483dd1d225cd04a298cef93f3efeb21b562469a1a"
        -:   28:					"8efa7069ff")) {
    #####:   29:		errno = EPERM;
    #####:   30:		return -1;
        -:   31:	}
        2:   32:	return 0;
        -:   33:}
        -:   34:
    62204:   35:int bible_parse_verse(Bible *bible, u64 index, char *buf) {
    62204:   36:	const char *strstr_res = strstr(buf, "|");
    62204:   37:	if (strstr_res == NULL) {
    #####:   38:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   39:		errno = EINVAL;
    #####:   40:		return -1;
        -:   41:	}
    62204:   42:	int end_book = strstr_res - buf;
    62204:   43:	if (end_book < 0) {
    #####:   44:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   45:		errno = EINVAL;
    #####:   46:		return -1;
        -:   47:	}
    62204:   48:	char bookname[end_book + 1];
    62204:   49:	memcpy(bookname, buf, end_book);
    62204:   50:	bookname[end_book] = 0;
        -:   51:
    62204:   52:	int start_chapter = end_book + 2;
    62204:   53:	const char *end_chapter_str = strstr(buf + start_chapter, "|");
    62204:   54:	if (end_chapter_str == NULL) {
    #####:   55:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   56:		errno = EINVAL;
    #####:   57:		return -1;
        -:   58:	}
    62204:   59:	int end_chapter = end_chapter_str - buf;
    62204:   60:	if (end_chapter < start_chapter) {
    #####:   61:		fprintf(stderr, "invalid line %s, index=%" PRIu64 ", end_chapter=%i,start_chap=%i\n", buf,
        -:   62:				index, end_chapter, start_chapter);
    #####:   63:		errno = EINVAL;
    #####:   64:		return -1;
        -:   65:	}
        -:   66:
    62204:   67:	char chapter[(end_chapter - start_chapter) + 1];
    62204:   68:	memcpy(chapter, buf + start_chapter, end_chapter - start_chapter);
    62204:   69:	chapter[end_chapter - start_chapter] = 0;
        -:   70:
    62204:   71:	int start_verse = end_chapter + 2;
    62204:   72:	const char *end_verse_str = strstr(buf + start_verse, "|");
    62204:   73:	if (end_verse_str == NULL) {
    #####:   74:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   75:		errno = EINVAL;
    #####:   76:		return -1;
        -:   77:	}
    62204:   78:	int end_verse = end_verse_str - buf;
        -:   79:
    62204:   80:	if (end_verse < start_verse) {
    #####:   81:		fprintf(stderr, "invalid line %s, index=%" PRIu64 ", end_chapter=%i,start_chap=%i\n", buf,
        -:   82:				index, end_verse, start_verse);
    #####:   83:		errno = EINVAL;
    #####:   84:		return -1;
        -:   85:	}
        -:   86:
    62204:   87:	char verse[(end_verse - start_verse) + 1];
    62204:   88:	memcpy(verse, buf + start_verse, end_verse - start_verse);
    62204:   89:	verse[end_verse - start_verse] = 0;
        -:   90:
    62204:   91:	int start_text = end_verse + 2;
        -:   92:
        -:   93:	int end_text;
    62204:   94:	const char *end_text_res = strstr(buf, "\n");
    62204:   95:	if (end_text_res == NULL) {
        -:   96:		// last line has no newline so just use entire line here
        2:   97:		end_text = strlen(buf);
        -:   98:	} else
    62202:   99:		end_text = end_text_res - buf;
        -:  100:
    62204:  101:	char text[(end_text - start_text) + 1];
    62204:  102:	memcpy(text, buf + start_text, end_text - start_text);
    62204:  103:	text[end_text - start_text] = 0;
        -:  104:
    62204:  105:	bible->verses[index].text = mymalloc(sizeof(char) * (end_text - start_text) + 1);
    62204:  106:	strcpy(bible->verses[index].text, text);
    62204:  107:	bible->verses[index].chapter_id = strtol(chapter, NULL, 10);
    62204:  108:	bible->verses[index].verse_id = strtol(verse, NULL, 10);
        -:  109:
        -:  110:	// find book
    62204:  111:	if (bible->book_id_count == 0) {
        -:  112:		// first book
        2:  113:		bible->book_ids = mymalloc(sizeof(BibleBookIdMap));
        2:  114:		bible->book_ids[0].book_id = 0;
        2:  115:		bible->book_ids[0].name = mymalloc(sizeof(char) * (strlen(bookname) + 1));
        2:  116:		strcpy(bible->book_ids[0].name, bookname);
        2:  117:		bible->book_id_count += 1;
        2:  118:		bible->verses[index].book_id = 0;
        -:  119:	} else {
    62202:  120:		char *cur_book = bible->book_ids[bible->book_id_count - 1].name;
        -:  121:		// check for new book
    62202:  122:		if (!strcmp(cur_book, bookname)) {
        -:  123:			// we're still in the same book
    62072:  124:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count - 1].book_id;
        -:  125:		} else {
        -:  126:			// new book, update book ids
      130:  127:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count - 1].book_id + 1;
        -:  128:			void *tmp =
      130:  129:				myrealloc(bible->book_ids, sizeof(BibleBookIdMap) * (bible->book_id_count + 1));
      130:  130:			if (!tmp)
    #####:  131:				return -1;
      130:  132:			bible->book_ids = tmp;
        -:  133:			// next higher book id
      130:  134:			bible->book_ids[bible->book_id_count].book_id =
      130:  135:				bible->book_ids[bible->book_id_count - 1].book_id + 1;
      260:  136:			bible->book_ids[bible->book_id_count].name =
      130:  137:				mymalloc(sizeof(char) * (strlen(bookname) + 1));
      130:  138:			strcpy(bible->book_ids[bible->book_id_count].name, bookname);
      130:  139:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count].book_id;
      130:  140:			bible->book_id_count += 1;
        -:  141:		}
        -:  142:	}
        -:  143:
    62204:  144:	return 0;
        -:  145:}
        -:  146:
      620:  147:int bible_book_id_map_compare(const void *a, const void *b) {
      620:  148:	return strcmp(((BibleBookIdMap *)a)->name, ((BibleBookIdMap *)b)->name);
        -:  149:}
        -:  150:
        2:  151:int bible_build(Bible *bible, char *path) {
        2:  152:	FILE *fp = myfopen(path, "r");
        2:  153:	if (fp == NULL) {
    #####:  154:		return -1;
        -:  155:	}
        -:  156:
        -:  157:	char bible_check[BIBLE_CHECKSUM_SCAN_BUF_SIZE];
        2:  158:	int len = fread(bible_check, sizeof(*bible_check), BIBLE_CHECKSUM_SCAN_BUF_SIZE, fp);
        2:  159:	bible_check[len] = 0;
        -:  160:
        2:  161:	if (bible_checksum(bible_check))
    #####:  162:		return -1;
        -:  163:
        2:  164:	fseek(fp, 0, SEEK_SET);
        -:  165:
        -:  166:	char buf[VERSE_BUF_LEN];
        -:  167:
        2:  168:	bible->verses = NULL;
        2:  169:	bible->verse_count = 0;
        2:  170:	bible->book_ids = NULL;
        2:  171:	bible->book_id_count = 0;
        -:  172:
        2:  173:	int max_len = 0;
    62216:  174:	while (fgets(buf, VERSE_BUF_LEN, fp)) {
    62214:  175:		if (strlen(buf) > max_len)
       36:  176:			max_len = strlen(buf);
    62214:  177:		if (bible->verse_count == 0) {
        2:  178:			bible->verses = mymalloc(sizeof(BibleVerse));
        2:  179:			if (bible->verses == NULL)
    #####:  180:				return -1;
        -:  181:		} else {
    62212:  182:			void *tmp = myrealloc(bible->verses, sizeof(BibleVerse) * (bible->verse_count + 1));
    62212:  183:			if (tmp == NULL)
    #####:  184:				return -1;
    62212:  185:			bible->verses = tmp;
        -:  186:		}
    62214:  187:		const char *strstr_res = strstr(buf, "|");
    62214:  188:		if (strstr_res == NULL) {
        -:  189:			// there is an empty line in the file. Skip it.
       10:  190:			continue;
        -:  191:		}
    62204:  192:		int end_book = strstr_res - buf;
    62204:  193:		if (bible_parse_verse(bible, bible->verse_count, buf))
    #####:  194:			return -1;
    62204:  195:		bible->verse_count += 1;
        -:  196:	}
        -:  197:
        -:  198:	// sort the books for quicker lookups
        2:  199:	bible->book_ids_sorted = mymalloc(sizeof(BibleVerse) * (bible->verse_count));
        2:  200:	if (bible->book_ids_sorted == NULL)
    #####:  201:		return -1;
        2:  202:	memcpy(bible->book_ids_sorted, bible->book_ids, bible->book_id_count * sizeof(BibleBookIdMap));
        2:  203:	qsort(bible->book_ids_sorted, bible->book_id_count, sizeof(BibleBookIdMap),
        -:  204:		  bible_book_id_map_compare);
        -:  205:
        2:  206:	myfclose(fp);
        2:  207:	return 0;
        -:  208:}
        -:  209:
        2:  210:void bible_cleanup(Bible *bible) {
    62206:  211:	for (int i = 0; i < bible->verse_count; i++)
    62204:  212:		myfree(bible->verses[i].text);
      134:  213:	for (int i = 0; i < bible->book_id_count; i++)
      132:  214:		myfree(bible->book_ids[i].name);
        2:  215:	myfree(bible->verses);
        2:  216:	myfree(bible->book_ids);
        2:  217:	myfree(bible->book_ids_sorted);
        2:  218:}
        -:  219:
    31102:  220:int format_verse(Bible *bible, int index, char *buf, int buf_len, bool colors) {
        -:  221:
    31102:  222:	if (colors)
    #####:  223:		return snprintf(buf, buf_len, "[%s%s%s:%s%i:%i%s] %s%s%s", GREEN,
    #####:  224:						bible->book_ids[bible->verses[index].book_id].name, RESET, CYAN,
    #####:  225:						bible->verses[index].chapter_id, bible->verses[index].verse_id, RESET,
    #####:  226:						YELLOW, bible->verses[index].text, RESET);
        -:  227:	else
    31102:  228:		return snprintf(buf, buf_len, "[%s:%i:%i] %s",
    31102:  229:						bible->book_ids[bible->verses[index].book_id].name,
    31102:  230:						bible->verses[index].chapter_id, bible->verses[index].verse_id,
    31102:  231:						bible->verses[index].text);
        -:  232:}
        -:  233:
    32350:  234:int bible_book_index(Bible *bible, char *book) {
        -:  235:	// use binary search to find the book
        -:  236:	int index;
    32350:  237:	int min = 0;
    32350:  238:	int max = bible->book_id_count - 1;
        -:  239:	int book_id;
   132081:  240:	while (true) {
   164431:  241:		if (max < min) {
    #####:  242:			errno = EINVAL;
    #####:  243:			return -1;
        -:  244:		}
   164431:  245:		index = min + ((max - min) / 2);
   164431:  246:		int strcmp_res = strcmp(book, bible->book_ids_sorted[index].name);
   164431:  247:		if (strcmp_res == 0) {
    32350:  248:			book_id = bible->book_ids_sorted[index].book_id;
    32350:  249:			break;
   132081:  250:		} else if (strcmp_res < 0) {
    65983:  251:			max = index - 1;
        -:  252:		} else {
    66098:  253:			min = index + 1;
        -:  254:		}
        -:  255:	}
    32350:  256:	return book_id;
        -:  257:}
        -:  258:
    32351:  259:int bible_verse_to_string(Bible *bible, char *book, u8 chapter, u8 verse, char *buf, int buf_len,
        -:  260:						  bool colors) {
    32351:  261:	if (book == NULL || strlen(book) == 0) {
        1:  262:		errno = EINVAL;
        1:  263:		return -1;
        -:  264:	}
    32350:  265:	return bible_random_verse_to_string(bible, buf, buf_len, colors, book, &chapter, &verse);
        -:  266:}
        -:  267:
    32350:  268:int bible_random_verse_to_string(Bible *bible, char *buf, int buf_len, bool colors,
        -:  269:								 char *optional_book, u8 *optional_chapter, u8 *optional_verse) {
        -:  270:	u16 r;
    32350:  271:	if (rand_u16(&r))
    #####:  272:		return -1;
        -:  273:
    32350:  274:	if (optional_book && strlen(optional_book) > 0) {
    32350:  275:		int book_id = bible_book_index(bible, optional_book);
    32350:  276:		if (book_id < 0)
    #####:  277:			return -1;
        -:  278:
        -:  279:		int index;
    32350:  280:		int min = 0;
    32350:  281:		int max = bible->verse_count;
        -:  282:
        -:  283:		// use binary search to find the verse
        -:  284:
        -:  285:		while (true) {
   140658:  286:			if (max < min) {
    #####:  287:				errno = EINVAL;
    #####:  288:				return -1;
        -:  289:			}
   140658:  290:			index = min + ((max - min) / 2);
   140658:  291:			if (book_id == bible->verses[index].book_id) {
    32350:  292:				min = index;
    32350:  293:				max = index;
 15912881:  294:				while (min - 1 >= 0 && bible->verses[min - 1].book_id == book_id)
 15880531:  295:					min--;
 16589666:  296:				while (max + 1 < bible->verse_count && bible->verses[max + 1].book_id == book_id)
 16557316:  297:					max++;
    32350:  298:				break;
   108308:  299:			} else if (book_id < bible->verses[index].book_id) {
    54604:  300:				max = index - 1;
        -:  301:			} else {
    53704:  302:				min = index + 1;
        -:  303:			}
        -:  304:		}
        -:  305:
    32350:  306:		if (optional_chapter) {
    32350:  307:			u8 target_chapter = *optional_chapter;
        -:  308:			while (true) {
   133500:  309:				if (max < min) {
       65:  310:					errno = EINVAL;
       65:  311:					return -1;
        -:  312:				}
   133435:  313:				index = min + ((max - min) / 2);
   133435:  314:				if (target_chapter == bible->verses[index].chapter_id) {
    32285:  315:					min = index;
    32285:  316:					max = index;
   527723:  317:					while (min - 1 >= 0 && bible->verses[min - 1].chapter_id == target_chapter &&
   495531:  318:						   bible->verses[min - 1].book_id == book_id)
   495438:  319:						min--;
    32285:  320:					while (max + 1 < bible->verse_count &&
   564609:  321:						   bible->verses[max + 1].chapter_id == target_chapter &&
   532422:  322:						   bible->verses[max + 1].book_id == book_id)
   532324:  323:						max++;
        -:  324:
    32285:  325:					if (optional_verse) {
    32285:  326:						u8 target_verse = *optional_verse;
    32285:  327:						if (target_verse > (1 + max) - min) {
     1183:  328:							errno = EINVAL;
     1183:  329:							return -1;
        -:  330:						}
    31102:  331:						min += target_verse - 1;
    31102:  332:						max = min + 2;
        -:  333:					}
    31102:  334:					break;
   101150:  335:				} else if (target_chapter < bible->verses[index].chapter_id) {
    50430:  336:					max = index - 1;
        -:  337:				} else {
    50720:  338:					min = index + 1;
        -:  339:				}
        -:  340:			}
        -:  341:		}
        -:  342:
    31102:  343:		r %= ((max - 1) - min);
    31102:  344:		r += (min);
        -:  345:	} else
    #####:  346:		r %= bible->verse_count;
    31102:  347:	return format_verse(bible, r, buf, buf_len, colors);
        -:  348:}
        -:    0:Source:proc_executor.c
        -:    0:Graph:proc_executor.gcno
        -:    0:Data:proc_executor.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/misc.h>
        -:   16:#include <sys/wait.h>
        -:   17:#include <unistd.h>
        -:   18:
    #####:   19:int execute_process(char *args[])
        -:   20:{
    #####:   21:	printf("Executing: ");
    #####:   22:	for (int i = 0; args[i]; i++) {
    #####:   23:		printf("%s ", args[i]);
        -:   24:	}
    #####:   25:	printf("\n");
        -:   26:
    #####:   27:	pid_t pid = fork();
        -:   28:
    #####:   29:	if (pid < 0) {
    #####:   30:		return -1;
    #####:   31:	} else if (pid == 0) {
    #####:   32:		execvp(args[0], args);
    #####:   33:		perror("execvp");
    #####:   34:		return -1;
        -:   35:	} else {
        -:   36:		int status;
    #####:   37:		waitpid(pid, &status, 0); // Wait for child process to finish
    #####:   38:		return status;
        -:   39:	}
        -:   40:}
        -:    0:Source:replace.c
        -:    0:Graph:replace.gcno
        -:    0:Data:replace.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <stdio.h>
        -:   17:#include <util/replace.h>
        -:   18:#include <util/trie.h>
        -:   19:
        1:   20:int replace_file(Path *in_path, Path *out_path, const char *patterns_in[],
        -:   21:	const bool is_case_sensisitive[], const char *replace[], int count)
        1:   22:{
        1:   23:	FILE *file = myfopen(path_to_string(in_path), "rb"); // Open the file in binary mode
        1:   24:	if (!file) {
    #####:   25:		perror("File opening failed");
    #####:   26:		return -1;
        -:   27:	}
        -:   28:
        -:   29:	// Move the file pointer to the end of the file to get its size
        1:   30:	fseek(file, 0, SEEK_END);
        1:   31:	long file_size = ftell(file); // Get the size of the file
        1:   32:	fseek(file, 0, SEEK_SET); // Move file pointer back to the beginning
        -:   33:
        -:   34:	// Allocate memory to store the contents (+1 for null terminator)
        1:   35:	char buffer[file_size + 1];
        -:   36:
        -:   37:	// Read the contents of the file into the buffer
        1:   38:	if (fread(buffer, 1, file_size, file) < file_size) {
    #####:   39:		perror("fread");
    #####:   40:		myfclose(file);
    #####:   41:		return -1;
        -:   42:	}
        1:   43:	buffer[file_size] = '\0'; // Null-terminate the buffer
        -:   44:
        1:   45:	myfclose(file); // Close the file
        -:   46:
        1:   47:	TrieMatch tm[count];
        1:   48:	Trie t;
        1:   49:	trie_build(&t, patterns_in, is_case_sensisitive, count);
        1:   50:	int matches = trie_match(&t, buffer, tm, count);
        -:   51:
        1:   52:	file = myfopen(path_to_string(out_path), "wb"); // Open file for writing
        1:   53:	if (!file) {
    #####:   54:		perror("File opening failed");
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        1:   58:	int itt = 0;
        -:   59:
        4:   60:	for (int i = 0; i < matches; i++) {
        3:   61:		if (tm[i].offset > itt) {
        3:   62:			int v = fwrite(buffer + itt, sizeof(char), tm[i].offset - itt, file);
        3:   63:			if (v < tm[i].offset - itt) {
    #####:   64:				perror("fwrite");
    #####:   65:				myfclose(file);
    #####:   66:				return -1;
        -:   67:			}
        3:   68:			itt = tm[i].offset;
        -:   69:		}
        3:   70:		fprintf(file, "%s", replace[tm[i].pattern_id]);
        3:   71:		itt += tm[i].len;
        -:   72:	}
        1:   73:	if (itt < file_size) {
        1:   74:		if (fwrite(buffer + itt, sizeof(char), file_size - itt, file) < file_size - itt) {
    #####:   75:			perror("fwrite");
    #####:   76:			myfclose(file);
    #####:   77:			return -1;
        -:   78:		}
        -:   79:	}
        -:   80:
        1:   81:	myfclose(file);
        -:   82:
        1:   83:	return 0;
        -:   84:}
        -:    0:Source:suffix_tree.c
        -:    0:Graph:suffix_tree.gcno
        -:    0:Data:suffix_tree.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/base.h>
        -:   16:#include <errno.h>
        -:   17:#include <string.h>
        -:   18:#include <util/suffix_tree.h>
        -:   19:
        -:   20:// The suffix pair represents the index and it's corresponding suffix. This is used to calcualte the
        -:   21:// suffix tree efficiently.
        -:   22:typedef struct SuffixPair {
        -:   23:	u64 index; // index (where does this suffix start within the text)
        -:   24:	const char *suffix; // the actual suffix
        -:   25:} SuffixPair;
        -:   26:
        -:   27:// The opaque SuffixTreeImpl
        -:   28:typedef struct SuffixTreeImpl {
        -:   29:	FatPtr suffix_array; // The array of u64 offsets
        -:   30:	FatPtr lcp_array; // The array of least common prefixes
        -:   31:	char *text; // The text for this suffix tree
        -:   32:	u64 suffix_array_len; // The length of the suffix array
        -:   33:} SuffixTreeImpl;
        -:   34:
        -:   35:// Deallocate all memory associated with the suffix tree
        1:   36:void suffix_tree_cleanup(SuffixTree *ptr)
        -:   37:{
        1:   38:	if (ptr->impl.data) {
        1:   39:		SuffixTreeImpl *si = ptr->impl.data;
        1:   40:		if (si->suffix_array.data) {
        1:   41:			chain_free(&si->suffix_array);
        -:   42:		}
        1:   43:		if (si->lcp_array.data) {
        1:   44:			chain_free(&si->lcp_array);
        -:   45:		}
        1:   46:		if (si->text) {
        1:   47:			myfree(si->text);
        1:   48:			si->text = NULL;
        -:   49:		}
        1:   50:		chain_free(&ptr->impl);
        -:   51:	}
        1:   52:}
        -:   53:
        -:   54:// Compare suffix pairs (for qsort)
      142:   55:int suffix_pair_compare(const void *p1, const void *p2)
        -:   56:{
      142:   57:	const SuffixPair *sp1 = p1;
      142:   58:	const SuffixPair *sp2 = p2;
      142:   59:	return strcmp(sp1->suffix, sp2->suffix);
        -:   60:}
        -:   61:
        -:   62:// Compare suffix matches (for qsort)
       15:   63:int suffix_match_compare(const void *s1, const void *s2)
        -:   64:{
       15:   65:	const SuffixTreeMatch *sm1 = s1;
       15:   66:	const SuffixTreeMatch *sm2 = s2;
       15:   67:	if (sm1->offset < sm2->offset)
        7:   68:		return -1;
        8:   69:	else if (sm1->offset > sm2->offset)
        8:   70:		return 1;
    #####:   71:	return 0;
        -:   72:}
        -:   73:
        -:   74:// build a suffix tree
        1:   75:int suffix_tree_build(SuffixTree *ptr, const char *text)
        1:   76:{
        -:   77:	// validate input
        1:   78:	if (text == NULL) {
    #####:   79:		errno = EINVAL;
    #####:   80:		return -1;
        -:   81:	}
        1:   82:	int text_len = strlen(text);
        1:   83:	if (text_len == 0) {
    #####:   84:		errno = EINVAL;
    #####:   85:		return -1;
        -:   86:	}
        -:   87:
        -:   88:	// allocate the needed memory for the SuffixTreeImpl
        1:   89:	if (chain_malloc(&ptr->impl, sizeof(SuffixTreeImpl))) {
    #####:   90:		return -1;
        -:   91:	}
        -:   92:
        -:   93:	// Pointer to our suffix tree impl
        1:   94:	SuffixTreeImpl *si = ptr->impl.data;
        -:   95:
        -:   96:	// allocate the suffix array
        1:   97:	if (chain_malloc(&si->suffix_array, sizeof(u64) * text_len)) {
    #####:   98:		chain_free(&ptr->impl);
    #####:   99:		return -1;
        -:  100:	}
        -:  101:
        -:  102:	// allocate the lcp array
        1:  103:	if (chain_malloc(&si->lcp_array, sizeof(u64) * text_len)) {
    #####:  104:		chain_free(&si->suffix_array);
    #####:  105:		chain_free(&ptr->impl);
    #####:  106:		return -1;
        -:  107:	}
        -:  108:
        -:  109:	// allocate the text
        1:  110:	si->text = mymalloc(sizeof(char) * text_len + 1);
        1:  111:	if (si->text == NULL) {
    #####:  112:		chain_free(&si->suffix_array);
    #####:  113:		chain_free(&si->lcp_array);
    #####:  114:		chain_free(&ptr->impl);
    #####:  115:		return -1;
        -:  116:	}
        -:  117:
        -:  118:	// create a suffix array to build our suffixes.
        1:  119:	SuffixPair arr[text_len];
        1:  120:	u64 rank[text_len];
        1:  121:	u64 *lcp_arr = si->lcp_array.data;
        -:  122:
        -:  123:	// initialize the values of the suffix array.
       37:  124:	for (u64 i = 0; i < text_len; i++) {
       36:  125:		arr[i].index = i;
       36:  126:		arr[i].suffix = (char *)(text + i);
        -:  127:	}
        -:  128:
        -:  129:	// sort them
        1:  130:	qsort(arr, text_len, sizeof(SuffixPair), suffix_pair_compare);
        -:  131:
        -:  132:	// initialize rank and lcp to 0
        1:  133:	memset(rank, 0, sizeof(u64) * text_len);
        1:  134:	memset(lcp_arr, 0, sizeof(u64) * text_len);
        -:  135:
        -:  136:	// update the data in our array and initialize 'rank' for LCP calc.
        1:  137:	u64 *suffix_arr = si->suffix_array.data;
       37:  138:	for (u64 i = 0; i < text_len; i++) {
       36:  139:		suffix_arr[i] = arr[i].index;
       36:  140:		rank[arr[i].index] = i;
        -:  141:	}
        -:  142:
        -:  143:	// calculate the LCP
        1:  144:	u64 h = 0; // Length of the common prefix
       37:  145:	for (u64 i = 0; i < text_len; i++) {
       36:  146:		u64 r = rank[i];
       36:  147:		if (r > 0) {
        -:  148:			// Previous suffix in sorted order
       35:  149:			u64 j = suffix_arr[r - 1];
        -:  150:
        -:  151:			// Compare characters
       60:  152:			while (i + h < text_len && j + h < text_len && text[i + h] == text[j + h]) {
       25:  153:				h++;
        -:  154:			}
       35:  155:			lcp_arr[r] = h; // Set LCP value
       35:  156:			if (h > 0) {
       25:  157:				h--; // Decrease h for the next suffix
        -:  158:			}
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	// copy the text and set the suffix_array_len
        1:  163:	strcpy(si->text, text);
        1:  164:	si->suffix_array_len = text_len;
        -:  165:
        1:  166:	return 0;
        -:  167:}
        -:  168:
        -:  169:// search our suffix tree for the specified pattern. Return up to limit entries in the
        -:  170:// SuffixTreeMatch.
        3:  171:int suffix_tree_search(SuffixTree *ptr, const char *pattern, SuffixTreeMatch *ret, u64 limit)
        -:  172:{
        -:  173:	// validate input
        3:  174:	if (pattern == NULL) {
    #####:  175:		errno = EINVAL;
    #####:  176:		return -1;
        -:  177:	}
        -:  178:
        3:  179:	SuffixTreeImpl *si = ptr->impl.data;
        3:  180:	if (si->suffix_array_len == 0) {
    #####:  181:		errno = EINVAL;
    #####:  182:		return -1;
        -:  183:	}
        -:  184:
        3:  185:	u64 pattern_len = strlen(pattern);
        3:  186:	if (pattern_len == 0 || limit == 0) {
    #####:  187:		errno = EINVAL;
    #####:  188:		return -1;
        -:  189:	}
        -:  190:
        -:  191:	// init other variables
        3:  192:	u64 *suffix_arr = si->suffix_array.data;
        3:  193:	u64 *lcp_arr = si->lcp_array.data;
        3:  194:	i32 min = 0;
        3:  195:	i32 max = si->suffix_array_len - 1;
        3:  196:	u64 match_index = UINT64_MAX;
        -:  197:
        -:  198:	// do a binary search to find a match
        -:  199:	loop
        7:  200:	{
        -:  201:		// take midpoint
       10:  202:		i64 mid = min + ((max - min) / 2);
        -:  203:		// compare
       10:  204:		int cmp = strncmp(pattern, si->text + suffix_arr[mid], pattern_len);
       10:  205:		if (cmp < 0) {
        -:  206:			// it's less so max must be lower
        3:  207:			max = mid - 1;
        7:  208:		} else if (cmp > 0) {
        -:  209:			// it's greater so min must be higher
        5:  210:			min = mid + 1;
        -:  211:		} else {
        -:  212:			// match found
        2:  213:			match_index = mid;
        2:  214:			break;
        -:  215:		}
        -:  216:		// can't go any further
        8:  217:		if (max < min)
        1:  218:			break;
        -:  219:	}
        -:  220:
        3:  221:	int count = 0;
        -:  222:	// If we have a match, iterate through up to limit times and set the ret[i].offset
        -:  223:	// appropriately.
        3:  224:	if (match_index != UINT64_MAX) {
        -:  225:		// populate first entry of the return array
        2:  226:		count++;
        2:  227:		ret[0].offset = suffix_arr[match_index];
        -:  228:
        -:  229:		// set direction to iterate up
        2:  230:		bool up = true;
        -:  231:		// initialize the match iterator
        2:  232:		u64 match_itt = match_index;
        -:  233:
        -:  234:		loop
        -:  235:		{
        -:  236:			// if count exceeds our limit break
       11:  237:			if (count >= limit)
    #####:  238:				break;
        -:  239:
       11:  240:			if (up) {
        -:  241:				// we are going up check lcp array upwards if it's lcp is greater than or equal to
        -:  242:				// pattern_len we know it's also a match.
        7:  243:				if (match_itt + 1 < si->suffix_array_len && lcp_arr[match_itt + 1] >= pattern_len) {
        -:  244:					// update the return array with this value
        5:  245:					ret[count].offset = suffix_arr[match_itt + 1];
        5:  246:					count++;
        5:  247:					match_itt++;
        -:  248:				} else {
        -:  249:					// it's not a match switch to downward direction and reset match index to our
        -:  250:					// original match
        2:  251:					up = false;
        2:  252:					match_itt = match_index;
        -:  253:				}
        -:  254:			} else {
        -:  255:				// we are now oriented downward check if the lcp for our current entry is greater
        -:  256:				// than pattern_len. If so we know the previous value must be a match.
        4:  257:				if (match_itt - 1 >= 0 && lcp_arr[match_itt] >= pattern_len) {
        -:  258:					// update the return array with this value
        2:  259:					ret[count].offset = suffix_arr[match_itt - 1];
        2:  260:					count++;
        2:  261:					match_itt--;
        -:  262:				} else {
        -:  263:					// it's not a match. break - no more matches.
        2:  264:					break;
        -:  265:				}
        -:  266:			}
        -:  267:		}
        -:  268:	}
        -:  269:	// return count
        3:  270:	return count;
        -:  271:}
        -:  272:
        -:  273:// sort the suffix tree using qsort
        2:  274:void suffix_tree_sort_results(SuffixTreeMatch *ret, u64 count)
        -:  275:{
        2:  276:	qsort(ret, count, sizeof(SuffixTreeMatch), suffix_match_compare);
        2:  277:}
        -:    0:Source:trie.c
        -:    0:Graph:trie.gcno
        -:    0:Data:trie.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <util/trie.h>
        -:   19:
        -:   20:typedef struct TrieNode {
        -:   21:	u32 children[256];
        -:   22:	u32 pattern_id;
        -:   23:} TrieNode;
        -:   24:
        -:   25:typedef struct TrieImpl {
        -:   26:	FatPtr memory_block;
        -:   27:	TrieNode *root;
        -:   28:	u32 cur;
        -:   29:} TrieImpl;
        -:   30:
        3:   31:void trie_cleanup(TrieNc *ptr)
        -:   32:{
        3:   33:	if (ptr->impl.data) {
        3:   34:		TrieImpl *ti = ptr->impl.data;
        3:   35:		if (ti)
        3:   36:			chain_free(&ti->memory_block);
        3:   37:		chain_free(&ptr->impl);
        -:   38:	}
        3:   39:}
        -:   40:
       34:   41:int trie_init_node(TrieNode *ptr)
        -:   42:{
       34:   43:	ptr->pattern_id = UINT32_MAX;
     8738:   44:	for (int i = 0; i < 256; i++)
     8704:   45:		ptr->children[i] = UINT32_MAX;
       34:   46:	return 0;
        -:   47:}
        -:   48:
        8:   49:int trie_insert(Trie *ptr, const char *str, bool is_case_sensitive, int pattern_id)
        -:   50:{
        8:   51:	TrieImpl *ti = ptr->impl.data;
        8:   52:	int slen = strlen(str);
        8:   53:	TrieNode *itt = ti->root;
       57:   54:	for (int i = 0; i < slen; i++) {
       49:   55:		char next = str[i];
       49:   56:		if (!is_case_sensitive) {
        5:   57:			if (next >= 'A' && next <= 'Z')
        3:   58:				next += 32;
        -:   59:		}
       49:   60:		u32 offset = itt->children[next];
       49:   61:		if (offset == UINT32_MAX) {
        -:   62:			// new node needed
       31:   63:			itt->children[next] = ti->cur;
       31:   64:			trie_init_node((TrieNode *)(ti->memory_block.data + ti->cur * sizeof(TrieNode)));
       31:   65:			offset = ti->cur;
       31:   66:			ti->cur++;
        -:   67:
        -:   68:		} else {
        -:   69:			// node exists follow it
        -:   70:		}
       49:   71:		itt = (TrieNode *)(ti->memory_block.data + offset * sizeof(TrieNode));
        -:   72:	}
        -:   73:
        8:   74:	itt->pattern_id = pattern_id;
        -:   75:
        8:   76:	return 0;
        -:   77:}
        -:   78:
        3:   79:int trie_build(Trie *ptr, const char *search_strings[], const bool is_case_sensitive[], int count)
        -:   80:{
        3:   81:	int m = 1; // 1 for root
       11:   82:	for (int i = 0; i < count; i++) {
        8:   83:		m += strlen(search_strings[i]);
        -:   84:	}
        3:   85:	if (chain_malloc(&ptr->impl, sizeof(TrieImpl)))
    #####:   86:		return -1;
        -:   87:
        3:   88:	TrieImpl *ti = ptr->impl.data;
        3:   89:	ti->cur = 1;
        -:   90:
        3:   91:	if (chain_malloc(&ti->memory_block, m * sizeof(TrieNode))) {
    #####:   92:		chain_free(&ptr->impl);
    #####:   93:		return -1;
        -:   94:	}
        3:   95:	ti->root = ti->memory_block.data;
        3:   96:	trie_init_node(ti->root);
        -:   97:
       11:   98:	for (int i = 0; i < count; i++) {
        8:   99:		if (trie_insert(ptr, search_strings[i], is_case_sensitive[i], i)) {
    #####:  100:			trie_cleanup(ptr);
    #####:  101:			return -1;
        -:  102:		}
        -:  103:	}
        -:  104:
        3:  105:	return 0;
        -:  106:}
        -:  107:
        1:  108:int trie_compare(const void *m1, const void *m2)
        -:  109:{
        1:  110:	const TrieMatch *tm1 = m1;
        1:  111:	const TrieMatch *tm2 = m2;
        1:  112:	if (tm1->offset < tm2->offset)
    #####:  113:		return -1;
        1:  114:	else if (tm1->offset > tm2->offset)
        1:  115:		return 1;
    #####:  116:	return 0;
        -:  117:}
        -:  118:
        3:  119:void trie_sort(TrieMatch ret[], u64 count)
        -:  120:{
        3:  121:	qsort(ret, count, sizeof(TrieMatch), trie_compare);
        3:  122:}
        -:  123:
        8:  124:int trie_match(Trie *ptr, const char *text, TrieMatch ret[], u64 limit)
        8:  125:{
        8:  126:	TrieMatch ci_matches[limit];
        8:  127:	int ci_match_count = 0;
        8:  128:	int match_count = 0;
        8:  129:	int tlen = strlen(text);
        8:  130:	TrieImpl *ti = ptr->impl.data;
        8:  131:	TrieNode *itt = ti->root;
        8:  132:	int match_len = 0;
      220:  133:	for (int i = 0; i < tlen; i++) {
      214:  134:		char next = text[i];
      214:  135:		u32 offset = itt->children[next];
      214:  136:		if (offset != UINT32_MAX) {
        -:  137:			// found the node
       66:  138:			itt = (TrieNode *)(ti->memory_block.data + offset * sizeof(TrieNode));
       66:  139:			if (itt->pattern_id != UINT32_MAX) {
        9:  140:				ret[match_count].pattern_id = itt->pattern_id;
        9:  141:				ret[match_count].offset = i - match_len;
        9:  142:				ret[match_count].len = match_len + 1;
        9:  143:				ci_matches[ci_match_count].pattern_id = itt->pattern_id;
        9:  144:				ci_matches[ci_match_count].offset = i - match_len;
        9:  145:				ci_match_count++;
        9:  146:				match_count++;
        -:  147:			}
       66:  148:			match_len++;
       66:  149:			if (match_count == limit)
        2:  150:				break;
        -:  151:		} else {
        -:  152:			// not found, return to root
      148:  153:			itt = ti->root;
      148:  154:			match_len = 0;
        -:  155:		}
        -:  156:	}
        -:  157:
        8:  158:	bool has_case_sensitive = false;
        8:  159:	if (match_count < limit) {
      165:  160:		for (int i = 0; i < tlen; i++) {
      159:  161:			char next = text[i];
      159:  162:			if (next >= 'A' && next <= 'Z')
       28:  163:				next += 32;
      159:  164:			u32 offset = itt->children[next];
      159:  165:			if (offset != UINT32_MAX) {
        -:  166:				// found the node
       40:  167:				itt = (TrieNode *)(ti->memory_block.data + offset * sizeof(TrieNode));
       40:  168:				if (itt->pattern_id != UINT32_MAX) {
        -:  169:
        6:  170:					bool duplicate = false;
       12:  171:					for (int j = 0; j < ci_match_count; j++) {
        6:  172:						if (ci_matches[j].pattern_id == itt->pattern_id
        3:  173:							&& ci_matches[j].offset == i - match_len) {
        3:  174:							duplicate = true;
        -:  175:						}
        -:  176:					}
        -:  177:
        6:  178:					if (!duplicate) {
        3:  179:						has_case_sensitive = true;
        3:  180:						ret[match_count].pattern_id = itt->pattern_id;
        3:  181:						ret[match_count].offset = i - match_len;
        3:  182:						ret[match_count].len = match_len + 1;
        3:  183:						match_count++;
        -:  184:					}
        -:  185:				}
       40:  186:				match_len++;
       40:  187:				if (match_count == limit)
    #####:  188:					break;
        -:  189:			} else {
        -:  190:				// not found, return to root
      119:  191:				itt = ti->root;
      119:  192:				match_len = 0;
        -:  193:			}
        -:  194:		}
        -:  195:	}
        -:  196:
        8:  197:	if (has_case_sensitive)
        3:  198:		trie_sort(ret, match_count);
        8:  199:	return match_count;
        -:  200:}
        -:    0:Source:vec.c
        -:    0:Graph:vec.gcno
        -:    0:Data:vec.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <base/resources.h>
        -:   17:#include <errno.h>
        -:   18:#include <string.h>
        -:   19:#include <util/vec.h>
        -:   20:
        -:   21:typedef struct VecImpl {
        -:   22:	void *data;
        -:   23:	u64 capacity;
        -:   24:	u64 cur;
        -:   25:	u64 size_of_entry;
        -:   26:} VecImpl;
        -:   27:
        1:   28:void vec_cleanup(Vec *p)
        -:   29:{
        1:   30:	if (p->impl.data) {
        1:   31:		VecImpl *vi = p->impl.data;
        1:   32:		if (vi->data) {
        1:   33:			myfree(vi->data);
        1:   34:			vi->data = NULL;
        -:   35:		}
        1:   36:		chain_free(&p->impl);
        -:   37:	}
        1:   38:}
        -:   39:
        1:   40:int vec_init(Vec *p, u64 initial_capacity, u64 size_of_entry)
        -:   41:{
        1:   42:	if (chain_malloc(&p->impl, sizeof(VecImpl))) {
    #####:   43:		return -1;
        -:   44:	}
        -:   45:
        1:   46:	VecImpl *vi = p->impl.data;
        1:   47:	if (initial_capacity) {
        1:   48:		vi->data = mymalloc(size_of_entry * initial_capacity);
        1:   49:		if (p->impl.data == NULL) {
    #####:   50:			chain_free(&p->impl);
    #####:   51:			return -1;
        -:   52:		}
        -:   53:	}
        -:   54:
        1:   55:	vi->cur = 0;
        1:   56:	vi->capacity = initial_capacity;
        1:   57:	vi->size_of_entry = size_of_entry;
        -:   58:
        1:   59:	return 0;
        -:   60:}
       10:   61:int vec_push(Vec *p, void *entry)
        -:   62:{
       10:   63:	VecImpl *vi = p->impl.data;
       10:   64:	if (vi->cur >= vi->capacity) {
        1:   65:		if (vec_resize(p, vi->capacity + 10)) {
    #####:   66:			return -1;
        -:   67:		}
        -:   68:	}
        -:   69:
       10:   70:	memcpy(vi->data + (vi->cur * vi->size_of_entry), entry, vi->size_of_entry);
       10:   71:	vi->cur++;
       10:   72:	return 0;
        -:   73:}
       19:   74:void *vec_element_at(const Vec *p, u64 index)
        -:   75:{
       19:   76:	VecImpl *vi = p->impl.data;
       19:   77:	if (index >= vi->cur)
    #####:   78:		return NULL;
       19:   79:	return vi->data + (index * vi->size_of_entry);
        -:   80:}
        1:   81:int vec_remove(Vec *p, u64 index)
        -:   82:{
        1:   83:	VecImpl *vi = p->impl.data;
        1:   84:	char *arr = (char *)vi->data;
        1:   85:	if (index >= vi->cur) {
    #####:   86:		errno = EOVERFLOW;
    #####:   87:		return -1;
        -:   88:	}
        1:   89:	char *start = arr + index * vi->size_of_entry;
        1:   90:	u64 bytes_to_move = (vi->cur - index - 1) * vi->size_of_entry;
        1:   91:	if (bytes_to_move > 0) {
        1:   92:		memmove(start, start + vi->size_of_entry, bytes_to_move);
        -:   93:	}
        1:   94:	vi->cur--;
        -:   95:
        1:   96:	return 0;
        -:   97:}
        1:   98:void *vec_pop(Vec *p)
        -:   99:{
        1:  100:	VecImpl *vi = p->impl.data;
        1:  101:	if (vi->cur == 0)
    #####:  102:		return NULL;
        1:  103:	void *ret = vec_element_at(p, vi->cur - 1);
        1:  104:	vi->cur--;
        1:  105:	return ret;
        -:  106:}
        1:  107:int vec_resize(Vec *p, u64 new_size)
        -:  108:{
        1:  109:	VecImpl *vi = p->impl.data;
        1:  110:	if (new_size < vi->cur)
    #####:  111:		new_size = vi->cur;
       1*:  112:	if (vi->data == NULL && new_size != 0) {
    #####:  113:		vi->data = mymalloc(new_size * vi->size_of_entry);
    #####:  114:		if (vi->data == NULL)
    #####:  115:			return -1;
        -:  116:	} else {
        1:  117:		void *tmp = myrealloc(vi->data, new_size * vi->size_of_entry);
        1:  118:		if (tmp == NULL)
    #####:  119:			return -1;
        1:  120:		vi->data = tmp;
        -:  121:	}
        1:  122:	vi->capacity = new_size;
        -:  123:
        1:  124:	return 0;
        -:  125:}
    #####:  126:int vec_truncate(Vec *p, u64 new_size)
        -:  127:{
    #####:  128:	VecImpl *vi = p->impl.data;
    #####:  129:	if (new_size == 0) {
    #####:  130:		myfree(vi->data);
    #####:  131:		vi->data = NULL;
        -:  132:	} else {
    #####:  133:		void *tmp = myrealloc(vi->data, new_size * vi->size_of_entry);
    #####:  134:		if (tmp == NULL)
    #####:  135:			return -1;
    #####:  136:		vi->data = tmp;
        -:  137:	}
    #####:  138:	vi->capacity = new_size;
    #####:  139:	return 0;
        -:  140:}
    #####:  141:int vec_clear(Vec *p)
        -:  142:{
    #####:  143:	VecImpl *vi = p->impl.data;
    #####:  144:	vi->cur = 0;
    #####:  145:	return 0;
        -:  146:}
        -:  147:
        4:  148:u64 vec_size(const Vec *p)
        -:  149:{
        4:  150:	VecImpl *vi = p->impl.data;
        4:  151:	return vi->cur;
        -:  152:}
        -:  153:
        4:  154:u64 vec_capacity(const Vec *p)
        -:  155:{
        4:  156:	VecImpl *vi = p->impl.data;
        4:  157:	return vi->capacity;
        -:  158:}
        -:    0:Source:lexer.c
        -:    0:Graph:lexer.gcno
        -:    0:Data:lexer.gcda
        -:    0:Runs:15
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/resources.h>
        -:   17:#include <errno.h>
        -:   18:#include <lexer/lexer.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:
      297:   22:char *lexer_read_line(Lexer *l)
        -:   23:{
      297:   24:	char *ret = NULL;
      297:   25:	u64 count = 0;
        2:   26:	while (true) {
      299:   27:		if (ret == NULL) {
      297:   28:			ret = mymalloc(sizeof(char) * LEXER_BUF_SIZE);
      297:   29:			strcpy(ret, "");
        -:   30:		} else {
        2:   31:			char *tmp = myrealloc(ret, sizeof(char) * LEXER_BUF_SIZE * (1 + count));
        2:   32:			if (tmp == NULL) {
    #####:   33:				myfree(ret);
    #####:   34:				return NULL;
        -:   35:			}
        2:   36:			ret = tmp;
        -:   37:		}
      299:   38:		u64 str_len = strlen(ret);
      299:   39:		if (fgets(ret + str_len, LEXER_BUF_SIZE, l->fp) == NULL) {
        5:   40:			myfree(ret);
        5:   41:			return NULL;
        -:   42:		}
        -:   43:
      294:   44:		count += 1;
      294:   45:		str_len = strlen(ret);
      294:   46:		if (str_len >= (count * (LEXER_BUF_SIZE - 1)))
        2:   47:			continue;
        -:   48:
      292:   49:		return ret;
        -:   50:	}
        -:   51:}
        -:   52:
        5:   53:int lexer_init(Lexer *l, char *file)
        -:   54:{
        -:   55:	// file/lexer cannot be null
        5:   56:	if (file == NULL || l == NULL) {
    #####:   57:		errno = EINVAL;
    #####:   58:		return LexerStateErr;
        -:   59:	}
        -:   60:
        5:   61:	l->fp = NULL;
        5:   62:	l->tokenizer = NULL;
        5:   63:	l->line_num = 1;
        5:   64:	l->file = mymalloc(sizeof(char) * (strlen(file) + 1));
        5:   65:	if (l->file == NULL) {
    #####:   66:		lexer_cleanup(l);
    #####:   67:		return -1;
        -:   68:	}
        5:   69:	strcpy(l->file, file);
        -:   70:
        -:   71:	// open the file for reading
        5:   72:	l->fp = myfopen(file, "r");
        -:   73:
        -:   74:	// if file cannot be read return error
        5:   75:	if (l->fp == NULL) {
    #####:   76:		return LexerStateErr;
        -:   77:	}
        -:   78:
        -:   79:	// allocate memory for the tokenizer
        5:   80:	l->tokenizer = mymalloc(sizeof(Tokenizer));
        -:   81:
        5:   82:	if (l->tokenizer == NULL) {
        -:   83:		// memory allocation err
    #####:   84:		lexer_cleanup(l);
    #####:   85:		return LexerStateErr;
        -:   86:	}
        -:   87:
        5:   88:	char *buf = lexer_read_line(l);
        5:   89:	if (buf == NULL) {
    #####:   90:		lexer_cleanup(l);
    #####:   91:		return LexerStateErr;
        -:   92:	}
        -:   93:
        -:   94:	// try to init the tokenizer
        5:   95:	if (tokenizer_init(l->tokenizer, buf) != TokenizerStateOk) {
    #####:   96:		lexer_cleanup(l);
    #####:   97:		myfree(buf);
    #####:   98:		return LexerStateErr;
        -:   99:	} else {
        5:  100:		myfree(buf);
        5:  101:		return LexerStateOk;
        -:  102:	}
        -:  103:}
        -:  104:
      959:  105:int lexer_next_token(Lexer *l, Token *token)
        -:  106:{
        -:  107:	// read the next token
      959:  108:	int state = tokenizer_next_token(l->tokenizer, token);
      959:  109:	char *line = NULL;
      959:  110:	token->span = NULL;
        -:  111:
        -:  112:	// if we're complete keep trying to get more lines until we have a token
        -:  113:	// or we're at the end of file
     1246:  114:	while (state == TokenizerStateComplete || state == TokenizerStateCompleteInComment) {
        -:  115:		// cleanup the previous tokenizer
      292:  116:		tokenizer_cleanup(l->tokenizer);
        -:  117:
      292:  118:		char *buf = lexer_read_line(l);
        -:  119:
      292:  120:		if (buf == NULL) {
        5:  121:			if (line)
        1:  122:				myfree(line);
        5:  123:			if (state == TokenizerStateCompleteInComment)
    #####:  124:				return LexerStateErr;
        -:  125:			else
        5:  126:				return LexerStateComplete;
        -:  127:		}
        -:  128:
      287:  129:		l->line_num += 1;
        -:  130:
        -:  131:		// try to init again
      287:  132:		if (tokenizer_init(l->tokenizer, buf) != TokenizerStateOk) {
    #####:  133:			myfree(buf);
    #####:  134:			if (line) {
    #####:  135:				myfree(line);
        -:  136:			}
    #####:  137:			return LexerStateErr;
        -:  138:		}
        -:  139:
      287:  140:		state = tokenizer_next_token(l->tokenizer, token);
      287:  141:		if (line)
       89:  142:			myfree(line);
      287:  143:		line = mymalloc(sizeof(char) * (1 + strlen(buf)));
      287:  144:		strcpy(line, buf);
      287:  145:		myfree(buf);
        -:  146:	}
        -:  147:
      954:  148:	if (line == NULL) {
      757:  149:		line = mymalloc((strlen(l->tokenizer->s) + 1) * sizeof(char));
      757:  150:		strcpy(line, l->tokenizer->s);
        -:  151:	}
        -:  152:
      954:  153:	if (state == TokenizerStateOk) {
      954:  154:		token->line_num = l->line_num;
      954:  155:		if (line == NULL)
    #####:  156:			token->span = NULL;
      954:  157:		else {
      954:  158:			int num_width = snprintf(NULL, 0, "%" PRIu64, l->line_num);
      954:  159:			int token_width = snprintf(NULL, 0, "%s", token->token);
        -:  160:			char spacer[100];
      954:  161:			int lsl = (l->tokenizer->pos + 1) - (token_width - 1);
      954:  162:			if (lsl <= 0)
    #####:  163:				lsl = 1;
      954:  164:			char long_spacer[lsl];
      954:  165:			bool has_tab = false;
    39723:  166:			for (int i = 0; i < lsl; i++) {
    38769:  167:				if (i < l->tokenizer->pos && l->tokenizer->s[i] == '\t') {
     1419:  168:					has_tab = true;
     1419:  169:					long_spacer[i] = '\t';
        -:  170:				} else {
    37350:  171:					long_spacer[i] = ' ';
        -:  172:				}
        -:  173:			}
      954:  174:			if (has_tab)
      796:  175:				long_spacer[lsl - 2] = 0;
      954:  176:			long_spacer[lsl - 1] = 0;
     3393:  177:			for (int i = 0; i < num_width && i < 100; i++) {
     2439:  178:				spacer[i] = ' ';
        -:  179:			}
      954:  180:			if (num_width < 100)
      954:  181:				spacer[num_width] = 0;
        -:  182:
      954:  183:			int span_len = snprintf(NULL, 0,
        -:  184:				"%s%s-->%s %s:%" PRIu64 ":%i\n%s %s|\n%" PRIu64 " | %s%s"
        -:  185:				"%s %s|%s%s^\n",
        -:  186:				spacer, CYAN, RESET, l->file, l->line_num, lsl, spacer, CYAN, l->line_num, RESET,
        -:  187:				line, spacer, CYAN, RESET, long_spacer);
      954:  188:			token->span = mymalloc((span_len + 1) * sizeof(char));
      954:  189:			if (token->span == NULL) {
    #####:  190:				myfree(line);
    #####:  191:				return LexerStateErr;
        -:  192:			}
      954:  193:			snprintf(token->span, span_len + 1,
        -:  194:				"%s%s-->%s %s:%" PRIu64 ":%i\n%s %s|\n%" PRIu64 " | %s%s"
        -:  195:				"%s %s|%s%s^\n",
        -:  196:				spacer, CYAN, RESET, l->file, l->line_num, lsl, spacer, CYAN, l->line_num, RESET,
        -:  197:				line, spacer, CYAN, RESET, long_spacer);
      954:  198:			myfree(line);
        -:  199:		}
        -:  200:
      954:  201:		return LexerStateOk;
        -:  202:	} else {
    #####:  203:		if (line)
    #####:  204:			myfree(line);
    #####:  205:		return LexerStateErr;
        -:  206:	}
        -:  207:}
        -:  208:
        5:  209:void lexer_cleanup(Lexer *l)
        -:  210:{
        -:  211:	// check if fp is NULL and close it then set to NULL so this can be
        -:  212:	// called multiple times
        5:  213:	if (l->fp != NULL) {
        5:  214:		myfclose(l->fp);
        5:  215:		l->fp = NULL;
        -:  216:	}
        -:  217:
        -:  218:	// same for the tokenizer
        5:  219:	if (l->tokenizer != NULL) {
        5:  220:		tokenizer_cleanup(l->tokenizer);
        5:  221:		myfree(l->tokenizer);
        -:  222:	}
        -:  223:
        -:  224:	// same for file
        5:  225:	if (l->file != NULL) {
        5:  226:		myfree(l->file);
        5:  227:		l->file = NULL;
        -:  228:	}
        5:  229:}
        -:    0:Source:tokenizer.c
        -:    0:Graph:tokenizer.gcno
        -:    0:Data:tokenizer.gcda
        -:    0:Runs:15
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/resources.h>
        -:   17:#include <errno.h>
        -:   18:#include <lexer/tokenizer.h>
        -:   19:#include <string.h>
        -:   20:
      315:   21:int tokenizer_init(Tokenizer *t, char *line)
        -:   22:{
        -:   23:	// check input
      315:   24:	if (line == NULL || t == NULL) {
    #####:   25:		errno = EINVAL;
    #####:   26:		return TokenizerStateErr;
        -:   27:	}
        -:   28:
        -:   29:	// copy the input string
      315:   30:	t->len = strlen(line);
      315:   31:	t->s = mymalloc(sizeof(char) * (1 + t->len));
      315:   32:	if (t->s == NULL) {
    #####:   33:		return TokenizerStateErr;
        -:   34:	}
      315:   35:	strcpy(t->s, line);
        -:   36:
        -:   37:	// set pos to 0
      315:   38:	t->pos = 0;
        -:   39:
      315:   40:	t->in_comment = false;
        -:   41:
      315:   42:	return TokenizerStateOk;
        -:   43:}
        -:   44:
     2500:   45:bool tokenizer_is_white_space(Tokenizer *t)
        -:   46:{
     2500:   47:	char ch = t->s[t->pos];
        -:   48:	// check for std whitespace chars
     2500:   49:	if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\v' || ch == '\f' || ch == '\r')
     1225:   50:		return true;
     1275:   51:	return false;
        -:   52:}
        -:   53:
     1481:   54:int tokenizer_skip_comments(Tokenizer *t, Token *next)
        -:   55:{
     1481:   56:	if (t->pos + 1 >= t->len)
      312:   57:		return TokenizerStateOk;
        -:   58:
     1169:   59:	char ch1 = t->s[t->pos];
     1169:   60:	char ch2 = t->s[t->pos + 1];
     1169:   61:	bool is_doc_comment = false;
        -:   62:
     1261:   63:	if (ch1 == '/' && ch2 == '/') {
       92:   64:		u64 start_doc = t->pos;
       92:   65:		if (t->pos + 2 < t->len) {
        -:   66:			// check if we're in a doc comment
       91:   67:			if (t->s[t->pos + 2] == '/') {
        -:   68:				// in doc comment
       13:   69:				is_doc_comment = true;
       13:   70:				t->pos = t->pos + 3;
       13:   71:				start_doc = t->pos;
        -:   72:			}
        -:   73:		}
        -:   74:
       92:   75:		bool found_start = false;
        -:   76:
        -:   77:		while (true) {
     3861:   78:			if (t->pos >= t->len || t->s[t->pos] == '\n')
        -:   79:				break;
        -:   80:
     3769:   81:			if (!found_start && tokenizer_is_white_space(t)) {
       23:   82:				start_doc = t->pos + 1;
        -:   83:			} else {
     3746:   84:				found_start = true;
        -:   85:			}
     3769:   86:			t->pos += 1;
        -:   87:		}
        -:   88:
       92:   89:		if (is_doc_comment) {
       13:   90:			next->type = TokenTypeDoc;
       13:   91:			u64 end_doc = t->pos;
       13:   92:			if (end_doc < start_doc)
    #####:   93:				end_doc = start_doc;
       13:   94:			u64 doc_size = end_doc - start_doc;
       13:   95:			next->token = mymalloc(sizeof(char) * (doc_size + 1));
       13:   96:			memcpy(next->token, t->s + start_doc, doc_size);
       13:   97:			next->token[doc_size] = 0;
        -:   98:		}
        -:   99:
     1077:  100:	} else if (ch1 == '/' && ch2 == '*') {
       12:  101:		t->in_comment = true;
       12:  102:		t->pos += 1;
        -:  103:		while (true) {
      172:  104:			if (t->pos >= t->len || (t->s[t->pos - 1] == '*' && t->s[t->pos] == '/')) {
       12:  105:				if (t->pos < t->len) {
       11:  106:					t->in_comment = false;
       11:  107:					t->pos += 1;
        -:  108:				}
        -:  109:
       16:  110:				while (t->pos < t->len) {
       12:  111:					if (!tokenizer_is_white_space(t))
        8:  112:						break;
        4:  113:					t->pos += 1;
        -:  114:				}
       12:  115:				break;
        -:  116:			}
      160:  117:			t->pos += 1;
        -:  118:		}
        -:  119:	}
        -:  120:
     1169:  121:	return TokenizerStateOk;
        -:  122:}
        -:  123:
     2679:  124:int tokenizer_skip_white_space(Tokenizer *t, Token *next)
        -:  125:{
        -:  126:	while (true) {
        -:  127:		// if we're at the end of the string or not in white space break
     2679:  128:		if (t->pos >= t->len || !tokenizer_is_white_space(t))
        -:  129:			break;
        -:  130:
     1198:  131:		t->pos += 1;
        -:  132:	}
        -:  133:
     1481:  134:	return TokenizerStateOk;
        -:  135:}
        -:  136:
     1481:  137:int tokenizer_skip_to_token(Tokenizer *t, Token *next)
        -:  138:{
        -:  139:	while (true) {
     1481:  140:		tokenizer_skip_white_space(t, next);
     1481:  141:		tokenizer_skip_comments(t, next);
        -:  142:
     1481:  143:		if (t->pos >= t->len || (t->s[t->pos] != '\n' && t->s[t->pos] != '/')
       89:  144:			|| next->type == TokenTypeDoc)
        -:  145:			break;
        -:  146:	}
        -:  147:
     1404:  148:	if (t->pos >= t->len && next->type != TokenTypeDoc) {
      315:  149:		if (t->in_comment)
        1:  150:			return TokenizerStateCompleteInComment;
      314:  151:		return TokenizerStateComplete;
        -:  152:	}
        -:  153:
     1089:  154:	return TokenizerStateOk;
        -:  155:}
        -:  156:
      413:  157:int tokenizer_proc_ident(Tokenizer *t, Token *next)
        -:  158:{
      413:  159:	next->type = TokenTypeIdent;
      413:  160:	u64 start = t->pos;
     3587:  161:	while (true) {
        -:  162:		// if we're at the end of the string, break
     4000:  163:		if (t->pos >= t->len)
        3:  164:			break;
        -:  165:
     3997:  166:		char ch = t->s[t->pos];
        -:  167:
        -:  168:		// continue until non-ident char
     3997:  169:		if (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_'
     2427:  170:				|| (ch >= '0' && ch <= '9'))) {
        -:  171:			break;
        -:  172:		}
     3587:  173:		t->pos += 1;
        -:  174:	}
      413:  175:	u64 end = t->pos;
      413:  176:	u64 tlen = end - start;
        -:  177:
        -:  178:	// allocate and copy over the token
      413:  179:	next->token = mymalloc(sizeof(char) * (tlen + 1));
      413:  180:	if (next->token == NULL)
    #####:  181:		return TokenizerStateErr;
      413:  182:	memcpy(next->token, t->s + start, tlen);
      413:  183:	next->token[tlen] = 0;
        -:  184:
      413:  185:	return TokenizerStateOk;
        -:  186:}
        -:  187:
       12:  188:int tokenizer_proc_string_literal(Tokenizer *t, Token *next)
        -:  189:{
       12:  190:	next->type = TokenTypeLiteral;
       12:  191:	u64 start = t->pos;
       97:  192:	while (true) {
        -:  193:		// if we're at the end of the string, break
      109:  194:		if (t->pos >= t->len)
    #####:  195:			break;
        -:  196:
      109:  197:		char ch = t->s[t->pos];
        -:  198:
        -:  199:		// continue until literal termination char
      109:  200:		if (ch == '\"' && t->pos != start) {
       12:  201:			t->pos += 1;
       12:  202:			break;
        -:  203:		}
       97:  204:		t->pos += 1;
        -:  205:	}
       12:  206:	u64 end = t->pos;
       12:  207:	u64 tlen = end - start;
        -:  208:
        -:  209:	// allocate and copy over the token
       12:  210:	next->token = mymalloc(sizeof(char) * (tlen + 1));
       12:  211:	if (next->token == NULL)
    #####:  212:		return TokenizerStateErr;
       12:  213:	memcpy(next->token, t->s + start, tlen);
       12:  214:	next->token[tlen] = 0;
        -:  215:
       12:  216:	return TokenizerStateOk;
        -:  217:}
        -:  218:
        1:  219:int tokenizer_proc_char_literal(Tokenizer *t, Token *next)
        -:  220:{
        1:  221:	next->type = TokenTypeLiteral;
        1:  222:	u64 start = t->pos;
        2:  223:	while (true) {
        -:  224:		// if we're at the end of the string, break
        3:  225:		if (t->pos >= t->len)
    #####:  226:			break;
        -:  227:
        3:  228:		char ch = t->s[t->pos];
        -:  229:
        -:  230:		// continue until literal termination char
        3:  231:		if (ch == '\'' && t->pos != start) {
        1:  232:			t->pos += 1;
        1:  233:			break;
        -:  234:		}
        2:  235:		t->pos += 1;
        -:  236:	}
        1:  237:	u64 end = t->pos;
        1:  238:	u64 tlen = end - start;
        -:  239:
        -:  240:	// allocate and copy over the token
        1:  241:	next->token = mymalloc(sizeof(char) * (tlen + 1));
        1:  242:	if (next->token == NULL)
    #####:  243:		return TokenizerStateErr;
        1:  244:	memcpy(next->token, t->s + start, tlen);
        1:  245:	next->token[tlen] = 0;
        -:  246:
        1:  247:	return TokenizerStateOk;
        -:  248:}
        -:  249:
       75:  250:int tokenizer_proc_num_literal(Tokenizer *t, Token *next)
        -:  251:{
       75:  252:	int ret = TokenizerStateOk;
       75:  253:	next->type = TokenTypeLiteral;
       75:  254:	u64 start = t->pos;
      194:  255:	while (true) {
        -:  256:		// if we're at the end of the string, break
      269:  257:		if (t->pos >= t->len)
        4:  258:			break;
        -:  259:
      265:  260:		char ch = t->s[t->pos];
        -:  261:
        -:  262:		// continue until literal termination char (we allow all
        -:  263:		// chars needed for the various types at the tokenizer
        -:  264:		// level. Checking the order, etc is done at a later
        -:  265:		// phase)
      265:  266:		if (t->pos == start) {
       75:  267:			if (!(ch == '-' || (ch >= '0' && ch <= '9')))
        -:  268:				break;
      263:  269:		} else if (!((ch >= '0' && ch <= '9') || ch == '.' || ch == '_' || ch == 'u' || ch == 'i'
       82:  270:					   || ch == 's' || ch == 'z' || ch == 'e' || ch == 'f' || ch == 'x'))
       71:  271:			break;
      194:  272:		t->pos += 1;
        -:  273:	}
       75:  274:	u64 end = t->pos;
       75:  275:	u64 tlen = end - start;
        -:  276:
        -:  277:	// special case of lone minus sign is a punct, not a literal
       75:  278:	if (tlen == 1 && t->s[start] == '-') {
       20:  279:		next->type = TokenTypePunct;
        -:  280:		// we also must deal with these: -= and ->
       20:  281:		if (t->pos < t->len) {
       20:  282:			if (t->s[t->pos] == '=' || t->s[t->pos] == '>') {
       18:  283:				t->pos += 1;
       18:  284:				end = t->pos;
       18:  285:				tlen = end - start;
        -:  286:			}
        -:  287:		}
        -:  288:	}
        -:  289:
        -:  290:	// allocate and copy over the token
       75:  291:	next->token = mymalloc(sizeof(char) * (tlen + 1));
       75:  292:	if (next->token == NULL)
    #####:  293:		return TokenizerStateErr;
       75:  294:	memcpy(next->token, t->s + start, tlen);
       75:  295:	next->token[tlen] = 0;
        -:  296:
       75:  297:	return ret;
        -:  298:}
        -:  299:
      570:  300:bool is_second_punct(char ch1, char ch2)
        -:  301:{
      570:  302:	if (ch1 == '!' && ch2 == '=')
        2:  303:		return true;
     568*:  304:	if (ch1 == '%' && ch2 == '%')
    #####:  305:		return true;
      568:  306:	if (ch1 == '&' && (ch2 == '&' || ch2 == '='))
    #####:  307:		return true;
      568:  308:	if (ch1 == '*' && ch2 == '=')
    #####:  309:		return true;
      568:  310:	if (ch1 == '+' && ch2 == '=')
        2:  311:		return true;
     566*:  312:	if (ch1 == '-' && (ch2 == '=' || ch2 == '>'))
    #####:  313:		return true;
     566*:  314:	if (ch1 == '/' && ch2 == '=')
    #####:  315:		return true;
     566*:  316:	if (ch1 == '^' && ch2 == '=')
    #####:  317:		return true;
      566:  318:	if (ch1 == '|' && (ch2 == '=' || ch2 == '|'))
    #####:  319:		return true;
      566:  320:	if (ch1 == '=' && (ch2 == '>' || ch2 == '='))
        6:  321:		return true;
      560:  322:	if (ch1 == ':' && ch2 == ':')
       17:  323:		return true;
      543:  324:	if (ch1 == '<' && (ch2 == '<' || ch2 == '=' || ch2 == '-'))
    #####:  325:		return true;
      543:  326:	if (ch1 == '>' && (ch2 == '>' || ch2 == '='))
    #####:  327:		return true;
      543:  328:	if (ch1 == '.' && ch2 == '.')
    #####:  329:		return true;
        -:  330:
      543:  331:	return false;
        -:  332:}
    #####:  333:bool is_third_punct(char ch1, char ch2, char ch3)
        -:  334:{
    #####:  335:	if (ch1 == '<' && ch2 == '<' && ch3 == '=')
    #####:  336:		return true;
    #####:  337:	if (ch1 == '>' && ch2 == '>' && ch3 == '=')
    #####:  338:		return true;
    #####:  339:	if (ch1 == '.' && ch2 == '.' && ch3 == '.')
    #####:  340:		return true;
    #####:  341:	if (ch1 == '.' && ch2 == '.' && ch3 == '=')
    #####:  342:		return true;
    #####:  343:	return false;
        -:  344:}
        -:  345:
      575:  346:int tokenizer_proc_punct(Tokenizer *t, Token *next)
        -:  347:{
      575:  348:	next->type = TokenTypePunct;
        -:  349:
      575:  350:	char ch1 = t->s[t->pos];
      575:  351:	char ch2 = t->pos + 1 < t->len && is_second_punct(ch1, t->s[t->pos + 1]) ? t->s[t->pos + 1] : 0;
     575*:  352:	char ch3 = t->pos + 2 < t->len && ch3 != 0 && is_third_punct(ch1, ch2, t->s[t->pos + 2])
    #####:  353:		? t->s[t->pos + 2]
        -:  354:		: 0;
        -:  355:
        -:  356:	// allocate and copy over the token
      575:  357:	next->token = mymalloc(sizeof(char) * 5);
      575:  358:	if (next->token == NULL)
    #####:  359:		return TokenizerStateErr;
        -:  360:
      575:  361:	next->token[0] = ch1;
      575:  362:	next->token[1] = ch2;
      575:  363:	next->token[2] = ch3;
      575:  364:	next->token[4] = 0;
        -:  365:
      575:  366:	t->pos += 1;
      575:  367:	if (ch2 != 0)
       27:  368:		t->pos += 1;
     575*:  369:	if (ch3 != 0 && ch2 != 0)
    #####:  370:		t->pos += 1;
        -:  371:
      575:  372:	return TokenizerStateOk;
        -:  373:}
        -:  374:
     1404:  375:int tokenizer_next_token(Tokenizer *t, Token *next)
        -:  376:{
     1404:  377:	next->span = NULL;
     1404:  378:	next->type = TokenTypeIdent; // init so that we know when it's been set to doc
        -:  379:	// first skip all whitespace / comments
     1404:  380:	int skip = tokenizer_skip_to_token(t, next);
     1404:  381:	if (skip != TokenizerStateOk || next->type == TokenTypeDoc)
      328:  382:		return skip;
        -:  383:
        -:  384:	// check first char to determine which type of token we're in
     1076:  385:	char first = t->s[t->pos];
     1076:  386:	if ((first >= 'a' && first <= 'z') || (first >= 'A' && first <= 'Z') || first == '_') {
        -:  387:		// ident
      413:  388:		int ret = tokenizer_proc_ident(t, next);
        -:  389:
        -:  390:		// special cases
      413:  391:		if (ret == TokenizerStateOk
      413:  392:			&& (!strcmp(next->token, "true") || !strcmp(next->token, "false"))) {
        3:  393:			next->type = TokenTypeLiteral;
        -:  394:		}
      413:  395:		return ret;
      663:  396:	} else if (first == '\"') {
        -:  397:		// string literal
       12:  398:		return tokenizer_proc_string_literal(t, next);
      651:  399:	} else if (first == '\'') {
        -:  400:		// char literal
        1:  401:		return tokenizer_proc_char_literal(t, next);
      650:  402:	} else if ((first >= '0' && first <= '9') || first == '-') {
        -:  403:		// number literal
       75:  404:		return tokenizer_proc_num_literal(t, next);
        -:  405:	} else {
        -:  406:		// punct or error
      575:  407:		return tokenizer_proc_punct(t, next);
        -:  408:	}
        -:  409:}
        -:  410:
      320:  411:void tokenizer_cleanup(Tokenizer *t)
        -:  412:{
        -:  413:	// check if it's null to be safe in case it's called twice
      320:  414:	if (t->s != NULL) {
      315:  415:		myfree(t->s);
      315:  416:		t->s = NULL;
        -:  417:	}
      320:  418:}
        -:  419:
     1089:  420:void token_cleanup(Token *t)
        -:  421:{
        -:  422:	// check if it's null to be safe in case it's called twice
     1089:  423:	if (t->token != NULL) {
     1089:  424:		myfree(t->token);
     1089:  425:		t->token = NULL;
        -:  426:	}
        -:  427:
        -:  428:	// check if it's null to be safe in case it's called twice
     1089:  429:	if (t->span != NULL) {
      954:  430:		myfree(t->span);
      954:  431:		t->span = NULL;
        -:  432:	}
     1089:  433:}
        -:  434:
        -:  435:typedef enum TokenDisplayType {
        -:  436:	TokenDisplayTypeError = 0,
        -:  437:	TokenDisplayTypeWarning = 1
        -:  438:} TokenDisplayType;
        -:  439:
    #####:  440:int token_display_impl(Token *token, TokenDisplayType type, char *fmt, va_list va_args)
        -:  441:{
    #####:  442:	if (type == TokenDisplayTypeError)
    #####:  443:		fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
        -:  444:	else
    #####:  445:		fprintf(stderr, "%sWarning%s: ", YELLOW, RESET);
    #####:  446:	vfprintf(stderr, fmt, va_args);
    #####:  447:	fprintf(stderr, "\n%s", token->span);
    #####:  448:	return 0;
        -:  449:}
        -:  450:
    #####:  451:int token_display_error(Token *token, char *fmt, ...)
        -:  452:{
        -:  453:	va_list va_args;
    #####:  454:	va_start(va_args, fmt);
    #####:  455:	int ret = token_display_impl(token, TokenDisplayTypeError, fmt, va_args);
    #####:  456:	va_end(va_args);
    #####:  457:	return ret;
        -:  458:
        -:  459:	/*
        -:  460:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
        -:  461:	vfprintf(stderr, fmt, va_args);
        -:  462:	va_end(va_args);
        -:  463:	fprintf(stderr, "\n%s", token->span);
        -:  464:	return 0;
        -:  465:	*/
        -:  466:}
        -:  467:
    #####:  468:int token_display_warning(Token *token, char *fmt, ...)
        -:  469:{
        -:  470:	va_list va_args;
    #####:  471:	va_start(va_args, fmt);
    #####:  472:	int ret = token_display_impl(token, TokenDisplayTypeWarning, fmt, va_args);
    #####:  473:	va_end(va_args);
    #####:  474:	return ret;
        -:  475:	/*
        -:  476:	va_list va_args;
        -:  477:	va_start(va_args, fmt);
        -:  478:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
        -:  479:	vfprintf(stderr, fmt, va_args);
        -:  480:	va_end(va_args);
        -:  481:	fprintf(stderr, "\n%s", token->span);
        -:  482:	return 0;
        -:  483:	*/
        -:  484:}
