        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
    #####:   16:int main(int argc, char **argv) { return 0; }
        -:    0:Source:toml.c
        -:    0:Graph:toml.gcno
        -:    0:Data:toml.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2:
        -:    3:  MIT License
        -:    4:
        -:    5:  Copyright (c) CK Tan
        -:    6:  https://github.com/cktan/tomlc99
        -:    7:
        -:    8:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    9:  of this software and associated documentation files (the "Software"), to deal
        -:   10:  in the Software without restriction, including without limitation the rights
        -:   11:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   12:  copies of the Software, and to permit persons to whom the Software is
        -:   13:  furnished to do so, subject to the following conditions:
        -:   14:
        -:   15:  The above copyright notice and this permission notice shall be included in all
        -:   16:  copies or substantial portions of the Software.
        -:   17:
        -:   18:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   19:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   20:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   21:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   22:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   23:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   24:  SOFTWARE.
        -:   25:
        -:   26:*/
        -:   27:#define _POSIX_C_SOURCE 200809L
        -:   28:#include <assert.h>
        -:   29:#include <ctype.h>
        -:   30:#include <errno.h>
        -:   31:#include <stdbool.h>
        -:   32:#include <stdint.h>
        -:   33:#include <stdio.h>
        -:   34:#include <stdlib.h>
        -:   35:#include <string.h>
        -:   36:#include <toml/toml.h>
        -:   37:
        -:   38:static void *(*ppmalloc)(size_t) = malloc;
        -:   39:static void (*ppfree)(void *) = free;
        -:   40:
    #####:   41:void toml_set_memutil(void *(*xxmalloc)(size_t), void (*xxfree)(void *)) {
    #####:   42:	if (xxmalloc)
    #####:   43:		ppmalloc = xxmalloc;
    #####:   44:	if (xxfree)
    #####:   45:		ppfree = xxfree;
    #####:   46:}
        -:   47:
        -:   48:#define ALIGN8(sz) (((sz) + 7) & ~7)
        -:   49:#define MALLOC(a) ppmalloc(a)
        -:   50:#define FREE(a) ppfree(a)
        -:   51:
        -:   52:#define malloc(x) error - forbidden - use MALLOC instead
        -:   53:#define free(x) error - forbidden - use FREE instead
        -:   54:#define calloc(x, y) error - forbidden - use CALLOC instead
        -:   55:
    #####:   56:static void *CALLOC(size_t nmemb, size_t sz) {
    #####:   57:	int nb = ALIGN8(sz) * nmemb;
    #####:   58:	void *p = MALLOC(nb);
    #####:   59:	if (p) {
    #####:   60:		memset(p, 0, nb);
        -:   61:	}
    #####:   62:	return p;
        -:   63:}
        -:   64:
        -:   65:// some old platforms define strdup macro -- drop it.
        -:   66:#undef strdup
        -:   67:#define strdup(x) error - forbidden - use STRDUP instead
        -:   68:
    #####:   69:static char *STRDUP(const char *s) {
    #####:   70:	int len = strlen(s);
    #####:   71:	char *p = MALLOC(len + 1);
    #####:   72:	if (p) {
    #####:   73:		memcpy(p, s, len);
    #####:   74:		p[len] = 0;
        -:   75:	}
    #####:   76:	return p;
        -:   77:}
        -:   78:
        -:   79:// some old platforms define strndup macro -- drop it.
        -:   80:#undef strndup
        -:   81:#define strndup(x) error - forbiden - use STRNDUP instead
        -:   82:
    #####:   83:static char *STRNDUP(const char *s, size_t n) {
    #####:   84:	size_t len = strnlen(s, n);
    #####:   85:	char *p = MALLOC(len + 1);
    #####:   86:	if (p) {
    #####:   87:		memcpy(p, s, len);
    #####:   88:		p[len] = 0;
        -:   89:	}
    #####:   90:	return p;
        -:   91:}
        -:   92:
        -:   93:/**
        -:   94: * Convert a char in utf8 into UCS, and store it in *ret.
        -:   95: * Return bytes consumed or -1 on failure.
        -:   96: */
    #####:   97:int toml_utf8_to_ucs(const char *orig, int len, int64_t *ret) {
    #####:   98:	const unsigned char *buf = (const unsigned char *)orig;
    #####:   99:	unsigned i = *buf++;
        -:  100:	int64_t v;
        -:  101:
        -:  102:	/* 0x00000000 - 0x0000007F:
        -:  103:	   0xxxxxxx
        -:  104:	*/
    #####:  105:	if (0 == (i >> 7)) {
    #####:  106:		if (len < 1)
    #####:  107:			return -1;
    #####:  108:		v = i;
    #####:  109:		return *ret = v, 1;
        -:  110:	}
        -:  111:	/* 0x00000080 - 0x000007FF:
        -:  112:	   110xxxxx 10xxxxxx
        -:  113:	*/
    #####:  114:	if (0x6 == (i >> 5)) {
    #####:  115:		if (len < 2)
    #####:  116:			return -1;
    #####:  117:		v = i & 0x1f;
    #####:  118:		for (int j = 0; j < 1; j++) {
    #####:  119:			i = *buf++;
    #####:  120:			if (0x2 != (i >> 6))
    #####:  121:				return -1;
    #####:  122:			v = (v << 6) | (i & 0x3f);
        -:  123:		}
    #####:  124:		return *ret = v, (const char *)buf - orig;
        -:  125:	}
        -:  126:
        -:  127:	/* 0x00000800 - 0x0000FFFF:
        -:  128:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  129:	*/
    #####:  130:	if (0xE == (i >> 4)) {
    #####:  131:		if (len < 3)
    #####:  132:			return -1;
    #####:  133:		v = i & 0x0F;
    #####:  134:		for (int j = 0; j < 2; j++) {
    #####:  135:			i = *buf++;
    #####:  136:			if (0x2 != (i >> 6))
    #####:  137:				return -1;
    #####:  138:			v = (v << 6) | (i & 0x3f);
        -:  139:		}
    #####:  140:		return *ret = v, (const char *)buf - orig;
        -:  141:	}
        -:  142:
        -:  143:	/* 0x00010000 - 0x001FFFFF:
        -:  144:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  145:	*/
    #####:  146:	if (0x1E == (i >> 3)) {
    #####:  147:		if (len < 4)
    #####:  148:			return -1;
    #####:  149:		v = i & 0x07;
    #####:  150:		for (int j = 0; j < 3; j++) {
    #####:  151:			i = *buf++;
    #####:  152:			if (0x2 != (i >> 6))
    #####:  153:				return -1;
    #####:  154:			v = (v << 6) | (i & 0x3f);
        -:  155:		}
    #####:  156:		return *ret = v, (const char *)buf - orig;
        -:  157:	}
        -:  158:
        -:  159:	/* 0x00200000 - 0x03FFFFFF:
        -:  160:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  161:	*/
    #####:  162:	if (0x3E == (i >> 2)) {
    #####:  163:		if (len < 5)
    #####:  164:			return -1;
    #####:  165:		v = i & 0x03;
    #####:  166:		for (int j = 0; j < 4; j++) {
    #####:  167:			i = *buf++;
    #####:  168:			if (0x2 != (i >> 6))
    #####:  169:				return -1;
    #####:  170:			v = (v << 6) | (i & 0x3f);
        -:  171:		}
    #####:  172:		return *ret = v, (const char *)buf - orig;
        -:  173:	}
        -:  174:
        -:  175:	/* 0x04000000 - 0x7FFFFFFF:
        -:  176:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  177:	*/
    #####:  178:	if (0x7e == (i >> 1)) {
    #####:  179:		if (len < 6)
    #####:  180:			return -1;
    #####:  181:		v = i & 0x01;
    #####:  182:		for (int j = 0; j < 5; j++) {
    #####:  183:			i = *buf++;
    #####:  184:			if (0x2 != (i >> 6))
    #####:  185:				return -1;
    #####:  186:			v = (v << 6) | (i & 0x3f);
        -:  187:		}
    #####:  188:		return *ret = v, (const char *)buf - orig;
        -:  189:	}
    #####:  190:	return -1;
        -:  191:}
        -:  192:
        -:  193:/**
        -:  194: *	Convert a UCS char to utf8 code, and return it in buf.
        -:  195: *	Return bytes used in buf to encode the char, or
        -:  196: *	-1 on error.
        -:  197: */
    #####:  198:int toml_ucs_to_utf8(int64_t code, char buf[6]) {
        -:  199:	/* http://stackoverflow.com/questions/6240055/manually-converting-unicode-codepoints-into-utf-8-and-utf-16
        -:  200:	 */
        -:  201:	/* The UCS code values 0xd800â€“0xdfff (UTF-16 surrogates) as well
        -:  202:	 * as 0xfffe and 0xffff (UCS noncharacters) should not appear in
        -:  203:	 * conforming UTF-8 streams.
        -:  204:	 */
    #####:  205:	if (0xd800 <= code && code <= 0xdfff)
    #####:  206:		return -1;
    #####:  207:	if (0xfffe <= code && code <= 0xffff)
    #####:  208:		return -1;
        -:  209:
        -:  210:	/* 0x00000000 - 0x0000007F:
        -:  211:	   0xxxxxxx
        -:  212:	*/
    #####:  213:	if (code < 0)
    #####:  214:		return -1;
    #####:  215:	if (code <= 0x7F) {
    #####:  216:		buf[0] = (unsigned char)code;
    #####:  217:		return 1;
        -:  218:	}
        -:  219:
        -:  220:	/* 0x00000080 - 0x000007FF:
        -:  221:	   110xxxxx 10xxxxxx
        -:  222:	*/
    #####:  223:	if (code <= 0x000007FF) {
    #####:  224:		buf[0] = (unsigned char)(0xc0 | (code >> 6));
    #####:  225:		buf[1] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  226:		return 2;
        -:  227:	}
        -:  228:
        -:  229:	/* 0x00000800 - 0x0000FFFF:
        -:  230:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  231:	*/
    #####:  232:	if (code <= 0x0000FFFF) {
    #####:  233:		buf[0] = (unsigned char)(0xe0 | (code >> 12));
    #####:  234:		buf[1] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  235:		buf[2] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  236:		return 3;
        -:  237:	}
        -:  238:
        -:  239:	/* 0x00010000 - 0x001FFFFF:
        -:  240:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  241:	*/
    #####:  242:	if (code <= 0x001FFFFF) {
    #####:  243:		buf[0] = (unsigned char)(0xf0 | (code >> 18));
    #####:  244:		buf[1] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  245:		buf[2] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  246:		buf[3] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  247:		return 4;
        -:  248:	}
        -:  249:
        -:  250:	/* 0x00200000 - 0x03FFFFFF:
        -:  251:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  252:	*/
    #####:  253:	if (code <= 0x03FFFFFF) {
    #####:  254:		buf[0] = (unsigned char)(0xf8 | (code >> 24));
    #####:  255:		buf[1] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  256:		buf[2] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  257:		buf[3] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  258:		buf[4] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  259:		return 5;
        -:  260:	}
        -:  261:
        -:  262:	/* 0x04000000 - 0x7FFFFFFF:
        -:  263:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  264:	*/
    #####:  265:	if (code <= 0x7FFFFFFF) {
    #####:  266:		buf[0] = (unsigned char)(0xfc | (code >> 30));
    #####:  267:		buf[1] = (unsigned char)(0x80 | ((code >> 24) & 0x3f));
    #####:  268:		buf[2] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  269:		buf[3] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  270:		buf[4] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  271:		buf[5] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  272:		return 6;
        -:  273:	}
        -:  274:
    #####:  275:	return -1;
        -:  276:}
        -:  277:
        -:  278:/*
        -:  279: *	TOML has 3 data structures: value, array, table.
        -:  280: *	Each of them can have identification key.
        -:  281: */
        -:  282:typedef struct toml_keyval_t toml_keyval_t;
        -:  283:struct toml_keyval_t {
        -:  284:	const char *key; /* key to this value */
        -:  285:	const char *val; /* the raw value */
        -:  286:};
        -:  287:
        -:  288:typedef struct toml_arritem_t toml_arritem_t;
        -:  289:struct toml_arritem_t {
        -:  290:	int valtype; /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring,
        -:  291:			't'ime, 'D'ate, 'T'imestamp */
        -:  292:	char *val;
        -:  293:	toml_array_t *arr;
        -:  294:	toml_table_t *tab;
        -:  295:};
        -:  296:
        -:  297:struct toml_array_t {
        -:  298:	const char *key; /* key to this array */
        -:  299:	int kind; /* element kind: 'v'alue, 'a'rray, or 't'able, 'm'ixed */
        -:  300:	int type; /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring, 't'ime,
        -:  301:		     'D'ate, 'T'imestamp, 'm'ixed */
        -:  302:
        -:  303:	int nitem; /* number of elements */
        -:  304:	toml_arritem_t *item;
        -:  305:};
        -:  306:
        -:  307:struct toml_table_t {
        -:  308:	const char *key; /* key to this table */
        -:  309:	bool implicit;	 /* table was created implicitly */
        -:  310:	bool readonly;	 /* no more modification allowed */
        -:  311:
        -:  312:	/* key-values in the table */
        -:  313:	int nkval;
        -:  314:	toml_keyval_t **kval;
        -:  315:
        -:  316:	/* arrays in the table */
        -:  317:	int narr;
        -:  318:	toml_array_t **arr;
        -:  319:
        -:  320:	/* tables in the table */
        -:  321:	int ntab;
        -:  322:	toml_table_t **tab;
        -:  323:};
        -:  324:
    #####:  325:static inline void xfree(const void *x) {
    #####:  326:	if (x)
    #####:  327:		FREE((void *)(intptr_t)x);
    #####:  328:}
        -:  329:
        -:  330:enum tokentype_t {
        -:  331:	INVALID,
        -:  332:	DOT,
        -:  333:	COMMA,
        -:  334:	EQUAL,
        -:  335:	LBRACE,
        -:  336:	RBRACE,
        -:  337:	NEWLINE,
        -:  338:	LBRACKET,
        -:  339:	RBRACKET,
        -:  340:	STRING,
        -:  341:};
        -:  342:typedef enum tokentype_t tokentype_t;
        -:  343:
        -:  344:typedef struct token_t token_t;
        -:  345:struct token_t {
        -:  346:	tokentype_t tok;
        -:  347:	int lineno;
        -:  348:	char *ptr; /* points into context->start */
        -:  349:	int len;
        -:  350:	int eof;
        -:  351:};
        -:  352:
        -:  353:typedef struct context_t context_t;
        -:  354:struct context_t {
        -:  355:	char *start;
        -:  356:	char *stop;
        -:  357:	char *errbuf;
        -:  358:	int errbufsz;
        -:  359:
        -:  360:	token_t tok;
        -:  361:	toml_table_t *root;
        -:  362:	toml_table_t *curtab;
        -:  363:
        -:  364:	struct {
        -:  365:		int top;
        -:  366:		char *key[10];
        -:  367:		token_t tok[10];
        -:  368:	} tpath;
        -:  369:};
        -:  370:
        -:  371:#define STRINGIFY(x) #x
        -:  372:#define TOSTRING(x) STRINGIFY(x)
        -:  373:#define FLINE __FILE__ ":" TOSTRING(__LINE__)
        -:  374:
        -:  375:static int next_token(context_t *ctx, int dotisspecial);
        -:  376:
        -:  377:/*
        -:  378:  Error reporting. Call when an error is detected. Always return -1.
        -:  379:*/
    #####:  380:static int e_outofmemory(context_t *ctx, const char *fline) {
    #####:  381:	snprintf(ctx->errbuf, ctx->errbufsz, "ERROR: out of memory (%s)",
        -:  382:		 fline);
    #####:  383:	return -1;
        -:  384:}
        -:  385:
    #####:  386:static int e_internal(context_t *ctx, const char *fline) {
    #####:  387:	snprintf(ctx->errbuf, ctx->errbufsz, "internal error (%s)", fline);
    #####:  388:	return -1;
        -:  389:}
        -:  390:
    #####:  391:static int e_syntax(context_t *ctx, int lineno, const char *msg) {
    #####:  392:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  393:	return -1;
        -:  394:}
        -:  395:
    #####:  396:static int e_badkey(context_t *ctx, int lineno) {
    #####:  397:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: bad key", lineno);
    #####:  398:	return -1;
        -:  399:}
        -:  400:
    #####:  401:static int e_keyexists(context_t *ctx, int lineno) {
    #####:  402:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: key exists", lineno);
    #####:  403:	return -1;
        -:  404:}
        -:  405:
    #####:  406:static int e_forbid(context_t *ctx, int lineno, const char *msg) {
    #####:  407:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  408:	return -1;
        -:  409:}
        -:  410:
    #####:  411:static void *expand(void *p, int sz, int newsz) {
    #####:  412:	void *s = MALLOC(newsz);
    #####:  413:	if (!s)
    #####:  414:		return 0;
        -:  415:
    #####:  416:	if (p) {
    #####:  417:		memcpy(s, p, sz);
    #####:  418:		FREE(p);
        -:  419:	}
    #####:  420:	return s;
        -:  421:}
        -:  422:
    #####:  423:static void **expand_ptrarr(void **p, int n) {
    #####:  424:	void **s = MALLOC((n + 1) * sizeof(void *));
    #####:  425:	if (!s)
    #####:  426:		return 0;
        -:  427:
    #####:  428:	s[n] = 0;
    #####:  429:	if (p) {
    #####:  430:		memcpy(s, p, n * sizeof(void *));
    #####:  431:		FREE(p);
        -:  432:	}
    #####:  433:	return s;
        -:  434:}
        -:  435:
    #####:  436:static toml_arritem_t *expand_arritem(toml_arritem_t *p, int n) {
    #####:  437:	toml_arritem_t *pp = expand(p, n * sizeof(*p), (n + 1) * sizeof(*p));
    #####:  438:	if (!pp)
    #####:  439:		return 0;
        -:  440:
    #####:  441:	memset(&pp[n], 0, sizeof(pp[n]));
    #####:  442:	return pp;
        -:  443:}
        -:  444:
    #####:  445:static char *norm_lit_str(const char *src, int srclen, int multiline,
        -:  446:			  char *errbuf, int errbufsz) {
    #####:  447:	char *dst = 0; /* will write to dst[] and return it */
    #####:  448:	int max = 0;   /* max size of dst[] */
    #####:  449:	int off = 0;   /* cur offset in dst[] */
    #####:  450:	const char *sp = src;
    #####:  451:	const char *sq = src + srclen;
        -:  452:	int ch;
        -:  453:
        -:  454:	/* scan forward on src */
        -:  455:	for (;;) {
    #####:  456:		if (off >= max - 10) { /* have some slack for misc stuff */
    #####:  457:			int newmax = max + 50;
    #####:  458:			char *x = expand(dst, max, newmax);
    #####:  459:			if (!x) {
    #####:  460:				xfree(dst);
    #####:  461:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  462:				return 0;
        -:  463:			}
    #####:  464:			dst = x;
    #####:  465:			max = newmax;
        -:  466:		}
        -:  467:
        -:  468:		/* finished? */
    #####:  469:		if (sp >= sq)
    #####:  470:			break;
        -:  471:
    #####:  472:		ch = *sp++;
        -:  473:		/* control characters other than tab is not allowed */
    #####:  474:		if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) ||
        -:  475:		    (ch == 0x7f)) {
    #####:  476:			if (!(multiline && (ch == '\r' || ch == '\n'))) {
    #####:  477:				xfree(dst);
    #####:  478:				snprintf(errbuf, errbufsz,
        -:  479:					 "invalid char U+%04x", ch);
    #####:  480:				return 0;
        -:  481:			}
        -:  482:		}
        -:  483:
        -:  484:		// a plain copy suffice
    #####:  485:		dst[off++] = ch;
        -:  486:	}
        -:  487:
    #####:  488:	dst[off++] = 0;
    #####:  489:	return dst;
        -:  490:}
        -:  491:
        -:  492:/*
        -:  493: * Convert src to raw unescaped utf-8 string.
        -:  494: * Returns NULL if error with errmsg in errbuf.
        -:  495: */
    #####:  496:static char *norm_basic_str(const char *src, int srclen, int multiline,
        -:  497:			    char *errbuf, int errbufsz) {
    #####:  498:	char *dst = 0; /* will write to dst[] and return it */
    #####:  499:	int max = 0;   /* max size of dst[] */
    #####:  500:	int off = 0;   /* cur offset in dst[] */
    #####:  501:	const char *sp = src;
    #####:  502:	const char *sq = src + srclen;
        -:  503:	int ch;
        -:  504:
        -:  505:	/* scan forward on src */
        -:  506:	for (;;) {
    #####:  507:		if (off >= max - 10) { /* have some slack for misc stuff */
    #####:  508:			int newmax = max + 50;
    #####:  509:			char *x = expand(dst, max, newmax);
    #####:  510:			if (!x) {
    #####:  511:				xfree(dst);
    #####:  512:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  513:				return 0;
        -:  514:			}
    #####:  515:			dst = x;
    #####:  516:			max = newmax;
        -:  517:		}
        -:  518:
        -:  519:		/* finished? */
    #####:  520:		if (sp >= sq)
    #####:  521:			break;
        -:  522:
    #####:  523:		ch = *sp++;
    #####:  524:		if (ch != '\\') {
        -:  525:			/* these chars must be escaped: U+0000 to U+0008, U+000A
        -:  526:			 * to U+001F, U+007F
        -:  527:			 */
    #####:  528:			if ((0 <= ch && ch <= 0x08) ||
    #####:  529:			    (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f)) {
    #####:  530:				if (!(multiline &&
    #####:  531:				      (ch == '\r' || ch == '\n'))) {
    #####:  532:					xfree(dst);
    #####:  533:					snprintf(errbuf, errbufsz,
        -:  534:						 "invalid char U+%04x", ch);
    #####:  535:					return 0;
        -:  536:				}
        -:  537:			}
        -:  538:
        -:  539:			// a plain copy suffice
    #####:  540:			dst[off++] = ch;
    #####:  541:			continue;
        -:  542:		}
        -:  543:
        -:  544:		/* ch was backslash. we expect the escape char. */
    #####:  545:		if (sp >= sq) {
    #####:  546:			snprintf(errbuf, errbufsz, "last backslash is invalid");
    #####:  547:			xfree(dst);
    #####:  548:			return 0;
        -:  549:		}
        -:  550:
        -:  551:		/* for multi-line, we want to kill line-ending-backslash ... */
    #####:  552:		if (multiline) {
        -:  553:
        -:  554:			// if there is only whitespace after the backslash ...
    #####:  555:			if (sp[strspn(sp, " \t\r")] == '\n') {
        -:  556:				/* skip all the following whitespaces */
    #####:  557:				sp += strspn(sp, " \t\r\n");
    #####:  558:				continue;
        -:  559:			}
        -:  560:		}
        -:  561:
        -:  562:		/* get the escaped char */
    #####:  563:		ch = *sp++;
    #####:  564:		switch (ch) {
    #####:  565:		case 'u':
        -:  566:		case 'U': {
    #####:  567:			int64_t ucs = 0;
    #####:  568:			int nhex = (ch == 'u' ? 4 : 8);
    #####:  569:			for (int i = 0; i < nhex; i++) {
    #####:  570:				if (sp >= sq) {
    #####:  571:					snprintf(errbuf, errbufsz,
        -:  572:						 "\\%c expects %d hex chars",
        -:  573:						 ch, nhex);
    #####:  574:					xfree(dst);
    #####:  575:					return 0;
        -:  576:				}
    #####:  577:				ch = *sp++;
    #####:  578:				int v = ('0' <= ch && ch <= '9')
        -:  579:					    ? ch - '0'
    #####:  580:					    : (('A' <= ch && ch <= 'F')
        -:  581:						   ? ch - 'A' + 10
    #####:  582:						   : -1);
    #####:  583:				if (-1 == v) {
    #####:  584:					snprintf(
        -:  585:					    errbuf, errbufsz,
        -:  586:					    "invalid hex chars for \\u or \\U");
    #####:  587:					xfree(dst);
    #####:  588:					return 0;
        -:  589:				}
    #####:  590:				ucs = ucs * 16 + v;
        -:  591:			}
    #####:  592:			int n = toml_ucs_to_utf8(ucs, &dst[off]);
    #####:  593:			if (-1 == n) {
    #####:  594:				snprintf(errbuf, errbufsz,
        -:  595:					 "illegal ucs code in \\u or \\U");
    #####:  596:				xfree(dst);
    #####:  597:				return 0;
        -:  598:			}
    #####:  599:			off += n;
        -:  600:		}
    #####:  601:			continue;
        -:  602:
    #####:  603:		case 'b':
    #####:  604:			ch = '\b';
    #####:  605:			break;
    #####:  606:		case 't':
    #####:  607:			ch = '\t';
    #####:  608:			break;
    #####:  609:		case 'n':
    #####:  610:			ch = '\n';
    #####:  611:			break;
    #####:  612:		case 'f':
    #####:  613:			ch = '\f';
    #####:  614:			break;
    #####:  615:		case 'r':
    #####:  616:			ch = '\r';
    #####:  617:			break;
    #####:  618:		case '"':
    #####:  619:			ch = '"';
    #####:  620:			break;
    #####:  621:		case '\\':
    #####:  622:			ch = '\\';
    #####:  623:			break;
    #####:  624:		default:
    #####:  625:			snprintf(errbuf, errbufsz, "illegal escape char \\%c",
        -:  626:				 ch);
    #####:  627:			xfree(dst);
    #####:  628:			return 0;
        -:  629:		}
        -:  630:
    #####:  631:		dst[off++] = ch;
        -:  632:	}
        -:  633:
        -:  634:	// Cap with NUL and return it.
    #####:  635:	dst[off++] = 0;
    #####:  636:	return dst;
        -:  637:}
        -:  638:
        -:  639:/* Normalize a key. Convert all special chars to raw unescaped utf-8 chars. */
    #####:  640:static char *normalize_key(context_t *ctx, token_t strtok) {
    #####:  641:	const char *sp = strtok.ptr;
    #####:  642:	const char *sq = strtok.ptr + strtok.len;
    #####:  643:	int lineno = strtok.lineno;
        -:  644:	char *ret;
    #####:  645:	int ch = *sp;
        -:  646:	char ebuf[80];
        -:  647:
        -:  648:	/* handle quoted string */
    #####:  649:	if (ch == '\'' || ch == '\"') {
        -:  650:		/* if ''' or """, take 3 chars off front and back. Else, take 1
        -:  651:		 * char off. */
    #####:  652:		int multiline = 0;
    #####:  653:		if (sp[1] == ch && sp[2] == ch) {
    #####:  654:			sp += 3, sq -= 3;
    #####:  655:			multiline = 1;
        -:  656:		} else
    #####:  657:			sp++, sq--;
        -:  658:
    #####:  659:		if (ch == '\'') {
        -:  660:			/* for single quote, take it verbatim. */
    #####:  661:			if (!(ret = STRNDUP(sp, sq - sp))) {
    #####:  662:				e_outofmemory(ctx, FLINE);
    #####:  663:				return 0;
        -:  664:			}
        -:  665:		} else {
        -:  666:			/* for double quote, we need to normalize */
    #####:  667:			ret = norm_basic_str(sp, sq - sp, multiline, ebuf,
        -:  668:					     sizeof(ebuf));
    #####:  669:			if (!ret) {
    #####:  670:				e_syntax(ctx, lineno, ebuf);
    #####:  671:				return 0;
        -:  672:			}
        -:  673:		}
        -:  674:
        -:  675:		/* newlines are not allowed in keys */
    #####:  676:		if (strchr(ret, '\n')) {
    #####:  677:			xfree(ret);
    #####:  678:			e_badkey(ctx, lineno);
    #####:  679:			return 0;
        -:  680:		}
    #####:  681:		return ret;
        -:  682:	}
        -:  683:
        -:  684:	/* for bare-key allow only this regex: [A-Za-z0-9_-]+ */
        -:  685:	const char *xp;
    #####:  686:	for (xp = sp; xp != sq; xp++) {
    #####:  687:		int k = *xp;
    #####:  688:		if (isalnum(k))
    #####:  689:			continue;
    #####:  690:		if (k == '_' || k == '-')
    #####:  691:			continue;
    #####:  692:		e_badkey(ctx, lineno);
    #####:  693:		return 0;
        -:  694:	}
        -:  695:
        -:  696:	/* dup and return it */
    #####:  697:	if (!(ret = STRNDUP(sp, sq - sp))) {
    #####:  698:		e_outofmemory(ctx, FLINE);
    #####:  699:		return 0;
        -:  700:	}
    #####:  701:	return ret;
        -:  702:}
        -:  703:
        -:  704:/*
        -:  705: * Look up key in tab. Return 0 if not found, or
        -:  706: * 'v'alue, 'a'rray or 't'able depending on the element.
        -:  707: */
    #####:  708:static int check_key(toml_table_t *tab, const char *key,
        -:  709:		     toml_keyval_t **ret_val, toml_array_t **ret_arr,
        -:  710:		     toml_table_t **ret_tab) {
        -:  711:	int i;
        -:  712:	void *dummy;
        -:  713:
    #####:  714:	if (!ret_tab)
    #####:  715:		ret_tab = (toml_table_t **)&dummy;
    #####:  716:	if (!ret_arr)
    #####:  717:		ret_arr = (toml_array_t **)&dummy;
    #####:  718:	if (!ret_val)
    #####:  719:		ret_val = (toml_keyval_t **)&dummy;
        -:  720:
    #####:  721:	*ret_tab = 0;
    #####:  722:	*ret_arr = 0;
    #####:  723:	*ret_val = 0;
        -:  724:
    #####:  725:	for (i = 0; i < tab->nkval; i++) {
    #####:  726:		if (0 == strcmp(key, tab->kval[i]->key)) {
    #####:  727:			*ret_val = tab->kval[i];
    #####:  728:			return 'v';
        -:  729:		}
        -:  730:	}
    #####:  731:	for (i = 0; i < tab->narr; i++) {
    #####:  732:		if (0 == strcmp(key, tab->arr[i]->key)) {
    #####:  733:			*ret_arr = tab->arr[i];
    #####:  734:			return 'a';
        -:  735:		}
        -:  736:	}
    #####:  737:	for (i = 0; i < tab->ntab; i++) {
    #####:  738:		if (0 == strcmp(key, tab->tab[i]->key)) {
    #####:  739:			*ret_tab = tab->tab[i];
    #####:  740:			return 't';
        -:  741:		}
        -:  742:	}
    #####:  743:	return 0;
        -:  744:}
        -:  745:
    #####:  746:static int key_kind(toml_table_t *tab, const char *key) {
    #####:  747:	return check_key(tab, key, 0, 0, 0);
        -:  748:}
        -:  749:
        -:  750:/* Create a keyval in the table.
        -:  751: */
    #####:  752:static toml_keyval_t *create_keyval_in_table(context_t *ctx, toml_table_t *tab,
        -:  753:					     token_t keytok) {
        -:  754:	/* first, normalize the key to be used for lookup.
        -:  755:	 * remember to free it if we error out.
        -:  756:	 */
    #####:  757:	char *newkey = normalize_key(ctx, keytok);
    #####:  758:	if (!newkey)
    #####:  759:		return 0;
        -:  760:
        -:  761:	/* if key exists: error out. */
    #####:  762:	toml_keyval_t *dest = 0;
    #####:  763:	if (key_kind(tab, newkey)) {
    #####:  764:		xfree(newkey);
    #####:  765:		e_keyexists(ctx, keytok.lineno);
    #####:  766:		return 0;
        -:  767:	}
        -:  768:
        -:  769:	/* make a new entry */
    #####:  770:	int n = tab->nkval;
        -:  771:	toml_keyval_t **base;
    #####:  772:	if (0 ==
    #####:  773:	    (base = (toml_keyval_t **)expand_ptrarr((void **)tab->kval, n))) {
    #####:  774:		xfree(newkey);
    #####:  775:		e_outofmemory(ctx, FLINE);
    #####:  776:		return 0;
        -:  777:	}
    #####:  778:	tab->kval = base;
        -:  779:
    #####:  780:	if (0 == (base[n] = (toml_keyval_t *)CALLOC(1, sizeof(*base[n])))) {
    #####:  781:		xfree(newkey);
    #####:  782:		e_outofmemory(ctx, FLINE);
    #####:  783:		return 0;
        -:  784:	}
    #####:  785:	dest = tab->kval[tab->nkval++];
        -:  786:
        -:  787:	/* save the key in the new value struct */
    #####:  788:	dest->key = newkey;
    #####:  789:	return dest;
        -:  790:}
        -:  791:
        -:  792:/* Create a table in the table.
        -:  793: */
    #####:  794:static toml_table_t *create_keytable_in_table(context_t *ctx, toml_table_t *tab,
        -:  795:					      token_t keytok) {
        -:  796:	/* first, normalize the key to be used for lookup.
        -:  797:	 * remember to free it if we error out.
        -:  798:	 */
    #####:  799:	char *newkey = normalize_key(ctx, keytok);
    #####:  800:	if (!newkey)
    #####:  801:		return 0;
        -:  802:
        -:  803:	/* if key exists: error out */
    #####:  804:	toml_table_t *dest = 0;
    #####:  805:	if (check_key(tab, newkey, 0, 0, &dest)) {
    #####:  806:		xfree(newkey); /* don't need this anymore */
        -:  807:
        -:  808:		/* special case: if table exists, but was created implicitly ...
        -:  809:		 */
    #####:  810:		if (dest && dest->implicit) {
        -:  811:			/* we make it explicit now, and simply return it. */
    #####:  812:			dest->implicit = false;
    #####:  813:			return dest;
        -:  814:		}
    #####:  815:		e_keyexists(ctx, keytok.lineno);
    #####:  816:		return 0;
        -:  817:	}
        -:  818:
        -:  819:	/* create a new table entry */
    #####:  820:	int n = tab->ntab;
        -:  821:	toml_table_t **base;
    #####:  822:	if (0 ==
    #####:  823:	    (base = (toml_table_t **)expand_ptrarr((void **)tab->tab, n))) {
    #####:  824:		xfree(newkey);
    #####:  825:		e_outofmemory(ctx, FLINE);
    #####:  826:		return 0;
        -:  827:	}
    #####:  828:	tab->tab = base;
        -:  829:
    #####:  830:	if (0 == (base[n] = (toml_table_t *)CALLOC(1, sizeof(*base[n])))) {
    #####:  831:		xfree(newkey);
    #####:  832:		e_outofmemory(ctx, FLINE);
    #####:  833:		return 0;
        -:  834:	}
    #####:  835:	dest = tab->tab[tab->ntab++];
        -:  836:
        -:  837:	/* save the key in the new table struct */
    #####:  838:	dest->key = newkey;
    #####:  839:	return dest;
        -:  840:}
        -:  841:
        -:  842:/* Create an array in the table.
        -:  843: */
    #####:  844:static toml_array_t *create_keyarray_in_table(context_t *ctx, toml_table_t *tab,
        -:  845:					      token_t keytok, char kind) {
        -:  846:	/* first, normalize the key to be used for lookup.
        -:  847:	 * remember to free it if we error out.
        -:  848:	 */
    #####:  849:	char *newkey = normalize_key(ctx, keytok);
    #####:  850:	if (!newkey)
    #####:  851:		return 0;
        -:  852:
        -:  853:	/* if key exists: error out */
    #####:  854:	if (key_kind(tab, newkey)) {
    #####:  855:		xfree(newkey); /* don't need this anymore */
    #####:  856:		e_keyexists(ctx, keytok.lineno);
    #####:  857:		return 0;
        -:  858:	}
        -:  859:
        -:  860:	/* make a new array entry */
    #####:  861:	int n = tab->narr;
        -:  862:	toml_array_t **base;
    #####:  863:	if (0 ==
    #####:  864:	    (base = (toml_array_t **)expand_ptrarr((void **)tab->arr, n))) {
    #####:  865:		xfree(newkey);
    #####:  866:		e_outofmemory(ctx, FLINE);
    #####:  867:		return 0;
        -:  868:	}
    #####:  869:	tab->arr = base;
        -:  870:
    #####:  871:	if (0 == (base[n] = (toml_array_t *)CALLOC(1, sizeof(*base[n])))) {
    #####:  872:		xfree(newkey);
    #####:  873:		e_outofmemory(ctx, FLINE);
    #####:  874:		return 0;
        -:  875:	}
    #####:  876:	toml_array_t *dest = tab->arr[tab->narr++];
        -:  877:
        -:  878:	/* save the key in the new array struct */
    #####:  879:	dest->key = newkey;
    #####:  880:	dest->kind = kind;
    #####:  881:	return dest;
        -:  882:}
        -:  883:
    #####:  884:static toml_arritem_t *create_value_in_array(context_t *ctx,
        -:  885:					     toml_array_t *parent) {
    #####:  886:	const int n = parent->nitem;
    #####:  887:	toml_arritem_t *base = expand_arritem(parent->item, n);
    #####:  888:	if (!base) {
    #####:  889:		e_outofmemory(ctx, FLINE);
    #####:  890:		return 0;
        -:  891:	}
    #####:  892:	parent->item = base;
    #####:  893:	parent->nitem++;
    #####:  894:	return &parent->item[n];
        -:  895:}
        -:  896:
        -:  897:/* Create an array in an array
        -:  898: */
    #####:  899:static toml_array_t *create_array_in_array(context_t *ctx,
        -:  900:					   toml_array_t *parent) {
    #####:  901:	const int n = parent->nitem;
    #####:  902:	toml_arritem_t *base = expand_arritem(parent->item, n);
    #####:  903:	if (!base) {
    #####:  904:		e_outofmemory(ctx, FLINE);
    #####:  905:		return 0;
        -:  906:	}
    #####:  907:	toml_array_t *ret = (toml_array_t *)CALLOC(1, sizeof(toml_array_t));
    #####:  908:	if (!ret) {
    #####:  909:		e_outofmemory(ctx, FLINE);
    #####:  910:		return 0;
        -:  911:	}
    #####:  912:	base[n].arr = ret;
    #####:  913:	parent->item = base;
    #####:  914:	parent->nitem++;
    #####:  915:	return ret;
        -:  916:}
        -:  917:
        -:  918:/* Create a table in an array
        -:  919: */
    #####:  920:static toml_table_t *create_table_in_array(context_t *ctx,
        -:  921:					   toml_array_t *parent) {
    #####:  922:	int n = parent->nitem;
    #####:  923:	toml_arritem_t *base = expand_arritem(parent->item, n);
    #####:  924:	if (!base) {
    #####:  925:		e_outofmemory(ctx, FLINE);
    #####:  926:		return 0;
        -:  927:	}
    #####:  928:	toml_table_t *ret = (toml_table_t *)CALLOC(1, sizeof(toml_table_t));
    #####:  929:	if (!ret) {
    #####:  930:		e_outofmemory(ctx, FLINE);
    #####:  931:		return 0;
        -:  932:	}
    #####:  933:	base[n].tab = ret;
    #####:  934:	parent->item = base;
    #####:  935:	parent->nitem++;
    #####:  936:	return ret;
        -:  937:}
        -:  938:
    #####:  939:static int skip_newlines(context_t *ctx, int isdotspecial) {
    #####:  940:	while (ctx->tok.tok == NEWLINE) {
    #####:  941:		if (next_token(ctx, isdotspecial))
    #####:  942:			return -1;
    #####:  943:		if (ctx->tok.eof)
    #####:  944:			break;
        -:  945:	}
    #####:  946:	return 0;
        -:  947:}
        -:  948:
        -:  949:static int parse_keyval(context_t *ctx, toml_table_t *tab);
        -:  950:
    #####:  951:static inline int eat_token(context_t *ctx, tokentype_t typ, int isdotspecial,
        -:  952:			    const char *fline) {
    #####:  953:	if (ctx->tok.tok != typ)
    #####:  954:		return e_internal(ctx, fline);
        -:  955:
    #####:  956:	if (next_token(ctx, isdotspecial))
    #####:  957:		return -1;
        -:  958:
    #####:  959:	return 0;
        -:  960:}
        -:  961:
        -:  962:/* We are at '{ ... }'.
        -:  963: * Parse the table.
        -:  964: */
    #####:  965:static int parse_inline_table(context_t *ctx, toml_table_t *tab) {
    #####:  966:	if (eat_token(ctx, LBRACE, 1, FLINE))
    #####:  967:		return -1;
        -:  968:
        -:  969:	for (;;) {
    #####:  970:		if (ctx->tok.tok == NEWLINE)
    #####:  971:			return e_syntax(ctx, ctx->tok.lineno,
        -:  972:					"newline not allowed in inline table");
        -:  973:
        -:  974:		/* until } */
    #####:  975:		if (ctx->tok.tok == RBRACE)
    #####:  976:			break;
        -:  977:
    #####:  978:		if (ctx->tok.tok != STRING)
    #####:  979:			return e_syntax(ctx, ctx->tok.lineno,
        -:  980:					"expect a string");
        -:  981:
    #####:  982:		if (parse_keyval(ctx, tab))
    #####:  983:			return -1;
        -:  984:
    #####:  985:		if (ctx->tok.tok == NEWLINE)
    #####:  986:			return e_syntax(ctx, ctx->tok.lineno,
        -:  987:					"newline not allowed in inline table");
        -:  988:
        -:  989:		/* on comma, continue to scan for next keyval */
    #####:  990:		if (ctx->tok.tok == COMMA) {
    #####:  991:			if (eat_token(ctx, COMMA, 1, FLINE))
    #####:  992:				return -1;
    #####:  993:			continue;
        -:  994:		}
    #####:  995:		break;
        -:  996:	}
        -:  997:
    #####:  998:	if (eat_token(ctx, RBRACE, 1, FLINE))
    #####:  999:		return -1;
        -: 1000:
    #####: 1001:	tab->readonly = 1;
        -: 1002:
    #####: 1003:	return 0;
        -: 1004:}
        -: 1005:
    #####: 1006:static int valtype(const char *val) {
        -: 1007:	toml_timestamp_t ts;
    #####: 1008:	if (*val == '\'' || *val == '"')
    #####: 1009:		return 's';
    #####: 1010:	if (0 == toml_rtob(val, 0))
    #####: 1011:		return 'b';
    #####: 1012:	if (0 == toml_rtoi(val, 0))
    #####: 1013:		return 'i';
    #####: 1014:	if (0 == toml_rtod(val, 0))
    #####: 1015:		return 'd';
    #####: 1016:	if (0 == toml_rtots(val, &ts)) {
    #####: 1017:		if (ts.year && ts.hour)
    #####: 1018:			return 'T'; /* timestamp */
    #####: 1019:		if (ts.year)
    #####: 1020:			return 'D'; /* date */
    #####: 1021:		return 't';	    /* time */
        -: 1022:	}
    #####: 1023:	return 'u'; /* unknown */
        -: 1024:}
        -: 1025:
        -: 1026:/* We are at '[...]' */
    #####: 1027:static int parse_array(context_t *ctx, toml_array_t *arr) {
    #####: 1028:	if (eat_token(ctx, LBRACKET, 0, FLINE))
    #####: 1029:		return -1;
        -: 1030:
        -: 1031:	for (;;) {
    #####: 1032:		if (skip_newlines(ctx, 0))
    #####: 1033:			return -1;
        -: 1034:
        -: 1035:		/* until ] */
    #####: 1036:		if (ctx->tok.tok == RBRACKET)
    #####: 1037:			break;
        -: 1038:
    #####: 1039:		switch (ctx->tok.tok) {
    #####: 1040:		case STRING: {
        -: 1041:			/* set array kind if this will be the first entry */
    #####: 1042:			if (arr->kind == 0)
    #####: 1043:				arr->kind = 'v';
    #####: 1044:			else if (arr->kind != 'v')
    #####: 1045:				arr->kind = 'm';
        -: 1046:
    #####: 1047:			char *val = ctx->tok.ptr;
    #####: 1048:			int vlen = ctx->tok.len;
        -: 1049:
        -: 1050:			/* make a new value in array */
        -: 1051:			toml_arritem_t *newval =
    #####: 1052:			    create_value_in_array(ctx, arr);
    #####: 1053:			if (!newval)
    #####: 1054:				return e_outofmemory(ctx, FLINE);
        -: 1055:
    #####: 1056:			if (!(newval->val = STRNDUP(val, vlen)))
    #####: 1057:				return e_outofmemory(ctx, FLINE);
        -: 1058:
    #####: 1059:			newval->valtype = valtype(newval->val);
        -: 1060:
        -: 1061:			/* set array type if this is the first entry */
    #####: 1062:			if (arr->nitem == 1)
    #####: 1063:				arr->type = newval->valtype;
    #####: 1064:			else if (arr->type != newval->valtype)
    #####: 1065:				arr->type = 'm'; /* mixed */
        -: 1066:
    #####: 1067:			if (eat_token(ctx, STRING, 0, FLINE))
    #####: 1068:				return -1;
    #####: 1069:			break;
        -: 1070:		}
        -: 1071:
    #####: 1072:		case LBRACKET: { /* [ [array], [array] ... ] */
        -: 1073:			/* set the array kind if this will be the first entry */
    #####: 1074:			if (arr->kind == 0)
    #####: 1075:				arr->kind = 'a';
    #####: 1076:			else if (arr->kind != 'a')
    #####: 1077:				arr->kind = 'm';
        -: 1078:
    #####: 1079:			toml_array_t *subarr = create_array_in_array(ctx, arr);
    #####: 1080:			if (!subarr)
    #####: 1081:				return -1;
    #####: 1082:			if (parse_array(ctx, subarr))
    #####: 1083:				return -1;
    #####: 1084:			break;
        -: 1085:		}
        -: 1086:
    #####: 1087:		case LBRACE: { /* [ {table}, {table} ... ] */
        -: 1088:			/* set the array kind if this will be the first entry */
    #####: 1089:			if (arr->kind == 0)
    #####: 1090:				arr->kind = 't';
    #####: 1091:			else if (arr->kind != 't')
    #####: 1092:				arr->kind = 'm';
        -: 1093:
    #####: 1094:			toml_table_t *subtab = create_table_in_array(ctx, arr);
    #####: 1095:			if (!subtab)
    #####: 1096:				return -1;
    #####: 1097:			if (parse_inline_table(ctx, subtab))
    #####: 1098:				return -1;
    #####: 1099:			break;
        -: 1100:		}
        -: 1101:
    #####: 1102:		default:
    #####: 1103:			return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1104:		}
        -: 1105:
    #####: 1106:		if (skip_newlines(ctx, 0))
    #####: 1107:			return -1;
        -: 1108:
        -: 1109:		/* on comma, continue to scan for next element */
    #####: 1110:		if (ctx->tok.tok == COMMA) {
    #####: 1111:			if (eat_token(ctx, COMMA, 0, FLINE))
    #####: 1112:				return -1;
    #####: 1113:			continue;
        -: 1114:		}
    #####: 1115:		break;
        -: 1116:	}
        -: 1117:
    #####: 1118:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1119:		return -1;
    #####: 1120:	return 0;
        -: 1121:}
        -: 1122:
        -: 1123:/* handle lines like these:
        -: 1124:   key = "value"
        -: 1125:   key = [ array ]
        -: 1126:   key = { table }
        -: 1127:*/
    #####: 1128:static int parse_keyval(context_t *ctx, toml_table_t *tab) {
    #####: 1129:	if (tab->readonly) {
    #####: 1130:		return e_forbid(ctx, ctx->tok.lineno,
        -: 1131:				"cannot insert new entry into existing table");
        -: 1132:	}
        -: 1133:
    #####: 1134:	token_t key = ctx->tok;
    #####: 1135:	if (eat_token(ctx, STRING, 1, FLINE))
    #####: 1136:		return -1;
        -: 1137:
    #####: 1138:	if (ctx->tok.tok == DOT) {
        -: 1139:		/* handle inline dotted key.
        -: 1140:		   e.g.
        -: 1141:		   physical.color = "orange"
        -: 1142:		   physical.shape = "round"
        -: 1143:		*/
    #####: 1144:		toml_table_t *subtab = 0;
        -: 1145:		{
    #####: 1146:			char *subtabstr = normalize_key(ctx, key);
    #####: 1147:			if (!subtabstr)
    #####: 1148:				return -1;
        -: 1149:
    #####: 1150:			subtab = toml_table_in(tab, subtabstr);
    #####: 1151:			xfree(subtabstr);
        -: 1152:		}
    #####: 1153:		if (!subtab) {
    #####: 1154:			subtab = create_keytable_in_table(ctx, tab, key);
    #####: 1155:			if (!subtab)
    #####: 1156:				return -1;
        -: 1157:		}
    #####: 1158:		if (next_token(ctx, 1))
    #####: 1159:			return -1;
    #####: 1160:		if (parse_keyval(ctx, subtab))
    #####: 1161:			return -1;
    #####: 1162:		return 0;
        -: 1163:	}
        -: 1164:
    #####: 1165:	if (ctx->tok.tok != EQUAL) {
    #####: 1166:		return e_syntax(ctx, ctx->tok.lineno, "missing =");
        -: 1167:	}
        -: 1168:
    #####: 1169:	if (next_token(ctx, 0))
    #####: 1170:		return -1;
        -: 1171:
    #####: 1172:	switch (ctx->tok.tok) {
    #####: 1173:	case STRING: { /* key = "value" */
    #####: 1174:		toml_keyval_t *keyval = create_keyval_in_table(ctx, tab, key);
    #####: 1175:		if (!keyval)
    #####: 1176:			return -1;
    #####: 1177:		token_t val = ctx->tok;
        -: 1178:
    #####: 1179:		assert(keyval->val == 0);
    #####: 1180:		if (!(keyval->val = STRNDUP(val.ptr, val.len)))
    #####: 1181:			return e_outofmemory(ctx, FLINE);
        -: 1182:
    #####: 1183:		if (next_token(ctx, 1))
    #####: 1184:			return -1;
        -: 1185:
    #####: 1186:		return 0;
        -: 1187:	}
        -: 1188:
    #####: 1189:	case LBRACKET: { /* key = [ array ] */
    #####: 1190:		toml_array_t *arr = create_keyarray_in_table(ctx, tab, key, 0);
    #####: 1191:		if (!arr)
    #####: 1192:			return -1;
    #####: 1193:		if (parse_array(ctx, arr))
    #####: 1194:			return -1;
    #####: 1195:		return 0;
        -: 1196:	}
        -: 1197:
    #####: 1198:	case LBRACE: { /* key = { table } */
    #####: 1199:		toml_table_t *nxttab = create_keytable_in_table(ctx, tab, key);
    #####: 1200:		if (!nxttab)
    #####: 1201:			return -1;
    #####: 1202:		if (parse_inline_table(ctx, nxttab))
    #####: 1203:			return -1;
    #####: 1204:		return 0;
        -: 1205:	}
        -: 1206:
    #####: 1207:	default:
    #####: 1208:		return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1209:	}
        -: 1210:	return 0;
        -: 1211:}
        -: 1212:
        -: 1213:typedef struct tabpath_t tabpath_t;
        -: 1214:struct tabpath_t {
        -: 1215:	int cnt;
        -: 1216:	token_t key[10];
        -: 1217:};
        -: 1218:
        -: 1219:/* at [x.y.z] or [[x.y.z]]
        -: 1220: * Scan forward and fill tabpath until it enters ] or ]]
        -: 1221: * There will be at least one entry on return.
        -: 1222: */
    #####: 1223:static int fill_tabpath(context_t *ctx) {
    #####: 1224:	int lineno = ctx->tok.lineno;
        -: 1225:	int i;
        -: 1226:
        -: 1227:	/* clear tpath */
    #####: 1228:	for (i = 0; i < ctx->tpath.top; i++) {
    #####: 1229:		char **p = &ctx->tpath.key[i];
    #####: 1230:		xfree(*p);
    #####: 1231:		*p = 0;
        -: 1232:	}
    #####: 1233:	ctx->tpath.top = 0;
        -: 1234:
    #####: 1235:	for (;;) {
    #####: 1236:		if (ctx->tpath.top >= 10)
    #####: 1237:			return e_syntax(
        -: 1238:			    ctx, lineno,
        -: 1239:			    "table path is too deep; max allowed is 10.");
        -: 1240:
    #####: 1241:		if (ctx->tok.tok != STRING)
    #####: 1242:			return e_syntax(ctx, lineno, "invalid or missing key");
        -: 1243:
    #####: 1244:		char *key = normalize_key(ctx, ctx->tok);
    #####: 1245:		if (!key)
    #####: 1246:			return -1;
    #####: 1247:		ctx->tpath.tok[ctx->tpath.top] = ctx->tok;
    #####: 1248:		ctx->tpath.key[ctx->tpath.top] = key;
    #####: 1249:		ctx->tpath.top++;
        -: 1250:
    #####: 1251:		if (next_token(ctx, 1))
    #####: 1252:			return -1;
        -: 1253:
    #####: 1254:		if (ctx->tok.tok == RBRACKET)
    #####: 1255:			break;
        -: 1256:
    #####: 1257:		if (ctx->tok.tok != DOT)
    #####: 1258:			return e_syntax(ctx, lineno, "invalid key");
        -: 1259:
    #####: 1260:		if (next_token(ctx, 1))
    #####: 1261:			return -1;
        -: 1262:	}
        -: 1263:
    #####: 1264:	if (ctx->tpath.top <= 0)
    #####: 1265:		return e_syntax(ctx, lineno, "empty table selector");
        -: 1266:
    #####: 1267:	return 0;
        -: 1268:}
        -: 1269:
        -: 1270:/* Walk tabpath from the root, and create new tables on the way.
        -: 1271: * Sets ctx->curtab to the final table.
        -: 1272: */
    #####: 1273:static int walk_tabpath(context_t *ctx) {
        -: 1274:	/* start from root */
    #####: 1275:	toml_table_t *curtab = ctx->root;
        -: 1276:
    #####: 1277:	for (int i = 0; i < ctx->tpath.top; i++) {
    #####: 1278:		const char *key = ctx->tpath.key[i];
        -: 1279:
    #####: 1280:		toml_keyval_t *nextval = 0;
    #####: 1281:		toml_array_t *nextarr = 0;
    #####: 1282:		toml_table_t *nexttab = 0;
    #####: 1283:		switch (check_key(curtab, key, &nextval, &nextarr, &nexttab)) {
    #####: 1284:		case 't':
        -: 1285:			/* found a table. nexttab is where we will go next. */
    #####: 1286:			break;
        -: 1287:
    #####: 1288:		case 'a':
        -: 1289:			/* found an array. nexttab is the last table in the
        -: 1290:			 * array. */
    #####: 1291:			if (nextarr->kind != 't')
    #####: 1292:				return e_internal(ctx, FLINE);
        -: 1293:
    #####: 1294:			if (nextarr->nitem == 0)
    #####: 1295:				return e_internal(ctx, FLINE);
        -: 1296:
    #####: 1297:			nexttab = nextarr->item[nextarr->nitem - 1].tab;
    #####: 1298:			break;
        -: 1299:
    #####: 1300:		case 'v':
    #####: 1301:			return e_keyexists(ctx, ctx->tpath.tok[i].lineno);
        -: 1302:
    #####: 1303:		default: { /* Not found. Let's create an implicit table. */
    #####: 1304:			int n = curtab->ntab;
    #####: 1305:			toml_table_t **base = (toml_table_t **)expand_ptrarr(
    #####: 1306:			    (void **)curtab->tab, n);
    #####: 1307:			if (0 == base)
    #####: 1308:				return e_outofmemory(ctx, FLINE);
        -: 1309:
    #####: 1310:			curtab->tab = base;
        -: 1311:
    #####: 1312:			if (0 == (base[n] = (toml_table_t *)CALLOC(
        -: 1313:				      1, sizeof(*base[n]))))
    #####: 1314:				return e_outofmemory(ctx, FLINE);
        -: 1315:
    #####: 1316:			if (0 == (base[n]->key = STRDUP(key)))
    #####: 1317:				return e_outofmemory(ctx, FLINE);
        -: 1318:
    #####: 1319:			nexttab = curtab->tab[curtab->ntab++];
        -: 1320:
        -: 1321:			/* tabs created by walk_tabpath are considered implicit
        -: 1322:			 */
    #####: 1323:			nexttab->implicit = true;
    #####: 1324:		} break;
        -: 1325:		}
        -: 1326:
        -: 1327:		/* switch to next tab */
    #####: 1328:		curtab = nexttab;
        -: 1329:	}
        -: 1330:
        -: 1331:	/* save it */
    #####: 1332:	ctx->curtab = curtab;
        -: 1333:
    #####: 1334:	return 0;
        -: 1335:}
        -: 1336:
        -: 1337:/* handle lines like [x.y.z] or [[x.y.z]] */
    #####: 1338:static int parse_select(context_t *ctx) {
    #####: 1339:	assert(ctx->tok.tok == LBRACKET);
        -: 1340:
        -: 1341:	/* true if [[ */
    #####: 1342:	int llb = (ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == '[');
        -: 1343:	/* need to detect '[[' on our own because next_token() will skip
        -: 1344:	   whitespace, and '[ [' would be taken as '[[', which is wrong. */
        -: 1345:
        -: 1346:	/* eat [ or [[ */
    #####: 1347:	if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1348:		return -1;
    #####: 1349:	if (llb) {
    #####: 1350:		assert(ctx->tok.tok == LBRACKET);
    #####: 1351:		if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1352:			return -1;
        -: 1353:	}
        -: 1354:
    #####: 1355:	if (fill_tabpath(ctx))
    #####: 1356:		return -1;
        -: 1357:
        -: 1358:	/* For [x.y.z] or [[x.y.z]], remove z from tpath.
        -: 1359:	 */
    #####: 1360:	token_t z = ctx->tpath.tok[ctx->tpath.top - 1];
    #####: 1361:	xfree(ctx->tpath.key[ctx->tpath.top - 1]);
    #####: 1362:	ctx->tpath.top--;
        -: 1363:
        -: 1364:	/* set up ctx->curtab */
    #####: 1365:	if (walk_tabpath(ctx))
    #####: 1366:		return -1;
        -: 1367:
    #####: 1368:	if (!llb) {
        -: 1369:		/* [x.y.z] -> create z = {} in x.y */
        -: 1370:		toml_table_t *curtab =
    #####: 1371:		    create_keytable_in_table(ctx, ctx->curtab, z);
    #####: 1372:		if (!curtab)
    #####: 1373:			return -1;
    #####: 1374:		ctx->curtab = curtab;
        -: 1375:	} else {
        -: 1376:		/* [[x.y.z]] -> create z = [] in x.y */
    #####: 1377:		toml_array_t *arr = 0;
        -: 1378:		{
    #####: 1379:			char *zstr = normalize_key(ctx, z);
    #####: 1380:			if (!zstr)
    #####: 1381:				return -1;
    #####: 1382:			arr = toml_array_in(ctx->curtab, zstr);
    #####: 1383:			xfree(zstr);
        -: 1384:		}
    #####: 1385:		if (!arr) {
        -: 1386:			arr =
    #####: 1387:			    create_keyarray_in_table(ctx, ctx->curtab, z, 't');
    #####: 1388:			if (!arr)
    #####: 1389:				return -1;
        -: 1390:		}
    #####: 1391:		if (arr->kind != 't')
    #####: 1392:			return e_syntax(ctx, z.lineno, "array mismatch");
        -: 1393:
        -: 1394:		/* add to z[] */
        -: 1395:		toml_table_t *dest;
        -: 1396:		{
    #####: 1397:			toml_table_t *t = create_table_in_array(ctx, arr);
    #####: 1398:			if (!t)
    #####: 1399:				return -1;
        -: 1400:
    #####: 1401:			if (0 == (t->key = STRDUP("__anon__")))
    #####: 1402:				return e_outofmemory(ctx, FLINE);
        -: 1403:
    #####: 1404:			dest = t;
        -: 1405:		}
        -: 1406:
    #####: 1407:		ctx->curtab = dest;
        -: 1408:	}
        -: 1409:
    #####: 1410:	if (ctx->tok.tok != RBRACKET) {
    #####: 1411:		return e_syntax(ctx, ctx->tok.lineno, "expects ]");
        -: 1412:	}
    #####: 1413:	if (llb) {
    #####: 1414:		if (!(ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == ']')) {
    #####: 1415:			return e_syntax(ctx, ctx->tok.lineno, "expects ]]");
        -: 1416:		}
    #####: 1417:		if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1418:			return -1;
        -: 1419:	}
        -: 1420:
    #####: 1421:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1422:		return -1;
        -: 1423:
    #####: 1424:	if (ctx->tok.tok != NEWLINE)
    #####: 1425:		return e_syntax(ctx, ctx->tok.lineno,
        -: 1426:				"extra chars after ] or ]]");
        -: 1427:
    #####: 1428:	return 0;
        -: 1429:}
        -: 1430:
    #####: 1431:toml_table_t *toml_parse(char *conf, char *errbuf, int errbufsz) {
        -: 1432:	context_t ctx;
        -: 1433:
        -: 1434:	// clear errbuf
    #####: 1435:	if (errbufsz <= 0)
    #####: 1436:		errbufsz = 0;
    #####: 1437:	if (errbufsz > 0)
    #####: 1438:		errbuf[0] = 0;
        -: 1439:
        -: 1440:	// init context
    #####: 1441:	memset(&ctx, 0, sizeof(ctx));
    #####: 1442:	ctx.start = conf;
    #####: 1443:	ctx.stop = ctx.start + strlen(conf);
    #####: 1444:	ctx.errbuf = errbuf;
    #####: 1445:	ctx.errbufsz = errbufsz;
        -: 1446:
        -: 1447:	// start with an artificial newline of length 0
    #####: 1448:	ctx.tok.tok = NEWLINE;
    #####: 1449:	ctx.tok.lineno = 1;
    #####: 1450:	ctx.tok.ptr = conf;
    #####: 1451:	ctx.tok.len = 0;
        -: 1452:
        -: 1453:	// make a root table
    #####: 1454:	if (0 == (ctx.root = CALLOC(1, sizeof(*ctx.root)))) {
    #####: 1455:		e_outofmemory(&ctx, FLINE);
        -: 1456:		// Do not goto fail, root table not set up yet
    #####: 1457:		return 0;
        -: 1458:	}
        -: 1459:
        -: 1460:	// set root as default table
    #####: 1461:	ctx.curtab = ctx.root;
        -: 1462:
        -: 1463:	/* Scan forward until EOF */
    #####: 1464:	for (token_t tok = ctx.tok; !tok.eof; tok = ctx.tok) {
    #####: 1465:		switch (tok.tok) {
        -: 1466:
    #####: 1467:		case NEWLINE:
    #####: 1468:			if (next_token(&ctx, 1))
    #####: 1469:				goto fail;
    #####: 1470:			break;
        -: 1471:
    #####: 1472:		case STRING:
    #####: 1473:			if (parse_keyval(&ctx, ctx.curtab))
    #####: 1474:				goto fail;
        -: 1475:
    #####: 1476:			if (ctx.tok.tok != NEWLINE) {
    #####: 1477:				e_syntax(&ctx, ctx.tok.lineno,
        -: 1478:					 "extra chars after value");
    #####: 1479:				goto fail;
        -: 1480:			}
        -: 1481:
    #####: 1482:			if (eat_token(&ctx, NEWLINE, 1, FLINE))
    #####: 1483:				goto fail;
    #####: 1484:			break;
        -: 1485:
    #####: 1486:		case LBRACKET: /* [ x.y.z ] or [[ x.y.z ]] */
    #####: 1487:			if (parse_select(&ctx))
    #####: 1488:				goto fail;
    #####: 1489:			break;
        -: 1490:
    #####: 1491:		default:
    #####: 1492:			e_syntax(&ctx, tok.lineno, "syntax error");
    #####: 1493:			goto fail;
        -: 1494:		}
        -: 1495:	}
        -: 1496:
        -: 1497:	/* success */
    #####: 1498:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1499:		xfree(ctx.tpath.key[i]);
    #####: 1500:	return ctx.root;
        -: 1501:
    #####: 1502:fail:
        -: 1503:	// Something bad has happened. Free resources and return error.
    #####: 1504:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1505:		xfree(ctx.tpath.key[i]);
    #####: 1506:	toml_free(ctx.root);
    #####: 1507:	return 0;
        -: 1508:}
        -: 1509:
    #####: 1510:toml_table_t *toml_parse_file(FILE *fp, char *errbuf, int errbufsz) {
    #####: 1511:	int bufsz = 0;
    #####: 1512:	char *buf = 0;
    #####: 1513:	int off = 0;
        -: 1514:
        -: 1515:	/* read from fp into buf */
    #####: 1516:	while (!feof(fp)) {
        -: 1517:
    #####: 1518:		if (off == bufsz) {
    #####: 1519:			int xsz = bufsz + 1000;
    #####: 1520:			char *x = expand(buf, bufsz, xsz);
    #####: 1521:			if (!x) {
    #####: 1522:				snprintf(errbuf, errbufsz, "out of memory");
    #####: 1523:				xfree(buf);
    #####: 1524:				return 0;
        -: 1525:			}
    #####: 1526:			buf = x;
    #####: 1527:			bufsz = xsz;
        -: 1528:		}
        -: 1529:
    #####: 1530:		errno = 0;
    #####: 1531:		int n = fread(buf + off, 1, bufsz - off, fp);
    #####: 1532:		if (ferror(fp)) {
    #####: 1533:			snprintf(errbuf, errbufsz, "%s",
    #####: 1534:				 errno ? strerror(errno)
        -: 1535:				       : "Error reading file");
    #####: 1536:			xfree(buf);
    #####: 1537:			return 0;
        -: 1538:		}
    #####: 1539:		off += n;
        -: 1540:	}
        -: 1541:
        -: 1542:	/* tag on a NUL to cap the string */
    #####: 1543:	if (off == bufsz) {
    #####: 1544:		int xsz = bufsz + 1;
    #####: 1545:		char *x = expand(buf, bufsz, xsz);
    #####: 1546:		if (!x) {
    #####: 1547:			snprintf(errbuf, errbufsz, "out of memory");
    #####: 1548:			xfree(buf);
    #####: 1549:			return 0;
        -: 1550:		}
    #####: 1551:		buf = x;
    #####: 1552:		bufsz = xsz;
        -: 1553:	}
    #####: 1554:	buf[off] = 0;
        -: 1555:
        -: 1556:	/* parse it, cleanup and finish */
    #####: 1557:	toml_table_t *ret = toml_parse(buf, errbuf, errbufsz);
    #####: 1558:	xfree(buf);
    #####: 1559:	return ret;
        -: 1560:}
        -: 1561:
    #####: 1562:static void xfree_kval(toml_keyval_t *p) {
    #####: 1563:	if (!p)
    #####: 1564:		return;
    #####: 1565:	xfree(p->key);
    #####: 1566:	xfree(p->val);
    #####: 1567:	xfree(p);
        -: 1568:}
        -: 1569:
        -: 1570:static void xfree_tab(toml_table_t *p);
        -: 1571:
    #####: 1572:static void xfree_arr(toml_array_t *p) {
    #####: 1573:	if (!p)
    #####: 1574:		return;
        -: 1575:
    #####: 1576:	xfree(p->key);
    #####: 1577:	const int n = p->nitem;
    #####: 1578:	for (int i = 0; i < n; i++) {
    #####: 1579:		toml_arritem_t *a = &p->item[i];
    #####: 1580:		if (a->val)
    #####: 1581:			xfree(a->val);
    #####: 1582:		else if (a->arr)
    #####: 1583:			xfree_arr(a->arr);
    #####: 1584:		else if (a->tab)
    #####: 1585:			xfree_tab(a->tab);
        -: 1586:	}
    #####: 1587:	xfree(p->item);
    #####: 1588:	xfree(p);
        -: 1589:}
        -: 1590:
    #####: 1591:static void xfree_tab(toml_table_t *p) {
        -: 1592:	int i;
        -: 1593:
    #####: 1594:	if (!p)
    #####: 1595:		return;
        -: 1596:
    #####: 1597:	xfree(p->key);
        -: 1598:
    #####: 1599:	for (i = 0; i < p->nkval; i++)
    #####: 1600:		xfree_kval(p->kval[i]);
    #####: 1601:	xfree(p->kval);
        -: 1602:
    #####: 1603:	for (i = 0; i < p->narr; i++)
    #####: 1604:		xfree_arr(p->arr[i]);
    #####: 1605:	xfree(p->arr);
        -: 1606:
    #####: 1607:	for (i = 0; i < p->ntab; i++)
    #####: 1608:		xfree_tab(p->tab[i]);
    #####: 1609:	xfree(p->tab);
        -: 1610:
    #####: 1611:	xfree(p);
        -: 1612:}
        -: 1613:
    #####: 1614:void toml_free(toml_table_t *tab) { xfree_tab(tab); }
        -: 1615:
    #####: 1616:static void set_token(context_t *ctx, tokentype_t tok, int lineno, char *ptr,
        -: 1617:		      int len) {
        -: 1618:	token_t t;
    #####: 1619:	t.tok = tok;
    #####: 1620:	t.lineno = lineno;
    #####: 1621:	t.ptr = ptr;
    #####: 1622:	t.len = len;
    #####: 1623:	t.eof = 0;
    #####: 1624:	ctx->tok = t;
    #####: 1625:}
        -: 1626:
    #####: 1627:static void set_eof(context_t *ctx, int lineno) {
    #####: 1628:	set_token(ctx, NEWLINE, lineno, ctx->stop, 0);
    #####: 1629:	ctx->tok.eof = 1;
    #####: 1630:}
        -: 1631:
        -: 1632:/* Scan p for n digits compositing entirely of [0-9] */
    #####: 1633:static int scan_digits(const char *p, int n) {
    #####: 1634:	int ret = 0;
    #####: 1635:	for (; n > 0 && isdigit(*p); n--, p++) {
    #####: 1636:		ret = 10 * ret + (*p - '0');
        -: 1637:	}
    #####: 1638:	return n ? -1 : ret;
        -: 1639:}
        -: 1640:
    #####: 1641:static int scan_date(const char *p, int *YY, int *MM, int *DD) {
        -: 1642:	int year, month, day;
    #####: 1643:	year = scan_digits(p, 4);
    #####: 1644:	month = (year >= 0 && p[4] == '-') ? scan_digits(p + 5, 2) : -1;
    #####: 1645:	day = (month >= 0 && p[7] == '-') ? scan_digits(p + 8, 2) : -1;
    #####: 1646:	if (YY)
    #####: 1647:		*YY = year;
    #####: 1648:	if (MM)
    #####: 1649:		*MM = month;
    #####: 1650:	if (DD)
    #####: 1651:		*DD = day;
    #####: 1652:	return (year >= 0 && month >= 0 && day >= 0) ? 0 : -1;
        -: 1653:}
        -: 1654:
    #####: 1655:static int scan_time(const char *p, int *hh, int *mm, int *ss) {
        -: 1656:	int hour, minute, second;
    #####: 1657:	hour = scan_digits(p, 2);
    #####: 1658:	minute = (hour >= 0 && p[2] == ':') ? scan_digits(p + 3, 2) : -1;
    #####: 1659:	second = (minute >= 0 && p[5] == ':') ? scan_digits(p + 6, 2) : -1;
    #####: 1660:	if (hh)
    #####: 1661:		*hh = hour;
    #####: 1662:	if (mm)
    #####: 1663:		*mm = minute;
    #####: 1664:	if (ss)
    #####: 1665:		*ss = second;
    #####: 1666:	return (hour >= 0 && minute >= 0 && second >= 0) ? 0 : -1;
        -: 1667:}
        -: 1668:
    #####: 1669:static int scan_string(context_t *ctx, char *p, int lineno, int dotisspecial) {
    #####: 1670:	char *orig = p;
    #####: 1671:	if (0 == strncmp(p, "'''", 3)) {
    #####: 1672:		char *q = p + 3;
        -: 1673:
        -: 1674:		while (1) {
    #####: 1675:			q = strstr(q, "'''");
    #####: 1676:			if (0 == q) {
    #####: 1677:				return e_syntax(ctx, lineno,
        -: 1678:						"unterminated triple-s-quote");
        -: 1679:			}
    #####: 1680:			while (q[3] == '\'')
    #####: 1681:				q++;
    #####: 1682:			break;
        -: 1683:		}
        -: 1684:
    #####: 1685:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1686:		return 0;
        -: 1687:	}
        -: 1688:
    #####: 1689:	if (0 == strncmp(p, "\"\"\"", 3)) {
    #####: 1690:		char *q = p + 3;
        -: 1691:
        -: 1692:		while (1) {
    #####: 1693:			q = strstr(q, "\"\"\"");
    #####: 1694:			if (0 == q) {
    #####: 1695:				return e_syntax(ctx, lineno,
        -: 1696:						"unterminated triple-d-quote");
        -: 1697:			}
    #####: 1698:			if (q[-1] == '\\') {
    #####: 1699:				q++;
    #####: 1700:				continue;
        -: 1701:			}
    #####: 1702:			while (q[3] == '\"')
    #####: 1703:				q++;
    #####: 1704:			break;
        -: 1705:		}
        -: 1706:
        -: 1707:		// the string is [p+3, q-1]
        -: 1708:
    #####: 1709:		int hexreq = 0; /* #hex required */
    #####: 1710:		int escape = 0;
    #####: 1711:		for (p += 3; p < q; p++) {
    #####: 1712:			if (escape) {
    #####: 1713:				escape = 0;
    #####: 1714:				if (strchr("btnfr\"\\", *p))
    #####: 1715:					continue;
    #####: 1716:				if (*p == 'u') {
    #####: 1717:					hexreq = 4;
    #####: 1718:					continue;
        -: 1719:				}
    #####: 1720:				if (*p == 'U') {
    #####: 1721:					hexreq = 8;
    #####: 1722:					continue;
        -: 1723:				}
    #####: 1724:				if (p[strspn(p, " \t\r")] == '\n')
    #####: 1725:					continue; /* allow for line ending
        -: 1726:						     backslash */
    #####: 1727:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1728:			}
    #####: 1729:			if (hexreq) {
    #####: 1730:				hexreq--;
    #####: 1731:				if (strchr("0123456789ABCDEF", *p))
    #####: 1732:					continue;
    #####: 1733:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1734:			}
    #####: 1735:			if (*p == '\\') {
    #####: 1736:				escape = 1;
    #####: 1737:				continue;
        -: 1738:			}
        -: 1739:		}
    #####: 1740:		if (escape)
    #####: 1741:			return e_syntax(ctx, lineno, "expect an escape char");
    #####: 1742:		if (hexreq)
    #####: 1743:			return e_syntax(ctx, lineno, "expected more hex char");
        -: 1744:
    #####: 1745:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1746:		return 0;
        -: 1747:	}
        -: 1748:
    #####: 1749:	if ('\'' == *p) {
    #####: 1750:		for (p++; *p && *p != '\n' && *p != '\''; p++)
        -: 1751:			;
    #####: 1752:		if (*p != '\'') {
    #####: 1753:			return e_syntax(ctx, lineno, "unterminated s-quote");
        -: 1754:		}
        -: 1755:
    #####: 1756:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1757:		return 0;
        -: 1758:	}
        -: 1759:
    #####: 1760:	if ('\"' == *p) {
    #####: 1761:		int hexreq = 0; /* #hex required */
    #####: 1762:		int escape = 0;
    #####: 1763:		for (p++; *p; p++) {
    #####: 1764:			if (escape) {
    #####: 1765:				escape = 0;
    #####: 1766:				if (strchr("btnfr\"\\", *p))
    #####: 1767:					continue;
    #####: 1768:				if (*p == 'u') {
    #####: 1769:					hexreq = 4;
    #####: 1770:					continue;
        -: 1771:				}
    #####: 1772:				if (*p == 'U') {
    #####: 1773:					hexreq = 8;
    #####: 1774:					continue;
        -: 1775:				}
    #####: 1776:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1777:			}
    #####: 1778:			if (hexreq) {
    #####: 1779:				hexreq--;
    #####: 1780:				if (strchr("0123456789ABCDEF", *p))
    #####: 1781:					continue;
    #####: 1782:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1783:			}
    #####: 1784:			if (*p == '\\') {
    #####: 1785:				escape = 1;
    #####: 1786:				continue;
        -: 1787:			}
    #####: 1788:			if (*p == '\'') {
    #####: 1789:				if (p[1] == '\'' && p[2] == '\'') {
    #####: 1790:					return e_syntax(
        -: 1791:					    ctx, lineno,
        -: 1792:					    "triple-s-quote inside string lit");
        -: 1793:				}
    #####: 1794:				continue;
        -: 1795:			}
    #####: 1796:			if (*p == '\n')
    #####: 1797:				break;
    #####: 1798:			if (*p == '"')
    #####: 1799:				break;
        -: 1800:		}
    #####: 1801:		if (*p != '"') {
    #####: 1802:			return e_syntax(ctx, lineno, "unterminated quote");
        -: 1803:		}
        -: 1804:
    #####: 1805:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1806:		return 0;
        -: 1807:	}
        -: 1808:
        -: 1809:	/* check for timestamp without quotes */
    #####: 1810:	if (0 == scan_date(p, 0, 0, 0) || 0 == scan_time(p, 0, 0, 0)) {
        -: 1811:		// forward thru the timestamp
    #####: 1812:		p += strspn(p, "0123456789.:+-Tt Zz");
        -: 1813:		// squeeze out any spaces at end of string
    #####: 1814:		for (; p[-1] == ' '; p--)
        -: 1815:			;
        -: 1816:		// tokenize
    #####: 1817:		set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 1818:		return 0;
        -: 1819:	}
        -: 1820:
        -: 1821:	/* literals */
    #####: 1822:	for (; *p && *p != '\n'; p++) {
    #####: 1823:		int ch = *p;
    #####: 1824:		if (ch == '.' && dotisspecial)
    #####: 1825:			break;
    #####: 1826:		if ('A' <= ch && ch <= 'Z')
    #####: 1827:			continue;
    #####: 1828:		if ('a' <= ch && ch <= 'z')
    #####: 1829:			continue;
    #####: 1830:		if (strchr("0123456789+-_.", ch))
    #####: 1831:			continue;
    #####: 1832:		break;
        -: 1833:	}
        -: 1834:
    #####: 1835:	set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 1836:	return 0;
        -: 1837:}
        -: 1838:
    #####: 1839:static int next_token(context_t *ctx, int dotisspecial) {
    #####: 1840:	int lineno = ctx->tok.lineno;
    #####: 1841:	char *p = ctx->tok.ptr;
        -: 1842:	int i;
        -: 1843:
        -: 1844:	/* eat this tok */
    #####: 1845:	for (i = 0; i < ctx->tok.len; i++) {
    #####: 1846:		if (*p++ == '\n')
    #####: 1847:			lineno++;
        -: 1848:	}
        -: 1849:
        -: 1850:	/* make next tok */
    #####: 1851:	while (p < ctx->stop) {
        -: 1852:		/* skip comment. stop just before the \n. */
    #####: 1853:		if (*p == '#') {
    #####: 1854:			for (p++; p < ctx->stop && *p != '\n'; p++)
        -: 1855:				;
    #####: 1856:			continue;
        -: 1857:		}
        -: 1858:
    #####: 1859:		if (dotisspecial && *p == '.') {
    #####: 1860:			set_token(ctx, DOT, lineno, p, 1);
    #####: 1861:			return 0;
        -: 1862:		}
        -: 1863:
    #####: 1864:		switch (*p) {
    #####: 1865:		case ',':
    #####: 1866:			set_token(ctx, COMMA, lineno, p, 1);
    #####: 1867:			return 0;
    #####: 1868:		case '=':
    #####: 1869:			set_token(ctx, EQUAL, lineno, p, 1);
    #####: 1870:			return 0;
    #####: 1871:		case '{':
    #####: 1872:			set_token(ctx, LBRACE, lineno, p, 1);
    #####: 1873:			return 0;
    #####: 1874:		case '}':
    #####: 1875:			set_token(ctx, RBRACE, lineno, p, 1);
    #####: 1876:			return 0;
    #####: 1877:		case '[':
    #####: 1878:			set_token(ctx, LBRACKET, lineno, p, 1);
    #####: 1879:			return 0;
    #####: 1880:		case ']':
    #####: 1881:			set_token(ctx, RBRACKET, lineno, p, 1);
    #####: 1882:			return 0;
    #####: 1883:		case '\n':
    #####: 1884:			set_token(ctx, NEWLINE, lineno, p, 1);
    #####: 1885:			return 0;
    #####: 1886:		case '\r':
        -: 1887:		case ' ':
        -: 1888:		case '\t':
        -: 1889:			/* ignore white spaces */
    #####: 1890:			p++;
    #####: 1891:			continue;
        -: 1892:		}
        -: 1893:
    #####: 1894:		return scan_string(ctx, p, lineno, dotisspecial);
        -: 1895:	}
        -: 1896:
    #####: 1897:	set_eof(ctx, lineno);
    #####: 1898:	return 0;
        -: 1899:}
        -: 1900:
    #####: 1901:const char *toml_key_in(const toml_table_t *tab, int keyidx) {
    #####: 1902:	if (keyidx < tab->nkval)
    #####: 1903:		return tab->kval[keyidx]->key;
        -: 1904:
    #####: 1905:	keyidx -= tab->nkval;
    #####: 1906:	if (keyidx < tab->narr)
    #####: 1907:		return tab->arr[keyidx]->key;
        -: 1908:
    #####: 1909:	keyidx -= tab->narr;
    #####: 1910:	if (keyidx < tab->ntab)
    #####: 1911:		return tab->tab[keyidx]->key;
        -: 1912:
    #####: 1913:	return 0;
        -: 1914:}
        -: 1915:
    #####: 1916:int toml_key_exists(const toml_table_t *tab, const char *key) {
        -: 1917:	int i;
    #####: 1918:	for (i = 0; i < tab->nkval; i++) {
    #####: 1919:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 1920:			return 1;
        -: 1921:	}
    #####: 1922:	for (i = 0; i < tab->narr; i++) {
    #####: 1923:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 1924:			return 1;
        -: 1925:	}
    #####: 1926:	for (i = 0; i < tab->ntab; i++) {
    #####: 1927:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 1928:			return 1;
        -: 1929:	}
    #####: 1930:	return 0;
        -: 1931:}
        -: 1932:
    #####: 1933:toml_raw_t toml_raw_in(const toml_table_t *tab, const char *key) {
        -: 1934:	int i;
    #####: 1935:	for (i = 0; i < tab->nkval; i++) {
    #####: 1936:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 1937:			return tab->kval[i]->val;
        -: 1938:	}
    #####: 1939:	return 0;
        -: 1940:}
        -: 1941:
    #####: 1942:toml_array_t *toml_array_in(const toml_table_t *tab, const char *key) {
        -: 1943:	int i;
    #####: 1944:	for (i = 0; i < tab->narr; i++) {
    #####: 1945:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 1946:			return tab->arr[i];
        -: 1947:	}
    #####: 1948:	return 0;
        -: 1949:}
        -: 1950:
    #####: 1951:toml_table_t *toml_table_in(const toml_table_t *tab, const char *key) {
        -: 1952:	int i;
    #####: 1953:	for (i = 0; i < tab->ntab; i++) {
    #####: 1954:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 1955:			return tab->tab[i];
        -: 1956:	}
    #####: 1957:	return 0;
        -: 1958:}
        -: 1959:
    #####: 1960:toml_raw_t toml_raw_at(const toml_array_t *arr, int idx) {
    #####: 1961:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].val : 0;
        -: 1962:}
        -: 1963:
    #####: 1964:char toml_array_kind(const toml_array_t *arr) { return arr->kind; }
        -: 1965:
    #####: 1966:char toml_array_type(const toml_array_t *arr) {
    #####: 1967:	if (arr->kind != 'v')
    #####: 1968:		return 0;
        -: 1969:
    #####: 1970:	if (arr->nitem == 0)
    #####: 1971:		return 0;
        -: 1972:
    #####: 1973:	return arr->type;
        -: 1974:}
        -: 1975:
    #####: 1976:int toml_array_nelem(const toml_array_t *arr) { return arr->nitem; }
        -: 1977:
    #####: 1978:const char *toml_array_key(const toml_array_t *arr) {
    #####: 1979:	return arr ? arr->key : (const char *)NULL;
        -: 1980:}
        -: 1981:
    #####: 1982:int toml_table_nkval(const toml_table_t *tab) { return tab->nkval; }
        -: 1983:
    #####: 1984:int toml_table_narr(const toml_table_t *tab) { return tab->narr; }
        -: 1985:
    #####: 1986:int toml_table_ntab(const toml_table_t *tab) { return tab->ntab; }
        -: 1987:
    #####: 1988:const char *toml_table_key(const toml_table_t *tab) {
    #####: 1989:	return tab ? tab->key : (const char *)NULL;
        -: 1990:}
        -: 1991:
    #####: 1992:toml_array_t *toml_array_at(const toml_array_t *arr, int idx) {
    #####: 1993:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].arr : 0;
        -: 1994:}
        -: 1995:
    #####: 1996:toml_table_t *toml_table_at(const toml_array_t *arr, int idx) {
    #####: 1997:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].tab : 0;
        -: 1998:}
        -: 1999:
        -: 2000:static int parse_millisec(const char *p, const char **endp);
        -: 2001:
    #####: 2002:int toml_rtots(toml_raw_t src_, toml_timestamp_t *ret) {
    #####: 2003:	if (!src_)
    #####: 2004:		return -1;
        -: 2005:
    #####: 2006:	const char *p = src_;
    #####: 2007:	int must_parse_time = 0;
        -: 2008:
    #####: 2009:	memset(ret, 0, sizeof(*ret));
        -: 2010:
    #####: 2011:	int *year = &ret->__buffer.year;
    #####: 2012:	int *month = &ret->__buffer.month;
    #####: 2013:	int *day = &ret->__buffer.day;
    #####: 2014:	int *hour = &ret->__buffer.hour;
    #####: 2015:	int *minute = &ret->__buffer.minute;
    #####: 2016:	int *second = &ret->__buffer.second;
    #####: 2017:	int *millisec = &ret->__buffer.millisec;
        -: 2018:
        -: 2019:	/* parse date YYYY-MM-DD */
    #####: 2020:	if (0 == scan_date(p, year, month, day)) {
    #####: 2021:		ret->year = year;
    #####: 2022:		ret->month = month;
    #####: 2023:		ret->day = day;
        -: 2024:
    #####: 2025:		p += 10;
    #####: 2026:		if (*p) {
        -: 2027:			// parse the T or space separator
    #####: 2028:			if (*p != 'T' && *p != 't' && *p != ' ')
    #####: 2029:				return -1;
    #####: 2030:			must_parse_time = 1;
    #####: 2031:			p++;
        -: 2032:		}
        -: 2033:	}
        -: 2034:
        -: 2035:	/* parse time HH:MM:SS */
    #####: 2036:	if (0 == scan_time(p, hour, minute, second)) {
    #####: 2037:		ret->hour = hour;
    #####: 2038:		ret->minute = minute;
    #####: 2039:		ret->second = second;
        -: 2040:
        -: 2041:		/* optionally, parse millisec */
    #####: 2042:		p += 8;
    #####: 2043:		if (*p == '.') {
    #####: 2044:			p++; /* skip '.' */
        -: 2045:			const char *qq;
    #####: 2046:			*millisec = parse_millisec(p, &qq);
    #####: 2047:			ret->millisec = millisec;
    #####: 2048:			p = qq;
        -: 2049:		}
        -: 2050:
    #####: 2051:		if (*p) {
        -: 2052:			/* parse and copy Z */
    #####: 2053:			char *z = ret->__buffer.z;
    #####: 2054:			ret->z = z;
    #####: 2055:			if (*p == 'Z' || *p == 'z') {
    #####: 2056:				*z++ = 'Z';
    #####: 2057:				p++;
    #####: 2058:				*z = 0;
        -: 2059:
    #####: 2060:			} else if (*p == '+' || *p == '-') {
    #####: 2061:				*z++ = *p++;
        -: 2062:
    #####: 2063:				if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2064:					return -1;
    #####: 2065:				*z++ = *p++;
    #####: 2066:				*z++ = *p++;
        -: 2067:
    #####: 2068:				if (*p == ':') {
    #####: 2069:					*z++ = *p++;
        -: 2070:
    #####: 2071:					if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2072:						return -1;
    #####: 2073:					*z++ = *p++;
    #####: 2074:					*z++ = *p++;
        -: 2075:				}
        -: 2076:
    #####: 2077:				*z = 0;
        -: 2078:			}
        -: 2079:		}
        -: 2080:	}
    #####: 2081:	if (*p != 0)
    #####: 2082:		return -1;
        -: 2083:
    #####: 2084:	if (must_parse_time && !ret->hour)
    #####: 2085:		return -1;
        -: 2086:
    #####: 2087:	return 0;
        -: 2088:}
        -: 2089:
        -: 2090:/* Raw to boolean */
    #####: 2091:int toml_rtob(toml_raw_t src, int *ret_) {
    #####: 2092:	if (!src)
    #####: 2093:		return -1;
        -: 2094:	int dummy;
    #####: 2095:	int *ret = ret_ ? ret_ : &dummy;
        -: 2096:
    #####: 2097:	if (0 == strcmp(src, "true")) {
    #####: 2098:		*ret = 1;
    #####: 2099:		return 0;
        -: 2100:	}
    #####: 2101:	if (0 == strcmp(src, "false")) {
    #####: 2102:		*ret = 0;
    #####: 2103:		return 0;
        -: 2104:	}
    #####: 2105:	return -1;
        -: 2106:}
        -: 2107:
        -: 2108:/* Raw to integer */
    #####: 2109:int toml_rtoi(toml_raw_t src, int64_t *ret_) {
    #####: 2110:	if (!src)
    #####: 2111:		return -1;
        -: 2112:
        -: 2113:	char buf[100];
    #####: 2114:	char *p = buf;
    #####: 2115:	char *q = p + sizeof(buf);
    #####: 2116:	const char *s = src;
    #####: 2117:	int base = 0;
        -: 2118:	int64_t dummy;
    #####: 2119:	int64_t *ret = ret_ ? ret_ : &dummy;
        -: 2120:
        -: 2121:	/* allow +/- */
    #####: 2122:	if (s[0] == '+' || s[0] == '-')
    #####: 2123:		*p++ = *s++;
        -: 2124:
        -: 2125:	/* disallow +_100 */
    #####: 2126:	if (s[0] == '_')
    #####: 2127:		return -1;
        -: 2128:
        -: 2129:	/* if 0* ... */
    #####: 2130:	if ('0' == s[0]) {
    #####: 2131:		switch (s[1]) {
    #####: 2132:		case 'x':
    #####: 2133:			base = 16;
    #####: 2134:			s += 2;
    #####: 2135:			break;
    #####: 2136:		case 'o':
    #####: 2137:			base = 8;
    #####: 2138:			s += 2;
    #####: 2139:			break;
    #####: 2140:		case 'b':
    #####: 2141:			base = 2;
    #####: 2142:			s += 2;
    #####: 2143:			break;
    #####: 2144:		case '\0':
    #####: 2145:			return *ret = 0, 0;
    #####: 2146:		default:
        -: 2147:			/* ensure no other digits after it */
    #####: 2148:			if (s[1])
    #####: 2149:				return -1;
        -: 2150:		}
        -: 2151:	}
        -: 2152:
        -: 2153:	/* just strip underscores and pass to strtoll */
    #####: 2154:	while (*s && p < q) {
    #####: 2155:		int ch = *s++;
    #####: 2156:		if (ch == '_') {
        -: 2157:			// disallow '__'
    #####: 2158:			if (s[0] == '_')
    #####: 2159:				return -1;
        -: 2160:			// numbers cannot end with '_'
    #####: 2161:			if (s[0] == '\0')
    #####: 2162:				return -1;
    #####: 2163:			continue; /* skip _ */
        -: 2164:		}
    #####: 2165:		*p++ = ch;
        -: 2166:	}
        -: 2167:
        -: 2168:	// if not at end-of-string or we ran out of buffer ...
    #####: 2169:	if (*s || p == q)
    #####: 2170:		return -1;
        -: 2171:
        -: 2172:	/* cap with NUL */
    #####: 2173:	*p = 0;
        -: 2174:
        -: 2175:	/* Run strtoll on buf to get the integer */
        -: 2176:	char *endp;
    #####: 2177:	errno = 0;
    #####: 2178:	*ret = strtoll(buf, &endp, base);
    #####: 2179:	return (errno || *endp) ? -1 : 0;
        -: 2180:}
        -: 2181:
    #####: 2182:int toml_rtod_ex(toml_raw_t src, double *ret_, char *buf, int buflen) {
    #####: 2183:	if (!src)
    #####: 2184:		return -1;
        -: 2185:
    #####: 2186:	char *p = buf;
    #####: 2187:	char *q = p + buflen;
    #####: 2188:	const char *s = src;
        -: 2189:	double dummy;
    #####: 2190:	double *ret = ret_ ? ret_ : &dummy;
        -: 2191:
        -: 2192:	/* allow +/- */
    #####: 2193:	if (s[0] == '+' || s[0] == '-')
    #####: 2194:		*p++ = *s++;
        -: 2195:
        -: 2196:	/* disallow +_1.00 */
    #####: 2197:	if (s[0] == '_')
    #####: 2198:		return -1;
        -: 2199:
        -: 2200:	/* decimal point, if used, must be surrounded by at least one digit on
        -: 2201:	 * each side */
        -: 2202:	{
    #####: 2203:		char *dot = strchr(s, '.');
    #####: 2204:		if (dot) {
    #####: 2205:			if (dot == s || !isdigit(dot[-1]) || !isdigit(dot[1]))
    #####: 2206:				return -1;
        -: 2207:		}
        -: 2208:	}
        -: 2209:
        -: 2210:	/* zero must be followed by . or 'e', or NUL */
    #####: 2211:	if (s[0] == '0' && s[1] && !strchr("eE.", s[1]))
    #####: 2212:		return -1;
        -: 2213:
        -: 2214:	/* just strip underscores and pass to strtod */
    #####: 2215:	while (*s && p < q) {
    #####: 2216:		int ch = *s++;
    #####: 2217:		if (ch == '_') {
        -: 2218:			// disallow '__'
    #####: 2219:			if (s[0] == '_')
    #####: 2220:				return -1;
        -: 2221:			// disallow last char '_'
    #####: 2222:			if (s[0] == 0)
    #####: 2223:				return -1;
    #####: 2224:			continue; /* skip _ */
        -: 2225:		}
    #####: 2226:		*p++ = ch;
        -: 2227:	}
    #####: 2228:	if (*s || p == q)
    #####: 2229:		return -1; /* reached end of string or buffer is full? */
        -: 2230:
        -: 2231:	/* cap with NUL */
    #####: 2232:	*p = 0;
        -: 2233:
        -: 2234:	/* Run strtod on buf to get the value */
        -: 2235:	char *endp;
    #####: 2236:	errno = 0;
    #####: 2237:	*ret = strtod(buf, &endp);
    #####: 2238:	return (errno || *endp) ? -1 : 0;
        -: 2239:}
        -: 2240:
    #####: 2241:int toml_rtod(toml_raw_t src, double *ret_) {
        -: 2242:	char buf[100];
    #####: 2243:	return toml_rtod_ex(src, ret_, buf, sizeof(buf));
        -: 2244:}
        -: 2245:
    #####: 2246:int toml_rtos(toml_raw_t src, char **ret) {
    #####: 2247:	int multiline = 0;
        -: 2248:	const char *sp;
        -: 2249:	const char *sq;
        -: 2250:
    #####: 2251:	*ret = 0;
    #####: 2252:	if (!src)
    #####: 2253:		return -1;
        -: 2254:
        -: 2255:	// for strings, first char must be a s-quote or d-quote
    #####: 2256:	int qchar = src[0];
    #####: 2257:	int srclen = strlen(src);
    #####: 2258:	if (!(qchar == '\'' || qchar == '"')) {
    #####: 2259:		return -1;
        -: 2260:	}
        -: 2261:
        -: 2262:	// triple quotes?
    #####: 2263:	if (qchar == src[1] && qchar == src[2]) {
    #####: 2264:		multiline = 1;	       // triple-quote implies multiline
    #####: 2265:		sp = src + 3;	       // first char after quote
    #####: 2266:		sq = src + srclen - 3; // first char of ending quote
        -: 2267:
    #####: 2268:		if (!(sp <= sq && sq[0] == qchar && sq[1] == qchar &&
    #####: 2269:		      sq[2] == qchar)) {
        -: 2270:			// last 3 chars in src must be qchar
    #####: 2271:			return -1;
        -: 2272:		}
        -: 2273:
        -: 2274:		/* skip new line immediate after qchar */
    #####: 2275:		if (sp[0] == '\n')
    #####: 2276:			sp++;
    #####: 2277:		else if (sp[0] == '\r' && sp[1] == '\n')
    #####: 2278:			sp += 2;
        -: 2279:
        -: 2280:	} else {
    #####: 2281:		sp = src + 1;	       // first char after quote
    #####: 2282:		sq = src + srclen - 1; // ending quote
    #####: 2283:		if (!(sp <= sq && *sq == qchar)) {
        -: 2284:			/* last char in src must be qchar */
    #####: 2285:			return -1;
        -: 2286:		}
        -: 2287:	}
        -: 2288:
        -: 2289:	// at this point:
        -: 2290:	//     sp points to first valid char after quote.
        -: 2291:	//     sq points to one char beyond last valid char.
        -: 2292:	//     string len is (sq - sp).
    #####: 2293:	if (qchar == '\'') {
    #####: 2294:		*ret = norm_lit_str(sp, sq - sp, multiline, 0, 0);
        -: 2295:	} else {
    #####: 2296:		*ret = norm_basic_str(sp, sq - sp, multiline, 0, 0);
        -: 2297:	}
        -: 2298:
    #####: 2299:	return *ret ? 0 : -1;
        -: 2300:}
        -: 2301:
    #####: 2302:toml_datum_t toml_string_at(const toml_array_t *arr, int idx) {
        -: 2303:	toml_datum_t ret;
    #####: 2304:	memset(&ret, 0, sizeof(ret));
    #####: 2305:	ret.ok = (0 == toml_rtos(toml_raw_at(arr, idx), &ret.u.s));
    #####: 2306:	return ret;
        -: 2307:}
        -: 2308:
    #####: 2309:toml_datum_t toml_bool_at(const toml_array_t *arr, int idx) {
        -: 2310:	toml_datum_t ret;
    #####: 2311:	memset(&ret, 0, sizeof(ret));
    #####: 2312:	ret.ok = (0 == toml_rtob(toml_raw_at(arr, idx), &ret.u.b));
    #####: 2313:	return ret;
        -: 2314:}
        -: 2315:
    #####: 2316:toml_datum_t toml_int_at(const toml_array_t *arr, int idx) {
        -: 2317:	toml_datum_t ret;
    #####: 2318:	memset(&ret, 0, sizeof(ret));
    #####: 2319:	ret.ok = (0 == toml_rtoi(toml_raw_at(arr, idx), &ret.u.i));
    #####: 2320:	return ret;
        -: 2321:}
        -: 2322:
    #####: 2323:toml_datum_t toml_double_at(const toml_array_t *arr, int idx) {
        -: 2324:	toml_datum_t ret;
    #####: 2325:	memset(&ret, 0, sizeof(ret));
    #####: 2326:	ret.ok = (0 == toml_rtod(toml_raw_at(arr, idx), &ret.u.d));
    #####: 2327:	return ret;
        -: 2328:}
        -: 2329:
    #####: 2330:toml_datum_t toml_timestamp_at(const toml_array_t *arr, int idx) {
        -: 2331:	toml_timestamp_t ts;
        -: 2332:	toml_datum_t ret;
    #####: 2333:	memset(&ret, 0, sizeof(ret));
    #####: 2334:	ret.ok = (0 == toml_rtots(toml_raw_at(arr, idx), &ts));
    #####: 2335:	if (ret.ok) {
    #####: 2336:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2337:		if (ret.ok) {
    #####: 2338:			*ret.u.ts = ts;
    #####: 2339:			if (ret.u.ts->year)
    #####: 2340:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2341:			if (ret.u.ts->month)
    #####: 2342:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2343:			if (ret.u.ts->day)
    #####: 2344:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2345:			if (ret.u.ts->hour)
    #####: 2346:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2347:			if (ret.u.ts->minute)
    #####: 2348:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2349:			if (ret.u.ts->second)
    #####: 2350:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2351:			if (ret.u.ts->millisec)
    #####: 2352:				ret.u.ts->millisec =
    #####: 2353:				    &ret.u.ts->__buffer.millisec;
    #####: 2354:			if (ret.u.ts->z)
    #####: 2355:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2356:		}
        -: 2357:	}
    #####: 2358:	return ret;
        -: 2359:}
        -: 2360:
    #####: 2361:toml_datum_t toml_string_in(const toml_table_t *arr, const char *key) {
        -: 2362:	toml_datum_t ret;
    #####: 2363:	memset(&ret, 0, sizeof(ret));
    #####: 2364:	toml_raw_t raw = toml_raw_in(arr, key);
    #####: 2365:	if (raw) {
    #####: 2366:		ret.ok = (0 == toml_rtos(raw, &ret.u.s));
        -: 2367:	}
    #####: 2368:	return ret;
        -: 2369:}
        -: 2370:
    #####: 2371:toml_datum_t toml_bool_in(const toml_table_t *arr, const char *key) {
        -: 2372:	toml_datum_t ret;
    #####: 2373:	memset(&ret, 0, sizeof(ret));
    #####: 2374:	ret.ok = (0 == toml_rtob(toml_raw_in(arr, key), &ret.u.b));
    #####: 2375:	return ret;
        -: 2376:}
        -: 2377:
    #####: 2378:toml_datum_t toml_int_in(const toml_table_t *arr, const char *key) {
        -: 2379:	toml_datum_t ret;
    #####: 2380:	memset(&ret, 0, sizeof(ret));
    #####: 2381:	ret.ok = (0 == toml_rtoi(toml_raw_in(arr, key), &ret.u.i));
    #####: 2382:	return ret;
        -: 2383:}
        -: 2384:
    #####: 2385:toml_datum_t toml_double_in(const toml_table_t *arr, const char *key) {
        -: 2386:	toml_datum_t ret;
    #####: 2387:	memset(&ret, 0, sizeof(ret));
    #####: 2388:	ret.ok = (0 == toml_rtod(toml_raw_in(arr, key), &ret.u.d));
    #####: 2389:	return ret;
        -: 2390:}
        -: 2391:
    #####: 2392:toml_datum_t toml_timestamp_in(const toml_table_t *arr, const char *key) {
        -: 2393:	toml_timestamp_t ts;
        -: 2394:	toml_datum_t ret;
    #####: 2395:	memset(&ret, 0, sizeof(ret));
    #####: 2396:	ret.ok = (0 == toml_rtots(toml_raw_in(arr, key), &ts));
    #####: 2397:	if (ret.ok) {
    #####: 2398:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2399:		if (ret.ok) {
    #####: 2400:			*ret.u.ts = ts;
    #####: 2401:			if (ret.u.ts->year)
    #####: 2402:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2403:			if (ret.u.ts->month)
    #####: 2404:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2405:			if (ret.u.ts->day)
    #####: 2406:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2407:			if (ret.u.ts->hour)
    #####: 2408:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2409:			if (ret.u.ts->minute)
    #####: 2410:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2411:			if (ret.u.ts->second)
    #####: 2412:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2413:			if (ret.u.ts->millisec)
    #####: 2414:				ret.u.ts->millisec =
    #####: 2415:				    &ret.u.ts->__buffer.millisec;
    #####: 2416:			if (ret.u.ts->z)
    #####: 2417:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2418:		}
        -: 2419:	}
    #####: 2420:	return ret;
        -: 2421:}
        -: 2422:
    #####: 2423:static int parse_millisec(const char *p, const char **endp) {
    #####: 2424:	int ret = 0;
    #####: 2425:	int unit = 100; /* unit in millisec */
    #####: 2426:	for (; '0' <= *p && *p <= '9'; p++, unit /= 10) {
    #####: 2427:		ret += (*p - '0') * unit;
        -: 2428:	}
    #####: 2429:	*endp = p;
    #####: 2430:	return ret;
        -: 2431:}
        -:    0:Source:chain_allocator.c
        -:    0:Graph:chain_allocator.gcno
        -:    0:Data:chain_allocator.gcda
        -:    0:Runs:19
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/chain_allocator.h>
        -:   16:#include <core/panic.h>
        -:   17:#include <errno.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:
        -:   21:// the default heap allocator for the current thread
        -:   22:_Thread_local HeapAllocator *__default_tl_heap_allocator = NULL;
        -:   23:
        -:   24:// the global heap allocator (used when the memory will potentially be
        -:   25:// deallocated in a different thread than it was created in
        -:   26:HeapAllocator *__global_sync_allocator = NULL;
        -:   27:// lock for the global heap allocator
        -:   28:Lock *__global_sync_allocator_lock = NULL;
        -:   29:
        -:   30:// default heap allocator config (no_malloc and zeroed are disabled)
        -:   31:HeapAllocatorConfig __default_hconfig_ = {false, false};
        -:   32:
        -:   33:// create default slab sizes for the heap allocator with alignment in mind
        -:   34:#define HD_CFG(size)                                                           \
        -:   35:	{ size, 10, 0, UINT32_MAX }
        -:   36:HeapDataParamsConfig __default_hdpc_arr_value[] = {HD_CFG(8),
        -:   37:						   HD_CFG(16),
        -:   38:						   HD_CFG(32),
        -:   39:						   HD_CFG(48),
        -:   40:						   HD_CFG(64),
        -:   41:						   HD_CFG(80),
        -:   42:						   HD_CFG(96),
        -:   43:						   HD_CFG(112),
        -:   44:						   HD_CFG(128),
        -:   45:						   HD_CFG(144),
        -:   46:						   HD_CFG(160),
        -:   47:						   HD_CFG(176),
        -:   48:						   HD_CFG(192),
        -:   49:						   HD_CFG(208),
        -:   50:						   HD_CFG(224),
        -:   51:						   HD_CFG(240),
        -:   52:						   HD_CFG(256),
        -:   53:						   HD_CFG(272),
        -:   54:						   HD_CFG(288),
        -:   55:						   HD_CFG(304),
        -:   56:						   HD_CFG(320),
        -:   57:						   HD_CFG(336),
        -:   58:						   HD_CFG(352),
        -:   59:						   HD_CFG(368),
        -:   60:						   HD_CFG(384),
        -:   61:						   HD_CFG(400),
        -:   62:						   HD_CFG(416),
        -:   63:						   HD_CFG(432),
        -:   64:						   HD_CFG(448),
        -:   65:						   HD_CFG(464),
        -:   66:						   HD_CFG(480),
        -:   67:						   HD_CFG(496),
        -:   68:						   HD_CFG(512),
        -:   69:						   HD_CFG(1024),
        -:   70:						   HD_CFG(2048),
        -:   71:						   HD_CFG(4096),
        -:   72:						   HD_CFG(8192),
        -:   73:						   {16384, 5, 0, UINT32_MAX},
        -:   74:						   {32768, 5, 0, UINT32_MAX},
        -:   75:						   {65536, 2, 0, UINT32_MAX}};
        -:   76:
        -:   77:// heap allocator config
        -:   78:HeapDataParamsConfig *__default_hdpc_arr_ = __default_hdpc_arr_value;
        -:   79:
        -:   80:// the size of the default array
        -:   81:u64 __default_hdpc_arr_size =
        -:   82:    sizeof(__default_hdpc_arr_value) / sizeof(__default_hdpc_arr_value[0]);
        -:   83:
        -:   84:// allows for overwriting the hconfig
    #####:   85:void set_default_hconfig(HeapAllocatorConfig *hconfig) {
    #####:   86:	__default_hconfig_ = *hconfig;
    #####:   87:}
        -:   88:
        -:   89:// allows for overwriting of the default hdpc array
        2:   90:void set_default_hdpc_arr(HeapDataParamsConfig arr[], u64 size) {
        2:   91:	__default_hdpc_arr_ = arr;
        2:   92:	__default_hdpc_arr_size = size;
        2:   93:}
        -:   94:
        -:   95:// build the using the default heap allocator config
        9:   96:int build_default_heap_allocator(HeapAllocator *ptr) {
        9:   97:	return heap_allocator_build_arr(ptr, &__default_hconfig_,
        -:   98:					__default_hdpc_arr_,
        -:   99:					__default_hdpc_arr_size);
        -:  100:}
        -:  101:
        -:  102:// init the global sync allocator
        4:  103:void global_sync_allocator_init() {
        -:  104:	// allocate for the data structure
        4:  105:	__global_sync_allocator = malloc(sizeof(HeapAllocator));
        4:  106:	__global_sync_allocator_lock = malloc(sizeof(Lock));
        -:  107:
        -:  108:	// check for failures
        4:  109:	if (__global_sync_allocator_lock == NULL ||
        4:  110:	    __global_sync_allocator == NULL) {
        -:  111:		// deallocate and panic
    #####:  112:		if (__global_sync_allocator_lock != NULL)
    #####:  113:			free(__global_sync_allocator_lock);
    #####:  114:		if (__global_sync_allocator != NULL)
    #####:  115:			free(__global_sync_allocator);
    #####:  116:		panic("Could not initialize the global sync HeapAllocator");
        -:  117:	}
        -:  118:
        -:  119:	// setup the lock
        4:  120:	*__global_sync_allocator_lock = LOCK();
        -:  121:
        -:  122:	// build with the default configurations
        4:  123:	if (build_default_heap_allocator(__global_sync_allocator)) {
    #####:  124:		free(__global_sync_allocator);
    #####:  125:		panic("Could not initialize the global sync HeapAllocator");
        -:  126:	}
        4:  127:}
        -:  128:
        -:  129:// Entry for the chain allocator stack.
        -:  130:typedef struct ChainGuardEntry {
        -:  131:	HeapAllocator *ha;
        -:  132:	bool is_sync;
        -:  133:	Lock *lock;
        -:  134:} ChainGuardEntry;
        -:  135:
        -:  136:// stack for chain allocators
        -:  137:_Thread_local ChainGuardEntry
        -:  138:    __thread_local_chain_allocator[MAX_CHAIN_ALLOCATOR_DEPTH];
        -:  139:_Thread_local u64 __thread_local_chain_allocator_index = 0;
        -:  140:
        -:  141:// cleanup the local thread allocator (used when threads terminate)
        1:  142:void thread_local_allocator_cleanup() {
        1:  143:	if (__thread_local_chain_allocator_index > 0)
        1:  144:		heap_allocator_cleanup(
        -:  145:		    __thread_local_chain_allocator
        -:  146:			[__thread_local_chain_allocator_index]
        -:  147:			    .ha);
        1:  148:}
        -:  149:
        1:  150:void global_sync_allocator_cleanup() {
        1:  151:	if (__global_sync_allocator != NULL)
        1:  152:		heap_allocator_cleanup(__global_sync_allocator);
        1:  153:}
        -:  154:
        7:  155:void chain_guard_cleanup(ChainGuard *ptr) {
        7:  156:	__thread_local_chain_allocator_index--;
        7:  157:}
        -:  158:
       10:  159:ChainGuard chain_guard(ChainConfig *config) {
       10:  160:	if (__thread_local_chain_allocator_index >= MAX_CHAIN_ALLOCATOR_DEPTH)
    #####:  161:		panic("too many chain allocators");
        -:  162:
       10:  163:	ChainGuardPtr ret = {__thread_local_chain_allocator_index, config->ha,
       10:  164:			     config->is_sync, config->lock};
        -:  165:
        -:  166:	__thread_local_chain_allocator[__thread_local_chain_allocator_index]
       10:  167:	    .ha = config->ha;
        -:  168:	__thread_local_chain_allocator[__thread_local_chain_allocator_index]
       10:  169:	    .is_sync = config->is_sync;
        -:  170:	__thread_local_chain_allocator[__thread_local_chain_allocator_index]
       10:  171:	    .lock = config->lock;
        -:  172:
       10:  173:	__thread_local_chain_allocator_index++;
       10:  174:	return ret;
        -:  175:}
        -:  176:
       21:  177:int chain_malloc(FatPtr *ptr, u64 size) {
       21:  178:	if (__thread_local_chain_allocator_index == 0) {
        -:  179:		// thread local allocator has not been initialized. Create it
        -:  180:		// now.
        5:  181:		HeapAllocator *ha = malloc(sizeof(HeapAllocator));
        5:  182:		if (!ha)
    #####:  183:			return -1;
        -:  184:
        5:  185:		if (build_default_heap_allocator(ha)) {
    #####:  186:			free(ha);
    #####:  187:			return -1;
        -:  188:		};
        -:  189:
        5:  190:		__default_tl_heap_allocator = ha;
        5:  191:		__thread_local_chain_allocator[0].ha = ha;
        5:  192:		__thread_local_chain_allocator[0].is_sync = false;
        5:  193:		__thread_local_chain_allocator_index++;
        -:  194:	}
       21:  195:	if (size == 0)
    #####:  196:		return -1;
        -:  197:
       21:  198:	u64 index = __thread_local_chain_allocator_index - 1;
       21:  199:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  200:
        -:  201:	int ret;
        -:  202:	{
       21:  203:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
       21:  204:		if (is_sync)
        5:  205:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  206:
       21:  207:		ret = heap_allocator_allocate(
        -:  208:		    __thread_local_chain_allocator[index].ha, size, ptr);
        -:  209:	}
        -:  210:
       21:  211:	return ret;
        -:  212:}
        1:  213:int chain_realloc(FatPtr *dst, FatPtr *src, u64 size) {
        1:  214:	if (__thread_local_chain_allocator_index == 0) {
    #####:  215:		return -1;
        -:  216:	}
        1:  217:	if (size == 0) {
    #####:  218:		errno = EINVAL;
    #####:  219:		return -1;
        -:  220:	}
        1:  221:	u64 index = __thread_local_chain_allocator_index - 1;
        1:  222:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  223:
        -:  224:	int ret;
        -:  225:	{
        1:  226:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
        1:  227:		if (is_sync)
    #####:  228:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  229:
        1:  230:		ret = heap_allocator_allocate(
        -:  231:		    __thread_local_chain_allocator[index].ha, size, dst);
        1:  232:		if (!ret) {
        1:  233:			void *src_data = fat_ptr_data(src);
        1:  234:			void *dst_data = fat_ptr_data(dst);
        1:  235:			u64 len = fat_ptr_len(src);
        1:  236:			memcpy(dst_data, src_data, len);
        1:  237:			ret = chain_free(src);
        -:  238:		}
        -:  239:	}
        -:  240:
        1:  241:	return ret;
        -:  242:}
       21:  243:int chain_free(FatPtr *ptr) {
       21:  244:	if (__thread_local_chain_allocator_index == 0) {
    #####:  245:		errno = ERANGE;
    #####:  246:		return -1;
        -:  247:	}
       21:  248:	u64 index = __thread_local_chain_allocator_index - 1;
       21:  249:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  250:
        -:  251:	int ret;
        -:  252:	{
       21:  253:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
       21:  254:		if (is_sync)
        4:  255:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  256:
       21:  257:		ret = heap_allocator_free(
        -:  258:		    __thread_local_chain_allocator[index].ha, ptr);
        -:  259:	}
       21:  260:	return ret;
        -:  261:}
        -:    0:Source:heap.c
        -:    0:Graph:heap.gcno
        -:    0:Data:heap.gcda
        -:    0:Runs:19
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/heap.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:
        -:   19:// internal representation of the HeapDataParamsConfig with the required
        -:   20:// free_list_head value.
        -:   21:typedef struct HeapDataParams {
        -:   22:	HeapDataParamsConfig config;
        -:   23:	u32 free_list_head; // The next slab that is free
        -:   24:} HeapDataParams;
        -:   25:
        -:   26:// The data associated with each slab_size.
        -:   27:typedef struct HeapData {
        -:   28:	void **data;	    // pointers to each chunk of data
        -:   29:	u32 *free_list;	    // the pointers for free slabs.
        -:   30:	u32 count;	    // the number of chunks currently allocated
        -:   31:	u32 cur_slabs;	    // the number of slabs currently allocated
        -:   32:	HeapDataParams hdp; // The heap data params for this HeapData
        -:   33:} HeapData;
        -:   34:
        -:   35:// The opaque pointer type which is stored in the HeapAllocator data structure
        -:   36:// which is used to access a HeapAllocator.
        -:   37:typedef struct HeapAllocatorImpl {
        -:   38:	u32 hd_size;		    // number of sizes available
        -:   39:	HeapAllocatorConfig config; // the configuration
        -:   40:	HeapData *hd_arr;	    // The array of heap data.
        -:   41:} HeapAllocatorImpl;
        -:   42:
        -:   43:// debugging options/counters
        -:   44:u64 __malloc_count = 0;
        -:   45:u64 __free_count = 0;
        -:   46:bool __debug_build_allocator_malloc_fail1 = false;
        -:   47:bool __debug_build_allocator_malloc_fail2 = false;
        -:   48:bool __debug_build_allocator_malloc_fail3 = false;
        -:   49:bool __debug_build_allocator_malloc_fail4 = false;
        -:   50:bool __debug_build_allocator_malloc_fail5 = false;
        -:   51:bool __debug_build_allocator_malloc_fail6 = false;
        -:   52:bool __debug_build_allocator_malloc_fail7 = false;
        -:   53:bool __debug_build_allocator_malloc_fail8 = false;
        -:   54:
      189:   55:void *do_malloc(size_t size) {
      189:   56:	__malloc_count += 1;
      189:   57:	void *ret = malloc(size);
        -:   58:	// printf("malloc %zu [%p (%llu)]\n", size, ret, __malloc_count);
      189:   59:	return ret;
        -:   60:}
        -:   61:
      143:   62:void do_free(void *ptr) {
      143:   63:	__free_count += 1;
        -:   64:	// printf("free %p (%llu)\n", ptr, __free_count);
      143:   65:	free(ptr);
      143:   66:}
        -:   67:
       21:   68:void *do_realloc(void *ptr, size_t size) {
       21:   69:	void *ret = realloc(ptr, size);
        -:   70:	// printf("realloc %zu [old=%p,new=%p]\n", size, ptr, ret);
       21:   71:	return ret;
        -:   72:}
        -:   73:
       29:   74:void *fat_ptr_data(const FatPtr *ptr) { return ptr->data; }
        -:   75:
       13:   76:u64 fat_ptr_len(const FatPtr *ptr) { return ptr->len; }
        -:   77:
        5:   78:u64 fat_ptr_id(const FatPtr *ptr) { return ptr->id; }
        -:   79:
       46:   80:int heap_allocator_init_free_list(HeapData *hd, u64 index, u32 slabs,
        -:   81:				  bool last_is_uint_max) {
       46:   82:	hd->data[index] = NULL; // set to NULL for cleanup consistency
        -:   83:
        -:   84:	// allocate memory for slabs
       46:   85:	if (!__debug_build_allocator_malloc_fail4)
       44:   86:		hd->data[index] = do_malloc(hd->hdp.config.slab_size * slabs);
       46:   87:	if (hd->data[index] == NULL)
        2:   88:		return -1;
        -:   89:
       44:   90:	void *tmp = NULL;
        -:   91:
        -:   92:	// allocate / or reallocate the freelist
       44:   93:	if (!__debug_build_allocator_malloc_fail5) {
       42:   94:		if (index == 0)
       32:   95:			tmp = do_malloc(sizeof(u32) * slabs);
        -:   96:		else {
       10:   97:			tmp = do_realloc(hd->free_list,
       10:   98:					 sizeof(u32) * (hd->cur_slabs + slabs));
        -:   99:		}
        -:  100:	}
        -:  101:
       44:  102:	if (!tmp) {
        2:  103:		do_free(hd->data[index]);
        2:  104:		return -1;
        -:  105:	}
        -:  106:
       42:  107:	hd->free_list = tmp;
        -:  108:
        -:  109:	// initialize the values of the free list.
       42:  110:	u32 offset = index * hd->hdp.config.slabs_per_resize;
      590:  111:	for (u64 i = 0; i < slabs; i++) {
      548:  112:		if ((i == (slabs - 1)) && last_is_uint_max)
       41:  113:			hd->free_list[i + offset] = UINT32_MAX;
        -:  114:		else
      507:  115:			hd->free_list[i + offset] = offset + i + 1;
        -:  116:	}
        -:  117:
       42:  118:	return 0;
        -:  119:}
        -:  120:
        -:  121:// compare function used for sorting.
      715:  122:int heap_data_compare(const void *p1, const void *p2) {
      715:  123:	int ret = 0;
        -:  124:
      715:  125:	HeapData d1 = *(HeapData *)p1;
      715:  126:	HeapData d2 = *(HeapData *)p2;
        -:  127:
      715:  128:	if (d1.hdp.config.slab_size > d2.hdp.config.slab_size)
        1:  129:		ret = 1;
      714:  130:	else if (d1.hdp.config.slab_size < d2.hdp.config.slab_size)
      713:  131:		ret = -1;
        -:  132:
      715:  133:	return ret;
        -:  134:}
        -:  135:
        -:  136:// initialize the heap data params
      315:  137:int heap_allocator_init_hdp(HeapAllocator *ptr, HeapDataParamsConfig *hdp,
        -:  138:			    u64 index) {
        -:  139:
        -:  140:	// set some value in case of a failure below such that cleanup can
        -:  141:	// succeed
      315:  142:	int ret = 0;
      315:  143:	ptr->impl->hd_arr[index].hdp.config = *hdp;
      315:  144:	ptr->impl->hd_arr[index].hdp.free_list_head = 0;
      315:  145:	ptr->impl->hd_arr[index].cur_slabs = 0;
      315:  146:	ptr->impl->hd_arr[index].count =
      315:  147:	    ptr->impl->hd_arr[index].hdp.config.initial_chunks;
        -:  148:
        -:  149:	// if we have initial chunks, initialize them
      315:  150:	if (ptr->impl->hd_arr[index].hdp.config.initial_chunks) {
       23:  151:		ptr->impl->hd_arr[index].data = NULL;
        -:  152:
        -:  153:		// try to allocate space for the data for this size
       23:  154:		if (!__debug_build_allocator_malloc_fail8)
       22:  155:			ptr->impl->hd_arr[index].data = do_malloc(
       22:  156:			    ptr->impl->hd_arr[index].hdp.config.initial_chunks *
        -:  157:			    sizeof(void *));
        -:  158:
        -:  159:		// if NULL return error
       23:  160:		if (ptr->impl->hd_arr[index].data == NULL)
        1:  161:			return -1;
        -:  162:
        -:  163:		// set cur_slabs value
       22:  164:		ptr->impl->hd_arr[index].cur_slabs =
       22:  165:		    ptr->impl->hd_arr[index].hdp.config.initial_chunks *
       22:  166:		    ptr->impl->hd_arr[index].hdp.config.slabs_per_resize;
        -:  167:
        -:  168:		// initialize the initial_chunks of the free list
       22:  169:		bool last_is_uint_max = false;
       22:  170:		ptr->impl->hd_arr[index].free_list = NULL;
       22:  171:		for (u64 i = 0;
       45:  172:		     i < ptr->impl->hd_arr[index].hdp.config.initial_chunks;
       23:  173:		     i++) {
        -:  174:
       23:  175:			if (i ==
       23:  176:			    ptr->impl->hd_arr[index].hdp.config.initial_chunks -
        -:  177:				1)
       22:  178:				last_is_uint_max = true;
       23:  179:			if (heap_allocator_init_free_list(
       23:  180:				&ptr->impl->hd_arr[index], i,
       23:  181:				ptr->impl->hd_arr[index]
        -:  182:				    .hdp.config.slabs_per_resize,
        -:  183:				last_is_uint_max))
        2:  184:				ret = -1;
        -:  185:		}
        -:  186:	} else
      292:  187:		ptr->impl->hd_arr[index].data = NULL;
      314:  188:	return ret;
        -:  189:}
        -:  190:
       35:  191:int heap_allocator_build_arr(HeapAllocator *ptr, HeapAllocatorConfig *config,
        -:  192:			     HeapDataParamsConfig arr[],
        -:  193:			     u64 heap_data_params_count) {
        -:  194:	// check inputs
       35:  195:	if (ptr == NULL || config == NULL || heap_data_params_count >= 256) {
        1:  196:		errno = EINVAL;
        1:  197:		return -1;
        -:  198:	}
        -:  199:
        -:  200:	// allocate the HeapAllocatorImpl
       34:  201:	if (!__debug_build_allocator_malloc_fail1)
       33:  202:		ptr->impl = do_malloc(sizeof(HeapAllocatorImpl));
       34:  203:	if (ptr->impl == NULL || __debug_build_allocator_malloc_fail1)
        1:  204:		return -1;
        -:  205:
       33:  206:	ptr->impl->hd_size = 0;
        -:  207:
        -:  208:	// copy the config
       33:  209:	ptr->impl->config = *config;
        -:  210:
        -:  211:	// allocate heap data array
       33:  212:	ptr->impl->hd_arr = NULL;
       33:  213:	if (!__debug_build_allocator_malloc_fail2)
       32:  214:		ptr->impl->hd_arr =
       32:  215:		    do_malloc(sizeof(HeapData) * heap_data_params_count);
       33:  216:	if (ptr->impl->hd_arr == NULL || __debug_build_allocator_malloc_fail2) {
        1:  217:		heap_allocator_cleanup(ptr);
        1:  218:		return -1;
        -:  219:	}
       32:  220:	ptr->impl->hd_size = heap_data_params_count;
        -:  221:
        -:  222:	// iterate through specified heap data params
      344:  223:	for (u64 i = 0; i < heap_data_params_count; i++) {
      316:  224:		HeapDataParamsConfig hdp = arr[i];
      316:  225:		ptr->impl->hd_arr[i].count = 0; // init to 0 for safe cleanup
      316:  226:		ptr->impl->hd_arr[i].data = NULL;
      631:  227:		if ((__debug_build_allocator_malloc_fail3 && i > 0) ||
      315:  228:		    heap_allocator_init_hdp(ptr, &hdp, i)) {
        4:  229:			ptr->impl->hd_size = i; // update for cleanup, others
        -:  230:						// did not get allocated
        4:  231:			if (ptr->impl->hd_arr[i].data) {
        2:  232:				do_free(ptr->impl->hd_arr[i].data);
        -:  233:			}
        4:  234:			heap_allocator_cleanup(ptr);
        4:  235:			return -1;
        -:  236:		}
        -:  237:	}
        -:  238:
       28:  239:	if (heap_data_params_count) {
       26:  240:		qsort(ptr->impl->hd_arr, heap_data_params_count,
        -:  241:		      sizeof(HeapData), heap_data_compare);
        -:  242:	}
        -:  243:
        -:  244:	// check invalid configurations
       28:  245:	u64 last_size = 0;
      337:  246:	for (u64 i = 0; i < heap_data_params_count; i++) {
      311:  247:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == 0) {
        -:  248:			// no 0 sized slabs allowed
        1:  249:			errno = EINVAL;
        1:  250:			heap_allocator_cleanup(ptr);
        1:  251:			return -1;
        -:  252:		}
        -:  253:		// note: logic correct because array is sorted.
      310:  254:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == last_size) {
        -:  255:			// Duplicate slab_size
        1:  256:			errno = EEXIST;
        1:  257:			heap_allocator_cleanup(ptr);
        1:  258:			return -1;
        -:  259:		}
      309:  260:		last_size = ptr->impl->hd_arr[i].hdp.config.slab_size;
        -:  261:	}
        -:  262:
       26:  263:	return 0;
        -:  264:}
        -:  265:
       26:  266:int heap_allocator_build(HeapAllocator *ptr, HeapAllocatorConfig *config,
       26:  267:			 int heap_data_params_count, ...) {
       26:  268:	int arr_size = heap_data_params_count;
        -:  269:
        -:  270:	// 0 size is allowed, so we update to address sanitizer warning.
       26:  271:	if (arr_size <= 0) {
        5:  272:		arr_size = 1;
        -:  273:	}
       26:  274:	HeapDataParamsConfig arr[arr_size];
        -:  275:	va_list hdps;
       26:  276:	va_start(hdps, heap_data_params_count);
        -:  277:	// build the array to pass to heap_allocator_build_arr
       55:  278:	for (u64 i = 0; i < heap_data_params_count; i++) {
       29:  279:		HeapDataParamsConfig hdp = va_arg(hdps, HeapDataParamsConfig);
       29:  280:		arr[i] = hdp;
        -:  281:	}
        -:  282:
       26:  283:	va_end(hdps);
        -:  284:	// call the array version of the function
       26:  285:	return heap_allocator_build_arr(ptr, config, arr,
        -:  286:					heap_data_params_count);
        -:  287:}
        -:  288:
        -:  289:// binary search for the correct slab size
      412:  290:int heap_allocator_index(HeapAllocator *ptr, u64 size) {
      412:  291:	int ret = -1;
      412:  292:	if (ptr->impl->hd_size == 0)
        2:  293:		return ret;
        -:  294:
      410:  295:	int left = 0;
      410:  296:	int right = ptr->impl->hd_size - 1;
        -:  297:
      586:  298:	while (left <= right) {
      531:  299:		int mid = left + (right - left) / 2;
      531:  300:		u64 slab_size = ptr->impl->hd_arr[mid].hdp.config.slab_size;
      531:  301:		if (slab_size == size) {
      355:  302:			ret = mid;
      355:  303:			break;
      176:  304:		} else if (slab_size > size)
       88:  305:			right = mid - 1;
        -:  306:		else
       88:  307:			left = mid + 1;
        -:  308:	}
        -:  309:
      410:  310:	if (ret == -1 && right + 1 <= ptr->impl->hd_size - 1) {
       43:  311:		return right + 1;
        -:  312:	}
        -:  313:
      367:  314:	return ret;
        -:  315:}
        -:  316:
       31:  317:int heap_data_resize(u64 index, HeapData *hd) {
        -:  318:	// check that we can resize this hdp
       31:  319:	if (hd->cur_slabs < hd->hdp.config.max_slabs) {
        -:  320:		// calculate the new slabs
       24:  321:		u32 nslabs_count =
       24:  322:		    hd->hdp.config.slabs_per_resize + hd->cur_slabs;
       24:  323:		if (nslabs_count > hd->hdp.config.max_slabs)
        2:  324:			nslabs_count = hd->hdp.config.max_slabs;
        -:  325:
        -:  326:		// determine slabs to allocate
       24:  327:		u32 slabs_to_alloc = nslabs_count - hd->cur_slabs;
        -:  328:
        -:  329:		// attempt to allocate
       24:  330:		void *tmp = NULL;
       24:  331:		if (!__debug_build_allocator_malloc_fail7) {
       23:  332:			if (hd->data)
       11:  333:				tmp = do_realloc(hd->data, (hd->count + 1) *
        -:  334:							       sizeof(void *));
        -:  335:			else
       12:  336:				tmp = do_malloc((hd->count + 1) *
        -:  337:						sizeof(void **));
        -:  338:		}
        -:  339:
       24:  340:		if (tmp == NULL)
        1:  341:			return -1;
       23:  342:		hd->data = tmp;
        -:  343:
        -:  344:		// initialize the new part of the free list
       23:  345:		if (heap_allocator_init_free_list(hd, hd->count, slabs_to_alloc,
        -:  346:						  true))
        2:  347:			return -1;
       21:  348:		hd->hdp.free_list_head = hd->cur_slabs;
       21:  349:		hd->cur_slabs = nslabs_count;
       21:  350:		hd->count += 1;
       21:  351:		return 0;
        -:  352:	}
        7:  353:	return -1;
        -:  354:}
        -:  355:
      407:  356:int heap_data_allocate(u64 index, HeapData *hd, FatPtr *fptr) {
      407:  357:	if (hd->cur_slabs == 0) {
        -:  358:		// this hd initially had 0 slabs
        -:  359:		// resize it
       13:  360:		if (heap_data_resize(index, hd))
        1:  361:			return -1;
        -:  362:	}
        -:  363:
        -:  364:	// no more slabs, return error
      406:  365:	if (hd->hdp.free_list_head == UINT32_MAX)
       17:  366:		return -1;
        -:  367:
        -:  368:	// get next free slab
      389:  369:	u64 id = hd->hdp.free_list_head;
        -:  370:
        -:  371:	// update free list head
      389:  372:	hd->hdp.free_list_head = hd->free_list[id];
        -:  373:
        -:  374:	// update with the specific index (differing slab sizes)
      389:  375:	fptr->id = id | (index << 56);
      389:  376:	fptr->len = hd->hdp.config.slab_size;
        -:  377:
      389:  378:	u64 heap_data_index = id / hd->hdp.config.slabs_per_resize;
      389:  379:	u64 offset_mod = id % hd->hdp.config.slabs_per_resize;
        -:  380:
        -:  381:	// set the data of the fptr
      389:  382:	fptr->data =
      389:  383:	    hd->data[heap_data_index] + offset_mod * hd->hdp.config.slab_size;
        -:  384:
      389:  385:	return 0;
        -:  386:}
        -:  387:
        -:  388:// free data in this HeapData
      138:  389:int heap_data_free(u64 index, HeapData *hd, FatPtr *fptr) {
      138:  390:	u64 rel = fptr->id & 0x00FFFFFFFFFFFFFF; // Extract the relative ID
        -:  391:
        -:  392:	// if this is invalid return an error
      138:  393:	if (rel >= hd->cur_slabs)
        1:  394:		return -1;
        -:  395:
        -:  396:	// update head and rest of the list
      137:  397:	u64 head = hd->hdp.free_list_head;
      137:  398:	hd->hdp.free_list_head = rel;
      137:  399:	hd->free_list[rel] = head;
        -:  400:
      137:  401:	return 0;
        -:  402:}
        -:  403:
        -:  404:// main allocation function
      412:  405:int heap_allocator_allocate(HeapAllocator *ptr, u64 size, FatPtr *fptr) {
      412:  406:	int ret = -1;
        -:  407:	// determine the index via binary search
      412:  408:	int index = heap_allocator_index(ptr, size);
        -:  409:
        -:  410:	// if this index is not found (too big) fall back to malloc
      412:  411:	if (index < 0) {
       14:  412:		if (!ptr->impl->config.no_malloc) {
       12:  413:			fptr->data = NULL;
       12:  414:			if (!__debug_build_allocator_malloc_fail6)
       11:  415:				fptr->data = do_malloc(size);
       12:  416:			if (fptr->data == NULL) {
        1:  417:				fptr->len = 0;
        1:  418:				ret = -1;
        -:  419:			} else {
       11:  420:				fptr->len = size;
       11:  421:				fptr->id = UINT64_MAX;
       11:  422:				ret = 0;
        -:  423:			}
        -:  424:		}
        -:  425:	} else {
      398:  426:		HeapData *hd = &ptr->impl->hd_arr[index];
      398:  427:		ret = heap_data_allocate(index, hd, fptr);
      398:  428:		if (ret) {
        -:  429:			// there are no more slabs. Try to resize
       18:  430:			if (!heap_data_resize(index, hd)) {
        -:  431:				// successful resize, allocate should always
        -:  432:				// succeed here
        9:  433:				ret = heap_data_allocate(index, hd, fptr);
        9:  434:			} else if (!ptr->impl->config.no_malloc) {
        -:  435:				// could not allocate, so we fall back to malloc
        -:  436:				// if configured
        4:  437:				fptr->data = NULL;
        4:  438:				if (!__debug_build_allocator_malloc_fail6)
        3:  439:					fptr->data = do_malloc(size);
        4:  440:				if (fptr->data == NULL) {
        1:  441:					fptr->len = 0;
        1:  442:					ret = -1;
        -:  443:				} else {
        3:  444:					fptr->len = size;
        3:  445:					fptr->id = UINT64_MAX;
        3:  446:					ret = 0;
        -:  447:				}
        -:  448:			}
        -:  449:		}
        -:  450:	}
        -:  451:
      412:  452:	if (!ret && ptr->impl->config.zeroed) {
      924:  453:		for (u64 i = 0; i < fptr->len; i++) {
      880:  454:			((char *)fptr->data)[i] = 0;
        -:  455:		}
        -:  456:	}
        -:  457:
        -:  458:	// printf("allocate size=%llu,id=%llu,p=%p\n", size, fptr->id,
        -:  459:	// fptr->data);
        -:  460:
      412:  461:	return ret;
        -:  462:}
        -:  463:
      153:  464:int heap_allocator_free(HeapAllocator *ptr, FatPtr *fptr) {
      153:  465:	int ret = 0;
      153:  466:	if (fptr->id == UINT64_MAX) {
        -:  467:		// malloc allocated
        -:  468:
       14:  469:		if (fptr->data) {
       14:  470:			do_free(fptr->data);
       14:  471:			fptr->data = NULL;
        -:  472:		}
        -:  473:
       14:  474:		ret = 0;
        -:  475:	} else {
        -:  476:
      139:  477:		u64 index = (fptr->id >> 56) & 0xFF; // Extract the index
        -:  478:
      139:  479:		if (index >= ptr->impl->hd_size) {
        1:  480:			errno = EINVAL;
        1:  481:			ret = -1; // invalid index
        -:  482:		} else {
      138:  483:			HeapData *hd = &ptr->impl->hd_arr[index];
      138:  484:			ret = heap_data_free(index, hd, fptr);
        -:  485:		}
        -:  486:	}
        -:  487:
      153:  488:	if (!ret && ptr->impl->config.zeroed) {
       17:  489:		for (u64 i = 0; i < fptr->len; i++) {
       16:  490:			((char *)fptr->data)[i] = 0;
        -:  491:		}
        -:  492:	}
        -:  493:
        -:  494:	// printf("free id=%llu,p=%p\n", fptr->id, fptr->data);
        -:  495:
      153:  496:	return ret;
        -:  497:}
        -:  498:
       29:  499:int heap_allocator_cleanup(HeapAllocator *ptr) {
        -:  500:	// check for impl and deallocate
       29:  501:	if (ptr->impl) {
       53:  502:		for (u32 i = 0; i < ptr->impl->hd_size; i++) {
       28:  503:			if (ptr->impl->hd_arr[i].count) {
        -:  504:				// check that it's not an unallocated heap data
       22:  505:				if (ptr->impl->hd_arr[i].free_list) {
       22:  506:					do_free(ptr->impl->hd_arr[i].free_list);
       22:  507:					ptr->impl->hd_arr[i].free_list = NULL;
        -:  508:				}
       54:  509:				for (u64 j = 0; j < ptr->impl->hd_arr[i].count;
       32:  510:				     j++) {
       32:  511:					do_free(ptr->impl->hd_arr[i].data[j]);
        -:  512:				}
       22:  513:				if (ptr->impl->hd_arr[i].data) {
       22:  514:					do_free(ptr->impl->hd_arr[i].data);
       22:  515:					ptr->impl->hd_arr[i].data = NULL;
        -:  516:				}
        -:  517:			}
        -:  518:		}
        -:  519:
       25:  520:		if (ptr->impl->hd_arr) {
       24:  521:			do_free(ptr->impl->hd_arr);
       24:  522:			ptr->impl->hd_arr = NULL;
        -:  523:		}
       25:  524:		do_free(ptr->impl);
       25:  525:		ptr->impl = NULL;
        -:  526:	}
       29:  527:	return 0;
        -:  528:}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:19
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/lock.h>
        -:   16:#include <core/panic.h>
        -:   17:#include <stdio.h>
        -:   18:#include <unistd.h>
        -:   19:
        -:   20:#define MAX_LOCKS 100
        -:   21:_Thread_local Lock *__active_locks_[MAX_LOCKS];
        -:   22:_Thread_local u64 __active_lock_count_ = 0;
        -:   23:
       15:   24:void insert_active_lock(Lock *ptr) {
       15:   25:	if (__active_lock_count_ >= MAX_LOCKS)
    #####:   26:		panic("too many locks!");
       15:   27:	__active_locks_[__active_lock_count_] = ptr;
       15:   28:	__active_lock_count_++;
       15:   29:}
       14:   30:void delete_active_lock(Lock *ptr) {
        -:   31:	// note: locks are removed in reverse order
        -:   32:	// It's possible that cleanup occurs in slightly different order
        -:   33:	// but the effect is the same each lock would be invalidated at the end
        -:   34:	// of a scope. For simplicity we just decrement here.
       14:   35:	if (__active_lock_count_ == 0)
    #####:   36:		panic("active lock stack underflow. Unexpected error!");
       14:   37:	__active_lock_count_--;
       14:   38:}
        -:   39:
        8:   40:Lock Lock_build() {
        -:   41:	LockPtr ret;
        8:   42:	pthread_mutex_init(&ret.lock, NULL);
        8:   43:	pthread_cond_init(&ret.cond, NULL);
        8:   44:	atomic_init(&ret.poison, false);
        8:   45:	atomic_init(&ret.is_locked, false);
        8:   46:	atomic_init(&ret.tid, 0);
        8:   47:	return ret;
        -:   48:}
        -:   49:
        4:   50:void Lock_cleanup(LockPtr *ptr) {
        4:   51:	pthread_mutex_destroy(&ptr->lock);
        4:   52:	pthread_cond_destroy(&ptr->cond);
        4:   53:}
        -:   54:
        1:   55:void Lock_set_poison(Lock *ptr) { atomic_exchange(&ptr->poison, true); }
        1:   56:bool Lock_is_poisoned(Lock *ptr) { return atomic_load(&ptr->poison); }
    #####:   57:void Lock_clear_poison(Lock *ptr) { atomic_exchange(&ptr->poison, false); }
       15:   58:u64 Lock_get_tid() {
        -:   59:	u64 tid;
        -:   60:#ifdef __APPLE__
        -:   61:	pthread_threadid_np(NULL, &tid);
        -:   62:#else
       15:   63:	tid = gettid();
        -:   64:#endif // tid code
       15:   65:	return tid;
        -:   66:}
        -:   67:
       15:   68:LockGuard lock(Lock *ptr) {
       15:   69:	if (atomic_load(&ptr->poison))
    #####:   70:		panic("Lock %p: poisoned!", ptr);
        -:   71:
       15:   72:	u64 tid = Lock_get_tid();
        -:   73:
        -:   74:	// check if this would be a deadlock
      15*:   75:	if (atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid)
    #####:   76:		panic("Lock %p: attempt to lock would deadlock!", lock);
        -:   77:
        -:   78:	// obtain lock
       15:   79:	pthread_mutex_lock(&ptr->lock);
       15:   80:	if (atomic_load(&ptr->poison))
    #####:   81:		panic("Lock %p: poisoned!", ptr);
        -:   82:
       15:   83:	insert_active_lock(ptr);
        -:   84:
        -:   85:	// set tid/is_locked and return
       15:   86:	atomic_exchange(&ptr->tid, tid);
       15:   87:	atomic_exchange(&ptr->is_locked, true);
       15:   88:	LockGuardPtr ret = {ptr};
       15:   89:	return ret;
        -:   90:}
        -:   91:
       48:   92:void Lockguard_cleanup(LockGuardPtr *ptr) {
       48:   93:	if (ptr && ptr->ref) {
       14:   94:		atomic_exchange(&ptr->ref->is_locked, false);
       14:   95:		pthread_mutex_unlock(&ptr->ref->lock);
       14:   96:		delete_active_lock(ptr->ref);
        -:   97:	}
       48:   98:}
        -:   99:
        3:  100:void Lock_mark_poisoned() {
        3:  101:	if (__active_lock_count_) {
        1:  102:		u64 i = __active_lock_count_ - 1;
        -:  103:		while (true) {
        1:  104:			Lock_set_poison(__active_locks_[i]);
        1:  105:			atomic_exchange(&__active_locks_[i]->is_locked, false);
        1:  106:			pthread_mutex_unlock(&__active_locks_[i]->lock);
        1:  107:			if (i == 0)
        1:  108:				break;
    #####:  109:			i--;
        -:  110:		}
        -:  111:	}
        3:  112:}
        -:  113:
    #####:  114:void Lock_wait(Lock *ptr, u64 nanoseconds) {
    #####:  115:	u64 tid = Lock_get_tid();
    #####:  116:	if (!(atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid))
    #####:  117:		panic("Attempt to wait on lock %p without first obtaining the "
        -:  118:		      "lock!",
        -:  119:		      ptr);
    #####:  120:	if (nanoseconds == 0) {
    #####:  121:		pthread_cond_wait(&ptr->cond, &ptr->lock);
        -:  122:	} else {
        -:  123:		struct timespec ts;
    #####:  124:		clock_gettime(CLOCK_REALTIME, &ts);
        -:  125:
        -:  126:		// Convert the wait time into seconds and nanoseconds
    #####:  127:		ts.tv_sec += nanoseconds / 1000000000;
    #####:  128:		ts.tv_nsec += nanoseconds % 1000000000;
        -:  129:
        -:  130:		// Normalize the timespec structure in case of overflow in
        -:  131:		// nanoseconds
    #####:  132:		if (ts.tv_nsec >= 1000000000) {
    #####:  133:			ts.tv_sec += ts.tv_nsec / 1000000000;
    #####:  134:			ts.tv_nsec %= 1000000000;
        -:  135:		}
    #####:  136:		pthread_cond_timedwait(&ptr->cond, &ptr->lock, &ts);
        -:  137:	}
    #####:  138:}
        -:  139:
        2:  140:void Lock_notify(Lock *ptr) { pthread_cond_signal(&ptr->cond); }
        -:  141:
    #####:  142:void Lock_notify_all(Lock *ptr) { pthread_cond_broadcast(&ptr->cond); }
        -:    0:Source:panic.c
        -:    0:Graph:panic.gcno
        -:    0:Data:panic.gcda
        -:    0:Runs:19
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/chain_allocator.h>
        -:   16:#include <core/lock.h>
        -:   17:#include <core/panic.h>
        -:   18:#include <setjmp.h>
        -:   19:#include <stdarg.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <stdnoreturn.h>
        -:   23:
        -:   24:_Thread_local jmp_buf return_jmp;
        -:   25:_Thread_local bool jmp_return_set = false;
        -:   26:
        3:   27:void panic(const char *fmt, ...) {
        -:   28:	va_list args;
        -:   29:
        3:   30:	fprintf(stderr, "thread panicked: ");
        3:   31:	va_start(args, fmt);
        3:   32:	vfprintf(stderr, fmt, args);
        3:   33:	va_end(args);
        3:   34:	fprintf(stderr, "\n");
        -:   35:
        3:   36:	Lock_mark_poisoned();
        -:   37:
        3:   38:	if (__default_tl_heap_allocator != NULL) {
    #####:   39:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   40:	}
        -:   41:
        -:   42:	// If jump return has not been set, we resort to an exit with an error
        -:   43:	// status.
        3:   44:	if (!jmp_return_set)
    #####:   45:		exit(-1);
        3:   46:	longjmp(return_jmp, THREAD_PANIC);
        -:   47:}
        -:    0:Source:thread.c
        -:    0:Graph:thread.gcno
        -:    0:Data:thread.gcda
        -:    0:Runs:19
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <core/chain_allocator.h>
        -:   17:#include <core/panic.h>
        -:   18:#include <core/thread.h>
        -:   19:#include <errno.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:int PANIC_TRUE = 1;
        -:   24:int PANIC_FALSE = 0;
        -:   25:
        -:   26:typedef struct ThreadArgsWrapper {
        -:   27:	void (*start_routine)(void *);
        -:   28:	void *args;
        -:   29:	FatPtr self;
        -:   30:} ThreadArgsWrapper;
        -:   31:
        -:   32:typedef struct ThreadImpl {
        -:   33:	pthread_t pth;
        -:   34:	u64 tid;
        -:   35:	FatPtr self;
        -:   36:} ThreadImpl;
        -:   37:
        4:   38:void Thread_cleanup(Thread *ptr) {
        4:   39:	if (chain_free(&ptr->impl))
    #####:   40:		panic("Could not free Thread");
        4:   41:}
        -:   42:
        4:   43:void *Thread_proc_start(void *arg) {
        -:   44:	// set jmp return point for panics
        4:   45:	if (PANIC_RETURN()) {
        1:   46:		pthread_exit(&PANIC_TRUE);
        -:   47:	}
        -:   48:
        4:   49:	ThreadArgsWrapper *taw = arg;
        4:   50:	(taw->start_routine)(taw->args);
        -:   51:
       3*:   52:	ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        3:   53:	if (chain_free(&taw->self))
    #####:   54:		panic("Could not free ThreadArgsWrapper");
        -:   55:
        3:   56:	if (__default_tl_heap_allocator != NULL) {
    #####:   57:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   58:	}
        -:   59:
        3:   60:	pthread_exit(&PANIC_FALSE);
        -:   61:}
        -:   62:
        4:   63:int Thread_start(Thread *th, void (*start_routine)(void *), void *args) {
        4:   64:	int ret = 0;
        4:   65:	ret = chain_malloc(&th->impl, sizeof(ThreadImpl));
        -:   66:
        4:   67:	if (!ret) {
        -:   68:
        8:   69:		ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        4:   70:		ThreadImpl *ti = th->impl.data;
        -:   71:
        -:   72:		FatPtr tawptr;
        4:   73:		ret = chain_malloc(&tawptr, sizeof(ThreadArgsWrapper));
        -:   74:
        4:   75:		if (!ret) {
        4:   76:			ThreadArgsWrapper *data = tawptr.data;
        4:   77:			data->start_routine = start_routine;
        4:   78:			data->args = args;
        4:   79:			data->self = tawptr;
        -:   80:
        4:   81:			ret = pthread_create(&ti->pth, NULL, Thread_proc_start,
        -:   82:					     data);
        -:   83:		}
        -:   84:	}
        4:   85:	return ret;
        -:   86:}
        -:   87:
        4:   88:JoinResult Thread_join(Thread *ptr) {
        4:   89:	int result = -1;
        4:   90:	int *status = &PANIC_FALSE;
        -:   91:
        4:   92:	if (ptr == NULL)
    #####:   93:		errno = EINVAL;
        -:   94:	else {
        4:   95:		ThreadImpl *ti = ptr->impl.data;
        4:   96:		result = pthread_join(ti->pth, (void *)&status);
        -:   97:	}
        4:   98:	JoinResult jr = {*status == PANIC_TRUE, result != 0};
        4:   99:	return jr;
        -:  100:}
        -:  101:
        4:  102:bool JoinResult_is_panic(JoinResult *jr) { return jr->is_panic; }
        -:  103:
        4:  104:bool JoinResult_is_error(JoinResult *jr) { return jr->is_error; }
        -:    0:Source:type.c
        -:    0:Graph:type.gcno
        -:    0:Data:type.gcda
        -:    0:Runs:19
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/panic.h>
        -:   16:#include <core/type.h>
        -:   17:#include <core/types.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:
        -:   21:/*
        -:   22:void __attribute__((constructor)) __init_tt() {
        -:   23:	__global_trait_table.entry_count = 1;
        -:   24:	__global_trait_table.entries = malloc(sizeof(TraitDefn));
        -:   25:	__global_trait_table.entries[0].name = "Drop";
        -:   26:	__global_trait_table.entries[0].entry_count = 1;
        -:   27:	__global_trait_table.entries[0].entries = malloc(sizeof(TraitRequired));
        -:   28:	__global_trait_table.entries[0].entries[0].name = "drop";
        -:   29:	__global_trait_table.entries[0].entries[0].bounds_count = 0;
        -:   30:}
        -:   31:*/
        -:   32:
        -:   33:u64 __global_counter__ = 0;
        -:   34:
        3:   35:u64 unique_id() { return __global_counter__++; }
        -:   36:
        3:   37:FatPtr build_fat_ptr(u64 size) {
        -:   38:	FatPtr ret;
        3:   39:	if (chain_malloc(&ret, size)) {
        -:   40:		// if chain_malloc is an error we set data to NULL and caller to
        -:   41:		// handle
    #####:   42:		ret.data = NULL;
        -:   43:	}
        3:   44:	return ret;
        -:   45:}
        -:   46:
       18:   47:int compare_vtable_entry(const void *ent1, const void *ent2) {
       18:   48:	const VtableEntry *vtent1 = ent1;
       18:   49:	const VtableEntry *vtent2 = ent2;
       18:   50:	return strcmp(vtent1->name, vtent2->name);
        -:   51:}
        -:   52:
       36:   53:void sort_vtable(Vtable *table) {
       36:   54:	qsort(table->entries, table->len, sizeof(VtableEntry),
        -:   55:	      compare_vtable_entry);
       36:   56:}
        -:   57:
       36:   58:void vtable_add_entry(Vtable *table, VtableEntry entry) {
       36:   59:	if (table->entries == NULL) {
       18:   60:		table->entries = malloc(sizeof(VtableEntry) * (table->len + 1));
       18:   61:		if (table->entries == NULL)
    #####:   62:			panic("Couldn't allocate memory for vtable");
        -:   63:	} else {
       18:   64:		void *tmp = realloc(table->entries,
       18:   65:				    sizeof(VtableEntry) * (table->len + 1));
       18:   66:		if (tmp == NULL)
    #####:   67:			panic("Couldn't allocate memory for vtable");
       18:   68:		table->entries = tmp;
        -:   69:	}
        -:   70:
       36:   71:	memcpy(&table->entries[table->len], &entry, sizeof(VtableEntry));
       36:   72:	table->len += 1;
       36:   73:	sort_vtable(table);
       36:   74:}
        -:   75:
        4:   76:void *find_fn(const Object *obj, const char *name) {
        4:   77:	int left = 0;
        4:   78:	int right = obj->vtable->len - 1;
        4:   79:	while (left <= right) {
        4:   80:		int mid = left + (right - left) / 2;
        4:   81:		int cmp = strcmp(name, obj->vtable->entries[mid].name);
        -:   82:
        4:   83:		if (cmp == 0) {
        4:   84:			return obj->vtable->entries[mid].fn_ptr;
    #####:   85:		} else if (cmp < 0) {
    #####:   86:			right = mid - 1;
        -:   87:		} else {
    #####:   88:			left = mid + 1;
        -:   89:		}
        -:   90:	}
    #####:   91:	return NULL;
        -:   92:}
        -:   93:
        -:   94:#if defined(__clang__)
        -:   95:// Clang-specific pragma
        -:   96:#pragma clang diagnostic ignored                                               \
        -:   97:    "-Wincompatible-pointer-types-discards-qualifiers"
        -:   98:#elif defined(__GNUC__) && !defined(__clang__)
        -:   99:// GCC-specific pragma
        -:  100:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  101:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  102:#else
        -:  103:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  104:#endif
        3:  105:void Object_cleanup(const Object *ptr) {
        3:  106:	Object *unconst = ptr;
        3:  107:	if ((unconst->flags & VDATA_FLAGS_NO_CLEANUP) == 0) {
        3:  108:		void (*drop)(Object * ptr) = find_fn(ptr, "drop");
        3:  109:		if (drop)
        3:  110:			drop(ptr);
        3:  111:		if (fat_ptr_data(&unconst->ptr)) {
        3:  112:			chain_free(&unconst->ptr);
        -:  113:		}
        -:  114:	}
        3:  115:}
