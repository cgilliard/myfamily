        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
    #####:   16:int main(int argc, char **argv) {
    #####:   17:	return real_main(argc, argv);
        -:   18:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <bible/bible.h>
        -:   17:#include <core/std.h>
        -:   18:#include <dirent.h>
        -:   19:#include <errno.h>
        -:   20:#include <stdio.h>
        -:   21:#include <string.h>
        -:   22:#include <sys/stat.h>
        -:   23:#include <unistd.h>
        -:   24:
    #####:   25:void build_args(Args *args) {
    #####:   26:	const char *home_dir = get_home_directory();
        -:   27:
    #####:   28:	args_build(args, "fam", "0.0.1-alpha.1", "The MyFamily Developers", 0, 0, 0);
        -:   29:
        -:   30:	// build the init SubCommand
        -:   31:	SubCommand init;
        -:   32:	ArgsParam cfg_dir;
    #####:   33:	args_param_build(&cfg_dir, "dir",
        -:   34:					 "Directory to initialize the project in (defaults to "
        -:   35:					 "the project name if not specified)",
        -:   36:					 "p", true, false, NULL);
    #####:   37:	sub_command_build(&init, "init", "Initialize project", 1, 1, "<project_name>");
    #####:   38:	sub_command_add_param(&init, &cfg_dir);
        -:   39:
    #####:   40:	args_add_sub_command(args, &init);
        -:   41:
        -:   42:	// build the build SubCommand
        -:   43:	SubCommand build;
    #####:   44:	sub_command_build(&build, "build", "Build project in release mode", 0, 0, "");
        -:   45:
    #####:   46:	args_add_sub_command(args, &build);
        -:   47:
        -:   48:	// build the debug SubCommand
        -:   49:	SubCommand bdebug;
    #####:   50:	sub_command_build(&bdebug, "debug", "Build project in debug mode", 0, 0, "");
        -:   51:
    #####:   52:	args_add_sub_command(args, &bdebug);
        -:   53:
        -:   54:	// build the test SubCommand
        -:   55:	SubCommand test;
    #####:   56:	sub_command_build(&test, "test", "Run tests", 0, 0, "");
        -:   57:
    #####:   58:	args_add_sub_command(args, &test);
        -:   59:
        -:   60:	// build the doc SubCommand
        -:   61:	SubCommand doc;
    #####:   62:	sub_command_build(&doc, "doc", "Build documentation", 0, 0, "");
        -:   63:
    #####:   64:	args_add_sub_command(args, &doc);
        -:   65:
        -:   66:	// build the verse SubCommand
        -:   67:	SubCommand verse;
    #####:   68:	sub_command_build(&verse, "verse", "Print a random Bible verse", 0, 0, "");
        -:   69:	ArgsParam no_colors_param, book_param, chapter_param, verse_param;
    #####:   70:	args_param_build(&no_colors_param, "no_colors", "Do not display colors", "n", false, false,
        -:   71:					 NULL);
    #####:   72:	args_param_build(&book_param, "book",
        -:   73:					 "Randomly select a verse from the specified book of the Bible", "b", true,
        -:   74:					 false, NULL);
    #####:   75:	args_param_build(&chapter_param, "chapter",
        -:   76:					 "Randomly select a verse from the specified chapter of the Bible. "
        -:   77:					 "This option requires that --book be specified as well.",
        -:   78:					 "x", true, false, NULL);
    #####:   79:	args_param_build(&verse_param, "verse",
        -:   80:					 "Select the specified verse. This option requires "
        -:   81:					 "that --book and --chapter be specified as well.",
        -:   82:					 "v", true, false, NULL);
        -:   83:
    #####:   84:	sub_command_add_param(&verse, &no_colors_param);
    #####:   85:	sub_command_add_param(&verse, &book_param);
    #####:   86:	sub_command_add_param(&verse, &chapter_param);
    #####:   87:	sub_command_add_param(&verse, &verse_param);
        -:   88:
    #####:   89:	args_add_sub_command(args, &verse);
        -:   90:
        -:   91:	// build the node SubCommand
        -:   92:	SubCommand node;
        -:   93:	ArgsParam cfg_threads, cfg_show;
    #####:   94:	args_param_build(&cfg_show, "show_request", "Show request information", "s", false, false,
        -:   95:					 NULL);
    #####:   96:	args_param_build(&cfg_threads, "threads", "Number of threads to execute", "t", true, false,
        -:   97:					 "1");
        -:   98:
    #####:   99:	sub_command_build(&node, "node", "Run full node", 0, 0, "");
    #####:  100:	sub_command_add_param(&node, &cfg_threads);
    #####:  101:	sub_command_add_param(&node, &cfg_show);
        -:  102:
    #####:  103:	args_add_sub_command(args, &node);
        -:  104:
        -:  105:	// build core options
        -:  106:	ArgsParam cfg_config_dir;
        -:  107:	ArgsParam cfg_debug;
        -:  108:
    #####:  109:	args_param_build(&cfg_debug, "debug", "Prints additional debugging information", "d", false,
        -:  110:					 false, NULL);
        -:  111:
    #####:  112:	char default_config_dir[strlen(home_dir) + 100];
    #####:  113:	snprintf(default_config_dir, strlen(home_dir) + 100, "%s/.fam", home_dir);
    #####:  114:	args_param_build(&cfg_config_dir, "config_dir",
        -:  115:					 "Directory where configuration files are stored", "c", true, false,
        -:  116:					 default_config_dir);
        -:  117:
    #####:  118:	args_add_param(args, &cfg_debug);
    #####:  119:	args_add_param(args, &cfg_config_dir);
    #####:  120:}
        -:  121:
    #####:  122:void process_verse(Args *args, char *config_dir) {
    #####:  123:	bool no_colors = args_value_of(args, "no_colors", NULL, 0, 0) >= 0;
        -:  124:	char book[100];
    #####:  125:	args_value_of(args, "book", book, 100, 0);
        -:  126:	char chapter_buf[100];
    #####:  127:	int chapter_int = -1;
    #####:  128:	if (args_value_of(args, "chapter", chapter_buf, 100, 0) != -1) {
    #####:  129:		chapter_int = atoi(chapter_buf);
    #####:  130:		if (chapter_int <= 0 || chapter_int > 255) {
    #####:  131:			fprintf(stderr, "The chapter specified must be a positive "
        -:  132:							"integer which is equal to or less than 255.\n");
    #####:  133:			exit(-1);
        -:  134:		}
        -:  135:	}
        -:  136:	char verse_buf[100];
    #####:  137:	int verse_int = -1;
    #####:  138:	if (args_value_of(args, "verse", verse_buf, 100, 0) != -1) {
    #####:  139:		verse_int = atoi(verse_buf);
    #####:  140:		if (verse_int <= 0 || verse_int > 255) {
    #####:  141:			fprintf(stderr, "The verse specified must be a positive "
        -:  142:							"integer which is equal to or less than 255.\n");
    #####:  143:			exit(-1);
        -:  144:		}
        -:  145:	}
        -:  146:
        -:  147:	Bible bible;
    #####:  148:	char bible_path[strlen(config_dir) + 10];
    #####:  149:	strcpy(bible_path, config_dir);
    #####:  150:	strcat(bible_path, "/akjv.txt");
    #####:  151:	if (bible_build(&bible, bible_path)) {
    #####:  152:		fprintf(stderr, "Could not load bible at path %s: %s\n", bible_path, strerror(errno));
    #####:  153:		exit(-1);
        -:  154:	}
        -:  155:
        -:  156:	char buf[1024];
        -:  157:	char book_buf[100];
        -:  158:	u8 chapter, verse;
        -:  159:
    #####:  160:	u8 *chapter_ptr = NULL;
    #####:  161:	if (chapter_int != -1) {
    #####:  162:		chapter = chapter_int;
    #####:  163:		chapter_ptr = &chapter;
        -:  164:	}
    #####:  165:	u8 *verse_ptr = NULL;
    #####:  166:	if (verse_int != -1) {
    #####:  167:		verse = verse_int;
    #####:  168:		verse_ptr = &verse;
        -:  169:	}
        -:  170:
    #####:  171:	if (verse_int != -1 && chapter_int == -1) {
    #####:  172:		fprintf(stderr, "If --verse is specified, --chapter must also "
        -:  173:						"be specified\n");
    #####:  174:		exit(-1);
        -:  175:	}
    #####:  176:	if (chapter_int != -1 && (strlen(book) == 0)) {
    #####:  177:		fprintf(stderr, "If --chapter is specified, --book must also "
        -:  178:						"be specified\n");
    #####:  179:		exit(-1);
        -:  180:	}
    #####:  181:	if (bible_random_verse_to_string(&bible, buf, 1024, !no_colors, book, chapter_ptr, verse_ptr) <
        -:  182:		0) {
    #####:  183:		fprintf(stderr, "Could not find random verse due to: %s\n", strerror(errno));
    #####:  184:		exit(-1);
        -:  185:	}
        -:  186:
    #####:  187:	printf("%s\n", buf);
    #####:  188:	bible_cleanup(&bible);
    #####:  189:}
        -:  190:
    #####:  191:int real_main(int argc, char **argv) {
        -:  192:	Args args;
    #####:  193:	build_args(&args);
    #####:  194:	args_init(&args, argc, argv);
        -:  195:
        -:  196:	// we always ensure that the config directory exists.
    #####:  197:	int config_dir_len = args_value_of(&args, "config_dir", NULL, 0, 0);
    #####:  198:	char config_dir[config_dir_len + 1];
    #####:  199:	args_value_of(&args, "config_dir", config_dir, config_dir_len + 1, 0);
    #####:  200:	if (access(config_dir, F_OK)) {
    #####:  201:		if (mkdir(config_dir, 0700)) {
    #####:  202:			perror("Failed to create specified config directory");
    #####:  203:			exit(-1);
        -:  204:		}
        -:  205:	}
        -:  206:
        -:  207:	// get first argument (subcommand)
        -:  208:	char command[100];
    #####:  209:	int ret = args_get_argument(&args, 0, command, 100);
    #####:  210:	if (ret > 0) {
    #####:  211:		if (!strcmp(command, "verse")) {
    #####:  212:			process_verse(&args, config_dir);
        -:  213:		} else {
    #####:  214:			printf("Not implemented!\n");
        -:  215:		}
        -:  216:	}
        -:  217:
    #####:  218:	args_cleanup(&args);
    #####:  219:	return 0;
        -:  220:}
        -:    0:Source:toml.c
        -:    0:Graph:toml.gcno
        -:    0:Data:toml.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2:
        -:    3:  MIT License
        -:    4:
        -:    5:  Copyright (c) CK Tan
        -:    6:  https://github.com/cktan/tomlc99
        -:    7:
        -:    8:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    9:  of this software and associated documentation files (the "Software"), to deal
        -:   10:  in the Software without restriction, including without limitation the rights
        -:   11:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   12:  copies of the Software, and to permit persons to whom the Software is
        -:   13:  furnished to do so, subject to the following conditions:
        -:   14:
        -:   15:  The above copyright notice and this permission notice shall be included in all
        -:   16:  copies or substantial portions of the Software.
        -:   17:
        -:   18:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   19:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   20:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   21:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   22:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   23:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   24:  SOFTWARE.
        -:   25:
        -:   26:*/
        -:   27:#define _POSIX_C_SOURCE 200809L
        -:   28:#include <assert.h>
        -:   29:#include <ctype.h>
        -:   30:#include <errno.h>
        -:   31:#include <stdbool.h>
        -:   32:#include <stdint.h>
        -:   33:#include <stdio.h>
        -:   34:#include <stdlib.h>
        -:   35:#include <string.h>
        -:   36:#include <toml/toml.h>
        -:   37:
        -:   38:static void* (*ppmalloc)(size_t) = malloc;
        -:   39:static void (*ppfree)(void*) = free;
        -:   40:
    #####:   41:void toml_set_memutil(void* (*xxmalloc)(size_t), void (*xxfree)(void*))
        -:   42:{
    #####:   43:	if (xxmalloc)
    #####:   44:		ppmalloc = xxmalloc;
    #####:   45:	if (xxfree)
    #####:   46:		ppfree = xxfree;
    #####:   47:}
        -:   48:
        -:   49:#define ALIGN8(sz) (((sz) + 7) & ~7)
        -:   50:#define MALLOC(a) ppmalloc(a)
        -:   51:#define FREE(a) ppfree(a)
        -:   52:
        -:   53:#define malloc(x) error - forbidden - use MALLOC instead
        -:   54:#define free(x) error - forbidden - use FREE instead
        -:   55:#define calloc(x, y) error - forbidden - use CALLOC instead
        -:   56:
    #####:   57:static void* CALLOC(size_t nmemb, size_t sz)
        -:   58:{
    #####:   59:	int nb = ALIGN8(sz) * nmemb;
    #####:   60:	void* p = MALLOC(nb);
    #####:   61:	if (p)
        -:   62:	{
    #####:   63:		memset(p, 0, nb);
        -:   64:	}
    #####:   65:	return p;
        -:   66:}
        -:   67:
        -:   68:// some old platforms define strdup macro -- drop it.
        -:   69:#undef strdup
        -:   70:#define strdup(x) error - forbidden - use STRDUP instead
        -:   71:
    #####:   72:static char* STRDUP(const char* s)
        -:   73:{
    #####:   74:	int len = strlen(s);
    #####:   75:	char* p = MALLOC(len + 1);
    #####:   76:	if (p)
        -:   77:	{
    #####:   78:		memcpy(p, s, len);
    #####:   79:		p[len] = 0;
        -:   80:	}
    #####:   81:	return p;
        -:   82:}
        -:   83:
        -:   84:// some old platforms define strndup macro -- drop it.
        -:   85:#undef strndup
        -:   86:#define strndup(x) error - forbiden - use STRNDUP instead
        -:   87:
    #####:   88:static char* STRNDUP(const char* s, size_t n)
        -:   89:{
    #####:   90:	size_t len = strnlen(s, n);
    #####:   91:	char* p = MALLOC(len + 1);
    #####:   92:	if (p)
        -:   93:	{
    #####:   94:		memcpy(p, s, len);
    #####:   95:		p[len] = 0;
        -:   96:	}
    #####:   97:	return p;
        -:   98:}
        -:   99:
        -:  100:/**
        -:  101: * Convert a char in utf8 into UCS, and store it in *ret.
        -:  102: * Return bytes consumed or -1 on failure.
        -:  103: */
    #####:  104:int toml_utf8_to_ucs(const char* orig, int len, int64_t* ret)
        -:  105:{
    #####:  106:	const unsigned char* buf = (const unsigned char*)orig;
    #####:  107:	unsigned i = *buf++;
        -:  108:	int64_t v;
        -:  109:
        -:  110:	/* 0x00000000 - 0x0000007F:
        -:  111:	   0xxxxxxx
        -:  112:	*/
    #####:  113:	if (0 == (i >> 7))
        -:  114:	{
    #####:  115:		if (len < 1)
    #####:  116:			return -1;
    #####:  117:		v = i;
    #####:  118:		return *ret = v, 1;
        -:  119:	}
        -:  120:	/* 0x00000080 - 0x000007FF:
        -:  121:	   110xxxxx 10xxxxxx
        -:  122:	*/
    #####:  123:	if (0x6 == (i >> 5))
        -:  124:	{
    #####:  125:		if (len < 2)
    #####:  126:			return -1;
    #####:  127:		v = i & 0x1f;
    #####:  128:		for (int j = 0; j < 1; j++)
        -:  129:		{
    #####:  130:			i = *buf++;
    #####:  131:			if (0x2 != (i >> 6))
    #####:  132:				return -1;
    #####:  133:			v = (v << 6) | (i & 0x3f);
        -:  134:		}
    #####:  135:		return *ret = v, (const char*)buf - orig;
        -:  136:	}
        -:  137:
        -:  138:	/* 0x00000800 - 0x0000FFFF:
        -:  139:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  140:	*/
    #####:  141:	if (0xE == (i >> 4))
        -:  142:	{
    #####:  143:		if (len < 3)
    #####:  144:			return -1;
    #####:  145:		v = i & 0x0F;
    #####:  146:		for (int j = 0; j < 2; j++)
        -:  147:		{
    #####:  148:			i = *buf++;
    #####:  149:			if (0x2 != (i >> 6))
    #####:  150:				return -1;
    #####:  151:			v = (v << 6) | (i & 0x3f);
        -:  152:		}
    #####:  153:		return *ret = v, (const char*)buf - orig;
        -:  154:	}
        -:  155:
        -:  156:	/* 0x00010000 - 0x001FFFFF:
        -:  157:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  158:	*/
    #####:  159:	if (0x1E == (i >> 3))
        -:  160:	{
    #####:  161:		if (len < 4)
    #####:  162:			return -1;
    #####:  163:		v = i & 0x07;
    #####:  164:		for (int j = 0; j < 3; j++)
        -:  165:		{
    #####:  166:			i = *buf++;
    #####:  167:			if (0x2 != (i >> 6))
    #####:  168:				return -1;
    #####:  169:			v = (v << 6) | (i & 0x3f);
        -:  170:		}
    #####:  171:		return *ret = v, (const char*)buf - orig;
        -:  172:	}
        -:  173:
        -:  174:	/* 0x00200000 - 0x03FFFFFF:
        -:  175:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  176:	*/
    #####:  177:	if (0x3E == (i >> 2))
        -:  178:	{
    #####:  179:		if (len < 5)
    #####:  180:			return -1;
    #####:  181:		v = i & 0x03;
    #####:  182:		for (int j = 0; j < 4; j++)
        -:  183:		{
    #####:  184:			i = *buf++;
    #####:  185:			if (0x2 != (i >> 6))
    #####:  186:				return -1;
    #####:  187:			v = (v << 6) | (i & 0x3f);
        -:  188:		}
    #####:  189:		return *ret = v, (const char*)buf - orig;
        -:  190:	}
        -:  191:
        -:  192:	/* 0x04000000 - 0x7FFFFFFF:
        -:  193:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  194:	*/
    #####:  195:	if (0x7e == (i >> 1))
        -:  196:	{
    #####:  197:		if (len < 6)
    #####:  198:			return -1;
    #####:  199:		v = i & 0x01;
    #####:  200:		for (int j = 0; j < 5; j++)
        -:  201:		{
    #####:  202:			i = *buf++;
    #####:  203:			if (0x2 != (i >> 6))
    #####:  204:				return -1;
    #####:  205:			v = (v << 6) | (i & 0x3f);
        -:  206:		}
    #####:  207:		return *ret = v, (const char*)buf - orig;
        -:  208:	}
    #####:  209:	return -1;
        -:  210:}
        -:  211:
        -:  212:/**
        -:  213: *	Convert a UCS char to utf8 code, and return it in buf.
        -:  214: *	Return bytes used in buf to encode the char, or
        -:  215: *	-1 on error.
        -:  216: */
    #####:  217:int toml_ucs_to_utf8(int64_t code, char buf[6])
        -:  218:{
        -:  219:	/* http://stackoverflow.com/questions/6240055/manually-converting-unicode-codepoints-into-utf-8-and-utf-16
        -:  220:	 */
        -:  221:	/* The UCS code values 0xd800–0xdfff (UTF-16 surrogates) as well
        -:  222:	 * as 0xfffe and 0xffff (UCS noncharacters) should not appear in
        -:  223:	 * conforming UTF-8 streams.
        -:  224:	 */
    #####:  225:	if (0xd800 <= code && code <= 0xdfff)
    #####:  226:		return -1;
    #####:  227:	if (0xfffe <= code && code <= 0xffff)
    #####:  228:		return -1;
        -:  229:
        -:  230:	/* 0x00000000 - 0x0000007F:
        -:  231:	   0xxxxxxx
        -:  232:	*/
    #####:  233:	if (code < 0)
    #####:  234:		return -1;
    #####:  235:	if (code <= 0x7F)
        -:  236:	{
    #####:  237:		buf[0] = (unsigned char)code;
    #####:  238:		return 1;
        -:  239:	}
        -:  240:
        -:  241:	/* 0x00000080 - 0x000007FF:
        -:  242:	   110xxxxx 10xxxxxx
        -:  243:	*/
    #####:  244:	if (code <= 0x000007FF)
        -:  245:	{
    #####:  246:		buf[0] = (unsigned char)(0xc0 | (code >> 6));
    #####:  247:		buf[1] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  248:		return 2;
        -:  249:	}
        -:  250:
        -:  251:	/* 0x00000800 - 0x0000FFFF:
        -:  252:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  253:	*/
    #####:  254:	if (code <= 0x0000FFFF)
        -:  255:	{
    #####:  256:		buf[0] = (unsigned char)(0xe0 | (code >> 12));
    #####:  257:		buf[1] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  258:		buf[2] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  259:		return 3;
        -:  260:	}
        -:  261:
        -:  262:	/* 0x00010000 - 0x001FFFFF:
        -:  263:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  264:	*/
    #####:  265:	if (code <= 0x001FFFFF)
        -:  266:	{
    #####:  267:		buf[0] = (unsigned char)(0xf0 | (code >> 18));
    #####:  268:		buf[1] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  269:		buf[2] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  270:		buf[3] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  271:		return 4;
        -:  272:	}
        -:  273:
        -:  274:	/* 0x00200000 - 0x03FFFFFF:
        -:  275:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  276:	*/
    #####:  277:	if (code <= 0x03FFFFFF)
        -:  278:	{
    #####:  279:		buf[0] = (unsigned char)(0xf8 | (code >> 24));
    #####:  280:		buf[1] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  281:		buf[2] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  282:		buf[3] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  283:		buf[4] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  284:		return 5;
        -:  285:	}
        -:  286:
        -:  287:	/* 0x04000000 - 0x7FFFFFFF:
        -:  288:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  289:	*/
    #####:  290:	if (code <= 0x7FFFFFFF)
        -:  291:	{
    #####:  292:		buf[0] = (unsigned char)(0xfc | (code >> 30));
    #####:  293:		buf[1] = (unsigned char)(0x80 | ((code >> 24) & 0x3f));
    #####:  294:		buf[2] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  295:		buf[3] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  296:		buf[4] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  297:		buf[5] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  298:		return 6;
        -:  299:	}
        -:  300:
    #####:  301:	return -1;
        -:  302:}
        -:  303:
        -:  304:/*
        -:  305: *	TOML has 3 data structures: value, array, table.
        -:  306: *	Each of them can have identification key.
        -:  307: */
        -:  308:typedef struct toml_keyval_t toml_keyval_t;
        -:  309:struct toml_keyval_t
        -:  310:{
        -:  311:	const char* key; /* key to this value */
        -:  312:	const char* val; /* the raw value */
        -:  313:};
        -:  314:
        -:  315:typedef struct toml_arritem_t toml_arritem_t;
        -:  316:struct toml_arritem_t
        -:  317:{
        -:  318:	int valtype; /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring,
        -:  319:			't'ime, 'D'ate, 'T'imestamp */
        -:  320:	char* val;
        -:  321:	toml_array_t* arr;
        -:  322:	toml_table_t* tab;
        -:  323:};
        -:  324:
        -:  325:struct toml_array_t
        -:  326:{
        -:  327:	const char* key; /* key to this array */
        -:  328:	int kind;	 /* element kind: 'v'alue, 'a'rray, or 't'able, 'm'ixed */
        -:  329:	int type;	 /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring, 't'ime,
        -:  330:			    'D'ate, 'T'imestamp, 'm'ixed */
        -:  331:
        -:  332:	int nitem; /* number of elements */
        -:  333:	toml_arritem_t* item;
        -:  334:};
        -:  335:
        -:  336:struct toml_table_t
        -:  337:{
        -:  338:	const char* key; /* key to this table */
        -:  339:	bool implicit;	 /* table was created implicitly */
        -:  340:	bool readonly;	 /* no more modification allowed */
        -:  341:
        -:  342:	/* key-values in the table */
        -:  343:	int nkval;
        -:  344:	toml_keyval_t** kval;
        -:  345:
        -:  346:	/* arrays in the table */
        -:  347:	int narr;
        -:  348:	toml_array_t** arr;
        -:  349:
        -:  350:	/* tables in the table */
        -:  351:	int ntab;
        -:  352:	toml_table_t** tab;
        -:  353:};
        -:  354:
    #####:  355:static inline void xfree(const void* x)
        -:  356:{
    #####:  357:	if (x)
    #####:  358:		FREE((void*)(intptr_t)x);
    #####:  359:}
        -:  360:
        -:  361:enum tokentype_t
        -:  362:{
        -:  363:	INVALID,
        -:  364:	DOT,
        -:  365:	COMMA,
        -:  366:	EQUAL,
        -:  367:	LBRACE,
        -:  368:	RBRACE,
        -:  369:	NEWLINE,
        -:  370:	LBRACKET,
        -:  371:	RBRACKET,
        -:  372:	STRING,
        -:  373:};
        -:  374:typedef enum tokentype_t tokentype_t;
        -:  375:
        -:  376:typedef struct token_t token_t;
        -:  377:struct token_t
        -:  378:{
        -:  379:	tokentype_t tok;
        -:  380:	int lineno;
        -:  381:	char* ptr; /* points into context->start */
        -:  382:	int len;
        -:  383:	int eof;
        -:  384:};
        -:  385:
        -:  386:typedef struct context_t context_t;
        -:  387:struct context_t
        -:  388:{
        -:  389:	char* start;
        -:  390:	char* stop;
        -:  391:	char* errbuf;
        -:  392:	int errbufsz;
        -:  393:
        -:  394:	token_t tok;
        -:  395:	toml_table_t* root;
        -:  396:	toml_table_t* curtab;
        -:  397:
        -:  398:	struct
        -:  399:	{
        -:  400:		int top;
        -:  401:		char* key[10];
        -:  402:		token_t tok[10];
        -:  403:	} tpath;
        -:  404:};
        -:  405:
        -:  406:#define STRINGIFY(x) #x
        -:  407:#define TOSTRING(x) STRINGIFY(x)
        -:  408:#define FLINE __FILE__ ":" TOSTRING(__LINE__)
        -:  409:
        -:  410:static int next_token(context_t* ctx, int dotisspecial);
        -:  411:
        -:  412:/*
        -:  413:  Error reporting. Call when an error is detected. Always return -1.
        -:  414:*/
    #####:  415:static int e_outofmemory(context_t* ctx, const char* fline)
        -:  416:{
    #####:  417:	snprintf(ctx->errbuf, ctx->errbufsz, "ERROR: out of memory (%s)",
        -:  418:		 fline);
    #####:  419:	return -1;
        -:  420:}
        -:  421:
    #####:  422:static int e_internal(context_t* ctx, const char* fline)
        -:  423:{
    #####:  424:	snprintf(ctx->errbuf, ctx->errbufsz, "internal error (%s)", fline);
    #####:  425:	return -1;
        -:  426:}
        -:  427:
    #####:  428:static int e_syntax(context_t* ctx, int lineno, const char* msg)
        -:  429:{
    #####:  430:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  431:	return -1;
        -:  432:}
        -:  433:
    #####:  434:static int e_badkey(context_t* ctx, int lineno)
        -:  435:{
    #####:  436:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: bad key", lineno);
    #####:  437:	return -1;
        -:  438:}
        -:  439:
    #####:  440:static int e_keyexists(context_t* ctx, int lineno)
        -:  441:{
    #####:  442:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: key exists", lineno);
    #####:  443:	return -1;
        -:  444:}
        -:  445:
    #####:  446:static int e_forbid(context_t* ctx, int lineno, const char* msg)
        -:  447:{
    #####:  448:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  449:	return -1;
        -:  450:}
        -:  451:
    #####:  452:static void* expand(void* p, int sz, int newsz)
        -:  453:{
    #####:  454:	void* s = MALLOC(newsz);
    #####:  455:	if (!s)
    #####:  456:		return 0;
        -:  457:
    #####:  458:	if (p)
        -:  459:	{
    #####:  460:		memcpy(s, p, sz);
    #####:  461:		FREE(p);
        -:  462:	}
    #####:  463:	return s;
        -:  464:}
        -:  465:
    #####:  466:static void** expand_ptrarr(void** p, int n)
        -:  467:{
    #####:  468:	void** s = MALLOC((n + 1) * sizeof(void*));
    #####:  469:	if (!s)
    #####:  470:		return 0;
        -:  471:
    #####:  472:	s[n] = 0;
    #####:  473:	if (p)
        -:  474:	{
    #####:  475:		memcpy(s, p, n * sizeof(void*));
    #####:  476:		FREE(p);
        -:  477:	}
    #####:  478:	return s;
        -:  479:}
        -:  480:
    #####:  481:static toml_arritem_t* expand_arritem(toml_arritem_t* p, int n)
        -:  482:{
    #####:  483:	toml_arritem_t* pp = expand(p, n * sizeof(*p), (n + 1) * sizeof(*p));
    #####:  484:	if (!pp)
    #####:  485:		return 0;
        -:  486:
    #####:  487:	memset(&pp[n], 0, sizeof(pp[n]));
    #####:  488:	return pp;
        -:  489:}
        -:  490:
    #####:  491:static char* norm_lit_str(const char* src, int srclen, int multiline,
        -:  492:			  char* errbuf, int errbufsz)
        -:  493:{
    #####:  494:	char* dst = 0; /* will write to dst[] and return it */
    #####:  495:	int max = 0;   /* max size of dst[] */
    #####:  496:	int off = 0;   /* cur offset in dst[] */
    #####:  497:	const char* sp = src;
    #####:  498:	const char* sq = src + srclen;
        -:  499:	int ch;
        -:  500:
        -:  501:	/* scan forward on src */
        -:  502:	for (;;)
        -:  503:	{
    #####:  504:		if (off >= max - 10)
        -:  505:		{ /* have some slack for misc stuff */
    #####:  506:			int newmax = max + 50;
    #####:  507:			char* x = expand(dst, max, newmax);
    #####:  508:			if (!x)
        -:  509:			{
    #####:  510:				xfree(dst);
    #####:  511:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  512:				return 0;
        -:  513:			}
    #####:  514:			dst = x;
    #####:  515:			max = newmax;
        -:  516:		}
        -:  517:
        -:  518:		/* finished? */
    #####:  519:		if (sp >= sq)
    #####:  520:			break;
        -:  521:
    #####:  522:		ch = *sp++;
        -:  523:		/* control characters other than tab is not allowed */
    #####:  524:		if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f))
        -:  525:		{
    #####:  526:			if (!(multiline && (ch == '\r' || ch == '\n')))
        -:  527:			{
    #####:  528:				xfree(dst);
    #####:  529:				snprintf(errbuf, errbufsz,
        -:  530:					 "invalid char U+%04x", ch);
    #####:  531:				return 0;
        -:  532:			}
        -:  533:		}
        -:  534:
        -:  535:		// a plain copy suffice
    #####:  536:		dst[off++] = ch;
        -:  537:	}
        -:  538:
    #####:  539:	dst[off++] = 0;
    #####:  540:	return dst;
        -:  541:}
        -:  542:
        -:  543:/*
        -:  544: * Convert src to raw unescaped utf-8 string.
        -:  545: * Returns NULL if error with errmsg in errbuf.
        -:  546: */
    #####:  547:static char* norm_basic_str(const char* src, int srclen, int multiline,
        -:  548:			    char* errbuf, int errbufsz)
        -:  549:{
    #####:  550:	char* dst = 0; /* will write to dst[] and return it */
    #####:  551:	int max = 0;   /* max size of dst[] */
    #####:  552:	int off = 0;   /* cur offset in dst[] */
    #####:  553:	const char* sp = src;
    #####:  554:	const char* sq = src + srclen;
        -:  555:	int ch;
        -:  556:
        -:  557:	/* scan forward on src */
        -:  558:	for (;;)
        -:  559:	{
    #####:  560:		if (off >= max - 10)
        -:  561:		{ /* have some slack for misc stuff */
    #####:  562:			int newmax = max + 50;
    #####:  563:			char* x = expand(dst, max, newmax);
    #####:  564:			if (!x)
        -:  565:			{
    #####:  566:				xfree(dst);
    #####:  567:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  568:				return 0;
        -:  569:			}
    #####:  570:			dst = x;
    #####:  571:			max = newmax;
        -:  572:		}
        -:  573:
        -:  574:		/* finished? */
    #####:  575:		if (sp >= sq)
    #####:  576:			break;
        -:  577:
    #####:  578:		ch = *sp++;
    #####:  579:		if (ch != '\\')
        -:  580:		{
        -:  581:			/* these chars must be escaped: U+0000 to U+0008, U+000A
        -:  582:			 * to U+001F, U+007F
        -:  583:			 */
    #####:  584:			if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f))
        -:  585:			{
    #####:  586:				if (!(multiline && (ch == '\r' || ch == '\n')))
        -:  587:				{
    #####:  588:					xfree(dst);
    #####:  589:					snprintf(errbuf, errbufsz,
        -:  590:						 "invalid char U+%04x", ch);
    #####:  591:					return 0;
        -:  592:				}
        -:  593:			}
        -:  594:
        -:  595:			// a plain copy suffice
    #####:  596:			dst[off++] = ch;
    #####:  597:			continue;
        -:  598:		}
        -:  599:
        -:  600:		/* ch was backslash. we expect the escape char. */
    #####:  601:		if (sp >= sq)
        -:  602:		{
    #####:  603:			snprintf(errbuf, errbufsz, "last backslash is invalid");
    #####:  604:			xfree(dst);
    #####:  605:			return 0;
        -:  606:		}
        -:  607:
        -:  608:		/* for multi-line, we want to kill line-ending-backslash ... */
    #####:  609:		if (multiline)
        -:  610:		{
        -:  611:
        -:  612:			// if there is only whitespace after the backslash ...
    #####:  613:			if (sp[strspn(sp, " \t\r")] == '\n')
        -:  614:			{
        -:  615:				/* skip all the following whitespaces */
    #####:  616:				sp += strspn(sp, " \t\r\n");
    #####:  617:				continue;
        -:  618:			}
        -:  619:		}
        -:  620:
        -:  621:		/* get the escaped char */
    #####:  622:		ch = *sp++;
    #####:  623:		switch (ch)
        -:  624:		{
    #####:  625:		case 'u':
        -:  626:		case 'U':
        -:  627:		{
    #####:  628:			int64_t ucs = 0;
    #####:  629:			int nhex = (ch == 'u' ? 4 : 8);
    #####:  630:			for (int i = 0; i < nhex; i++)
        -:  631:			{
    #####:  632:				if (sp >= sq)
        -:  633:				{
    #####:  634:					snprintf(errbuf, errbufsz,
        -:  635:						 "\\%c expects %d hex chars",
        -:  636:						 ch, nhex);
    #####:  637:					xfree(dst);
    #####:  638:					return 0;
        -:  639:				}
    #####:  640:				ch = *sp++;
    #####:  641:				int v = ('0' <= ch && ch <= '9')
        -:  642:					    ? ch - '0'
    #####:  643:					    : (('A' <= ch && ch <= 'F')
        -:  644:						   ? ch - 'A' + 10
    #####:  645:						   : -1);
    #####:  646:				if (-1 == v)
        -:  647:				{
    #####:  648:					snprintf(
        -:  649:					    errbuf, errbufsz,
        -:  650:					    "invalid hex chars for \\u or \\U");
    #####:  651:					xfree(dst);
    #####:  652:					return 0;
        -:  653:				}
    #####:  654:				ucs = ucs * 16 + v;
        -:  655:			}
    #####:  656:			int n = toml_ucs_to_utf8(ucs, &dst[off]);
    #####:  657:			if (-1 == n)
        -:  658:			{
    #####:  659:				snprintf(errbuf, errbufsz,
        -:  660:					 "illegal ucs code in \\u or \\U");
    #####:  661:				xfree(dst);
    #####:  662:				return 0;
        -:  663:			}
    #####:  664:			off += n;
        -:  665:		}
    #####:  666:			continue;
        -:  667:
    #####:  668:		case 'b':
    #####:  669:			ch = '\b';
    #####:  670:			break;
    #####:  671:		case 't':
    #####:  672:			ch = '\t';
    #####:  673:			break;
    #####:  674:		case 'n':
    #####:  675:			ch = '\n';
    #####:  676:			break;
    #####:  677:		case 'f':
    #####:  678:			ch = '\f';
    #####:  679:			break;
    #####:  680:		case 'r':
    #####:  681:			ch = '\r';
    #####:  682:			break;
    #####:  683:		case '"':
    #####:  684:			ch = '"';
    #####:  685:			break;
    #####:  686:		case '\\':
    #####:  687:			ch = '\\';
    #####:  688:			break;
    #####:  689:		default:
    #####:  690:			snprintf(errbuf, errbufsz, "illegal escape char \\%c",
        -:  691:				 ch);
    #####:  692:			xfree(dst);
    #####:  693:			return 0;
        -:  694:		}
        -:  695:
    #####:  696:		dst[off++] = ch;
        -:  697:	}
        -:  698:
        -:  699:	// Cap with NUL and return it.
    #####:  700:	dst[off++] = 0;
    #####:  701:	return dst;
        -:  702:}
        -:  703:
        -:  704:/* Normalize a key. Convert all special chars to raw unescaped utf-8 chars. */
    #####:  705:static char* normalize_key(context_t* ctx, token_t strtok)
        -:  706:{
    #####:  707:	const char* sp = strtok.ptr;
    #####:  708:	const char* sq = strtok.ptr + strtok.len;
    #####:  709:	int lineno = strtok.lineno;
        -:  710:	char* ret;
    #####:  711:	int ch = *sp;
        -:  712:	char ebuf[80];
        -:  713:
        -:  714:	/* handle quoted string */
    #####:  715:	if (ch == '\'' || ch == '\"')
        -:  716:	{
        -:  717:		/* if ''' or """, take 3 chars off front and back. Else, take 1
        -:  718:		 * char off. */
    #####:  719:		int multiline = 0;
    #####:  720:		if (sp[1] == ch && sp[2] == ch)
        -:  721:		{
    #####:  722:			sp += 3, sq -= 3;
    #####:  723:			multiline = 1;
        -:  724:		}
        -:  725:		else
    #####:  726:			sp++, sq--;
        -:  727:
    #####:  728:		if (ch == '\'')
        -:  729:		{
        -:  730:			/* for single quote, take it verbatim. */
    #####:  731:			if (!(ret = STRNDUP(sp, sq - sp)))
        -:  732:			{
    #####:  733:				e_outofmemory(ctx, FLINE);
    #####:  734:				return 0;
        -:  735:			}
        -:  736:		}
        -:  737:		else
        -:  738:		{
        -:  739:			/* for double quote, we need to normalize */
    #####:  740:			ret = norm_basic_str(sp, sq - sp, multiline, ebuf,
        -:  741:					     sizeof(ebuf));
    #####:  742:			if (!ret)
        -:  743:			{
    #####:  744:				e_syntax(ctx, lineno, ebuf);
    #####:  745:				return 0;
        -:  746:			}
        -:  747:		}
        -:  748:
        -:  749:		/* newlines are not allowed in keys */
    #####:  750:		if (strchr(ret, '\n'))
        -:  751:		{
    #####:  752:			xfree(ret);
    #####:  753:			e_badkey(ctx, lineno);
    #####:  754:			return 0;
        -:  755:		}
    #####:  756:		return ret;
        -:  757:	}
        -:  758:
        -:  759:	/* for bare-key allow only this regex: [A-Za-z0-9_-]+ */
        -:  760:	const char* xp;
    #####:  761:	for (xp = sp; xp != sq; xp++)
        -:  762:	{
    #####:  763:		int k = *xp;
    #####:  764:		if (isalnum(k))
    #####:  765:			continue;
    #####:  766:		if (k == '_' || k == '-')
    #####:  767:			continue;
    #####:  768:		e_badkey(ctx, lineno);
    #####:  769:		return 0;
        -:  770:	}
        -:  771:
        -:  772:	/* dup and return it */
    #####:  773:	if (!(ret = STRNDUP(sp, sq - sp)))
        -:  774:	{
    #####:  775:		e_outofmemory(ctx, FLINE);
    #####:  776:		return 0;
        -:  777:	}
    #####:  778:	return ret;
        -:  779:}
        -:  780:
        -:  781:/*
        -:  782: * Look up key in tab. Return 0 if not found, or
        -:  783: * 'v'alue, 'a'rray or 't'able depending on the element.
        -:  784: */
    #####:  785:static int check_key(toml_table_t* tab, const char* key,
        -:  786:		     toml_keyval_t** ret_val, toml_array_t** ret_arr,
        -:  787:		     toml_table_t** ret_tab)
        -:  788:{
        -:  789:	int i;
        -:  790:	void* dummy;
        -:  791:
    #####:  792:	if (!ret_tab)
    #####:  793:		ret_tab = (toml_table_t**)&dummy;
    #####:  794:	if (!ret_arr)
    #####:  795:		ret_arr = (toml_array_t**)&dummy;
    #####:  796:	if (!ret_val)
    #####:  797:		ret_val = (toml_keyval_t**)&dummy;
        -:  798:
    #####:  799:	*ret_tab = 0;
    #####:  800:	*ret_arr = 0;
    #####:  801:	*ret_val = 0;
        -:  802:
    #####:  803:	for (i = 0; i < tab->nkval; i++)
        -:  804:	{
    #####:  805:		if (0 == strcmp(key, tab->kval[i]->key))
        -:  806:		{
    #####:  807:			*ret_val = tab->kval[i];
    #####:  808:			return 'v';
        -:  809:		}
        -:  810:	}
    #####:  811:	for (i = 0; i < tab->narr; i++)
        -:  812:	{
    #####:  813:		if (0 == strcmp(key, tab->arr[i]->key))
        -:  814:		{
    #####:  815:			*ret_arr = tab->arr[i];
    #####:  816:			return 'a';
        -:  817:		}
        -:  818:	}
    #####:  819:	for (i = 0; i < tab->ntab; i++)
        -:  820:	{
    #####:  821:		if (0 == strcmp(key, tab->tab[i]->key))
        -:  822:		{
    #####:  823:			*ret_tab = tab->tab[i];
    #####:  824:			return 't';
        -:  825:		}
        -:  826:	}
    #####:  827:	return 0;
        -:  828:}
        -:  829:
    #####:  830:static int key_kind(toml_table_t* tab, const char* key)
        -:  831:{
    #####:  832:	return check_key(tab, key, 0, 0, 0);
        -:  833:}
        -:  834:
        -:  835:/* Create a keyval in the table.
        -:  836: */
    #####:  837:static toml_keyval_t* create_keyval_in_table(context_t* ctx, toml_table_t* tab,
        -:  838:					     token_t keytok)
        -:  839:{
        -:  840:	/* first, normalize the key to be used for lookup.
        -:  841:	 * remember to free it if we error out.
        -:  842:	 */
    #####:  843:	char* newkey = normalize_key(ctx, keytok);
    #####:  844:	if (!newkey)
    #####:  845:		return 0;
        -:  846:
        -:  847:	/* if key exists: error out. */
    #####:  848:	toml_keyval_t* dest = 0;
    #####:  849:	if (key_kind(tab, newkey))
        -:  850:	{
    #####:  851:		xfree(newkey);
    #####:  852:		e_keyexists(ctx, keytok.lineno);
    #####:  853:		return 0;
        -:  854:	}
        -:  855:
        -:  856:	/* make a new entry */
    #####:  857:	int n = tab->nkval;
        -:  858:	toml_keyval_t** base;
    #####:  859:	if (0 == (base = (toml_keyval_t**)expand_ptrarr((void**)tab->kval, n)))
        -:  860:	{
    #####:  861:		xfree(newkey);
    #####:  862:		e_outofmemory(ctx, FLINE);
    #####:  863:		return 0;
        -:  864:	}
    #####:  865:	tab->kval = base;
        -:  866:
    #####:  867:	if (0 == (base[n] = (toml_keyval_t*)CALLOC(1, sizeof(*base[n]))))
        -:  868:	{
    #####:  869:		xfree(newkey);
    #####:  870:		e_outofmemory(ctx, FLINE);
    #####:  871:		return 0;
        -:  872:	}
    #####:  873:	dest = tab->kval[tab->nkval++];
        -:  874:
        -:  875:	/* save the key in the new value struct */
    #####:  876:	dest->key = newkey;
    #####:  877:	return dest;
        -:  878:}
        -:  879:
        -:  880:/* Create a table in the table.
        -:  881: */
    #####:  882:static toml_table_t* create_keytable_in_table(context_t* ctx, toml_table_t* tab,
        -:  883:					      token_t keytok)
        -:  884:{
        -:  885:	/* first, normalize the key to be used for lookup.
        -:  886:	 * remember to free it if we error out.
        -:  887:	 */
    #####:  888:	char* newkey = normalize_key(ctx, keytok);
    #####:  889:	if (!newkey)
    #####:  890:		return 0;
        -:  891:
        -:  892:	/* if key exists: error out */
    #####:  893:	toml_table_t* dest = 0;
    #####:  894:	if (check_key(tab, newkey, 0, 0, &dest))
        -:  895:	{
    #####:  896:		xfree(newkey); /* don't need this anymore */
        -:  897:
        -:  898:		/* special case: if table exists, but was created implicitly ...
        -:  899:		 */
    #####:  900:		if (dest && dest->implicit)
        -:  901:		{
        -:  902:			/* we make it explicit now, and simply return it. */
    #####:  903:			dest->implicit = false;
    #####:  904:			return dest;
        -:  905:		}
    #####:  906:		e_keyexists(ctx, keytok.lineno);
    #####:  907:		return 0;
        -:  908:	}
        -:  909:
        -:  910:	/* create a new table entry */
    #####:  911:	int n = tab->ntab;
        -:  912:	toml_table_t** base;
    #####:  913:	if (0 == (base = (toml_table_t**)expand_ptrarr((void**)tab->tab, n)))
        -:  914:	{
    #####:  915:		xfree(newkey);
    #####:  916:		e_outofmemory(ctx, FLINE);
    #####:  917:		return 0;
        -:  918:	}
    #####:  919:	tab->tab = base;
        -:  920:
    #####:  921:	if (0 == (base[n] = (toml_table_t*)CALLOC(1, sizeof(*base[n]))))
        -:  922:	{
    #####:  923:		xfree(newkey);
    #####:  924:		e_outofmemory(ctx, FLINE);
    #####:  925:		return 0;
        -:  926:	}
    #####:  927:	dest = tab->tab[tab->ntab++];
        -:  928:
        -:  929:	/* save the key in the new table struct */
    #####:  930:	dest->key = newkey;
    #####:  931:	return dest;
        -:  932:}
        -:  933:
        -:  934:/* Create an array in the table.
        -:  935: */
    #####:  936:static toml_array_t* create_keyarray_in_table(context_t* ctx, toml_table_t* tab,
        -:  937:					      token_t keytok, char kind)
        -:  938:{
        -:  939:	/* first, normalize the key to be used for lookup.
        -:  940:	 * remember to free it if we error out.
        -:  941:	 */
    #####:  942:	char* newkey = normalize_key(ctx, keytok);
    #####:  943:	if (!newkey)
    #####:  944:		return 0;
        -:  945:
        -:  946:	/* if key exists: error out */
    #####:  947:	if (key_kind(tab, newkey))
        -:  948:	{
    #####:  949:		xfree(newkey); /* don't need this anymore */
    #####:  950:		e_keyexists(ctx, keytok.lineno);
    #####:  951:		return 0;
        -:  952:	}
        -:  953:
        -:  954:	/* make a new array entry */
    #####:  955:	int n = tab->narr;
        -:  956:	toml_array_t** base;
    #####:  957:	if (0 == (base = (toml_array_t**)expand_ptrarr((void**)tab->arr, n)))
        -:  958:	{
    #####:  959:		xfree(newkey);
    #####:  960:		e_outofmemory(ctx, FLINE);
    #####:  961:		return 0;
        -:  962:	}
    #####:  963:	tab->arr = base;
        -:  964:
    #####:  965:	if (0 == (base[n] = (toml_array_t*)CALLOC(1, sizeof(*base[n]))))
        -:  966:	{
    #####:  967:		xfree(newkey);
    #####:  968:		e_outofmemory(ctx, FLINE);
    #####:  969:		return 0;
        -:  970:	}
    #####:  971:	toml_array_t* dest = tab->arr[tab->narr++];
        -:  972:
        -:  973:	/* save the key in the new array struct */
    #####:  974:	dest->key = newkey;
    #####:  975:	dest->kind = kind;
    #####:  976:	return dest;
        -:  977:}
        -:  978:
    #####:  979:static toml_arritem_t* create_value_in_array(context_t* ctx,
        -:  980:					     toml_array_t* parent)
        -:  981:{
    #####:  982:	const int n = parent->nitem;
    #####:  983:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####:  984:	if (!base)
        -:  985:	{
    #####:  986:		e_outofmemory(ctx, FLINE);
    #####:  987:		return 0;
        -:  988:	}
    #####:  989:	parent->item = base;
    #####:  990:	parent->nitem++;
    #####:  991:	return &parent->item[n];
        -:  992:}
        -:  993:
        -:  994:/* Create an array in an array
        -:  995: */
    #####:  996:static toml_array_t* create_array_in_array(context_t* ctx, toml_array_t* parent)
        -:  997:{
    #####:  998:	const int n = parent->nitem;
    #####:  999:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####: 1000:	if (!base)
        -: 1001:	{
    #####: 1002:		e_outofmemory(ctx, FLINE);
    #####: 1003:		return 0;
        -: 1004:	}
    #####: 1005:	toml_array_t* ret = (toml_array_t*)CALLOC(1, sizeof(toml_array_t));
    #####: 1006:	if (!ret)
        -: 1007:	{
    #####: 1008:		e_outofmemory(ctx, FLINE);
    #####: 1009:		return 0;
        -: 1010:	}
    #####: 1011:	base[n].arr = ret;
    #####: 1012:	parent->item = base;
    #####: 1013:	parent->nitem++;
    #####: 1014:	return ret;
        -: 1015:}
        -: 1016:
        -: 1017:/* Create a table in an array
        -: 1018: */
    #####: 1019:static toml_table_t* create_table_in_array(context_t* ctx, toml_array_t* parent)
        -: 1020:{
    #####: 1021:	int n = parent->nitem;
    #####: 1022:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####: 1023:	if (!base)
        -: 1024:	{
    #####: 1025:		e_outofmemory(ctx, FLINE);
    #####: 1026:		return 0;
        -: 1027:	}
    #####: 1028:	toml_table_t* ret = (toml_table_t*)CALLOC(1, sizeof(toml_table_t));
    #####: 1029:	if (!ret)
        -: 1030:	{
    #####: 1031:		e_outofmemory(ctx, FLINE);
    #####: 1032:		return 0;
        -: 1033:	}
    #####: 1034:	base[n].tab = ret;
    #####: 1035:	parent->item = base;
    #####: 1036:	parent->nitem++;
    #####: 1037:	return ret;
        -: 1038:}
        -: 1039:
    #####: 1040:static int skip_newlines(context_t* ctx, int isdotspecial)
        -: 1041:{
    #####: 1042:	while (ctx->tok.tok == NEWLINE)
        -: 1043:	{
    #####: 1044:		if (next_token(ctx, isdotspecial))
    #####: 1045:			return -1;
    #####: 1046:		if (ctx->tok.eof)
    #####: 1047:			break;
        -: 1048:	}
    #####: 1049:	return 0;
        -: 1050:}
        -: 1051:
        -: 1052:static int parse_keyval(context_t* ctx, toml_table_t* tab);
        -: 1053:
    #####: 1054:static inline int eat_token(context_t* ctx, tokentype_t typ, int isdotspecial,
        -: 1055:			    const char* fline)
        -: 1056:{
    #####: 1057:	if (ctx->tok.tok != typ)
    #####: 1058:		return e_internal(ctx, fline);
        -: 1059:
    #####: 1060:	if (next_token(ctx, isdotspecial))
    #####: 1061:		return -1;
        -: 1062:
    #####: 1063:	return 0;
        -: 1064:}
        -: 1065:
        -: 1066:/* We are at '{ ... }'.
        -: 1067: * Parse the table.
        -: 1068: */
    #####: 1069:static int parse_inline_table(context_t* ctx, toml_table_t* tab)
        -: 1070:{
    #####: 1071:	if (eat_token(ctx, LBRACE, 1, FLINE))
    #####: 1072:		return -1;
        -: 1073:
        -: 1074:	for (;;)
        -: 1075:	{
    #####: 1076:		if (ctx->tok.tok == NEWLINE)
    #####: 1077:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1078:					"newline not allowed in inline table");
        -: 1079:
        -: 1080:		/* until } */
    #####: 1081:		if (ctx->tok.tok == RBRACE)
    #####: 1082:			break;
        -: 1083:
    #####: 1084:		if (ctx->tok.tok != STRING)
    #####: 1085:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1086:					"expect a string");
        -: 1087:
    #####: 1088:		if (parse_keyval(ctx, tab))
    #####: 1089:			return -1;
        -: 1090:
    #####: 1091:		if (ctx->tok.tok == NEWLINE)
    #####: 1092:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1093:					"newline not allowed in inline table");
        -: 1094:
        -: 1095:		/* on comma, continue to scan for next keyval */
    #####: 1096:		if (ctx->tok.tok == COMMA)
        -: 1097:		{
    #####: 1098:			if (eat_token(ctx, COMMA, 1, FLINE))
    #####: 1099:				return -1;
    #####: 1100:			continue;
        -: 1101:		}
    #####: 1102:		break;
        -: 1103:	}
        -: 1104:
    #####: 1105:	if (eat_token(ctx, RBRACE, 1, FLINE))
    #####: 1106:		return -1;
        -: 1107:
    #####: 1108:	tab->readonly = 1;
        -: 1109:
    #####: 1110:	return 0;
        -: 1111:}
        -: 1112:
    #####: 1113:static int valtype(const char* val)
        -: 1114:{
        -: 1115:	toml_timestamp_t ts;
    #####: 1116:	if (*val == '\'' || *val == '"')
    #####: 1117:		return 's';
    #####: 1118:	if (0 == toml_rtob(val, 0))
    #####: 1119:		return 'b';
    #####: 1120:	if (0 == toml_rtoi(val, 0))
    #####: 1121:		return 'i';
    #####: 1122:	if (0 == toml_rtod(val, 0))
    #####: 1123:		return 'd';
    #####: 1124:	if (0 == toml_rtots(val, &ts))
        -: 1125:	{
    #####: 1126:		if (ts.year && ts.hour)
    #####: 1127:			return 'T'; /* timestamp */
    #####: 1128:		if (ts.year)
    #####: 1129:			return 'D'; /* date */
    #####: 1130:		return 't';	    /* time */
        -: 1131:	}
    #####: 1132:	return 'u'; /* unknown */
        -: 1133:}
        -: 1134:
        -: 1135:/* We are at '[...]' */
    #####: 1136:static int parse_array(context_t* ctx, toml_array_t* arr)
        -: 1137:{
    #####: 1138:	if (eat_token(ctx, LBRACKET, 0, FLINE))
    #####: 1139:		return -1;
        -: 1140:
        -: 1141:	for (;;)
        -: 1142:	{
    #####: 1143:		if (skip_newlines(ctx, 0))
    #####: 1144:			return -1;
        -: 1145:
        -: 1146:		/* until ] */
    #####: 1147:		if (ctx->tok.tok == RBRACKET)
    #####: 1148:			break;
        -: 1149:
    #####: 1150:		switch (ctx->tok.tok)
        -: 1151:		{
    #####: 1152:		case STRING:
        -: 1153:		{
        -: 1154:			/* set array kind if this will be the first entry */
    #####: 1155:			if (arr->kind == 0)
    #####: 1156:				arr->kind = 'v';
    #####: 1157:			else if (arr->kind != 'v')
    #####: 1158:				arr->kind = 'm';
        -: 1159:
    #####: 1160:			char* val = ctx->tok.ptr;
    #####: 1161:			int vlen = ctx->tok.len;
        -: 1162:
        -: 1163:			/* make a new value in array */
        -: 1164:			toml_arritem_t* newval =
    #####: 1165:			    create_value_in_array(ctx, arr);
    #####: 1166:			if (!newval)
    #####: 1167:				return e_outofmemory(ctx, FLINE);
        -: 1168:
    #####: 1169:			if (!(newval->val = STRNDUP(val, vlen)))
    #####: 1170:				return e_outofmemory(ctx, FLINE);
        -: 1171:
    #####: 1172:			newval->valtype = valtype(newval->val);
        -: 1173:
        -: 1174:			/* set array type if this is the first entry */
    #####: 1175:			if (arr->nitem == 1)
    #####: 1176:				arr->type = newval->valtype;
    #####: 1177:			else if (arr->type != newval->valtype)
    #####: 1178:				arr->type = 'm'; /* mixed */
        -: 1179:
    #####: 1180:			if (eat_token(ctx, STRING, 0, FLINE))
    #####: 1181:				return -1;
    #####: 1182:			break;
        -: 1183:		}
        -: 1184:
    #####: 1185:		case LBRACKET:
        -: 1186:		{ /* [ [array], [array] ... ] */
        -: 1187:			/* set the array kind if this will be the first entry */
    #####: 1188:			if (arr->kind == 0)
    #####: 1189:				arr->kind = 'a';
    #####: 1190:			else if (arr->kind != 'a')
    #####: 1191:				arr->kind = 'm';
        -: 1192:
    #####: 1193:			toml_array_t* subarr = create_array_in_array(ctx, arr);
    #####: 1194:			if (!subarr)
    #####: 1195:				return -1;
    #####: 1196:			if (parse_array(ctx, subarr))
    #####: 1197:				return -1;
    #####: 1198:			break;
        -: 1199:		}
        -: 1200:
    #####: 1201:		case LBRACE:
        -: 1202:		{ /* [ {table}, {table} ... ] */
        -: 1203:			/* set the array kind if this will be the first entry */
    #####: 1204:			if (arr->kind == 0)
    #####: 1205:				arr->kind = 't';
    #####: 1206:			else if (arr->kind != 't')
    #####: 1207:				arr->kind = 'm';
        -: 1208:
    #####: 1209:			toml_table_t* subtab = create_table_in_array(ctx, arr);
    #####: 1210:			if (!subtab)
    #####: 1211:				return -1;
    #####: 1212:			if (parse_inline_table(ctx, subtab))
    #####: 1213:				return -1;
    #####: 1214:			break;
        -: 1215:		}
        -: 1216:
    #####: 1217:		default:
    #####: 1218:			return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1219:		}
        -: 1220:
    #####: 1221:		if (skip_newlines(ctx, 0))
    #####: 1222:			return -1;
        -: 1223:
        -: 1224:		/* on comma, continue to scan for next element */
    #####: 1225:		if (ctx->tok.tok == COMMA)
        -: 1226:		{
    #####: 1227:			if (eat_token(ctx, COMMA, 0, FLINE))
    #####: 1228:				return -1;
    #####: 1229:			continue;
        -: 1230:		}
    #####: 1231:		break;
        -: 1232:	}
        -: 1233:
    #####: 1234:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1235:		return -1;
    #####: 1236:	return 0;
        -: 1237:}
        -: 1238:
        -: 1239:/* handle lines like these:
        -: 1240:   key = "value"
        -: 1241:   key = [ array ]
        -: 1242:   key = { table }
        -: 1243:*/
    #####: 1244:static int parse_keyval(context_t* ctx, toml_table_t* tab)
        -: 1245:{
    #####: 1246:	if (tab->readonly)
        -: 1247:	{
    #####: 1248:		return e_forbid(ctx, ctx->tok.lineno,
        -: 1249:				"cannot insert new entry into existing table");
        -: 1250:	}
        -: 1251:
    #####: 1252:	token_t key = ctx->tok;
    #####: 1253:	if (eat_token(ctx, STRING, 1, FLINE))
    #####: 1254:		return -1;
        -: 1255:
    #####: 1256:	if (ctx->tok.tok == DOT)
        -: 1257:	{
        -: 1258:		/* handle inline dotted key.
        -: 1259:		   e.g.
        -: 1260:		   physical.color = "orange"
        -: 1261:		   physical.shape = "round"
        -: 1262:		*/
    #####: 1263:		toml_table_t* subtab = 0;
        -: 1264:		{
    #####: 1265:			char* subtabstr = normalize_key(ctx, key);
    #####: 1266:			if (!subtabstr)
    #####: 1267:				return -1;
        -: 1268:
    #####: 1269:			subtab = toml_table_in(tab, subtabstr);
    #####: 1270:			xfree(subtabstr);
        -: 1271:		}
    #####: 1272:		if (!subtab)
        -: 1273:		{
    #####: 1274:			subtab = create_keytable_in_table(ctx, tab, key);
    #####: 1275:			if (!subtab)
    #####: 1276:				return -1;
        -: 1277:		}
    #####: 1278:		if (next_token(ctx, 1))
    #####: 1279:			return -1;
    #####: 1280:		if (parse_keyval(ctx, subtab))
    #####: 1281:			return -1;
    #####: 1282:		return 0;
        -: 1283:	}
        -: 1284:
    #####: 1285:	if (ctx->tok.tok != EQUAL)
        -: 1286:	{
    #####: 1287:		return e_syntax(ctx, ctx->tok.lineno, "missing =");
        -: 1288:	}
        -: 1289:
    #####: 1290:	if (next_token(ctx, 0))
    #####: 1291:		return -1;
        -: 1292:
    #####: 1293:	switch (ctx->tok.tok)
        -: 1294:	{
    #####: 1295:	case STRING:
        -: 1296:	{ /* key = "value" */
    #####: 1297:		toml_keyval_t* keyval = create_keyval_in_table(ctx, tab, key);
    #####: 1298:		if (!keyval)
    #####: 1299:			return -1;
    #####: 1300:		token_t val = ctx->tok;
        -: 1301:
    #####: 1302:		assert(keyval->val == 0);
    #####: 1303:		if (!(keyval->val = STRNDUP(val.ptr, val.len)))
    #####: 1304:			return e_outofmemory(ctx, FLINE);
        -: 1305:
    #####: 1306:		if (next_token(ctx, 1))
    #####: 1307:			return -1;
        -: 1308:
    #####: 1309:		return 0;
        -: 1310:	}
        -: 1311:
    #####: 1312:	case LBRACKET:
        -: 1313:	{ /* key = [ array ] */
    #####: 1314:		toml_array_t* arr = create_keyarray_in_table(ctx, tab, key, 0);
    #####: 1315:		if (!arr)
    #####: 1316:			return -1;
    #####: 1317:		if (parse_array(ctx, arr))
    #####: 1318:			return -1;
    #####: 1319:		return 0;
        -: 1320:	}
        -: 1321:
    #####: 1322:	case LBRACE:
        -: 1323:	{ /* key = { table } */
    #####: 1324:		toml_table_t* nxttab = create_keytable_in_table(ctx, tab, key);
    #####: 1325:		if (!nxttab)
    #####: 1326:			return -1;
    #####: 1327:		if (parse_inline_table(ctx, nxttab))
    #####: 1328:			return -1;
    #####: 1329:		return 0;
        -: 1330:	}
        -: 1331:
    #####: 1332:	default:
    #####: 1333:		return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1334:	}
        -: 1335:	return 0;
        -: 1336:}
        -: 1337:
        -: 1338:typedef struct tabpath_t tabpath_t;
        -: 1339:struct tabpath_t
        -: 1340:{
        -: 1341:	int cnt;
        -: 1342:	token_t key[10];
        -: 1343:};
        -: 1344:
        -: 1345:/* at [x.y.z] or [[x.y.z]]
        -: 1346: * Scan forward and fill tabpath until it enters ] or ]]
        -: 1347: * There will be at least one entry on return.
        -: 1348: */
    #####: 1349:static int fill_tabpath(context_t* ctx)
        -: 1350:{
    #####: 1351:	int lineno = ctx->tok.lineno;
        -: 1352:	int i;
        -: 1353:
        -: 1354:	/* clear tpath */
    #####: 1355:	for (i = 0; i < ctx->tpath.top; i++)
        -: 1356:	{
    #####: 1357:		char** p = &ctx->tpath.key[i];
    #####: 1358:		xfree(*p);
    #####: 1359:		*p = 0;
        -: 1360:	}
    #####: 1361:	ctx->tpath.top = 0;
        -: 1362:
        -: 1363:	for (;;)
    #####: 1364:	{
    #####: 1365:		if (ctx->tpath.top >= 10)
    #####: 1366:			return e_syntax(
        -: 1367:			    ctx, lineno,
        -: 1368:			    "table path is too deep; max allowed is 10.");
        -: 1369:
    #####: 1370:		if (ctx->tok.tok != STRING)
    #####: 1371:			return e_syntax(ctx, lineno, "invalid or missing key");
        -: 1372:
    #####: 1373:		char* key = normalize_key(ctx, ctx->tok);
    #####: 1374:		if (!key)
    #####: 1375:			return -1;
    #####: 1376:		ctx->tpath.tok[ctx->tpath.top] = ctx->tok;
    #####: 1377:		ctx->tpath.key[ctx->tpath.top] = key;
    #####: 1378:		ctx->tpath.top++;
        -: 1379:
    #####: 1380:		if (next_token(ctx, 1))
    #####: 1381:			return -1;
        -: 1382:
    #####: 1383:		if (ctx->tok.tok == RBRACKET)
    #####: 1384:			break;
        -: 1385:
    #####: 1386:		if (ctx->tok.tok != DOT)
    #####: 1387:			return e_syntax(ctx, lineno, "invalid key");
        -: 1388:
    #####: 1389:		if (next_token(ctx, 1))
    #####: 1390:			return -1;
        -: 1391:	}
        -: 1392:
    #####: 1393:	if (ctx->tpath.top <= 0)
    #####: 1394:		return e_syntax(ctx, lineno, "empty table selector");
        -: 1395:
    #####: 1396:	return 0;
        -: 1397:}
        -: 1398:
        -: 1399:/* Walk tabpath from the root, and create new tables on the way.
        -: 1400: * Sets ctx->curtab to the final table.
        -: 1401: */
    #####: 1402:static int walk_tabpath(context_t* ctx)
        -: 1403:{
        -: 1404:	/* start from root */
    #####: 1405:	toml_table_t* curtab = ctx->root;
        -: 1406:
    #####: 1407:	for (int i = 0; i < ctx->tpath.top; i++)
        -: 1408:	{
    #####: 1409:		const char* key = ctx->tpath.key[i];
        -: 1410:
    #####: 1411:		toml_keyval_t* nextval = 0;
    #####: 1412:		toml_array_t* nextarr = 0;
    #####: 1413:		toml_table_t* nexttab = 0;
    #####: 1414:		switch (check_key(curtab, key, &nextval, &nextarr, &nexttab))
        -: 1415:		{
    #####: 1416:		case 't':
        -: 1417:			/* found a table. nexttab is where we will go next. */
    #####: 1418:			break;
        -: 1419:
    #####: 1420:		case 'a':
        -: 1421:			/* found an array. nexttab is the last table in the
        -: 1422:			 * array. */
    #####: 1423:			if (nextarr->kind != 't')
    #####: 1424:				return e_internal(ctx, FLINE);
        -: 1425:
    #####: 1426:			if (nextarr->nitem == 0)
    #####: 1427:				return e_internal(ctx, FLINE);
        -: 1428:
    #####: 1429:			nexttab = nextarr->item[nextarr->nitem - 1].tab;
    #####: 1430:			break;
        -: 1431:
    #####: 1432:		case 'v':
    #####: 1433:			return e_keyexists(ctx, ctx->tpath.tok[i].lineno);
        -: 1434:
    #####: 1435:		default:
        -: 1436:		{ /* Not found. Let's create an implicit table. */
    #####: 1437:			int n = curtab->ntab;
    #####: 1438:			toml_table_t** base = (toml_table_t**)expand_ptrarr(
    #####: 1439:			    (void**)curtab->tab, n);
    #####: 1440:			if (0 == base)
    #####: 1441:				return e_outofmemory(ctx, FLINE);
        -: 1442:
    #####: 1443:			curtab->tab = base;
        -: 1444:
    #####: 1445:			if (0 == (base[n] = (toml_table_t*)CALLOC(1, sizeof(*base[n]))))
    #####: 1446:				return e_outofmemory(ctx, FLINE);
        -: 1447:
    #####: 1448:			if (0 == (base[n]->key = STRDUP(key)))
    #####: 1449:				return e_outofmemory(ctx, FLINE);
        -: 1450:
    #####: 1451:			nexttab = curtab->tab[curtab->ntab++];
        -: 1452:
        -: 1453:			/* tabs created by walk_tabpath are considered implicit
        -: 1454:			 */
    #####: 1455:			nexttab->implicit = true;
        -: 1456:		}
    #####: 1457:		break;
        -: 1458:		}
        -: 1459:
        -: 1460:		/* switch to next tab */
    #####: 1461:		curtab = nexttab;
        -: 1462:	}
        -: 1463:
        -: 1464:	/* save it */
    #####: 1465:	ctx->curtab = curtab;
        -: 1466:
    #####: 1467:	return 0;
        -: 1468:}
        -: 1469:
        -: 1470:/* handle lines like [x.y.z] or [[x.y.z]] */
    #####: 1471:static int parse_select(context_t* ctx)
        -: 1472:{
    #####: 1473:	assert(ctx->tok.tok == LBRACKET);
        -: 1474:
        -: 1475:	/* true if [[ */
    #####: 1476:	int llb = (ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == '[');
        -: 1477:	/* need to detect '[[' on our own because next_token() will skip
        -: 1478:	   whitespace, and '[ [' would be taken as '[[', which is wrong. */
        -: 1479:
        -: 1480:	/* eat [ or [[ */
    #####: 1481:	if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1482:		return -1;
    #####: 1483:	if (llb)
        -: 1484:	{
    #####: 1485:		assert(ctx->tok.tok == LBRACKET);
    #####: 1486:		if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1487:			return -1;
        -: 1488:	}
        -: 1489:
    #####: 1490:	if (fill_tabpath(ctx))
    #####: 1491:		return -1;
        -: 1492:
        -: 1493:	/* For [x.y.z] or [[x.y.z]], remove z from tpath.
        -: 1494:	 */
    #####: 1495:	token_t z = ctx->tpath.tok[ctx->tpath.top - 1];
    #####: 1496:	xfree(ctx->tpath.key[ctx->tpath.top - 1]);
    #####: 1497:	ctx->tpath.top--;
        -: 1498:
        -: 1499:	/* set up ctx->curtab */
    #####: 1500:	if (walk_tabpath(ctx))
    #####: 1501:		return -1;
        -: 1502:
    #####: 1503:	if (!llb)
        -: 1504:	{
        -: 1505:		/* [x.y.z] -> create z = {} in x.y */
        -: 1506:		toml_table_t* curtab =
    #####: 1507:		    create_keytable_in_table(ctx, ctx->curtab, z);
    #####: 1508:		if (!curtab)
    #####: 1509:			return -1;
    #####: 1510:		ctx->curtab = curtab;
        -: 1511:	}
        -: 1512:	else
        -: 1513:	{
        -: 1514:		/* [[x.y.z]] -> create z = [] in x.y */
    #####: 1515:		toml_array_t* arr = 0;
        -: 1516:		{
    #####: 1517:			char* zstr = normalize_key(ctx, z);
    #####: 1518:			if (!zstr)
    #####: 1519:				return -1;
    #####: 1520:			arr = toml_array_in(ctx->curtab, zstr);
    #####: 1521:			xfree(zstr);
        -: 1522:		}
    #####: 1523:		if (!arr)
        -: 1524:		{
        -: 1525:			arr =
    #####: 1526:			    create_keyarray_in_table(ctx, ctx->curtab, z, 't');
    #####: 1527:			if (!arr)
    #####: 1528:				return -1;
        -: 1529:		}
    #####: 1530:		if (arr->kind != 't')
    #####: 1531:			return e_syntax(ctx, z.lineno, "array mismatch");
        -: 1532:
        -: 1533:		/* add to z[] */
        -: 1534:		toml_table_t* dest;
        -: 1535:		{
    #####: 1536:			toml_table_t* t = create_table_in_array(ctx, arr);
    #####: 1537:			if (!t)
    #####: 1538:				return -1;
        -: 1539:
    #####: 1540:			if (0 == (t->key = STRDUP("__anon__")))
    #####: 1541:				return e_outofmemory(ctx, FLINE);
        -: 1542:
    #####: 1543:			dest = t;
        -: 1544:		}
        -: 1545:
    #####: 1546:		ctx->curtab = dest;
        -: 1547:	}
        -: 1548:
    #####: 1549:	if (ctx->tok.tok != RBRACKET)
        -: 1550:	{
    #####: 1551:		return e_syntax(ctx, ctx->tok.lineno, "expects ]");
        -: 1552:	}
    #####: 1553:	if (llb)
        -: 1554:	{
    #####: 1555:		if (!(ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == ']'))
        -: 1556:		{
    #####: 1557:			return e_syntax(ctx, ctx->tok.lineno, "expects ]]");
        -: 1558:		}
    #####: 1559:		if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1560:			return -1;
        -: 1561:	}
        -: 1562:
    #####: 1563:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1564:		return -1;
        -: 1565:
    #####: 1566:	if (ctx->tok.tok != NEWLINE)
    #####: 1567:		return e_syntax(ctx, ctx->tok.lineno,
        -: 1568:				"extra chars after ] or ]]");
        -: 1569:
    #####: 1570:	return 0;
        -: 1571:}
        -: 1572:
    #####: 1573:toml_table_t* toml_parse(char* conf, char* errbuf, int errbufsz)
        -: 1574:{
        -: 1575:	context_t ctx;
        -: 1576:
        -: 1577:	// clear errbuf
    #####: 1578:	if (errbufsz <= 0)
    #####: 1579:		errbufsz = 0;
    #####: 1580:	if (errbufsz > 0)
    #####: 1581:		errbuf[0] = 0;
        -: 1582:
        -: 1583:	// init context
    #####: 1584:	memset(&ctx, 0, sizeof(ctx));
    #####: 1585:	ctx.start = conf;
    #####: 1586:	ctx.stop = ctx.start + strlen(conf);
    #####: 1587:	ctx.errbuf = errbuf;
    #####: 1588:	ctx.errbufsz = errbufsz;
        -: 1589:
        -: 1590:	// start with an artificial newline of length 0
    #####: 1591:	ctx.tok.tok = NEWLINE;
    #####: 1592:	ctx.tok.lineno = 1;
    #####: 1593:	ctx.tok.ptr = conf;
    #####: 1594:	ctx.tok.len = 0;
        -: 1595:
        -: 1596:	// make a root table
    #####: 1597:	if (0 == (ctx.root = CALLOC(1, sizeof(*ctx.root))))
        -: 1598:	{
    #####: 1599:		e_outofmemory(&ctx, FLINE);
        -: 1600:		// Do not goto fail, root table not set up yet
    #####: 1601:		return 0;
        -: 1602:	}
        -: 1603:
        -: 1604:	// set root as default table
    #####: 1605:	ctx.curtab = ctx.root;
        -: 1606:
        -: 1607:	/* Scan forward until EOF */
    #####: 1608:	for (token_t tok = ctx.tok; !tok.eof; tok = ctx.tok)
        -: 1609:	{
    #####: 1610:		switch (tok.tok)
        -: 1611:		{
        -: 1612:
    #####: 1613:		case NEWLINE:
    #####: 1614:			if (next_token(&ctx, 1))
    #####: 1615:				goto fail;
    #####: 1616:			break;
        -: 1617:
    #####: 1618:		case STRING:
    #####: 1619:			if (parse_keyval(&ctx, ctx.curtab))
    #####: 1620:				goto fail;
        -: 1621:
    #####: 1622:			if (ctx.tok.tok != NEWLINE)
        -: 1623:			{
    #####: 1624:				e_syntax(&ctx, ctx.tok.lineno,
        -: 1625:					 "extra chars after value");
    #####: 1626:				goto fail;
        -: 1627:			}
        -: 1628:
    #####: 1629:			if (eat_token(&ctx, NEWLINE, 1, FLINE))
    #####: 1630:				goto fail;
    #####: 1631:			break;
        -: 1632:
    #####: 1633:		case LBRACKET: /* [ x.y.z ] or [[ x.y.z ]] */
    #####: 1634:			if (parse_select(&ctx))
    #####: 1635:				goto fail;
    #####: 1636:			break;
        -: 1637:
    #####: 1638:		default:
    #####: 1639:			e_syntax(&ctx, tok.lineno, "syntax error");
    #####: 1640:			goto fail;
        -: 1641:		}
        -: 1642:	}
        -: 1643:
        -: 1644:	/* success */
    #####: 1645:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1646:		xfree(ctx.tpath.key[i]);
    #####: 1647:	return ctx.root;
        -: 1648:
    #####: 1649:fail:
        -: 1650:	// Something bad has happened. Free resources and return error.
    #####: 1651:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1652:		xfree(ctx.tpath.key[i]);
    #####: 1653:	toml_free(ctx.root);
    #####: 1654:	return 0;
        -: 1655:}
        -: 1656:
    #####: 1657:toml_table_t* toml_parse_file(FILE* fp, char* errbuf, int errbufsz)
        -: 1658:{
    #####: 1659:	int bufsz = 0;
    #####: 1660:	char* buf = 0;
    #####: 1661:	int off = 0;
        -: 1662:
        -: 1663:	/* read from fp into buf */
    #####: 1664:	while (!feof(fp))
        -: 1665:	{
        -: 1666:
    #####: 1667:		if (off == bufsz)
        -: 1668:		{
    #####: 1669:			int xsz = bufsz + 1000;
    #####: 1670:			char* x = expand(buf, bufsz, xsz);
    #####: 1671:			if (!x)
        -: 1672:			{
    #####: 1673:				snprintf(errbuf, errbufsz, "out of memory");
    #####: 1674:				xfree(buf);
    #####: 1675:				return 0;
        -: 1676:			}
    #####: 1677:			buf = x;
    #####: 1678:			bufsz = xsz;
        -: 1679:		}
        -: 1680:
    #####: 1681:		errno = 0;
    #####: 1682:		int n = fread(buf + off, 1, bufsz - off, fp);
    #####: 1683:		if (ferror(fp))
        -: 1684:		{
    #####: 1685:			snprintf(errbuf, errbufsz, "%s",
    #####: 1686:				 errno ? strerror(errno)
        -: 1687:				       : "Error reading file");
    #####: 1688:			xfree(buf);
    #####: 1689:			return 0;
        -: 1690:		}
    #####: 1691:		off += n;
        -: 1692:	}
        -: 1693:
        -: 1694:	/* tag on a NUL to cap the string */
    #####: 1695:	if (off == bufsz)
        -: 1696:	{
    #####: 1697:		int xsz = bufsz + 1;
    #####: 1698:		char* x = expand(buf, bufsz, xsz);
    #####: 1699:		if (!x)
        -: 1700:		{
    #####: 1701:			snprintf(errbuf, errbufsz, "out of memory");
    #####: 1702:			xfree(buf);
    #####: 1703:			return 0;
        -: 1704:		}
    #####: 1705:		buf = x;
    #####: 1706:		bufsz = xsz;
        -: 1707:	}
    #####: 1708:	buf[off] = 0;
        -: 1709:
        -: 1710:	/* parse it, cleanup and finish */
    #####: 1711:	toml_table_t* ret = toml_parse(buf, errbuf, errbufsz);
    #####: 1712:	xfree(buf);
    #####: 1713:	return ret;
        -: 1714:}
        -: 1715:
    #####: 1716:static void xfree_kval(toml_keyval_t* p)
        -: 1717:{
    #####: 1718:	if (!p)
    #####: 1719:		return;
    #####: 1720:	xfree(p->key);
    #####: 1721:	xfree(p->val);
    #####: 1722:	xfree(p);
        -: 1723:}
        -: 1724:
        -: 1725:static void xfree_tab(toml_table_t* p);
        -: 1726:
    #####: 1727:static void xfree_arr(toml_array_t* p)
        -: 1728:{
    #####: 1729:	if (!p)
    #####: 1730:		return;
        -: 1731:
    #####: 1732:	xfree(p->key);
    #####: 1733:	const int n = p->nitem;
    #####: 1734:	for (int i = 0; i < n; i++)
        -: 1735:	{
    #####: 1736:		toml_arritem_t* a = &p->item[i];
    #####: 1737:		if (a->val)
    #####: 1738:			xfree(a->val);
    #####: 1739:		else if (a->arr)
    #####: 1740:			xfree_arr(a->arr);
    #####: 1741:		else if (a->tab)
    #####: 1742:			xfree_tab(a->tab);
        -: 1743:	}
    #####: 1744:	xfree(p->item);
    #####: 1745:	xfree(p);
        -: 1746:}
        -: 1747:
    #####: 1748:static void xfree_tab(toml_table_t* p)
        -: 1749:{
        -: 1750:	int i;
        -: 1751:
    #####: 1752:	if (!p)
    #####: 1753:		return;
        -: 1754:
    #####: 1755:	xfree(p->key);
        -: 1756:
    #####: 1757:	for (i = 0; i < p->nkval; i++)
    #####: 1758:		xfree_kval(p->kval[i]);
    #####: 1759:	xfree(p->kval);
        -: 1760:
    #####: 1761:	for (i = 0; i < p->narr; i++)
    #####: 1762:		xfree_arr(p->arr[i]);
    #####: 1763:	xfree(p->arr);
        -: 1764:
    #####: 1765:	for (i = 0; i < p->ntab; i++)
    #####: 1766:		xfree_tab(p->tab[i]);
    #####: 1767:	xfree(p->tab);
        -: 1768:
    #####: 1769:	xfree(p);
        -: 1770:}
        -: 1771:
    #####: 1772:void toml_free(toml_table_t* tab) { xfree_tab(tab); }
        -: 1773:
    #####: 1774:static void set_token(context_t* ctx, tokentype_t tok, int lineno, char* ptr,
        -: 1775:		      int len)
        -: 1776:{
        -: 1777:	token_t t;
    #####: 1778:	t.tok = tok;
    #####: 1779:	t.lineno = lineno;
    #####: 1780:	t.ptr = ptr;
    #####: 1781:	t.len = len;
    #####: 1782:	t.eof = 0;
    #####: 1783:	ctx->tok = t;
    #####: 1784:}
        -: 1785:
    #####: 1786:static void set_eof(context_t* ctx, int lineno)
        -: 1787:{
    #####: 1788:	set_token(ctx, NEWLINE, lineno, ctx->stop, 0);
    #####: 1789:	ctx->tok.eof = 1;
    #####: 1790:}
        -: 1791:
        -: 1792:/* Scan p for n digits compositing entirely of [0-9] */
    #####: 1793:static int scan_digits(const char* p, int n)
        -: 1794:{
    #####: 1795:	int ret = 0;
    #####: 1796:	for (; n > 0 && isdigit(*p); n--, p++)
        -: 1797:	{
    #####: 1798:		ret = 10 * ret + (*p - '0');
        -: 1799:	}
    #####: 1800:	return n ? -1 : ret;
        -: 1801:}
        -: 1802:
    #####: 1803:static int scan_date(const char* p, int* YY, int* MM, int* DD)
        -: 1804:{
        -: 1805:	int year, month, day;
    #####: 1806:	year = scan_digits(p, 4);
    #####: 1807:	month = (year >= 0 && p[4] == '-') ? scan_digits(p + 5, 2) : -1;
    #####: 1808:	day = (month >= 0 && p[7] == '-') ? scan_digits(p + 8, 2) : -1;
    #####: 1809:	if (YY)
    #####: 1810:		*YY = year;
    #####: 1811:	if (MM)
    #####: 1812:		*MM = month;
    #####: 1813:	if (DD)
    #####: 1814:		*DD = day;
    #####: 1815:	return (year >= 0 && month >= 0 && day >= 0) ? 0 : -1;
        -: 1816:}
        -: 1817:
    #####: 1818:static int scan_time(const char* p, int* hh, int* mm, int* ss)
        -: 1819:{
        -: 1820:	int hour, minute, second;
    #####: 1821:	hour = scan_digits(p, 2);
    #####: 1822:	minute = (hour >= 0 && p[2] == ':') ? scan_digits(p + 3, 2) : -1;
    #####: 1823:	second = (minute >= 0 && p[5] == ':') ? scan_digits(p + 6, 2) : -1;
    #####: 1824:	if (hh)
    #####: 1825:		*hh = hour;
    #####: 1826:	if (mm)
    #####: 1827:		*mm = minute;
    #####: 1828:	if (ss)
    #####: 1829:		*ss = second;
    #####: 1830:	return (hour >= 0 && minute >= 0 && second >= 0) ? 0 : -1;
        -: 1831:}
        -: 1832:
    #####: 1833:static int scan_string(context_t* ctx, char* p, int lineno, int dotisspecial)
        -: 1834:{
    #####: 1835:	char* orig = p;
    #####: 1836:	if (0 == strncmp(p, "'''", 3))
        -: 1837:	{
    #####: 1838:		char* q = p + 3;
        -: 1839:
        -: 1840:		while (1)
        -: 1841:		{
    #####: 1842:			q = strstr(q, "'''");
    #####: 1843:			if (0 == q)
        -: 1844:			{
    #####: 1845:				return e_syntax(ctx, lineno,
        -: 1846:						"unterminated triple-s-quote");
        -: 1847:			}
    #####: 1848:			while (q[3] == '\'')
    #####: 1849:				q++;
    #####: 1850:			break;
        -: 1851:		}
        -: 1852:
    #####: 1853:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1854:		return 0;
        -: 1855:	}
        -: 1856:
    #####: 1857:	if (0 == strncmp(p, "\"\"\"", 3))
        -: 1858:	{
    #####: 1859:		char* q = p + 3;
        -: 1860:
        -: 1861:		while (1)
        -: 1862:		{
    #####: 1863:			q = strstr(q, "\"\"\"");
    #####: 1864:			if (0 == q)
        -: 1865:			{
    #####: 1866:				return e_syntax(ctx, lineno,
        -: 1867:						"unterminated triple-d-quote");
        -: 1868:			}
    #####: 1869:			if (q[-1] == '\\')
        -: 1870:			{
    #####: 1871:				q++;
    #####: 1872:				continue;
        -: 1873:			}
    #####: 1874:			while (q[3] == '\"')
    #####: 1875:				q++;
    #####: 1876:			break;
        -: 1877:		}
        -: 1878:
        -: 1879:		// the string is [p+3, q-1]
        -: 1880:
    #####: 1881:		int hexreq = 0; /* #hex required */
    #####: 1882:		int escape = 0;
    #####: 1883:		for (p += 3; p < q; p++)
        -: 1884:		{
    #####: 1885:			if (escape)
        -: 1886:			{
    #####: 1887:				escape = 0;
    #####: 1888:				if (strchr("btnfr\"\\", *p))
    #####: 1889:					continue;
    #####: 1890:				if (*p == 'u')
        -: 1891:				{
    #####: 1892:					hexreq = 4;
    #####: 1893:					continue;
        -: 1894:				}
    #####: 1895:				if (*p == 'U')
        -: 1896:				{
    #####: 1897:					hexreq = 8;
    #####: 1898:					continue;
        -: 1899:				}
    #####: 1900:				if (p[strspn(p, " \t\r")] == '\n')
    #####: 1901:					continue; /* allow for line ending
        -: 1902:						     backslash */
    #####: 1903:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1904:			}
    #####: 1905:			if (hexreq)
        -: 1906:			{
    #####: 1907:				hexreq--;
    #####: 1908:				if (strchr("0123456789ABCDEF", *p))
    #####: 1909:					continue;
    #####: 1910:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1911:			}
    #####: 1912:			if (*p == '\\')
        -: 1913:			{
    #####: 1914:				escape = 1;
    #####: 1915:				continue;
        -: 1916:			}
        -: 1917:		}
    #####: 1918:		if (escape)
    #####: 1919:			return e_syntax(ctx, lineno, "expect an escape char");
    #####: 1920:		if (hexreq)
    #####: 1921:			return e_syntax(ctx, lineno, "expected more hex char");
        -: 1922:
    #####: 1923:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1924:		return 0;
        -: 1925:	}
        -: 1926:
    #####: 1927:	if ('\'' == *p)
        -: 1928:	{
    #####: 1929:		for (p++; *p && *p != '\n' && *p != '\''; p++)
        -: 1930:			;
    #####: 1931:		if (*p != '\'')
        -: 1932:		{
    #####: 1933:			return e_syntax(ctx, lineno, "unterminated s-quote");
        -: 1934:		}
        -: 1935:
    #####: 1936:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1937:		return 0;
        -: 1938:	}
        -: 1939:
    #####: 1940:	if ('\"' == *p)
        -: 1941:	{
    #####: 1942:		int hexreq = 0; /* #hex required */
    #####: 1943:		int escape = 0;
    #####: 1944:		for (p++; *p; p++)
        -: 1945:		{
    #####: 1946:			if (escape)
        -: 1947:			{
    #####: 1948:				escape = 0;
    #####: 1949:				if (strchr("btnfr\"\\", *p))
    #####: 1950:					continue;
    #####: 1951:				if (*p == 'u')
        -: 1952:				{
    #####: 1953:					hexreq = 4;
    #####: 1954:					continue;
        -: 1955:				}
    #####: 1956:				if (*p == 'U')
        -: 1957:				{
    #####: 1958:					hexreq = 8;
    #####: 1959:					continue;
        -: 1960:				}
    #####: 1961:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1962:			}
    #####: 1963:			if (hexreq)
        -: 1964:			{
    #####: 1965:				hexreq--;
    #####: 1966:				if (strchr("0123456789ABCDEF", *p))
    #####: 1967:					continue;
    #####: 1968:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1969:			}
    #####: 1970:			if (*p == '\\')
        -: 1971:			{
    #####: 1972:				escape = 1;
    #####: 1973:				continue;
        -: 1974:			}
    #####: 1975:			if (*p == '\'')
        -: 1976:			{
    #####: 1977:				if (p[1] == '\'' && p[2] == '\'')
        -: 1978:				{
    #####: 1979:					return e_syntax(
        -: 1980:					    ctx, lineno,
        -: 1981:					    "triple-s-quote inside string lit");
        -: 1982:				}
    #####: 1983:				continue;
        -: 1984:			}
    #####: 1985:			if (*p == '\n')
    #####: 1986:				break;
    #####: 1987:			if (*p == '"')
    #####: 1988:				break;
        -: 1989:		}
    #####: 1990:		if (*p != '"')
        -: 1991:		{
    #####: 1992:			return e_syntax(ctx, lineno, "unterminated quote");
        -: 1993:		}
        -: 1994:
    #####: 1995:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1996:		return 0;
        -: 1997:	}
        -: 1998:
        -: 1999:	/* check for timestamp without quotes */
    #####: 2000:	if (0 == scan_date(p, 0, 0, 0) || 0 == scan_time(p, 0, 0, 0))
        -: 2001:	{
        -: 2002:		// forward thru the timestamp
    #####: 2003:		p += strspn(p, "0123456789.:+-Tt Zz");
        -: 2004:		// squeeze out any spaces at end of string
    #####: 2005:		for (; p[-1] == ' '; p--)
        -: 2006:			;
        -: 2007:		// tokenize
    #####: 2008:		set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 2009:		return 0;
        -: 2010:	}
        -: 2011:
        -: 2012:	/* literals */
    #####: 2013:	for (; *p && *p != '\n'; p++)
        -: 2014:	{
    #####: 2015:		int ch = *p;
    #####: 2016:		if (ch == '.' && dotisspecial)
    #####: 2017:			break;
    #####: 2018:		if ('A' <= ch && ch <= 'Z')
    #####: 2019:			continue;
    #####: 2020:		if ('a' <= ch && ch <= 'z')
    #####: 2021:			continue;
    #####: 2022:		if (strchr("0123456789+-_.", ch))
    #####: 2023:			continue;
    #####: 2024:		break;
        -: 2025:	}
        -: 2026:
    #####: 2027:	set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 2028:	return 0;
        -: 2029:}
        -: 2030:
    #####: 2031:static int next_token(context_t* ctx, int dotisspecial)
        -: 2032:{
    #####: 2033:	int lineno = ctx->tok.lineno;
    #####: 2034:	char* p = ctx->tok.ptr;
        -: 2035:	int i;
        -: 2036:
        -: 2037:	/* eat this tok */
    #####: 2038:	for (i = 0; i < ctx->tok.len; i++)
        -: 2039:	{
    #####: 2040:		if (*p++ == '\n')
    #####: 2041:			lineno++;
        -: 2042:	}
        -: 2043:
        -: 2044:	/* make next tok */
    #####: 2045:	while (p < ctx->stop)
        -: 2046:	{
        -: 2047:		/* skip comment. stop just before the \n. */
    #####: 2048:		if (*p == '#')
        -: 2049:		{
    #####: 2050:			for (p++; p < ctx->stop && *p != '\n'; p++)
        -: 2051:				;
    #####: 2052:			continue;
        -: 2053:		}
        -: 2054:
    #####: 2055:		if (dotisspecial && *p == '.')
        -: 2056:		{
    #####: 2057:			set_token(ctx, DOT, lineno, p, 1);
    #####: 2058:			return 0;
        -: 2059:		}
        -: 2060:
    #####: 2061:		switch (*p)
        -: 2062:		{
    #####: 2063:		case ',':
    #####: 2064:			set_token(ctx, COMMA, lineno, p, 1);
    #####: 2065:			return 0;
    #####: 2066:		case '=':
    #####: 2067:			set_token(ctx, EQUAL, lineno, p, 1);
    #####: 2068:			return 0;
    #####: 2069:		case '{':
    #####: 2070:			set_token(ctx, LBRACE, lineno, p, 1);
    #####: 2071:			return 0;
    #####: 2072:		case '}':
    #####: 2073:			set_token(ctx, RBRACE, lineno, p, 1);
    #####: 2074:			return 0;
    #####: 2075:		case '[':
    #####: 2076:			set_token(ctx, LBRACKET, lineno, p, 1);
    #####: 2077:			return 0;
    #####: 2078:		case ']':
    #####: 2079:			set_token(ctx, RBRACKET, lineno, p, 1);
    #####: 2080:			return 0;
    #####: 2081:		case '\n':
    #####: 2082:			set_token(ctx, NEWLINE, lineno, p, 1);
    #####: 2083:			return 0;
    #####: 2084:		case '\r':
        -: 2085:		case ' ':
        -: 2086:		case '\t':
        -: 2087:			/* ignore white spaces */
    #####: 2088:			p++;
    #####: 2089:			continue;
        -: 2090:		}
        -: 2091:
    #####: 2092:		return scan_string(ctx, p, lineno, dotisspecial);
        -: 2093:	}
        -: 2094:
    #####: 2095:	set_eof(ctx, lineno);
    #####: 2096:	return 0;
        -: 2097:}
        -: 2098:
    #####: 2099:const char* toml_key_in(const toml_table_t* tab, int keyidx)
        -: 2100:{
    #####: 2101:	if (keyidx < tab->nkval)
    #####: 2102:		return tab->kval[keyidx]->key;
        -: 2103:
    #####: 2104:	keyidx -= tab->nkval;
    #####: 2105:	if (keyidx < tab->narr)
    #####: 2106:		return tab->arr[keyidx]->key;
        -: 2107:
    #####: 2108:	keyidx -= tab->narr;
    #####: 2109:	if (keyidx < tab->ntab)
    #####: 2110:		return tab->tab[keyidx]->key;
        -: 2111:
    #####: 2112:	return 0;
        -: 2113:}
        -: 2114:
    #####: 2115:int toml_key_exists(const toml_table_t* tab, const char* key)
        -: 2116:{
        -: 2117:	int i;
    #####: 2118:	for (i = 0; i < tab->nkval; i++)
        -: 2119:	{
    #####: 2120:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 2121:			return 1;
        -: 2122:	}
    #####: 2123:	for (i = 0; i < tab->narr; i++)
        -: 2124:	{
    #####: 2125:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 2126:			return 1;
        -: 2127:	}
    #####: 2128:	for (i = 0; i < tab->ntab; i++)
        -: 2129:	{
    #####: 2130:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 2131:			return 1;
        -: 2132:	}
    #####: 2133:	return 0;
        -: 2134:}
        -: 2135:
    #####: 2136:toml_raw_t toml_raw_in(const toml_table_t* tab, const char* key)
        -: 2137:{
        -: 2138:	int i;
    #####: 2139:	for (i = 0; i < tab->nkval; i++)
        -: 2140:	{
    #####: 2141:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 2142:			return tab->kval[i]->val;
        -: 2143:	}
    #####: 2144:	return 0;
        -: 2145:}
        -: 2146:
    #####: 2147:toml_array_t* toml_array_in(const toml_table_t* tab, const char* key)
        -: 2148:{
        -: 2149:	int i;
    #####: 2150:	for (i = 0; i < tab->narr; i++)
        -: 2151:	{
    #####: 2152:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 2153:			return tab->arr[i];
        -: 2154:	}
    #####: 2155:	return 0;
        -: 2156:}
        -: 2157:
    #####: 2158:toml_table_t* toml_table_in(const toml_table_t* tab, const char* key)
        -: 2159:{
        -: 2160:	int i;
    #####: 2161:	for (i = 0; i < tab->ntab; i++)
        -: 2162:	{
    #####: 2163:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 2164:			return tab->tab[i];
        -: 2165:	}
    #####: 2166:	return 0;
        -: 2167:}
        -: 2168:
    #####: 2169:toml_raw_t toml_raw_at(const toml_array_t* arr, int idx)
        -: 2170:{
    #####: 2171:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].val : 0;
        -: 2172:}
        -: 2173:
    #####: 2174:char toml_array_kind(const toml_array_t* arr) { return arr->kind; }
        -: 2175:
    #####: 2176:char toml_array_type(const toml_array_t* arr)
        -: 2177:{
    #####: 2178:	if (arr->kind != 'v')
    #####: 2179:		return 0;
        -: 2180:
    #####: 2181:	if (arr->nitem == 0)
    #####: 2182:		return 0;
        -: 2183:
    #####: 2184:	return arr->type;
        -: 2185:}
        -: 2186:
    #####: 2187:int toml_array_nelem(const toml_array_t* arr) { return arr->nitem; }
        -: 2188:
    #####: 2189:const char* toml_array_key(const toml_array_t* arr)
        -: 2190:{
    #####: 2191:	return arr ? arr->key : (const char*)NULL;
        -: 2192:}
        -: 2193:
    #####: 2194:int toml_table_nkval(const toml_table_t* tab) { return tab->nkval; }
        -: 2195:
    #####: 2196:int toml_table_narr(const toml_table_t* tab) { return tab->narr; }
        -: 2197:
    #####: 2198:int toml_table_ntab(const toml_table_t* tab) { return tab->ntab; }
        -: 2199:
    #####: 2200:const char* toml_table_key(const toml_table_t* tab)
        -: 2201:{
    #####: 2202:	return tab ? tab->key : (const char*)NULL;
        -: 2203:}
        -: 2204:
    #####: 2205:toml_array_t* toml_array_at(const toml_array_t* arr, int idx)
        -: 2206:{
    #####: 2207:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].arr : 0;
        -: 2208:}
        -: 2209:
    #####: 2210:toml_table_t* toml_table_at(const toml_array_t* arr, int idx)
        -: 2211:{
    #####: 2212:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].tab : 0;
        -: 2213:}
        -: 2214:
        -: 2215:static int parse_millisec(const char* p, const char** endp);
        -: 2216:
    #####: 2217:int toml_rtots(toml_raw_t src_, toml_timestamp_t* ret)
        -: 2218:{
    #####: 2219:	if (!src_)
    #####: 2220:		return -1;
        -: 2221:
    #####: 2222:	const char* p = src_;
    #####: 2223:	int must_parse_time = 0;
        -: 2224:
    #####: 2225:	memset(ret, 0, sizeof(*ret));
        -: 2226:
    #####: 2227:	int* year = &ret->__buffer.year;
    #####: 2228:	int* month = &ret->__buffer.month;
    #####: 2229:	int* day = &ret->__buffer.day;
    #####: 2230:	int* hour = &ret->__buffer.hour;
    #####: 2231:	int* minute = &ret->__buffer.minute;
    #####: 2232:	int* second = &ret->__buffer.second;
    #####: 2233:	int* millisec = &ret->__buffer.millisec;
        -: 2234:
        -: 2235:	/* parse date YYYY-MM-DD */
    #####: 2236:	if (0 == scan_date(p, year, month, day))
        -: 2237:	{
    #####: 2238:		ret->year = year;
    #####: 2239:		ret->month = month;
    #####: 2240:		ret->day = day;
        -: 2241:
    #####: 2242:		p += 10;
    #####: 2243:		if (*p)
        -: 2244:		{
        -: 2245:			// parse the T or space separator
    #####: 2246:			if (*p != 'T' && *p != 't' && *p != ' ')
    #####: 2247:				return -1;
    #####: 2248:			must_parse_time = 1;
    #####: 2249:			p++;
        -: 2250:		}
        -: 2251:	}
        -: 2252:
        -: 2253:	/* parse time HH:MM:SS */
    #####: 2254:	if (0 == scan_time(p, hour, minute, second))
        -: 2255:	{
    #####: 2256:		ret->hour = hour;
    #####: 2257:		ret->minute = minute;
    #####: 2258:		ret->second = second;
        -: 2259:
        -: 2260:		/* optionally, parse millisec */
    #####: 2261:		p += 8;
    #####: 2262:		if (*p == '.')
        -: 2263:		{
    #####: 2264:			p++; /* skip '.' */
        -: 2265:			const char* qq;
    #####: 2266:			*millisec = parse_millisec(p, &qq);
    #####: 2267:			ret->millisec = millisec;
    #####: 2268:			p = qq;
        -: 2269:		}
        -: 2270:
    #####: 2271:		if (*p)
        -: 2272:		{
        -: 2273:			/* parse and copy Z */
    #####: 2274:			char* z = ret->__buffer.z;
    #####: 2275:			ret->z = z;
    #####: 2276:			if (*p == 'Z' || *p == 'z')
        -: 2277:			{
    #####: 2278:				*z++ = 'Z';
    #####: 2279:				p++;
    #####: 2280:				*z = 0;
        -: 2281:			}
    #####: 2282:			else if (*p == '+' || *p == '-')
        -: 2283:			{
    #####: 2284:				*z++ = *p++;
        -: 2285:
    #####: 2286:				if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2287:					return -1;
    #####: 2288:				*z++ = *p++;
    #####: 2289:				*z++ = *p++;
        -: 2290:
    #####: 2291:				if (*p == ':')
        -: 2292:				{
    #####: 2293:					*z++ = *p++;
        -: 2294:
    #####: 2295:					if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2296:						return -1;
    #####: 2297:					*z++ = *p++;
    #####: 2298:					*z++ = *p++;
        -: 2299:				}
        -: 2300:
    #####: 2301:				*z = 0;
        -: 2302:			}
        -: 2303:		}
        -: 2304:	}
    #####: 2305:	if (*p != 0)
    #####: 2306:		return -1;
        -: 2307:
    #####: 2308:	if (must_parse_time && !ret->hour)
    #####: 2309:		return -1;
        -: 2310:
    #####: 2311:	return 0;
        -: 2312:}
        -: 2313:
        -: 2314:/* Raw to boolean */
    #####: 2315:int toml_rtob(toml_raw_t src, int* ret_)
        -: 2316:{
    #####: 2317:	if (!src)
    #####: 2318:		return -1;
        -: 2319:	int dummy;
    #####: 2320:	int* ret = ret_ ? ret_ : &dummy;
        -: 2321:
    #####: 2322:	if (0 == strcmp(src, "true"))
        -: 2323:	{
    #####: 2324:		*ret = 1;
    #####: 2325:		return 0;
        -: 2326:	}
    #####: 2327:	if (0 == strcmp(src, "false"))
        -: 2328:	{
    #####: 2329:		*ret = 0;
    #####: 2330:		return 0;
        -: 2331:	}
    #####: 2332:	return -1;
        -: 2333:}
        -: 2334:
        -: 2335:/* Raw to integer */
    #####: 2336:int toml_rtoi(toml_raw_t src, int64_t* ret_)
        -: 2337:{
    #####: 2338:	if (!src)
    #####: 2339:		return -1;
        -: 2340:
        -: 2341:	char buf[100];
    #####: 2342:	char* p = buf;
    #####: 2343:	char* q = p + sizeof(buf);
    #####: 2344:	const char* s = src;
    #####: 2345:	int base = 0;
        -: 2346:	int64_t dummy;
    #####: 2347:	int64_t* ret = ret_ ? ret_ : &dummy;
        -: 2348:
        -: 2349:	/* allow +/- */
    #####: 2350:	if (s[0] == '+' || s[0] == '-')
    #####: 2351:		*p++ = *s++;
        -: 2352:
        -: 2353:	/* disallow +_100 */
    #####: 2354:	if (s[0] == '_')
    #####: 2355:		return -1;
        -: 2356:
        -: 2357:	/* if 0* ... */
    #####: 2358:	if ('0' == s[0])
        -: 2359:	{
    #####: 2360:		switch (s[1])
        -: 2361:		{
    #####: 2362:		case 'x':
    #####: 2363:			base = 16;
    #####: 2364:			s += 2;
    #####: 2365:			break;
    #####: 2366:		case 'o':
    #####: 2367:			base = 8;
    #####: 2368:			s += 2;
    #####: 2369:			break;
    #####: 2370:		case 'b':
    #####: 2371:			base = 2;
    #####: 2372:			s += 2;
    #####: 2373:			break;
    #####: 2374:		case '\0':
    #####: 2375:			return *ret = 0, 0;
    #####: 2376:		default:
        -: 2377:			/* ensure no other digits after it */
    #####: 2378:			if (s[1])
    #####: 2379:				return -1;
        -: 2380:		}
        -: 2381:	}
        -: 2382:
        -: 2383:	/* just strip underscores and pass to strtoll */
    #####: 2384:	while (*s && p < q)
        -: 2385:	{
    #####: 2386:		int ch = *s++;
    #####: 2387:		if (ch == '_')
        -: 2388:		{
        -: 2389:			// disallow '__'
    #####: 2390:			if (s[0] == '_')
    #####: 2391:				return -1;
        -: 2392:			// numbers cannot end with '_'
    #####: 2393:			if (s[0] == '\0')
    #####: 2394:				return -1;
    #####: 2395:			continue; /* skip _ */
        -: 2396:		}
    #####: 2397:		*p++ = ch;
        -: 2398:	}
        -: 2399:
        -: 2400:	// if not at end-of-string or we ran out of buffer ...
    #####: 2401:	if (*s || p == q)
    #####: 2402:		return -1;
        -: 2403:
        -: 2404:	/* cap with NUL */
    #####: 2405:	*p = 0;
        -: 2406:
        -: 2407:	/* Run strtoll on buf to get the integer */
        -: 2408:	char* endp;
    #####: 2409:	errno = 0;
    #####: 2410:	*ret = strtoll(buf, &endp, base);
    #####: 2411:	return (errno || *endp) ? -1 : 0;
        -: 2412:}
        -: 2413:
    #####: 2414:int toml_rtod_ex(toml_raw_t src, double* ret_, char* buf, int buflen)
        -: 2415:{
    #####: 2416:	if (!src)
    #####: 2417:		return -1;
        -: 2418:
    #####: 2419:	char* p = buf;
    #####: 2420:	char* q = p + buflen;
    #####: 2421:	const char* s = src;
        -: 2422:	double dummy;
    #####: 2423:	double* ret = ret_ ? ret_ : &dummy;
        -: 2424:
        -: 2425:	/* allow +/- */
    #####: 2426:	if (s[0] == '+' || s[0] == '-')
    #####: 2427:		*p++ = *s++;
        -: 2428:
        -: 2429:	/* disallow +_1.00 */
    #####: 2430:	if (s[0] == '_')
    #####: 2431:		return -1;
        -: 2432:
        -: 2433:	/* decimal point, if used, must be surrounded by at least one digit on
        -: 2434:	 * each side */
        -: 2435:	{
    #####: 2436:		char* dot = strchr(s, '.');
    #####: 2437:		if (dot)
        -: 2438:		{
    #####: 2439:			if (dot == s || !isdigit(dot[-1]) || !isdigit(dot[1]))
    #####: 2440:				return -1;
        -: 2441:		}
        -: 2442:	}
        -: 2443:
        -: 2444:	/* zero must be followed by . or 'e', or NUL */
    #####: 2445:	if (s[0] == '0' && s[1] && !strchr("eE.", s[1]))
    #####: 2446:		return -1;
        -: 2447:
        -: 2448:	/* just strip underscores and pass to strtod */
    #####: 2449:	while (*s && p < q)
        -: 2450:	{
    #####: 2451:		int ch = *s++;
    #####: 2452:		if (ch == '_')
        -: 2453:		{
        -: 2454:			// disallow '__'
    #####: 2455:			if (s[0] == '_')
    #####: 2456:				return -1;
        -: 2457:			// disallow last char '_'
    #####: 2458:			if (s[0] == 0)
    #####: 2459:				return -1;
    #####: 2460:			continue; /* skip _ */
        -: 2461:		}
    #####: 2462:		*p++ = ch;
        -: 2463:	}
    #####: 2464:	if (*s || p == q)
    #####: 2465:		return -1; /* reached end of string or buffer is full? */
        -: 2466:
        -: 2467:	/* cap with NUL */
    #####: 2468:	*p = 0;
        -: 2469:
        -: 2470:	/* Run strtod on buf to get the value */
        -: 2471:	char* endp;
    #####: 2472:	errno = 0;
    #####: 2473:	*ret = strtod(buf, &endp);
    #####: 2474:	return (errno || *endp) ? -1 : 0;
        -: 2475:}
        -: 2476:
    #####: 2477:int toml_rtod(toml_raw_t src, double* ret_)
        -: 2478:{
        -: 2479:	char buf[100];
    #####: 2480:	return toml_rtod_ex(src, ret_, buf, sizeof(buf));
        -: 2481:}
        -: 2482:
    #####: 2483:int toml_rtos(toml_raw_t src, char** ret)
        -: 2484:{
    #####: 2485:	int multiline = 0;
        -: 2486:	const char* sp;
        -: 2487:	const char* sq;
        -: 2488:
    #####: 2489:	*ret = 0;
    #####: 2490:	if (!src)
    #####: 2491:		return -1;
        -: 2492:
        -: 2493:	// for strings, first char must be a s-quote or d-quote
    #####: 2494:	int qchar = src[0];
    #####: 2495:	int srclen = strlen(src);
    #####: 2496:	if (!(qchar == '\'' || qchar == '"'))
        -: 2497:	{
    #####: 2498:		return -1;
        -: 2499:	}
        -: 2500:
        -: 2501:	// triple quotes?
    #####: 2502:	if (qchar == src[1] && qchar == src[2])
        -: 2503:	{
    #####: 2504:		multiline = 1;	       // triple-quote implies multiline
    #####: 2505:		sp = src + 3;	       // first char after quote
    #####: 2506:		sq = src + srclen - 3; // first char of ending quote
        -: 2507:
    #####: 2508:		if (!(sp <= sq && sq[0] == qchar && sq[1] == qchar && sq[2] == qchar))
        -: 2509:		{
        -: 2510:			// last 3 chars in src must be qchar
    #####: 2511:			return -1;
        -: 2512:		}
        -: 2513:
        -: 2514:		/* skip new line immediate after qchar */
    #####: 2515:		if (sp[0] == '\n')
    #####: 2516:			sp++;
    #####: 2517:		else if (sp[0] == '\r' && sp[1] == '\n')
    #####: 2518:			sp += 2;
        -: 2519:	}
        -: 2520:	else
        -: 2521:	{
    #####: 2522:		sp = src + 1;	       // first char after quote
    #####: 2523:		sq = src + srclen - 1; // ending quote
    #####: 2524:		if (!(sp <= sq && *sq == qchar))
        -: 2525:		{
        -: 2526:			/* last char in src must be qchar */
    #####: 2527:			return -1;
        -: 2528:		}
        -: 2529:	}
        -: 2530:
        -: 2531:	// at this point:
        -: 2532:	//     sp points to first valid char after quote.
        -: 2533:	//     sq points to one char beyond last valid char.
        -: 2534:	//     string len is (sq - sp).
    #####: 2535:	if (qchar == '\'')
        -: 2536:	{
    #####: 2537:		*ret = norm_lit_str(sp, sq - sp, multiline, 0, 0);
        -: 2538:	}
        -: 2539:	else
        -: 2540:	{
    #####: 2541:		*ret = norm_basic_str(sp, sq - sp, multiline, 0, 0);
        -: 2542:	}
        -: 2543:
    #####: 2544:	return *ret ? 0 : -1;
        -: 2545:}
        -: 2546:
    #####: 2547:toml_datum_t toml_string_at(const toml_array_t* arr, int idx)
        -: 2548:{
        -: 2549:	toml_datum_t ret;
    #####: 2550:	memset(&ret, 0, sizeof(ret));
    #####: 2551:	ret.ok = (0 == toml_rtos(toml_raw_at(arr, idx), &ret.u.s));
    #####: 2552:	return ret;
        -: 2553:}
        -: 2554:
    #####: 2555:toml_datum_t toml_bool_at(const toml_array_t* arr, int idx)
        -: 2556:{
        -: 2557:	toml_datum_t ret;
    #####: 2558:	memset(&ret, 0, sizeof(ret));
    #####: 2559:	ret.ok = (0 == toml_rtob(toml_raw_at(arr, idx), &ret.u.b));
    #####: 2560:	return ret;
        -: 2561:}
        -: 2562:
    #####: 2563:toml_datum_t toml_int_at(const toml_array_t* arr, int idx)
        -: 2564:{
        -: 2565:	toml_datum_t ret;
    #####: 2566:	memset(&ret, 0, sizeof(ret));
    #####: 2567:	ret.ok = (0 == toml_rtoi(toml_raw_at(arr, idx), &ret.u.i));
    #####: 2568:	return ret;
        -: 2569:}
        -: 2570:
    #####: 2571:toml_datum_t toml_double_at(const toml_array_t* arr, int idx)
        -: 2572:{
        -: 2573:	toml_datum_t ret;
    #####: 2574:	memset(&ret, 0, sizeof(ret));
    #####: 2575:	ret.ok = (0 == toml_rtod(toml_raw_at(arr, idx), &ret.u.d));
    #####: 2576:	return ret;
        -: 2577:}
        -: 2578:
    #####: 2579:toml_datum_t toml_timestamp_at(const toml_array_t* arr, int idx)
        -: 2580:{
        -: 2581:	toml_timestamp_t ts;
        -: 2582:	toml_datum_t ret;
    #####: 2583:	memset(&ret, 0, sizeof(ret));
    #####: 2584:	ret.ok = (0 == toml_rtots(toml_raw_at(arr, idx), &ts));
    #####: 2585:	if (ret.ok)
        -: 2586:	{
    #####: 2587:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2588:		if (ret.ok)
        -: 2589:		{
    #####: 2590:			*ret.u.ts = ts;
    #####: 2591:			if (ret.u.ts->year)
    #####: 2592:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2593:			if (ret.u.ts->month)
    #####: 2594:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2595:			if (ret.u.ts->day)
    #####: 2596:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2597:			if (ret.u.ts->hour)
    #####: 2598:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2599:			if (ret.u.ts->minute)
    #####: 2600:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2601:			if (ret.u.ts->second)
    #####: 2602:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2603:			if (ret.u.ts->millisec)
    #####: 2604:				ret.u.ts->millisec =
    #####: 2605:				    &ret.u.ts->__buffer.millisec;
    #####: 2606:			if (ret.u.ts->z)
    #####: 2607:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2608:		}
        -: 2609:	}
    #####: 2610:	return ret;
        -: 2611:}
        -: 2612:
    #####: 2613:toml_datum_t toml_string_in(const toml_table_t* arr, const char* key)
        -: 2614:{
        -: 2615:	toml_datum_t ret;
    #####: 2616:	memset(&ret, 0, sizeof(ret));
    #####: 2617:	toml_raw_t raw = toml_raw_in(arr, key);
    #####: 2618:	if (raw)
        -: 2619:	{
    #####: 2620:		ret.ok = (0 == toml_rtos(raw, &ret.u.s));
        -: 2621:	}
    #####: 2622:	return ret;
        -: 2623:}
        -: 2624:
    #####: 2625:toml_datum_t toml_bool_in(const toml_table_t* arr, const char* key)
        -: 2626:{
        -: 2627:	toml_datum_t ret;
    #####: 2628:	memset(&ret, 0, sizeof(ret));
    #####: 2629:	ret.ok = (0 == toml_rtob(toml_raw_in(arr, key), &ret.u.b));
    #####: 2630:	return ret;
        -: 2631:}
        -: 2632:
    #####: 2633:toml_datum_t toml_int_in(const toml_table_t* arr, const char* key)
        -: 2634:{
        -: 2635:	toml_datum_t ret;
    #####: 2636:	memset(&ret, 0, sizeof(ret));
    #####: 2637:	ret.ok = (0 == toml_rtoi(toml_raw_in(arr, key), &ret.u.i));
    #####: 2638:	return ret;
        -: 2639:}
        -: 2640:
    #####: 2641:toml_datum_t toml_double_in(const toml_table_t* arr, const char* key)
        -: 2642:{
        -: 2643:	toml_datum_t ret;
    #####: 2644:	memset(&ret, 0, sizeof(ret));
    #####: 2645:	ret.ok = (0 == toml_rtod(toml_raw_in(arr, key), &ret.u.d));
    #####: 2646:	return ret;
        -: 2647:}
        -: 2648:
    #####: 2649:toml_datum_t toml_timestamp_in(const toml_table_t* arr, const char* key)
        -: 2650:{
        -: 2651:	toml_timestamp_t ts;
        -: 2652:	toml_datum_t ret;
    #####: 2653:	memset(&ret, 0, sizeof(ret));
    #####: 2654:	ret.ok = (0 == toml_rtots(toml_raw_in(arr, key), &ts));
    #####: 2655:	if (ret.ok)
        -: 2656:	{
    #####: 2657:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2658:		if (ret.ok)
        -: 2659:		{
    #####: 2660:			*ret.u.ts = ts;
    #####: 2661:			if (ret.u.ts->year)
    #####: 2662:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2663:			if (ret.u.ts->month)
    #####: 2664:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2665:			if (ret.u.ts->day)
    #####: 2666:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2667:			if (ret.u.ts->hour)
    #####: 2668:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2669:			if (ret.u.ts->minute)
    #####: 2670:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2671:			if (ret.u.ts->second)
    #####: 2672:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2673:			if (ret.u.ts->millisec)
    #####: 2674:				ret.u.ts->millisec =
    #####: 2675:				    &ret.u.ts->__buffer.millisec;
    #####: 2676:			if (ret.u.ts->z)
    #####: 2677:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2678:		}
        -: 2679:	}
    #####: 2680:	return ret;
        -: 2681:}
        -: 2682:
    #####: 2683:static int parse_millisec(const char* p, const char** endp)
        -: 2684:{
    #####: 2685:	int ret = 0;
    #####: 2686:	int unit = 100; /* unit in millisec */
    #####: 2687:	for (; '0' <= *p && *p <= '9'; p++, unit /= 10)
        -: 2688:	{
    #####: 2689:		ret += (*p - '0') * unit;
        -: 2690:	}
    #####: 2691:	*endp = p;
    #####: 2692:	return ret;
        -: 2693:}
        -:    0:Source:prim.c
        -:    0:Graph:prim.gcno
        -:    0:Data:prim.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/prim.h>
        -:   16:
        -:   17:#define DEFINE_PRIM(lower, upper, bits)                               \
        -:   18:	Type(upper##bits, Field(lower##bits, value));                 \
        -:   19:	void upper##bits##_build(const upper##bits##Config* config)   \
        -:   20:	{                                                             \
        -:   21:		$Var(value) = config->value;                          \
        -:   22:	}                                                             \
        -:   23:	void upper##bits##_value_of(void* buf)                        \
        -:   24:	{                                                             \
        -:   25:		*(lower##bits*)buf = $(value);                        \
        -:   26:	}                                                             \
        -:   27:	bool upper##bits##_equal(const Obj* rhs)                      \
        -:   28:	{                                                             \
        -:   29:		return $(value) == $Context(rhs, upper##bits, value); \
        -:   30:	}
        -:   31:
        -:   32:#define IMPL U8
      51*:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_equal:
    #####:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_value_of:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_build:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
__add_impls_U8_vtable:
       39:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_drop_internal:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_build_internal:
        2:   33:DEFINE_PRIM(u, U, 8);
------------------
U8_size:
        4:   33:DEFINE_PRIM(u, U, 8);
------------------
        -:   34:#undef IMPL
        -:   35:
        -:   36:#define IMPL U16
      51*:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_equal:
    #####:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_value_of:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_build:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
__add_impls_U16_vtable:
       39:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_drop_internal:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_build_internal:
        2:   37:DEFINE_PRIM(u, U, 16);
------------------
U16_size:
        4:   37:DEFINE_PRIM(u, U, 16);
------------------
        -:   38:#undef IMPL
        -:   39:
        -:   40:#define IMPL U32
      69*:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_equal:
    #####:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_value_of:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_build:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
__add_impls_U32_vtable:
       39:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_drop_internal:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_build_internal:
        5:   41:DEFINE_PRIM(u, U, 32);
------------------
U32_size:
       10:   41:DEFINE_PRIM(u, U, 32);
------------------
        -:   42:#undef IMPL
        -:   43:
        -:   44:#define IMPL U64
       81:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_equal:
        2:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_value_of:
        4:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_build:
        8:   45:DEFINE_PRIM(u, U, 64);
------------------
__add_impls_U64_vtable:
       39:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_drop_internal:
        4:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_build_internal:
        8:   45:DEFINE_PRIM(u, U, 64);
------------------
U64_size:
       16:   45:DEFINE_PRIM(u, U, 64);
------------------
        -:   46:#undef IMPL
        -:   47:
        -:   48:#define IMPL U128
      51*:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_equal:
    #####:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_value_of:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_build:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
__add_impls_U128_vtable:
       39:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_drop_internal:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_build_internal:
        2:   49:DEFINE_PRIM(u, U, 128);
------------------
U128_size:
        4:   49:DEFINE_PRIM(u, U, 128);
------------------
        -:   50:#undef IMPL
        -:   51:
        -:   52:#define IMPL I8
      51*:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_equal:
    #####:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_value_of:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_build:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
__add_impls_I8_vtable:
       39:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_drop_internal:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_build_internal:
        2:   53:DEFINE_PRIM(i, I, 8);
------------------
I8_size:
        4:   53:DEFINE_PRIM(i, I, 8);
------------------
        -:   54:#undef IMPL
        -:   55:
        -:   56:#define IMPL I16
      51*:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_equal:
    #####:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_value_of:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_build:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
__add_impls_I16_vtable:
       39:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_drop_internal:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_build_internal:
        2:   57:DEFINE_PRIM(i, I, 16);
------------------
I16_size:
        4:   57:DEFINE_PRIM(i, I, 16);
------------------
        -:   58:#undef IMPL
        -:   59:
        -:   60:#define IMPL I32
       88:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_equal:
        4:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_value_of:
        3:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_build:
        9:   61:DEFINE_PRIM(i, I, 32);
------------------
__add_impls_I32_vtable:
       39:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_drop_internal:
        6:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_build_internal:
        9:   61:DEFINE_PRIM(i, I, 32);
------------------
I32_size:
       18:   61:DEFINE_PRIM(i, I, 32);
------------------
        -:   62:#undef IMPL
        -:   63:
        -:   64:#define IMPL I64
      51*:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_equal:
    #####:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_value_of:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_build:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
__add_impls_I64_vtable:
       39:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_drop_internal:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_build_internal:
        2:   65:DEFINE_PRIM(i, I, 64);
------------------
I64_size:
        4:   65:DEFINE_PRIM(i, I, 64);
------------------
        -:   66:#undef IMPL
        -:   67:
        -:   68:#define IMPL I128
      51*:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_equal:
    #####:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_value_of:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_build:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
__add_impls_I128_vtable:
       39:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_drop_internal:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_build_internal:
        2:   69:DEFINE_PRIM(i, I, 128);
------------------
I128_size:
        4:   69:DEFINE_PRIM(i, I, 128);
------------------
        -:   70:#undef IMPL
        -:   71:
        -:   72:#define IMPL F32
      51*:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_equal:
    #####:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_value_of:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_build:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
__add_impls_F32_vtable:
       39:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_drop_internal:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_build_internal:
        2:   73:DEFINE_PRIM(f, F, 32);
------------------
F32_size:
        4:   73:DEFINE_PRIM(f, F, 32);
------------------
        -:   74:#undef IMPL
        -:   75:
        -:   76:#define IMPL F64
      51*:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_equal:
    #####:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_value_of:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_build:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
__add_impls_F64_vtable:
       39:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_drop_internal:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_build_internal:
        2:   77:DEFINE_PRIM(f, F, 64);
------------------
F64_size:
        4:   77:DEFINE_PRIM(f, F, 64);
------------------
        -:   78:#undef IMPL
        -:   79:
        -:   80:#define IMPL Bool
       71:   81:Type(Bool, Field(bool, value));
------------------
__add_impls_Bool_vtable:
       39:   81:Type(Bool, Field(bool, value));
------------------
Bool_drop_internal:
        8:   81:Type(Bool, Field(bool, value));
------------------
Bool_build_internal:
        8:   81:Type(Bool, Field(bool, value));
------------------
Bool_size:
       16:   81:Type(Bool, Field(bool, value));
------------------
        8:   82:void Bool_build(const BoolConfig* config)
        -:   83:{
        8:   84:	$Var(value) = config->value;
        8:   85:}
        8:   86:void Bool_value_of(void* buf)
        -:   87:{
        8:   88:	*(bool*)buf = $(value);
        8:   89:}
    #####:   90:bool Bool_equal(const Obj* rhs)
        -:   91:{
    #####:   92:	return $(value) == $Context(rhs, Bool, value);
        -:   93:}
        -:   94:#undef IMPL
        -:    0:Source:rc.c
        -:    0:Graph:rc.gcno
        -:    0:Data:rc.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/prim.h>
        -:   16:#include <core/rc.h>
        -:   17:
        -:   18:// Rc has two 'FatPtr's The first is a counter and the second is holds the value. The value
        -:   19:// can be any object (Obj).
      151:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
__add_impls_Rc_vtable:
       39:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_drop_internal:
       16:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_build_internal:
       32:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
Rc_size:
       64:   20:Type(Rc, Field(FatPtr, counter), Field(FatPtr, value));
------------------
        -:   21:
        -:   22:#define IMPL Rc
        -:   23:// Build an Rc.
       32:   24:void Rc_build(const RcConfig* config)
        -:   25:{
        -:   26:	// Allocate memory for both the counter and the value. The value is an Obj regardless of
        -:   27:	// what type. It's data is held in the Object's own FatPtr.
       32:   28:	chain_malloc(&($Var(value)), sizeof(Obj));
       32:   29:	if ($(value).data == NULL)
    #####:   30:		panic("Could not allocate sufficient memory");
       32:   31:	chain_malloc(&($Var(counter)), sizeof(u64));
       32:   32:	if ($(counter).data == NULL)
        -:   33:	{
    #####:   34:		chain_free(&($Var(value)));
    #####:   35:		panic("Could not allocate sufficient memory");
        -:   36:	}
        -:   37:	// pointer to the internal data location
       32:   38:	Obj* obj = $Var(value).data;
        -:   39:	// initialize the object
       32:   40:	*obj = OBJECT_INIT;
        -:   41:	// if a value is passed in (which will be the case generally if the user is calling new,
        -:   42:	// we move the Object into the shared memory location.
       32:   43:	if (config->value)
      14*:   44:		Move(obj, config->value);
        -:   45:	// Initialize the counter to 1.
       32:   46:	*(u64*)$Var(counter).data = 1;
       32:   47:}
        -:   48:// Drop an Rc.
       32:   49:void Rc_drop()
        -:   50:{
        -:   51:	// When an instance of Rc is dropped, we decrement our counter and check if it is 0
        -:   52:	// indicating that no more references remain.
       32:   53:	(*(u64*)$Var(counter).data)--;
       32:   54:	if ((*(u64*)$Var(counter).data) == 0)
        -:   55:	{
        -:   56:		// No other references remain.
       14:   57:		Obj* value = $(value).data;
        -:   58:		// If the Object is not yet consumed, drop it.
       14:   59:		if ((value->flags & OBJECT_FLAGS_CONSUMED) == 0)
       13:   60:			drop(value);
        -:   61:		// Free the allocated memory for this Rc.
       14:   62:		if (chain_free(&($Var(counter))))
    #####:   63:			panic("Unexpected return from a chain_free!");
       14:   64:		if (chain_free(&($Var(value))))
    #####:   65:			panic("Unexpeted return from a chain_free!");
        -:   66:	}
       32:   67:}
        -:   68:
        -:   69:// Unwrap an Rc.
       16:   70:Obj Rc_unwrap()
        -:   71:{
        -:   72:	Obj ret;
        -:   73:	// If there are additional references, the returned object (acting as a reference to the shared data)
        -:   74:	// should not be cleaned up. We merely copy the data and marked the returned reference as 'no cleanup'.
       16:   75:	if (*(u64*)($(counter).data) > 1)
        -:   76:	{
       15:   77:		ret = *(Obj*)$(value).data;
       15:   78:		ret.flags |= OBJECT_FLAGS_NO_CLEANUP;
        -:   79:	}
        -:   80:	else
        -:   81:	{
        -:   82:		// This is the final reference so we move out the Object
        1:   83:		ret = OBJECT_INIT;
       1*:   84:		Move(&ret, (Obj*)$(value).data);
        -:   85:	}
        -:   86:	// Drop this instance of the Rc
       16:   87:	drop($Var());
        -:   88:	// return the objecct.
       16:   89:	return ret;
        -:   90:}
        -:   91:
        -:   92:// Clone the Rc.
       18:   93:Obj Rc_klone()
        -:   94:{
        -:   95:	// Update the counter by incrementing
       18:   96:	u64* counter = $(counter).data;
       18:   97:	(*counter)++;
        -:   98:
        -:   99:	// Create an Rc without a value
       18:  100:	var ret = new (Rc);
        -:  101:	// Set both the value and the counter to the appropriate values
       18:  102:	$ContextVar((&ret), Rc, value).data = ((Obj*)$(value).data);
       18:  103:	$ContextVar((&ret), Rc, counter).data = counter;
        -:  104:	// Safely return the Object
       18:  105:	ReturnObj(ret);
        -:  106:}
        -:  107:#undef IMPL
        -:    0:Source:test_encapsulation.c
        -:    0:Graph:test_encapsulation.gcno
        -:    0:Data:test_encapsulation.gcda
        -:    0:Runs:38
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/test_encapsulation.h>
        -:   16:#include <core/traits.h>
        -:   17:#include <core/type.h>
        -:   18:
       45:   19:Type(HiddenDrop);
------------------
__add_impls_HiddenDrop_vtable:
       38:   19:Type(HiddenDrop);
------------------
HiddenDrop_drop_internal:
        1:   19:Type(HiddenDrop);
------------------
HiddenDrop_build_internal:
        2:   19:Type(HiddenDrop);
------------------
HiddenDrop_size:
        4:   19:Type(HiddenDrop);
------------------
        -:   20:Builder(HiddenDrop);
       76:   21:Impl(HiddenDrop, Drop);
------------------
vtable_add_trait_impl_HiddenDrop_Drop:
       38:   21:Impl(HiddenDrop, Drop);
------------------
__required_add__HiddenDrop_drop:
       38:   21:Impl(HiddenDrop, Drop);
------------------
        -:   22:
        -:   23:#define IMPL HiddenDrop
        1:   24:void HiddenDrop_drop() {}
        -:   25:#undef IMPL
        -:   26:
     123*:   27:Type(
------------------
__add_impls_Hidden_vtable:
       38:   27:Type(
------------------
Hidden_drop_internal:
        1:   27:Type(
------------------
Hidden_build_internal:
       4*:   27:Type(
------------------
__add_where_Hidden_T_vtable:
       76:   27:Type(
------------------
Hidden_size:
        4:   27:Type(
------------------
        -:   28:    Hidden,
        -:   29:    Where(T, TraitBound(Drop)),
        -:   30:    Field(u64, value),
        -:   31:    Field(HiddenConfig, config),
        -:   32:    Generic(T, v2),
        -:   33:    Object(HiddenDrop, dd));
        -:   34:
        -:   35:#define IMPL Hidden
        2:   36:void Hidden_build(const HiddenConfig* config)
        -:   37:{
        2:   38:	printf("building hidden: capacity = %" PRIu64 "\n", config->capacity);
        2:   39:	$Var(config) = *config;
        2:   40:	let hd = new (HiddenDrop);
       4*:   41:	Move(&$Var(v2), &hd);
        2:   42:}
        -:   43:
        2:   44:void Hidden_drop()
        -:   45:{
        2:   46:	printf("drop value=%" PRIu64 "\n", $(value));
        2:   47:}
        4:   48:u64 Hidden_get_value()
        -:   49:{
        4:   50:	return $(value);
        -:   51:}
        1:   52:u64 Hidden_get_capacity_impl()
        -:   53:{
        1:   54:	return $(config).capacity;
        -:   55:}
        3:   56:void Hidden_set_value(u64 v)
        -:   57:{
        3:   58:	$Var(value) = v;
        3:   59:}
        -:   60:#undef IMPL
        -:   61:
      63*:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_as_ref:
        5:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_variant_id:
        5:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_build:
       3*:   62:EnumImpl(HiddenEnum);
------------------
__add_impls_HiddenEnum_vtable:
       38:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_drop_internal:
        3:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_build_internal:
       3*:   62:EnumImpl(HiddenEnum);
------------------
HiddenEnum_size:
        6:   62:EnumImpl(HiddenEnum);
------------------
        -:    0:Source:test_server.c
        -:    0:Graph:test_server.gcno
        -:    0:Data:test_server.gcda
        -:    0:Runs:38
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/test_server.h>
        -:   16:
        -:   17:// In this file we implement the HttpServer type along with some other types that are
        -:   18:// used by HttpServer. This is a .c file so the implementation details are hidden
        -:   19:// from the user providing encapsulation of the data within the HttpServer type.
        -:   20:
        -:   21:// We create a type that implements the 'Drop' trait. This is needed to satisfy
        -:   22:// the trait bound of HttpServer in our example. We also call the required macros
        -:   23:// to minimally intialize this type and declare that the Drop trait will be
        -:   24:// implemented.
       42:   25:Type(CanDrop);
------------------
__add_impls_CanDrop_vtable:
       38:   25:Type(CanDrop);
------------------
CanDrop_drop_internal:
        1:   25:Type(CanDrop);
------------------
CanDrop_build_internal:
        1:   25:Type(CanDrop);
------------------
CanDrop_size:
        2:   25:Type(CanDrop);
------------------
        -:   26:Builder(CanDrop);
       76:   27:Impl(CanDrop, Drop);
------------------
vtable_add_trait_impl_CanDrop_Drop:
       38:   27:Impl(CanDrop, Drop);
------------------
__required_add__CanDrop_drop:
       38:   27:Impl(CanDrop, Drop);
------------------
        -:   28:
        -:   29:// Do the drop implementation for this type. By defining 'IMPL', we have access
        -:   30:// to the $() macro which allows for self operations and access to the data types.
        -:   31:#define IMPL CanDrop
        1:   32:void CanDrop_drop() { printf("dropping can drop\n"); }
        -:   33:#undef IMPL
        -:   34:
        -:   35:// Now we declare a second type which will demonstrate concrete types. This type
        -:   36:// also has some data fields which are used and a Builder which allows configuration.
       42:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
__add_impls_HttpServerComponent_vtable:
       38:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_drop_internal:
        1:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_build_internal:
        1:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
HttpServerComponent_size:
        2:   37:Type(HttpServerComponent, Field(u64, state), Field(void*, alloc_mem));
------------------
        -:   38:Builder(HttpServerComponent, Config(u64, state));
        -:   39:
        -:   40:// Implement Drop and Build for this type.
       76:   41:Impl(HttpServerComponent, Drop);
------------------
vtable_add_trait_impl_HttpServerComponent_Drop:
       38:   41:Impl(HttpServerComponent, Drop);
------------------
__required_add__HttpServerComponent_drop:
       38:   41:Impl(HttpServerComponent, Drop);
------------------
       76:   42:Impl(HttpServerComponent, Build);
------------------
vtable_add_trait_impl_HttpServerComponent_Build:
       38:   42:Impl(HttpServerComponent, Build);
------------------
__required_add__HttpServerComponent_build:
       38:   42:Impl(HttpServerComponent, Build);
------------------
        -:   43:
        -:   44:// Here we implement drop and build, the required methods for our traits.
        -:   45:#define IMPL HttpServerComponent
        1:   46:void HttpServerComponent_drop()
        -:   47:{
        -:   48:	// The $() macro allows us to access data fields in our type. In this case
        -:   49:	// We print out $(alloc_mem) and free it.
        1:   50:	printf("dropping http server component. Free %p\n", $(alloc_mem));
        1:   51:	free($(alloc_mem));
        1:   52:}
        1:   53:void HttpServerComponent_build(const HttpServerComponentConfig* config_in)
        -:   54:{
        -:   55:	// In contrast to the drop implementation, here we use the $Var macro.
        -:   56:	// The difference from the $ macro is that the $Var macro is mutable.
        -:   57:	// If the $Var macro is used in an immutable function, a thread panic
        -:   58:	// will occur.
        1:   59:	const HttpServerComponentConfig* config = config_in;
        -:   60:	// Set the 'state' data member of this type using the config.
        1:   61:	$Var(state) = config->state;
        -:   62:	// allocate memory to our void pointer type to demonstrate the usage of build/drop.
        1:   63:	$Var(alloc_mem) = malloc(100);
        1:   64:	printf("building http server component. Alloc %p\n", $(alloc_mem));
        1:   65:}
        -:   66:#undef IMPL
        -:   67:
        -:   68:// Now we define the main type. This type information is hidden from the user as this
        -:   69:// data is defined in our .c file and treated as an opaque pointer.
        -:   70:// The HttpServer type demonstrates the 'Where' clause for defining generics and the usage
        -:   71:// of all three types of data members (Generic, Object, and Field).
     119*:   72:Type(
------------------
__add_impls_HttpServer_vtable:
       38:   72:Type(
------------------
HttpServer_drop_internal:
        1:   72:Type(
------------------
HttpServer_build_internal:
       2*:   72:Type(
------------------
__add_where_HttpServer_T_vtable:
       76:   72:Type(
------------------
HttpServer_size:
        2:   72:Type(
------------------
        -:   73:    HttpServer,
        -:   74:    Where(T, TraitBound(Drop)),
        -:   75:    Field(HttpServerConfig, config),
        -:   76:    Field(bool, is_started),
        -:   77:    Object(HttpServerComponent, hsc),
        -:   78:    Generic(T, droppable));
        -:   79:
        -:   80:// Finally, we implement the HttpServer type.
        -:   81:#define IMPL HttpServer
        -:   82:// This function is not defined by any traits. It serves as a private method within our type.
        -:   83:// Since it is within the IMPL block, we can access both the $Var and $ variables and mutability
        -:   84:// is maintained based on what function calls this function.
        1:   85:void HttpServer_validate_input(const HttpServerConfig* config)
        -:   86:{
        -:   87:	// First set the config to the passed in configuration.
        1:   88:	$Var(config) = *config;
        -:   89:	// check threads and panic if they are not configured. memset is called on all
        -:   90:	// data of the type so everything will be set to 0 initially including this parameter. So,
        -:   91:	// here we effectively force the user to configure threads or a thread panic will occur.
        1:   92:	if ($(config).threads == 0)
    #####:   93:		panic("Threads must be greater than 0. Halting!");
        -:   94:
        -:   95:	// For port and host, we set default values keeping in mind the fact that everything is
        -:   96:	// initialized to 0.
        1:   97:	if ($(config).port == 0)
        1:   98:		$Var(config).port = 8080;
        1:   99:	if ($(config).host == NULL)
        1:  100:		$Var(config).host = "127.0.0.1";
        1:  101:}
        1:  102:void HttpServer_build(const HttpServerConfig* config)
        -:  103:{
        -:  104:	// The build function is automatically called by the system when an Object is instantiated.
        1:  105:	HttpServer_validate_input(config);
        -:  106:	// set is_started to false.
        1:  107:	$Var(is_started) = false;
        -:  108:	// create a 'CanDrop' object which will fulfil the trait bounds of 'droppable'.
        2:  109:	let can_drop = new (CanDrop);
        -:  110:	// Always use Move to move Objects as it will enforce all trait bounds and set the cleanup
        -:  111:	// and other flags appropriately for all types.
       2*:  112:	Move(&$Var(droppable), &can_drop);
        -:  113:	// create an immutable HttpServerComponent instance with state initialized to 1.
        1:  114:	let hsc = new (HttpServerComponent, With(state, 1));
        -:  115:	// Once again use the Move macro to move the instance into the proper memory location.
       1*:  116:	Move(&$Var(hsc), &hsc);
        1:  117:}
        -:  118:// Implement a drop method which just prints out the message below.
        1:  119:void HttpServer_drop() { printf("dropping http server\n"); }
        -:  120:// Return the is_started status of the server using the immutable self macro '$'.
        2:  121:bool HttpServer_is_started() { return $(is_started); }
        -:  122:// Implement the start_server Required function.
        2:  123:bool HttpServer_start_server()
        -:  124:{
        -:  125:	// Do error checking.
        2:  126:	if ($(is_started))
        1:  127:		return false;
        -:  128:	// Set is_started to appropriate value.
        1:  129:	$Var(is_started) = true;
        -:  130:	// Print the configuration
        1:  131:	printf(
        -:  132:	    "Server started on %s:%" PRIu16 " with %" PRIu32 " threads\n",
        1:  133:	    $(config).host, $(config).port, $(config).threads);
        -:  134:	// Call the format_print_stats function. This function will execute the provided format_print_stats
        -:  135:	// function. Note that we use the $() which refers to the pointer whose context we are currently in.
        -:  136:	// This can be used to call any trait member functions.
        1:  137:	format_print_stats($());
        1:  138:	return true;
        -:  139:}
        -:  140:// Implement a basic printing of the stats.
        1:  141:void HttpServer_print_stats()
        -:  142:{
        1:  143:	printf("Current stats: is_started: %i\n", $(is_started));
        1:  144:}
    #####:  145:void HttpServer_blorp(u64 v) {}
        -:  146:#undef IMPL
        -:  147:
        -:  148:// This is the default implementation for the format_print_stats function. Note that we can still access
        -:  149:// the $ and $Var macros as a sort of a self operator, but since this is not part of any implementation,
        -:  150:// fields cannot be specified.
        1:  151:void format_print_stats_impl()
        -:  152:{
        1:  153:	printf("-----------------------------------------------------\n");
        1:  154:	print_stats($());
        1:  155:	printf("-----------------------------------------------------\n");
        1:  156:}
        -:    0:Source:thread.c
        -:    0:Graph:thread.gcno
        -:    0:Data:thread.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <base/chain_allocator.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <core/thread.h>
        -:   19:#include <errno.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:int PANIC_TRUE = 1;
        -:   24:int PANIC_FALSE = 0;
        -:   25:
        -:   26:typedef struct ThreadArgsWrapper {
        -:   27:	void (*start_routine)(void *);
        -:   28:	void *args;
        -:   29:	FatPtr self;
        -:   30:} ThreadArgsWrapper;
        -:   31:
        -:   32:typedef struct ThreadImpl {
        -:   33:	pthread_t pth;
        -:   34:	u64 tid;
        -:   35:	FatPtr self;
        -:   36:} ThreadImpl;
        -:   37:
        4:   38:void Thread_cleanup(Thread *ptr) {
        4:   39:	if (chain_free(&ptr->impl))
    #####:   40:		panic("Could not free Thread");
        4:   41:}
        -:   42:
        4:   43:void *Thread_proc_start(void *arg) {
        -:   44:	// set jmp return point for panics
        4:   45:	if (PANIC_RETURN()) {
        1:   46:		pthread_exit(&PANIC_TRUE);
        -:   47:	}
        -:   48:
        4:   49:	ThreadArgsWrapper *taw = arg;
        4:   50:	(taw->start_routine)(taw->args);
        -:   51:
       3*:   52:	ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        3:   53:	if (chain_free(&taw->self))
    #####:   54:		panic("Could not free ThreadArgsWrapper");
        -:   55:
        3:   56:	if (__default_tl_heap_allocator != NULL) {
    #####:   57:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   58:	}
        -:   59:
        3:   60:	pthread_exit(&PANIC_FALSE);
        -:   61:}
        -:   62:
        4:   63:int Thread_start(Thread *th, void (*start_routine)(void *), void *args) {
        4:   64:	int ret = 0;
        4:   65:	ret = chain_malloc(&th->impl, sizeof(ThreadImpl));
        -:   66:
        4:   67:	if (!ret) {
        -:   68:
        8:   69:		ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        4:   70:		ThreadImpl *ti = th->impl.data;
        -:   71:
        -:   72:		FatPtr tawptr;
        4:   73:		ret = chain_malloc(&tawptr, sizeof(ThreadArgsWrapper));
        -:   74:
        4:   75:		if (!ret) {
        4:   76:			ThreadArgsWrapper *data = tawptr.data;
        4:   77:			data->start_routine = start_routine;
        4:   78:			data->args = args;
        4:   79:			data->self = tawptr;
        -:   80:
        4:   81:			ret = pthread_create(&ti->pth, NULL, Thread_proc_start, data);
        -:   82:		}
        -:   83:	}
        4:   84:	return ret;
        -:   85:}
        -:   86:
        4:   87:JoinResult Thread_join(Thread *ptr) {
        4:   88:	int result = -1;
        4:   89:	int *status = &PANIC_FALSE;
        -:   90:
        4:   91:	if (ptr == NULL)
    #####:   92:		errno = EINVAL;
        -:   93:	else {
        4:   94:		ThreadImpl *ti = ptr->impl.data;
        4:   95:		result = pthread_join(ti->pth, (void *)&status);
        -:   96:	}
        4:   97:	JoinResult jr = {*status == PANIC_TRUE, result != 0};
        4:   98:	return jr;
        -:   99:}
        -:  100:
        4:  101:bool JoinResult_is_panic(JoinResult *jr) {
        4:  102:	return jr->is_panic;
        -:  103:}
        -:  104:
        4:  105:bool JoinResult_is_error(JoinResult *jr) {
        4:  106:	return jr->is_error;
        -:  107:}
        -:    0:Source:traits.c
        -:    0:Graph:traits.gcno
        -:    0:Data:traits.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/traits.h>
        -:   16:
    #####:   17:u64 size(const Obj* self)
        -:   18:{
    #####:   19:	if (self->flags & OBJECT_FLAGS_CONSUMED)
    #####:   20:		panic("Runtime error: Obj [%s@%" PRIu64
        -:   21:		      "] has already been consumed!",
    #####:   22:		      self->vtable->name, self->ptr.id);
    #####:   23:	u64 (*impl)() = find_fn(self, "size");
    #####:   24:	if (!impl)
    #####:   25:		panic("Runtime error: Trait bound violation! "
        -:   26:		      "Type "
        -:   27:		      "'%s' does "
        -:   28:		      "not implement the "
        -:   29:		      "required function [%s]",
    #####:   30:		      TypeName((*self)), "size");
    #####:   31:	SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};
    #####:   32:	__thread_local_self_Const = self;
    #####:   33:	__thread_local_self_Var = NULL;
        -:   34:
    #####:   35:	return impl();
        -:   36:}
        -:   37:
       30:   38:void drop(Obj* self)
        -:   39:{
       30:   40:	if (self->flags & OBJECT_FLAGS_CONSUMED)
    #####:   41:		panic("Runtime error: Obj [%s@%" PRIu64
        -:   42:		      "] has already been consumed!",
    #####:   43:		      self->vtable->name, self->ptr.id);
       30:   44:	void (*impl)() = find_fn(self, "drop");
       30:   45:	SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};
       30:   46:	__thread_local_self_Const = self;
       30:   47:	__thread_local_self_Var = self;
        -:   48:
        -:   49:	// custom code here (set no cleanup since we're already done and consume
        -:   50:	// the object):
       30:   51:	self->flags |= OBJECT_FLAGS_NO_CLEANUP | OBJECT_FLAGS_CONSUMED;
        -:   52:	// free the pointer here as well since cleanup will not be called
       30:   53:	if (fat_ptr_data(&self->ptr))
        -:   54:	{
       30:   55:		chain_free(&self->ptr);
        -:   56:	}
        -:   57:	// in the case of no drop existing we just return
       30:   58:	if (impl)
       20:   59:		impl();
       30:   60:}
        -:   61:
        -:   62:// default implementation of clone_from
        1:   63:void clone_from_impl(Obj* to_clone)
        -:   64:{
        -:   65:	// call the type specific 'klone' required method.
        1:   66:	let v = klone(to_clone);
        -:   67:	// move the result to $Var() internal self reference.
        -:   68:	// cleanup handled by Move.
       1*:   69:	Move($Var(), &v);
        1:   70:}
        -:    0:Source:type.c
        -:    0:Graph:type.gcno
        -:    0:Data:type.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/panic.h>
        -:   16:#include <core/type.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        -:   20:_Thread_local const Obj *__thread_local_self_Const = NULL;
        -:   21:_Thread_local Obj *__thread_local_self_Var = NULL;
        -:   22:
        -:   23:atomic_ullong __global_counter__;
       39:   24:void __attribute__((constructor)) init_global_counter() {
       39:   25:	atomic_init(&__global_counter__, 1);
       39:   26:}
        -:   27:
    #####:   28:u64 unique_id() {
    #####:   29:	u64 ret = atomic_fetch_add(&__global_counter__, 1);
    #####:   30:	return ret;
        -:   31:}
        -:   32:
      152:   33:FatPtr build_fat_ptr(u64 size) {
        -:   34:	FatPtr ret;
      152:   35:	if (chain_malloc(&ret, size)) {
        -:   36:		// if chain_malloc is an error we set data to NULL and caller to
        -:   37:		// handle
    #####:   38:		ret.data = NULL;
        -:   39:	}
      152:   40:	return ret;
        -:   41:}
        -:   42:
   111991:   43:int compare_vtable_entry(const void *ent1, const void *ent2) {
   111991:   44:	const VtableEntry *vtent1 = ent1;
   111991:   45:	const VtableEntry *vtent2 = ent2;
   111991:   46:	return strcmp(vtent1->name, vtent2->name);
        -:   47:}
        -:   48:
    14264:   49:void sort_vtable(Vtable *table) {
    14264:   50:	qsort(table->entries, table->len, sizeof(VtableEntry), compare_vtable_entry);
    14264:   51:}
        -:   52:
    14264:   53:void vtable_add_entry(Vtable *table, VtableEntry entry) {
    14264:   54:	if (table->entries == NULL) {
     1725:   55:		table->entries = malloc(sizeof(VtableEntry) * (table->len + 1));
     1725:   56:		if (table->entries == NULL)
    #####:   57:			panic("Couldn't allocate memory for vtable");
        -:   58:	} else {
    12539:   59:		void *tmp = realloc(table->entries, sizeof(VtableEntry) * (table->len + 1));
    12539:   60:		if (tmp == NULL)
    #####:   61:			panic("Couldn't allocate memory for vtable");
    12539:   62:		table->entries = tmp;
        -:   63:	}
        -:   64:
    14264:   65:	memcpy(&table->entries[table->len], &entry, sizeof(VtableEntry));
    14264:   66:	table->len += 1;
    14264:   67:	sort_vtable(table);
    14264:   68:}
        -:   69:
       38:   70:void vtable_override(Vtable *table, VtableEntry entry) {
      228:   71:	for (int i = 0; i < table->len; i++) {
      190:   72:		if (!strcmp(entry.name, table->entries[i].name)) {
       38:   73:			table->entries[i].fn_ptr = entry.fn_ptr;
        -:   74:		}
        -:   75:	}
       38:   76:}
        -:   77:
      304:   78:bool vtable_check_impl_trait(const Vtable *table, const char *trait) {
      304:   79:	bool ret = false;
        -:   80:
      494:   81:	for (u64 i = 0; i < table->trait_len; i++) {
      494:   82:		if (!strcmp(table->trait_entries[i].trait_name, trait)) {
      304:   83:			ret = true;
      304:   84:			break;
        -:   85:		}
        -:   86:	}
        -:   87:
      304:   88:	return ret;
        -:   89:}
        -:   90:
     8252:   91:void vtable_add_trait(Vtable *table, char *trait) {
     8252:   92:	if (table->trait_entries == NULL) {
     1724:   93:		table->trait_entries = malloc(sizeof(VtableTraitEntry) * (table->trait_len + 1));
     1724:   94:		if (table->trait_entries == NULL)
    #####:   95:			panic("Couldn't allocate memory for vtable");
        -:   96:	} else {
        -:   97:		void *tmp =
     6528:   98:			realloc(table->trait_entries, sizeof(VtableTraitEntry) * (table->trait_len + 1));
     6528:   99:		if (tmp == NULL)
    #####:  100:			panic("Couldn't allocate memory for vtable");
     6528:  101:		table->trait_entries = tmp;
        -:  102:	}
        -:  103:
        -:  104:	VtableTraitEntry entry;
     8252:  105:	if (strlen(trait) >= MAX_TRAIT_NAME_LEN)
    #####:  106:		panic("trait name [%s] is too long. MAX_TRAIT_NAME_LEN = %i\n", trait,
        -:  107:			  MAX_TRAIT_NAME_LEN - 1);
     8252:  108:	strcpy(entry.trait_name, trait);
        -:  109:
     8252:  110:	memcpy(&table->trait_entries[table->trait_len], &entry, sizeof(VtableTraitEntry));
     8252:  111:	table->trait_len += 1;
     8252:  112:}
        -:  113:
      795:  114:void *find_fn(const Obj *obj, const char *name) {
      795:  115:	int left = 0;
      795:  116:	int right = obj->vtable->len - 1;
     2138:  117:	while (left <= right) {
     2048:  118:		int mid = left + (right - left) / 2;
     2048:  119:		int cmp = strcmp(name, obj->vtable->entries[mid].name);
        -:  120:
     2048:  121:		if (cmp == 0) {
      705:  122:			return obj->vtable->entries[mid].fn_ptr;
     1343:  123:		} else if (cmp < 0) {
      643:  124:			right = mid - 1;
        -:  125:		} else {
      700:  126:			left = mid + 1;
        -:  127:		}
        -:  128:	}
       90:  129:	return NULL;
        -:  130:}
        -:  131:
      247:  132:void SelfCleanupImpl_update(SelfCleanupImpl *ptr) {
      247:  133:	__thread_local_self_Const = ptr->prev_tl_self_Const;
      247:  134:	__thread_local_self_Var = ptr->prev_tl_self_Var;
      247:  135:}
        -:  136:
       69:  137:void Obj_check_param(const Obj *obj) {
       69:  138:	if (obj && (obj->flags & OBJECT_FLAGS_CONSUMED) != 0)
    #####:  139:		panic("Passing a consumed object as a function "
        -:  140:			  "parameter!");
       69:  141:}
        -:  142:
       17:  143:bool Obj_is_type(const Obj *ptr, char *ref) {
       17:  144:	if (!strcmp(TypeName((*ptr)), ref))
       17:  145:		return true;
    #####:  146:	return false;
        -:  147:}
        -:  148:
      152:  149:void Obj_build_int(Obj *ptr) {
        -:  150:	// call internal build handler
      152:  151:	void (*build_int)(Obj *ptr) = find_fn(ptr, "build_internal");
      152:  152:	if (!build_int)
    #####:  153:		panic("no internal build handler found");
      152:  154:	build_int(ptr);
      152:  155:}
        -:  156:
      152:  157:void Obj_build(Obj *ptr, const void *config) {
      152:  158:	void (*do_build)(const void *config) = find_fn(ptr, "build");
      152:  159:	if (do_build) {
        -:  160:		// setup self references
      148:  161:		Obj *tmp_Var = __thread_local_self_Var;
      148:  162:		const Obj *tmp_Const = __thread_local_self_Const;
      148:  163:		__thread_local_self_Const = ptr;
      148:  164:		__thread_local_self_Var = ptr;
      148:  165:		do_build(config);
        -:  166:		// revert
      148:  167:		__thread_local_self_Var = tmp_Var;
      148:  168:		__thread_local_self_Const = tmp_Const;
        -:  169:	}
      152:  170:}
        -:  171:
        -:  172:#if defined(__clang__)
        -:  173:// Clang-specific pragma
        -:  174:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  175:#elif defined(__GNUC__) && !defined(__clang__)
        -:  176:// GCC-specific pragma
        -:  177:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  178:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  179:#else
        -:  180:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  181:#endif
      236:  182:void Obj_cleanup(const Obj *ptr) {
      236:  183:	Obj *unconst = ptr;
      236:  184:	if ((unconst->flags & OBJECT_FLAGS_NO_CLEANUP) == 0) {
        -:  185:		// call internal drop handler
      122:  186:		void (*drop_int)(Obj *ptr) = find_fn(ptr, "drop_internal");
      122:  187:		if (!drop_int)
    #####:  188:			panic("no internal drop handler found");
      122:  189:		drop_int(unconst);
        -:  190:
        -:  191:		// call defined drop handler
      122:  192:		void (*drop)(Obj *ptr) = find_fn(ptr, "drop");
      122:  193:		if (drop) {
        -:  194:			// setup self references
       46:  195:			Obj *tmp_Var = __thread_local_self_Var;
       46:  196:			Obj *tmp_Const = __thread_local_self_Const;
       46:  197:			__thread_local_self_Const = unconst;
       46:  198:			__thread_local_self_Var = unconst;
       46:  199:			drop(ptr);
        -:  200:			// revert
       46:  201:			__thread_local_self_Var = tmp_Var;
       46:  202:			__thread_local_self_Const = tmp_Const;
        -:  203:		}
      122:  204:		if (fat_ptr_data(&unconst->ptr)) {
      122:  205:			chain_free(&unconst->ptr);
        -:  206:		}
        -:  207:	}
      236:  208:}
        -:  209:
        -:  210:#if defined(__clang__)
        -:  211:// Clang-specific pragma
        -:  212:#pragma GCC diagnostic push
        -:  213:#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
        -:  214:#elif defined(__GNUC__) && !defined(__clang__)
        -:  215:// GCC-specific pragma
        -:  216:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  217:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  218:#else
        -:  219:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  220:#endif
       45:  221:void Obj_mark_consumed(const Obj *ptr) {
       45:  222:	Obj *unconst = ptr;
       45:  223:	unconst->flags |= OBJECT_FLAGS_NO_CLEANUP | OBJECT_FLAGS_CONSUMED;
       45:  224:}
        -:  225:#pragma GCC diagnostic pop
        -:    0:Source:unit.c
        -:    0:Graph:unit.gcno
        -:    0:Data:unit.gcda
        -:    0:Runs:39
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/unit.h>
        -:   16:
      39*:   17:Type(Unit);
------------------
__add_impls_Unit_vtable:
       39:   17:Type(Unit);
------------------
Unit_drop_internal:
    #####:   17:Type(Unit);
------------------
Unit_build_internal:
    #####:   17:Type(Unit);
------------------
Unit_size:
    #####:   17:Type(Unit);
------------------
        -:    0:Source:chain_allocator.c
        -:    0:Graph:chain_allocator.gcno
        -:    0:Data:chain_allocator.gcda
        -:    0:Runs:50
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <base/resources.h>
        -:   18:#include <errno.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <string.h>
        -:   21:
        -:   22:// the default heap allocator for the current thread
        -:   23:_Thread_local HeapAllocator *__default_tl_heap_allocator = NULL;
        -:   24:
        -:   25:// the global heap allocator (used when the memory will potentially be
        -:   26:// deallocated in a different thread than it was created in
        -:   27:HeapAllocator *__global_sync_allocator = NULL;
        -:   28:// lock for the global heap allocator
        -:   29:Lock *__global_sync_allocator_lock = NULL;
        -:   30:
        -:   31:// default heap allocator config (no_malloc and zeroed are disabled)
        -:   32:HeapAllocatorConfig __default_hconfig_ = {false, false};
        -:   33:
        -:   34:// create default slab sizes for the heap allocator with alignment in mind
        -:   35:#define HD_CFG(size) {size, 10, 0, UINT32_MAX}
        -:   36:HeapDataParamsConfig __default_hdpc_arr_value[] = {HD_CFG(8),
        -:   37:												   HD_CFG(16),
        -:   38:												   HD_CFG(32),
        -:   39:												   HD_CFG(48),
        -:   40:												   HD_CFG(64),
        -:   41:												   HD_CFG(80),
        -:   42:												   HD_CFG(96),
        -:   43:												   HD_CFG(112),
        -:   44:												   HD_CFG(128),
        -:   45:												   HD_CFG(144),
        -:   46:												   HD_CFG(160),
        -:   47:												   HD_CFG(176),
        -:   48:												   HD_CFG(192),
        -:   49:												   HD_CFG(208),
        -:   50:												   HD_CFG(224),
        -:   51:												   HD_CFG(240),
        -:   52:												   HD_CFG(256),
        -:   53:												   HD_CFG(272),
        -:   54:												   HD_CFG(288),
        -:   55:												   HD_CFG(304),
        -:   56:												   HD_CFG(320),
        -:   57:												   HD_CFG(336),
        -:   58:												   HD_CFG(352),
        -:   59:												   HD_CFG(368),
        -:   60:												   HD_CFG(384),
        -:   61:												   HD_CFG(400),
        -:   62:												   HD_CFG(416),
        -:   63:												   HD_CFG(432),
        -:   64:												   HD_CFG(448),
        -:   65:												   HD_CFG(464),
        -:   66:												   HD_CFG(480),
        -:   67:												   HD_CFG(496),
        -:   68:												   HD_CFG(512),
        -:   69:												   HD_CFG(1024),
        -:   70:												   HD_CFG(2048),
        -:   71:												   HD_CFG(4096),
        -:   72:												   HD_CFG(8192),
        -:   73:												   {16384, 5, 0, UINT32_MAX},
        -:   74:												   {32768, 5, 0, UINT32_MAX},
        -:   75:												   {65536, 2, 0, UINT32_MAX}};
        -:   76:
        -:   77:// heap allocator config
        -:   78:HeapDataParamsConfig *__default_hdpc_arr_ = __default_hdpc_arr_value;
        -:   79:
        -:   80:// the size of the default array
        -:   81:u64 __default_hdpc_arr_size =
        -:   82:	sizeof(__default_hdpc_arr_value) / sizeof(__default_hdpc_arr_value[0]);
        -:   83:
        -:   84:// allows for overwriting the hconfig
    #####:   85:void set_default_hconfig(HeapAllocatorConfig *hconfig) {
    #####:   86:	__default_hconfig_ = *hconfig;
    #####:   87:}
        -:   88:
        -:   89:// allows for overwriting of the default hdpc array
        2:   90:void set_default_hdpc_arr(HeapDataParamsConfig arr[], u64 size) {
        2:   91:	__default_hdpc_arr_ = arr;
        2:   92:	__default_hdpc_arr_size = size;
        2:   93:}
        -:   94:
        -:   95:// build the using the default heap allocator config
       29:   96:int build_default_heap_allocator(HeapAllocator *ptr) {
       29:   97:	return heap_allocator_build_arr(ptr, &__default_hconfig_, __default_hdpc_arr_,
        -:   98:									__default_hdpc_arr_size);
        -:   99:}
        -:  100:
        -:  101:// init the global sync allocator
        4:  102:void global_sync_allocator_init() {
        -:  103:	// allocate for the data structure
        4:  104:	__global_sync_allocator = mymalloc(sizeof(HeapAllocator));
        4:  105:	__global_sync_allocator_lock = mymalloc(sizeof(Lock));
        -:  106:
        -:  107:	// check for failures
        4:  108:	if (__global_sync_allocator_lock == NULL || __global_sync_allocator == NULL) {
        -:  109:		// deallocate and panic
    #####:  110:		if (__global_sync_allocator_lock != NULL)
    #####:  111:			myfree(__global_sync_allocator_lock);
    #####:  112:		if (__global_sync_allocator != NULL)
    #####:  113:			myfree(__global_sync_allocator);
    #####:  114:		panic("Could not initialize the global sync HeapAllocator");
        -:  115:	}
        -:  116:
        -:  117:	// setup the lock
        4:  118:	*__global_sync_allocator_lock = LOCK();
        -:  119:
        -:  120:	// build with the default configurations
        4:  121:	if (build_default_heap_allocator(__global_sync_allocator)) {
    #####:  122:		myfree(__global_sync_allocator);
    #####:  123:		panic("Could not initialize the global sync HeapAllocator");
        -:  124:	}
        4:  125:}
        -:  126:
        -:  127:// Entry for the chain allocator stack.
        -:  128:typedef struct ChainGuardEntry {
        -:  129:	HeapAllocator *ha;
        -:  130:	bool is_sync;
        -:  131:	Lock *lock;
        -:  132:} ChainGuardEntry;
        -:  133:
        -:  134:// stack for chain allocators
        -:  135:_Thread_local ChainGuardEntry __thread_local_chain_allocator[MAX_CHAIN_ALLOCATOR_DEPTH];
        -:  136:_Thread_local u64 __thread_local_chain_allocator_index = 0;
        -:  137:
        -:  138:// cleanup the local thread allocator (used when threads terminate)
        1:  139:void thread_local_allocator_cleanup() {
        1:  140:	if (__thread_local_chain_allocator_index > 0)
        1:  141:		heap_allocator_cleanup(
        -:  142:			__thread_local_chain_allocator[__thread_local_chain_allocator_index].ha);
        1:  143:}
        -:  144:
        1:  145:void global_sync_allocator_cleanup() {
        1:  146:	if (__global_sync_allocator != NULL)
        1:  147:		heap_allocator_cleanup(__global_sync_allocator);
        1:  148:}
        -:  149:
        7:  150:void chain_guard_cleanup(ChainGuard *ptr) {
        7:  151:	__thread_local_chain_allocator_index--;
        7:  152:}
        -:  153:
       10:  154:ChainGuard chain_guard(ChainConfig *config) {
       10:  155:	if (__thread_local_chain_allocator_index >= MAX_CHAIN_ALLOCATOR_DEPTH)
    #####:  156:		panic("too many chain allocators");
        -:  157:
       10:  158:	ChainGuardPtr ret = {__thread_local_chain_allocator_index, config->ha, config->is_sync,
       10:  159:						 config->lock};
        -:  160:
       10:  161:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].ha = config->ha;
       10:  162:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].is_sync = config->is_sync;
       10:  163:	__thread_local_chain_allocator[__thread_local_chain_allocator_index].lock = config->lock;
        -:  164:
       10:  165:	__thread_local_chain_allocator_index++;
       10:  166:	return ret;
        -:  167:}
        -:  168:
      234:  169:int chain_malloc(FatPtr *ptr, u64 size) {
      234:  170:	if (__thread_local_chain_allocator_index == 0) {
        -:  171:		// thread local allocator has not been initialized. Create it
        -:  172:		// now.
       25:  173:		HeapAllocator *ha = mymalloc(sizeof(HeapAllocator));
       25:  174:		if (!ha)
    #####:  175:			return -1;
        -:  176:
       25:  177:		if (build_default_heap_allocator(ha)) {
    #####:  178:			myfree(ha);
    #####:  179:			return -1;
        -:  180:		};
        -:  181:
       25:  182:		__default_tl_heap_allocator = ha;
       25:  183:		__thread_local_chain_allocator[0].ha = ha;
       25:  184:		__thread_local_chain_allocator[0].is_sync = false;
       25:  185:		__thread_local_chain_allocator_index++;
        -:  186:	}
      234:  187:	if (size == 0)
    #####:  188:		return -1;
        -:  189:
      234:  190:	u64 index = __thread_local_chain_allocator_index - 1;
      234:  191:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  192:
        -:  193:	int ret;
        -:  194:	{
      234:  195:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
      234:  196:		if (is_sync)
        5:  197:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  198:
      234:  199:		ret = heap_allocator_allocate(__thread_local_chain_allocator[index].ha, size, ptr);
        -:  200:	}
        -:  201:
      234:  202:	return ret;
        -:  203:}
        1:  204:int chain_realloc(FatPtr *dst, FatPtr *src, u64 size) {
        1:  205:	if (__thread_local_chain_allocator_index == 0) {
    #####:  206:		return -1;
        -:  207:	}
        1:  208:	if (size == 0) {
    #####:  209:		errno = EINVAL;
    #####:  210:		return -1;
        -:  211:	}
        1:  212:	u64 index = __thread_local_chain_allocator_index - 1;
        1:  213:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  214:
        -:  215:	int ret;
        -:  216:	{
        1:  217:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
        1:  218:		if (is_sync)
    #####:  219:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  220:
        1:  221:		ret = heap_allocator_allocate(__thread_local_chain_allocator[index].ha, size, dst);
        1:  222:		if (!ret) {
        1:  223:			void *src_data = fat_ptr_data(src);
        1:  224:			void *dst_data = fat_ptr_data(dst);
        1:  225:			u64 len = fat_ptr_len(src);
        1:  226:			memcpy(dst_data, src_data, len);
        1:  227:			ret = chain_free(src);
        -:  228:		}
        -:  229:	}
        -:  230:
        1:  231:	return ret;
        -:  232:}
      198:  233:int chain_free(FatPtr *ptr) {
      198:  234:	if (__thread_local_chain_allocator_index == 0) {
    #####:  235:		errno = ERANGE;
    #####:  236:		return -1;
        -:  237:	}
      198:  238:	u64 index = __thread_local_chain_allocator_index - 1;
      198:  239:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  240:
        -:  241:	int ret;
        -:  242:	{
      198:  243:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
      198:  244:		if (is_sync)
        4:  245:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  246:
      198:  247:		ret = heap_allocator_free(__thread_local_chain_allocator[index].ha, ptr);
        -:  248:	}
      198:  249:	return ret;
        -:  250:}
        -:    0:Source:heap.c
        -:    0:Graph:heap.gcno
        -:    0:Data:heap.gcda
        -:    0:Runs:50
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/heap.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        -:   20:// internal representation of the HeapDataParamsConfig with the required
        -:   21:// free_list_head value.
        -:   22:typedef struct HeapDataParams {
        -:   23:	HeapDataParamsConfig config;
        -:   24:	u32 free_list_head; // The next slab that is free
        -:   25:} HeapDataParams;
        -:   26:
        -:   27:// The data associated with each slab_size.
        -:   28:typedef struct HeapData {
        -:   29:	void **data;		// pointers to each chunk of data
        -:   30:	u32 *free_list;		// the pointers for free slabs.
        -:   31:	u32 count;			// the number of chunks currently allocated
        -:   32:	u32 cur_slabs;		// the number of slabs currently allocated
        -:   33:	HeapDataParams hdp; // The heap data params for this HeapData
        -:   34:} HeapData;
        -:   35:
        -:   36:// The opaque pointer type which is stored in the HeapAllocator data structure
        -:   37:// which is used to access a HeapAllocator.
        -:   38:typedef struct HeapAllocatorImpl {
        -:   39:	u32 hd_size;				// number of sizes available
        -:   40:	HeapAllocatorConfig config; // the configuration
        -:   41:	HeapData *hd_arr;			// The array of heap data.
        -:   42:} HeapAllocatorImpl;
        -:   43:
        -:   44:// debugging options/counters
        -:   45:u64 __malloc_count = 0;
        -:   46:u64 __free_count = 0;
        -:   47:bool __debug_build_allocator_malloc_fail1 = false;
        -:   48:bool __debug_build_allocator_malloc_fail2 = false;
        -:   49:bool __debug_build_allocator_malloc_fail3 = false;
        -:   50:bool __debug_build_allocator_malloc_fail4 = false;
        -:   51:bool __debug_build_allocator_malloc_fail5 = false;
        -:   52:bool __debug_build_allocator_malloc_fail6 = false;
        -:   53:bool __debug_build_allocator_malloc_fail7 = false;
        -:   54:bool __debug_build_allocator_malloc_fail8 = false;
        -:   55:
      335:   56:void *do_malloc(size_t size) {
      335:   57:	__malloc_count += 1;
      335:   58:	void *ret = malloc(size);
        -:   59:	// printf("malloc %zu [%p (%llu)]\n", size, ret, __malloc_count);
      335:   60:	return ret;
        -:   61:}
        -:   62:
      143:   63:void do_free(void *ptr) {
      143:   64:	__free_count += 1;
        -:   65:	// printf("free %p (%llu)\n", ptr, __free_count);
      143:   66:	free(ptr);
      143:   67:}
        -:   68:
       35:   69:void *do_realloc(void *ptr, size_t size) {
       35:   70:	void *ret = realloc(ptr, size);
        -:   71:	// printf("realloc %zu [old=%p,new=%p]\n", size, ptr, ret);
       35:   72:	return ret;
        -:   73:}
        -:   74:
      162:   75:void *fat_ptr_data(const FatPtr *ptr) {
      162:   76:	return ptr->data;
        -:   77:}
        -:   78:
       13:   79:u64 fat_ptr_len(const FatPtr *ptr) {
       13:   80:	return ptr->len;
        -:   81:}
        -:   82:
        5:   83:u64 fat_ptr_id(const FatPtr *ptr) {
        5:   84:	return ptr->id;
        -:   85:}
        -:   86:
       86:   87:int heap_allocator_init_free_list(HeapData *hd, u64 index, u32 slabs, bool last_is_uint_max) {
       86:   88:	hd->data[index] = NULL; // set to NULL for cleanup consistency
        -:   89:
        -:   90:	// allocate memory for slabs
       86:   91:	if (!__debug_build_allocator_malloc_fail4)
       84:   92:		hd->data[index] = do_malloc(hd->hdp.config.slab_size * slabs);
       86:   93:	if (hd->data[index] == NULL)
        2:   94:		return -1;
        -:   95:
       84:   96:	void *tmp = NULL;
        -:   97:
        -:   98:	// allocate / or reallocate the freelist
       84:   99:	if (!__debug_build_allocator_malloc_fail5) {
       82:  100:		if (index == 0)
       65:  101:			tmp = do_malloc(sizeof(u32) * slabs);
        -:  102:		else {
       17:  103:			tmp = do_realloc(hd->free_list, sizeof(u32) * (hd->cur_slabs + slabs));
        -:  104:		}
        -:  105:	}
        -:  106:
       84:  107:	if (!tmp) {
        2:  108:		do_free(hd->data[index]);
        2:  109:		return -1;
        -:  110:	}
        -:  111:
       82:  112:	hd->free_list = tmp;
        -:  113:
        -:  114:	// initialize the values of the free list.
       82:  115:	u32 offset = index * hd->hdp.config.slabs_per_resize;
     1030:  116:	for (u64 i = 0; i < slabs; i++) {
      948:  117:		if ((i == (slabs - 1)) && last_is_uint_max)
       81:  118:			hd->free_list[i + offset] = UINT32_MAX;
        -:  119:		else
      867:  120:			hd->free_list[i + offset] = offset + i + 1;
        -:  121:	}
        -:  122:
       82:  123:	return 0;
        -:  124:}
        -:  125:
        -:  126:// compare function used for sorting.
     2715:  127:int heap_data_compare(const void *p1, const void *p2) {
     2715:  128:	int ret = 0;
        -:  129:
     2715:  130:	HeapData d1 = *(HeapData *)p1;
     2715:  131:	HeapData d2 = *(HeapData *)p2;
        -:  132:
     2715:  133:	if (d1.hdp.config.slab_size > d2.hdp.config.slab_size)
        1:  134:		ret = 1;
     2714:  135:	else if (d1.hdp.config.slab_size < d2.hdp.config.slab_size)
     2713:  136:		ret = -1;
        -:  137:
     2715:  138:	return ret;
        -:  139:}
        -:  140:
        -:  141:// initialize the heap data params
     1115:  142:int heap_allocator_init_hdp(HeapAllocator *ptr, HeapDataParamsConfig *hdp, u64 index) {
        -:  143:
        -:  144:	// set some value in case of a failure below such that cleanup can
        -:  145:	// succeed
     1115:  146:	int ret = 0;
     1115:  147:	ptr->impl->hd_arr[index].hdp.config = *hdp;
     1115:  148:	ptr->impl->hd_arr[index].hdp.free_list_head = 0;
     1115:  149:	ptr->impl->hd_arr[index].cur_slabs = 0;
     1115:  150:	ptr->impl->hd_arr[index].count = ptr->impl->hd_arr[index].hdp.config.initial_chunks;
        -:  151:
        -:  152:	// if we have initial chunks, initialize them
     1115:  153:	if (ptr->impl->hd_arr[index].hdp.config.initial_chunks) {
       23:  154:		ptr->impl->hd_arr[index].data = NULL;
        -:  155:
        -:  156:		// try to allocate space for the data for this size
       23:  157:		if (!__debug_build_allocator_malloc_fail8)
       22:  158:			ptr->impl->hd_arr[index].data =
       22:  159:				do_malloc(ptr->impl->hd_arr[index].hdp.config.initial_chunks * sizeof(void *));
        -:  160:
        -:  161:		// if NULL return error
       23:  162:		if (ptr->impl->hd_arr[index].data == NULL)
        1:  163:			return -1;
        -:  164:
        -:  165:		// set cur_slabs value
       22:  166:		ptr->impl->hd_arr[index].cur_slabs = ptr->impl->hd_arr[index].hdp.config.initial_chunks *
       22:  167:											 ptr->impl->hd_arr[index].hdp.config.slabs_per_resize;
        -:  168:
        -:  169:		// initialize the initial_chunks of the free list
       22:  170:		bool last_is_uint_max = false;
       22:  171:		ptr->impl->hd_arr[index].free_list = NULL;
       45:  172:		for (u64 i = 0; i < ptr->impl->hd_arr[index].hdp.config.initial_chunks; i++) {
        -:  173:
       23:  174:			if (i == ptr->impl->hd_arr[index].hdp.config.initial_chunks - 1)
       22:  175:				last_is_uint_max = true;
       23:  176:			if (heap_allocator_init_free_list(&ptr->impl->hd_arr[index], i,
       23:  177:											  ptr->impl->hd_arr[index].hdp.config.slabs_per_resize,
        -:  178:											  last_is_uint_max))
        2:  179:				ret = -1;
        -:  180:		}
        -:  181:	} else
     1092:  182:		ptr->impl->hd_arr[index].data = NULL;
     1114:  183:	return ret;
        -:  184:}
        -:  185:
       55:  186:int heap_allocator_build_arr(HeapAllocator *ptr, HeapAllocatorConfig *config,
        -:  187:							 HeapDataParamsConfig arr[], u64 heap_data_params_count) {
        -:  188:	// check inputs
       55:  189:	if (ptr == NULL || config == NULL || heap_data_params_count >= 256) {
        1:  190:		errno = EINVAL;
        1:  191:		return -1;
        -:  192:	}
        -:  193:
        -:  194:	// allocate the HeapAllocatorImpl
       54:  195:	if (!__debug_build_allocator_malloc_fail1)
       53:  196:		ptr->impl = do_malloc(sizeof(HeapAllocatorImpl));
       54:  197:	if (ptr->impl == NULL || __debug_build_allocator_malloc_fail1)
        1:  198:		return -1;
        -:  199:
       53:  200:	ptr->impl->hd_size = 0;
        -:  201:
        -:  202:	// copy the config
       53:  203:	ptr->impl->config = *config;
        -:  204:
        -:  205:	// allocate heap data array
       53:  206:	ptr->impl->hd_arr = NULL;
       53:  207:	if (!__debug_build_allocator_malloc_fail2)
       52:  208:		ptr->impl->hd_arr = do_malloc(sizeof(HeapData) * heap_data_params_count);
       53:  209:	if (ptr->impl->hd_arr == NULL || __debug_build_allocator_malloc_fail2) {
        1:  210:		heap_allocator_cleanup(ptr);
        1:  211:		return -1;
        -:  212:	}
       52:  213:	ptr->impl->hd_size = heap_data_params_count;
        -:  214:
        -:  215:	// iterate through specified heap data params
     1164:  216:	for (u64 i = 0; i < heap_data_params_count; i++) {
     1116:  217:		HeapDataParamsConfig hdp = arr[i];
     1116:  218:		ptr->impl->hd_arr[i].count = 0; // init to 0 for safe cleanup
     1116:  219:		ptr->impl->hd_arr[i].data = NULL;
     2231:  220:		if ((__debug_build_allocator_malloc_fail3 && i > 0) ||
     1115:  221:			heap_allocator_init_hdp(ptr, &hdp, i)) {
        4:  222:			ptr->impl->hd_size = i; // update for cleanup, others
        -:  223:									// did not get allocated
        4:  224:			if (ptr->impl->hd_arr[i].data) {
        2:  225:				do_free(ptr->impl->hd_arr[i].data);
        -:  226:			}
        4:  227:			heap_allocator_cleanup(ptr);
        4:  228:			return -1;
        -:  229:		}
        -:  230:	}
        -:  231:
       48:  232:	if (heap_data_params_count) {
       46:  233:		qsort(ptr->impl->hd_arr, heap_data_params_count, sizeof(HeapData), heap_data_compare);
        -:  234:	}
        -:  235:
        -:  236:	// check invalid configurations
       48:  237:	u64 last_size = 0;
     1157:  238:	for (u64 i = 0; i < heap_data_params_count; i++) {
     1111:  239:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == 0) {
        -:  240:			// no 0 sized slabs allowed
        1:  241:			errno = EINVAL;
        1:  242:			heap_allocator_cleanup(ptr);
        1:  243:			return -1;
        -:  244:		}
        -:  245:		// note: logic correct because array is sorted.
     1110:  246:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == last_size) {
        -:  247:			// Duplicate slab_size
        1:  248:			errno = EEXIST;
        1:  249:			heap_allocator_cleanup(ptr);
        1:  250:			return -1;
        -:  251:		}
     1109:  252:		last_size = ptr->impl->hd_arr[i].hdp.config.slab_size;
        -:  253:	}
        -:  254:
       46:  255:	return 0;
        -:  256:}
        -:  257:
       26:  258:int heap_allocator_build(HeapAllocator *ptr, HeapAllocatorConfig *config,
       26:  259:						 int heap_data_params_count, ...) {
       26:  260:	int arr_size = heap_data_params_count;
        -:  261:
        -:  262:	// 0 size is allowed, so we update to address sanitizer warning.
       26:  263:	if (arr_size <= 0) {
        5:  264:		arr_size = 1;
        -:  265:	}
       26:  266:	HeapDataParamsConfig arr[arr_size];
        -:  267:	va_list hdps;
       26:  268:	va_start(hdps, heap_data_params_count);
        -:  269:	// build the array to pass to heap_allocator_build_arr
       55:  270:	for (u64 i = 0; i < heap_data_params_count; i++) {
       29:  271:		HeapDataParamsConfig hdp = va_arg(hdps, HeapDataParamsConfig);
       29:  272:		arr[i] = hdp;
        -:  273:	}
        -:  274:
       26:  275:	va_end(hdps);
        -:  276:	// call the array version of the function
       26:  277:	return heap_allocator_build_arr(ptr, config, arr, heap_data_params_count);
        -:  278:}
        -:  279:
        -:  280:// binary search for the correct slab size
      625:  281:int heap_allocator_index(HeapAllocator *ptr, u64 size) {
      625:  282:	int ret = -1;
      625:  283:	if (ptr->impl->hd_size == 0)
        2:  284:		return ret;
        -:  285:
      623:  286:	int left = 0;
      623:  287:	int right = ptr->impl->hd_size - 1;
        -:  288:
     1800:  289:	while (left <= right) {
     1663:  290:		int mid = left + (right - left) / 2;
     1663:  291:		u64 slab_size = ptr->impl->hd_arr[mid].hdp.config.slab_size;
     1663:  292:		if (slab_size == size) {
      486:  293:			ret = mid;
      486:  294:			break;
     1177:  295:		} else if (slab_size > size)
      920:  296:			right = mid - 1;
        -:  297:		else
      257:  298:			left = mid + 1;
        -:  299:	}
        -:  300:
      623:  301:	if (ret == -1 && right + 1 <= ptr->impl->hd_size - 1) {
      125:  302:		return right + 1;
        -:  303:	}
        -:  304:
      498:  305:	return ret;
        -:  306:}
        -:  307:
       71:  308:int heap_data_resize(u64 index, HeapData *hd) {
        -:  309:	// check that we can resize this hdp
       71:  310:	if (hd->cur_slabs < hd->hdp.config.max_slabs) {
        -:  311:		// calculate the new slabs
       64:  312:		u32 nslabs_count = hd->hdp.config.slabs_per_resize + hd->cur_slabs;
       64:  313:		if (nslabs_count > hd->hdp.config.max_slabs)
        2:  314:			nslabs_count = hd->hdp.config.max_slabs;
        -:  315:
        -:  316:		// determine slabs to allocate
       64:  317:		u32 slabs_to_alloc = nslabs_count - hd->cur_slabs;
        -:  318:
        -:  319:		// attempt to allocate
       64:  320:		void *tmp = NULL;
       64:  321:		if (!__debug_build_allocator_malloc_fail7) {
       63:  322:			if (hd->data)
       18:  323:				tmp = do_realloc(hd->data, (hd->count + 1) * sizeof(void *));
        -:  324:			else
       45:  325:				tmp = do_malloc((hd->count + 1) * sizeof(void **));
        -:  326:		}
        -:  327:
       64:  328:		if (tmp == NULL)
        1:  329:			return -1;
       63:  330:		hd->data = tmp;
        -:  331:
        -:  332:		// initialize the new part of the free list
       63:  333:		if (heap_allocator_init_free_list(hd, hd->count, slabs_to_alloc, true))
        2:  334:			return -1;
       61:  335:		hd->hdp.free_list_head = hd->cur_slabs;
       61:  336:		hd->cur_slabs = nslabs_count;
       61:  337:		hd->count += 1;
       61:  338:		return 0;
        -:  339:	}
        7:  340:	return -1;
        -:  341:}
        -:  342:
      627:  343:int heap_data_allocate(u64 index, HeapData *hd, FatPtr *fptr) {
      627:  344:	if (hd->cur_slabs == 0) {
        -:  345:		// this hd initially had 0 slabs
        -:  346:		// resize it
       46:  347:		if (heap_data_resize(index, hd))
        1:  348:			return -1;
        -:  349:	}
        -:  350:
        -:  351:	// no more slabs, return error
      626:  352:	if (hd->hdp.free_list_head == UINT32_MAX)
       24:  353:		return -1;
        -:  354:
        -:  355:	// get next free slab
      602:  356:	u64 id = hd->hdp.free_list_head;
        -:  357:
        -:  358:	// update free list head
      602:  359:	hd->hdp.free_list_head = hd->free_list[id];
        -:  360:
        -:  361:	// update with the specific index (differing slab sizes)
      602:  362:	fptr->id = id | (index << 56);
      602:  363:	fptr->len = hd->hdp.config.slab_size;
        -:  364:
      602:  365:	u64 heap_data_index = id / hd->hdp.config.slabs_per_resize;
      602:  366:	u64 offset_mod = id % hd->hdp.config.slabs_per_resize;
        -:  367:
        -:  368:	// set the data of the fptr
      602:  369:	fptr->data = hd->data[heap_data_index] + offset_mod * hd->hdp.config.slab_size;
        -:  370:
      602:  371:	return 0;
        -:  372:}
        -:  373:
        -:  374:// free data in this HeapData
      315:  375:int heap_data_free(u64 index, HeapData *hd, FatPtr *fptr) {
      315:  376:	u64 rel = fptr->id & 0x00FFFFFFFFFFFFFF; // Extract the relative ID
        -:  377:
        -:  378:	// if this is invalid return an error
      315:  379:	if (rel >= hd->cur_slabs)
        1:  380:		return -1;
        -:  381:
        -:  382:	// update head and rest of the list
      314:  383:	u64 head = hd->hdp.free_list_head;
      314:  384:	hd->hdp.free_list_head = rel;
      314:  385:	hd->free_list[rel] = head;
        -:  386:
      314:  387:	return 0;
        -:  388:}
        -:  389:
        -:  390:// main allocation function
      625:  391:int heap_allocator_allocate(HeapAllocator *ptr, u64 size, FatPtr *fptr) {
      625:  392:	int ret = -1;
        -:  393:	// determine the index via binary search
      625:  394:	int index = heap_allocator_index(ptr, size);
        -:  395:
        -:  396:	// if this index is not found (too big) fall back to malloc
      625:  397:	if (index < 0) {
       14:  398:		if (!ptr->impl->config.no_malloc) {
       12:  399:			fptr->data = NULL;
       12:  400:			if (!__debug_build_allocator_malloc_fail6)
       11:  401:				fptr->data = do_malloc(size);
       12:  402:			if (fptr->data == NULL) {
        1:  403:				fptr->len = 0;
        1:  404:				ret = -1;
        -:  405:			} else {
       11:  406:				fptr->len = size;
       11:  407:				fptr->id = UINT64_MAX;
       11:  408:				ret = 0;
        -:  409:			}
        -:  410:		}
        -:  411:	} else {
      611:  412:		HeapData *hd = &ptr->impl->hd_arr[index];
      611:  413:		ret = heap_data_allocate(index, hd, fptr);
      611:  414:		if (ret) {
        -:  415:			// there are no more slabs. Try to resize
       25:  416:			if (!heap_data_resize(index, hd)) {
        -:  417:				// successful resize, allocate should always
        -:  418:				// succeed here
       16:  419:				ret = heap_data_allocate(index, hd, fptr);
        9:  420:			} else if (!ptr->impl->config.no_malloc) {
        -:  421:				// could not allocate, so we fall back to malloc
        -:  422:				// if configured
        4:  423:				fptr->data = NULL;
        4:  424:				if (!__debug_build_allocator_malloc_fail6)
        3:  425:					fptr->data = do_malloc(size);
        4:  426:				if (fptr->data == NULL) {
        1:  427:					fptr->len = 0;
        1:  428:					ret = -1;
        -:  429:				} else {
        3:  430:					fptr->len = size;
        3:  431:					fptr->id = UINT64_MAX;
        3:  432:					ret = 0;
        -:  433:				}
        -:  434:			}
        -:  435:		}
        -:  436:	}
        -:  437:
        -:  438:	// if zeroed is configured set all memory of allocated slabs to 0.
      625:  439:	if (!ret && ptr->impl->config.zeroed) {
       44:  440:		memset(fptr->data, 0, fptr->len);
        -:  441:	}
        -:  442:
      625:  443:	return ret;
        -:  444:}
        -:  445:
      330:  446:int heap_allocator_free(HeapAllocator *ptr, FatPtr *fptr) {
      330:  447:	int ret = 0;
      330:  448:	if (fptr->id == UINT64_MAX) {
        -:  449:		// malloc allocated
        -:  450:
       14:  451:		if (fptr->data) {
       14:  452:			do_free(fptr->data);
       14:  453:			fptr->data = NULL;
        -:  454:		}
        -:  455:
       14:  456:		ret = 0;
        -:  457:	} else {
        -:  458:
      316:  459:		u64 index = (fptr->id >> 56) & 0xFF; // Extract the index
        -:  460:
      316:  461:		if (index >= ptr->impl->hd_size) {
        1:  462:			errno = EINVAL;
        1:  463:			ret = -1; // invalid index
        -:  464:		} else {
      315:  465:			HeapData *hd = &ptr->impl->hd_arr[index];
      315:  466:			ret = heap_data_free(index, hd, fptr);
        -:  467:		}
        -:  468:	}
        -:  469:
      330:  470:	if (!ret && ptr->impl->config.zeroed) {
        1:  471:		memset(fptr->data, 0, fptr->len);
        -:  472:	}
        -:  473:
      330:  474:	return ret;
        -:  475:}
        -:  476:
       29:  477:int heap_allocator_cleanup(HeapAllocator *ptr) {
        -:  478:	// check for impl and deallocate
       29:  479:	if (ptr->impl) {
       53:  480:		for (u32 i = 0; i < ptr->impl->hd_size; i++) {
       28:  481:			if (ptr->impl->hd_arr[i].count) {
        -:  482:				// check that it's not an unallocated heap data
       22:  483:				if (ptr->impl->hd_arr[i].free_list) {
       22:  484:					do_free(ptr->impl->hd_arr[i].free_list);
       22:  485:					ptr->impl->hd_arr[i].free_list = NULL;
        -:  486:				}
       54:  487:				for (u64 j = 0; j < ptr->impl->hd_arr[i].count; j++) {
       32:  488:					do_free(ptr->impl->hd_arr[i].data[j]);
        -:  489:				}
       22:  490:				if (ptr->impl->hd_arr[i].data) {
       22:  491:					do_free(ptr->impl->hd_arr[i].data);
       22:  492:					ptr->impl->hd_arr[i].data = NULL;
        -:  493:				}
        -:  494:			}
        -:  495:		}
        -:  496:
       25:  497:		if (ptr->impl->hd_arr) {
       24:  498:			do_free(ptr->impl->hd_arr);
       24:  499:			ptr->impl->hd_arr = NULL;
        -:  500:		}
       25:  501:		do_free(ptr->impl);
       25:  502:		ptr->impl = NULL;
        -:  503:	}
       29:  504:	return 0;
        -:  505:}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:50
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/lock.h>
        -:   16:#include <base/panic.h>
        -:   17:#include <stdio.h>
        -:   18:#include <unistd.h>
        -:   19:
        -:   20:#define MAX_LOCKS 100
        -:   21:_Thread_local Lock *__active_locks_[MAX_LOCKS];
        -:   22:_Thread_local u64 __active_lock_count_ = 0;
        -:   23:
       15:   24:void insert_active_lock(Lock *ptr) {
       15:   25:	if (__active_lock_count_ >= MAX_LOCKS)
    #####:   26:		panic("too many locks!");
       15:   27:	__active_locks_[__active_lock_count_] = ptr;
       15:   28:	__active_lock_count_++;
       15:   29:}
       14:   30:void delete_active_lock(Lock *ptr) {
        -:   31:	// note: locks are removed in reverse order
        -:   32:	// It's possible that cleanup occurs in slightly different order
        -:   33:	// but the effect is the same each lock would be invalidated at the end
        -:   34:	// of a scope. For simplicity we just decrement here.
       14:   35:	if (__active_lock_count_ == 0)
    #####:   36:		panic("active lock stack underflow. Unexpected error!");
       14:   37:	__active_lock_count_--;
       14:   38:}
        -:   39:
        8:   40:Lock Lock_build() {
        -:   41:	LockPtr ret;
        8:   42:	pthread_mutex_init(&ret.lock, NULL);
        8:   43:	pthread_cond_init(&ret.cond, NULL);
        8:   44:	atomic_init(&ret.poison, false);
        8:   45:	atomic_init(&ret.is_locked, false);
        8:   46:	atomic_init(&ret.tid, 0);
        8:   47:	return ret;
        -:   48:}
        -:   49:
        4:   50:void Lock_cleanup(LockPtr *ptr) {
        4:   51:	pthread_mutex_destroy(&ptr->lock);
        4:   52:	pthread_cond_destroy(&ptr->cond);
        4:   53:}
        -:   54:
        1:   55:void Lock_set_poison(Lock *ptr) {
        1:   56:	atomic_exchange(&ptr->poison, true);
        1:   57:}
        1:   58:bool Lock_is_poisoned(Lock *ptr) {
        1:   59:	return atomic_load(&ptr->poison);
        -:   60:}
    #####:   61:void Lock_clear_poison(Lock *ptr) {
    #####:   62:	atomic_exchange(&ptr->poison, false);
    #####:   63:}
       15:   64:u64 Lock_get_tid() {
        -:   65:	u64 tid;
        -:   66:#ifdef __APPLE__
        -:   67:	pthread_threadid_np(NULL, &tid);
        -:   68:#else
       15:   69:	tid = gettid();
        -:   70:#endif // tid code
       15:   71:	return tid;
        -:   72:}
        -:   73:
       15:   74:LockGuard lock(Lock *ptr) {
       15:   75:	if (atomic_load(&ptr->poison))
    #####:   76:		panic("Lock %p: poisoned!", ptr);
        -:   77:
       15:   78:	u64 tid = Lock_get_tid();
        -:   79:
        -:   80:	// check if this would be a deadlock
      15*:   81:	if (atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid)
    #####:   82:		panic("Lock %p: attempt to lock would deadlock!", lock);
        -:   83:
        -:   84:	// obtain lock
       15:   85:	pthread_mutex_lock(&ptr->lock);
       15:   86:	if (atomic_load(&ptr->poison))
    #####:   87:		panic("Lock %p: poisoned!", ptr);
        -:   88:
       15:   89:	insert_active_lock(ptr);
        -:   90:
        -:   91:	// set tid/is_locked and return
       15:   92:	atomic_exchange(&ptr->tid, tid);
       15:   93:	atomic_exchange(&ptr->is_locked, true);
       15:   94:	LockGuardPtr ret = {ptr};
       15:   95:	return ret;
        -:   96:}
        -:   97:
      438:   98:void Lockguard_cleanup(LockGuardPtr *ptr) {
      438:   99:	if (ptr && ptr->ref) {
       14:  100:		atomic_exchange(&ptr->ref->is_locked, false);
       14:  101:		pthread_mutex_unlock(&ptr->ref->lock);
       14:  102:		delete_active_lock(ptr->ref);
        -:  103:	}
      438:  104:}
        -:  105:
        3:  106:void Lock_mark_poisoned() {
        3:  107:	if (__active_lock_count_) {
        1:  108:		u64 i = __active_lock_count_ - 1;
        -:  109:		while (true) {
        1:  110:			Lock_set_poison(__active_locks_[i]);
        1:  111:			atomic_exchange(&__active_locks_[i]->is_locked, false);
        1:  112:			pthread_mutex_unlock(&__active_locks_[i]->lock);
        1:  113:			if (i == 0)
        1:  114:				break;
    #####:  115:			i--;
        -:  116:		}
        -:  117:	}
        3:  118:}
        -:  119:
    #####:  120:void Lock_wait(Lock *ptr, u64 nanoseconds) {
    #####:  121:	u64 tid = Lock_get_tid();
    #####:  122:	if (!(atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid))
    #####:  123:		panic("Attempt to wait on lock %p without first obtaining the "
        -:  124:			  "lock!",
        -:  125:			  ptr);
    #####:  126:	if (nanoseconds == 0) {
    #####:  127:		pthread_cond_wait(&ptr->cond, &ptr->lock);
        -:  128:	} else {
        -:  129:		struct timespec ts;
    #####:  130:		clock_gettime(CLOCK_REALTIME, &ts);
        -:  131:
        -:  132:		// Convert the wait time into seconds and nanoseconds
    #####:  133:		ts.tv_sec += nanoseconds / 1000000000;
    #####:  134:		ts.tv_nsec += nanoseconds % 1000000000;
        -:  135:
        -:  136:		// Normalize the timespec structure in case of overflow in
        -:  137:		// nanoseconds
    #####:  138:		if (ts.tv_nsec >= 1000000000) {
    #####:  139:			ts.tv_sec += ts.tv_nsec / 1000000000;
    #####:  140:			ts.tv_nsec %= 1000000000;
        -:  141:		}
    #####:  142:		pthread_cond_timedwait(&ptr->cond, &ptr->lock, &ts);
        -:  143:	}
    #####:  144:}
        -:  145:
        2:  146:void Lock_notify(Lock *ptr) {
        2:  147:	pthread_cond_signal(&ptr->cond);
        2:  148:}
        -:  149:
    #####:  150:void Lock_notify_all(Lock *ptr) {
    #####:  151:	pthread_cond_broadcast(&ptr->cond);
    #####:  152:}
        -:    0:Source:panic.c
        -:    0:Graph:panic.gcno
        -:    0:Data:panic.gcda
        -:    0:Runs:50
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/chain_allocator.h>
        -:   16:#include <base/lock.h>
        -:   17:#include <base/panic.h>
        -:   18:#include <setjmp.h>
        -:   19:#include <stdarg.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <stdnoreturn.h>
        -:   23:
        -:   24:_Thread_local jmp_buf return_jmp;
        -:   25:_Thread_local bool jmp_return_set = false;
        -:   26:
        3:   27:void panic(const char *fmt, ...) {
        -:   28:	va_list args;
        -:   29:
        3:   30:	fprintf(stderr, "thread panicked: ");
        3:   31:	va_start(args, fmt);
        3:   32:	vfprintf(stderr, fmt, args);
        3:   33:	va_end(args);
        3:   34:	fprintf(stderr, "\n");
        -:   35:
        3:   36:	Lock_mark_poisoned();
        -:   37:
        3:   38:	if (__default_tl_heap_allocator != NULL) {
    #####:   39:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   40:	}
        -:   41:
        -:   42:	// If jump return has not been set, we resort to an exit with an error
        -:   43:	// status.
        3:   44:	if (!jmp_return_set)
    #####:   45:		exit(-1);
        3:   46:	longjmp(return_jmp, THREAD_PANIC);
        -:   47:}
        -:    0:Source:rand.c
        -:    0:Graph:rand.gcno
        -:    0:Data:rand.gcda
        -:    0:Runs:50
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/rand.h>
        -:   16:#include <base/types.h>
        -:   17:#include <sys/random.h>
        -:   18:
    #####:   19:int rand_i8(i8 *v) {
    #####:   20:	return getentropy(v, sizeof(i8));
        -:   21:}
        -:   22:
    #####:   23:int rand_u8(u8 *v) {
    #####:   24:	return getentropy(v, sizeof(u8));
        -:   25:}
        -:   26:
    #####:   27:int rand_i16(i16 *v) {
    #####:   28:	return getentropy(v, sizeof(i16));
        -:   29:}
        -:   30:
    32350:   31:int rand_u16(u16 *v) {
    32350:   32:	return getentropy(v, sizeof(u16));
        -:   33:}
        -:   34:
    #####:   35:int rand_i32(i32 *v) {
    #####:   36:	return getentropy(v, sizeof(i32));
        -:   37:}
        -:   38:
    #####:   39:int rand_u32(u32 *v) {
    #####:   40:	return getentropy(v, sizeof(u32));
        -:   41:}
        -:   42:
    #####:   43:int rand_i64(i64 *v) {
    #####:   44:	return getentropy(v, sizeof(i64));
        -:   45:}
        -:   46:
    #####:   47:int rand_u64(u64 *v) {
    #####:   48:	return getentropy(v, sizeof(u64));
        -:   49:}
        -:   50:
    #####:   51:int rand_i128(i128 *v) {
    #####:   52:	return getentropy(v, sizeof(i128));
        -:   53:}
        -:   54:
    #####:   55:int rand_u128(u128 *v) {
    #####:   56:	return getentropy(v, sizeof(u128));
        -:   57:}
        -:   58:
    #####:   59:int rand_bytes(void *buf, u64 length) {
    #####:   60:	return getentropy(buf, length);
        -:   61:}
        -:    0:Source:resources.c
        -:    0:Graph:resources.gcno
        -:    0:Data:resources.gcda
        -:    0:Runs:50
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/resources.h>
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   19:
    62463:   20:void *mymalloc(usize size) {
        -:   21:	void *ret;
    62463:   22:	ret = malloc(size);
        -:   23:
    62463:   24:	if (ret) {
    62463:   25:		THREAD_LOCAL_RESOURCE_STATS.malloc_sum += 1;
        -:   26:	}
    62463:   27:	return ret;
        -:   28:}
    62349:   29:void *myrealloc(void *ptr, usize size) {
        -:   30:	void *ret;
    62349:   31:	ret = realloc(ptr, size);
        -:   32:
    62349:   33:	if (ret) {
    62349:   34:		THREAD_LOCAL_RESOURCE_STATS.realloc_sum += 1;
        -:   35:	}
    62349:   36:	return ret;
        -:   37:}
    62430:   38:void myfree(void *ptr) {
    62430:   39:	THREAD_LOCAL_RESOURCE_STATS.free_sum += 1;
    62430:   40:	free(ptr);
    62430:   41:}
        2:   42:FILE *myfopen(char *path, const char *mode) {
        2:   43:	FILE *ret = fopen(path, mode);
        -:   44:
        2:   45:	if (ret) {
        2:   46:		THREAD_LOCAL_RESOURCE_STATS.fopen_sum += 1;
        -:   47:	}
        2:   48:	return ret;
        -:   49:}
        2:   50:void myfclose(FILE *ptr) {
        2:   51:	THREAD_LOCAL_RESOURCE_STATS.fclose_sum += 1;
        2:   52:	fclose(ptr);
        2:   53:}
       17:   54:u64 mymalloc_sum() {
       17:   55:	return THREAD_LOCAL_RESOURCE_STATS.malloc_sum;
        -:   56:}
    #####:   57:u64 myrealloc_sum() {
    #####:   58:	return THREAD_LOCAL_RESOURCE_STATS.realloc_sum;
        -:   59:}
       17:   60:u64 myfree_sum() {
       17:   61:	return THREAD_LOCAL_RESOURCE_STATS.free_sum;
        -:   62:}
       21:   63:u64 myfopen_sum() {
       21:   64:	return THREAD_LOCAL_RESOURCE_STATS.fopen_sum;
        -:   65:}
       21:   66:u64 myfclose_sum() {
       21:   67:	return THREAD_LOCAL_RESOURCE_STATS.fclose_sum;
        -:   68:}
        -:    0:Source:sha256.c
        -:    0:Graph:sha256.gcno
        -:    0:Data:sha256.gcda
        -:    0:Runs:50
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:
        -:    5:#define uchar unsigned char
        -:    6:#define uint unsigned int
        -:    7:
        -:    8:#define DBL_INT_ADD(a, b, c)                                                                       \
        -:    9:	if (a > 0xffffffff - (c))                                                                      \
        -:   10:		++b;                                                                                       \
        -:   11:	a += c;
        -:   12:#define ROTLEFT(a, b) (((a) << (b)) | ((a) >> (32 - (b))))
        -:   13:#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
        -:   14:
        -:   15:#define CH(x, y, z) (((x) & (y)) ^ (~(x) & (z)))
        -:   16:#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
        -:   17:#define EP0(x) (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
        -:   18:#define EP1(x) (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
        -:   19:#define SIG0(x) (ROTRIGHT(x, 7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
        -:   20:#define SIG1(x) (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))
        -:   21:
        -:   22:typedef struct {
        -:   23:	uchar data[64];
        -:   24:	uint datalen;
        -:   25:	uint bitlen[2];
        -:   26:	uint state[8];
        -:   27:} SHA256_CTX;
        -:   28:
        -:   29:uint k[64] = {
        -:   30:	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        -:   31:	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        -:   32:	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        -:   33:	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        -:   34:	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        -:   35:	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        -:   36:	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        -:   37:	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
        -:   38:
   144820:   39:void SHA256Transform(SHA256_CTX *ctx, uchar data[]) {
        -:   40:	uint a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
        -:   41:
  2461940:   42:	for (i = 0, j = 0; i < 16; ++i, j += 4)
  2317120:   43:		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
  7096180:   44:	for (; i < 64; ++i)
  6951360:   45:		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
        -:   46:
   144820:   47:	a = ctx->state[0];
   144820:   48:	b = ctx->state[1];
   144820:   49:	c = ctx->state[2];
   144820:   50:	d = ctx->state[3];
   144820:   51:	e = ctx->state[4];
   144820:   52:	f = ctx->state[5];
   144820:   53:	g = ctx->state[6];
   144820:   54:	h = ctx->state[7];
        -:   55:
  9413300:   56:	for (i = 0; i < 64; ++i) {
  9268480:   57:		t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
  9268480:   58:		t2 = EP0(a) + MAJ(a, b, c);
  9268480:   59:		h = g;
  9268480:   60:		g = f;
  9268480:   61:		f = e;
  9268480:   62:		e = d + t1;
  9268480:   63:		d = c;
  9268480:   64:		c = b;
  9268480:   65:		b = a;
  9268480:   66:		a = t1 + t2;
        -:   67:	}
        -:   68:
   144820:   69:	ctx->state[0] += a;
   144820:   70:	ctx->state[1] += b;
   144820:   71:	ctx->state[2] += c;
   144820:   72:	ctx->state[3] += d;
   144820:   73:	ctx->state[4] += e;
   144820:   74:	ctx->state[5] += f;
   144820:   75:	ctx->state[6] += g;
   144820:   76:	ctx->state[7] += h;
   144820:   77:}
        -:   78:
        2:   79:void SHA256Init(SHA256_CTX *ctx) {
        2:   80:	ctx->datalen = 0;
        2:   81:	ctx->bitlen[0] = 0;
        2:   82:	ctx->bitlen[1] = 0;
        2:   83:	ctx->state[0] = 0x6a09e667;
        2:   84:	ctx->state[1] = 0xbb67ae85;
        2:   85:	ctx->state[2] = 0x3c6ef372;
        2:   86:	ctx->state[3] = 0xa54ff53a;
        2:   87:	ctx->state[4] = 0x510e527f;
        2:   88:	ctx->state[5] = 0x9b05688c;
        2:   89:	ctx->state[6] = 0x1f83d9ab;
        2:   90:	ctx->state[7] = 0x5be0cd19;
        2:   91:}
        -:   92:
        2:   93:void SHA256Update(SHA256_CTX *ctx, uchar data[], uint len) {
  9268460:   94:	for (uint i = 0; i < len; ++i) {
  9268458:   95:		ctx->data[ctx->datalen] = data[i];
  9268458:   96:		ctx->datalen++;
  9268458:   97:		if (ctx->datalen == 64) {
   144818:   98:			SHA256Transform(ctx, ctx->data);
  144818*:   99:			DBL_INT_ADD(ctx->bitlen[0], ctx->bitlen[1], 512);
   144818:  100:			ctx->datalen = 0;
        -:  101:		}
        -:  102:	}
        2:  103:}
        -:  104:
        2:  105:void SHA256Final(SHA256_CTX *ctx, uchar hash[]) {
        2:  106:	uint i = ctx->datalen;
        -:  107:
        2:  108:	if (ctx->datalen < 56) {
        2:  109:		ctx->data[i++] = 0x80;
        6:  110:		while (i < 56)
        4:  111:			ctx->data[i++] = 0x00;
        -:  112:	} else {
    #####:  113:		ctx->data[i++] = 0x80;
    #####:  114:		while (i < 64)
    #####:  115:			ctx->data[i++] = 0x00;
    #####:  116:		SHA256Transform(ctx, ctx->data);
    #####:  117:		memset(ctx->data, 0, 56);
        -:  118:	}
        -:  119:
       2*:  120:	DBL_INT_ADD(ctx->bitlen[0], ctx->bitlen[1], ctx->datalen * 8);
        2:  121:	ctx->data[63] = ctx->bitlen[0];
        2:  122:	ctx->data[62] = ctx->bitlen[0] >> 8;
        2:  123:	ctx->data[61] = ctx->bitlen[0] >> 16;
        2:  124:	ctx->data[60] = ctx->bitlen[0] >> 24;
        2:  125:	ctx->data[59] = ctx->bitlen[1];
        2:  126:	ctx->data[58] = ctx->bitlen[1] >> 8;
        2:  127:	ctx->data[57] = ctx->bitlen[1] >> 16;
        2:  128:	ctx->data[56] = ctx->bitlen[1] >> 24;
        2:  129:	SHA256Transform(ctx, ctx->data);
        -:  130:
       10:  131:	for (i = 0; i < 4; ++i) {
        8:  132:		hash[i] = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
        8:  133:		hash[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
        8:  134:		hash[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
        8:  135:		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
        8:  136:		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
        8:  137:		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
        8:  138:		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
        8:  139:		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
        -:  140:	}
        2:  141:}
        -:  142:
        2:  143:int SHA256(unsigned char *data, char hashStr[65]) {
        2:  144:	if (hashStr == NULL || data == NULL)
    #####:  145:		return -1;
        2:  146:	int strLen = strlen((const char *)data);
        -:  147:	SHA256_CTX ctx;
        -:  148:	unsigned char hash[32];
        2:  149:	strcpy(hashStr, "");
        -:  150:
        2:  151:	SHA256Init(&ctx);
        2:  152:	SHA256Update(&ctx, data, strLen);
        2:  153:	SHA256Final(&ctx, hash);
        -:  154:
        -:  155:	char s[3];
       66:  156:	for (int i = 0; i < 32; i++) {
       64:  157:		snprintf(s, 3, "%02x", hash[i]);
       64:  158:		strcat(hashStr, s);
        -:  159:	}
        -:  160:
        2:  161:	return 0;
        -:  162:}
        -:    0:Source:args.c
        -:    0:Graph:args.gcno
        -:    0:Data:args.gcda
        -:    0:Runs:4
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <args/args.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        8:   20:int args_param_build(ArgsParam *ap, char *name, char *help, char *short_name, bool takes_value,
        -:   21:					 bool multiple, char *default_value) {
        8:   22:	if (ap == NULL || name == NULL || help == NULL || short_name == NULL) {
    #####:   23:		errno = EINVAL;
    #####:   24:		return -1;
        -:   25:	}
        -:   26:
        8:   27:	if (strlen(short_name) > strlen(name)) {
    #####:   28:		fprintf(stderr, "short_name cannot be longer than name\n");
    #####:   29:		return -1;
        -:   30:	}
        -:   31:
        8:   32:	ap->name = NULL;
        8:   33:	ap->help = NULL;
        8:   34:	ap->short_name = NULL;
        8:   35:	ap->default_value = NULL;
        -:   36:
        8:   37:	ap->name = mymalloc((1 + strlen(name)) * sizeof(char));
        8:   38:	if (ap->name == NULL) {
    #####:   39:		return -1;
        -:   40:	}
        8:   41:	strcpy(ap->name, name);
        -:   42:
        8:   43:	ap->help = mymalloc((1 + strlen(help)) * sizeof(char));
        8:   44:	if (ap->help == NULL) {
    #####:   45:		args_param_cleanup(ap);
    #####:   46:		return -1;
        -:   47:	}
        8:   48:	strcpy(ap->help, help);
        -:   49:
        8:   50:	ap->short_name = mymalloc((1 + strlen(short_name)) * sizeof(char));
        8:   51:	if (ap->short_name == NULL) {
    #####:   52:		args_param_cleanup(ap);
    #####:   53:		return -1;
        -:   54:	}
        8:   55:	strcpy(ap->short_name, short_name);
        -:   56:
        8:   57:	ap->takes_value = takes_value;
        8:   58:	ap->multiple = multiple;
        -:   59:
        8:   60:	if (default_value) {
        5:   61:		ap->default_value = mymalloc((1 + strlen(default_value)) * sizeof(char));
        5:   62:		if (ap->default_value == NULL) {
    #####:   63:			args_param_cleanup(ap);
    #####:   64:			return -1;
        -:   65:		}
        5:   66:		strcpy(ap->default_value, default_value);
        -:   67:	} else
        3:   68:		ap->default_value = NULL;
        -:   69:
        8:   70:	return 0;
        -:   71:}
       15:   72:void args_param_cleanup(ArgsParam *ap) {
       15:   73:	if (ap->name) {
       15:   74:		myfree(ap->name);
       15:   75:		ap->name = NULL;
        -:   76:	}
       15:   77:	if (ap->short_name) {
       15:   78:		myfree(ap->short_name);
       15:   79:		ap->short_name = NULL;
        -:   80:	}
       15:   81:	if (ap->help) {
       15:   82:		myfree(ap->help);
       15:   83:		ap->help = NULL;
        -:   84:	}
       15:   85:	if (ap->default_value) {
       10:   86:		myfree(ap->default_value);
       10:   87:		ap->default_value = NULL;
        -:   88:	}
       15:   89:}
        7:   90:int sub_command_build(SubCommand *sc, char *name, char *help, u32 min_args, u32 max_args,
        -:   91:					  char *arg_doc) {
        7:   92:	if (name == NULL || help == NULL || min_args > max_args || arg_doc == NULL) {
        2:   93:		errno = EINVAL;
        2:   94:		return -1;
        -:   95:	}
        -:   96:
        5:   97:	sc->name = NULL;
        5:   98:	sc->help = NULL;
        5:   99:	sc->arg_doc = NULL;
        5:  100:	sc->params_count = 0;
        -:  101:
        5:  102:	sc->name = mymalloc((1 + strlen(name)) * sizeof(char));
        5:  103:	if (sc->name == NULL) {
    #####:  104:		sub_command_cleanup(sc);
    #####:  105:		return -1;
        -:  106:	}
        5:  107:	strcpy(sc->name, name);
        -:  108:
        5:  109:	sc->help = mymalloc((1 + strlen(help)) * sizeof(char));
        5:  110:	if (sc->help == NULL) {
    #####:  111:		sub_command_cleanup(sc);
    #####:  112:		return -1;
        -:  113:	}
        5:  114:	strcpy(sc->help, help);
        -:  115:
        5:  116:	sc->arg_doc = mymalloc((1 + strlen(arg_doc)) * sizeof(char));
        5:  117:	if (sc->arg_doc == NULL) {
    #####:  118:		sub_command_cleanup(sc);
    #####:  119:		return -1;
        -:  120:	}
        5:  121:	strcpy(sc->arg_doc, arg_doc);
        -:  122:
        5:  123:	sc->min_args = min_args;
        5:  124:	sc->max_args = max_args;
        5:  125:	return 0;
        -:  126:}
        5:  127:void sub_command_cleanup(SubCommand *sc) {
        5:  128:	if (sc->name) {
        5:  129:		myfree(sc->name);
        5:  130:		sc->name = NULL;
        -:  131:	}
        -:  132:
        5:  133:	if (sc->help) {
        5:  134:		myfree(sc->help);
        5:  135:		sc->help = NULL;
        -:  136:	}
        -:  137:
        5:  138:	if (sc->arg_doc) {
        5:  139:		myfree(sc->arg_doc);
        5:  140:		sc->arg_doc = NULL;
        -:  141:	}
        -:  142:
        5:  143:	if (sc->params_count != 0) {
       11:  144:		for (u64 i = 0; i < sc->params_count; i++) {
        7:  145:			args_param_cleanup(&sc->params[i]);
        -:  146:		}
        -:  147:
        4:  148:		myfree(sc->params);
        4:  149:		myfree(sc->params_state);
        4:  150:		sc->params = NULL;
        4:  151:		sc->params_state = NULL;
        4:  152:		sc->params_count = 0;
        -:  153:	}
        5:  154:}
        7:  155:int sub_command_add_param(SubCommand *sc, ArgsParam *ap) {
        7:  156:	if (ap->name == NULL || ap->help == NULL || ap->short_name == NULL) {
    #####:  157:		errno = EINVAL;
    #####:  158:		return -1;
        -:  159:	}
        7:  160:	if (sc->params_count == 0) {
        4:  161:		sc->params = mymalloc(sizeof(ArgsParam));
        4:  162:		sc->params_state = mymalloc(sizeof(ArgsParamState));
        -:  163:
        4:  164:		if (sc->params == NULL || sc->params_state == NULL) {
        -:  165:
    #####:  166:			sub_command_cleanup(sc);
    #####:  167:			return -1;
        -:  168:		}
        4:  169:		sc->params_count = 1;
        -:  170:	} else {
        3:  171:		sc->params_count += 1;
        3:  172:		void *tmp1 = myrealloc(sc->params, sizeof(ArgsParam) * sc->params_count);
        3:  173:		void *tmp2 = myrealloc(sc->params_state, sizeof(ArgsParamState) * sc->params_count);
        -:  174:
        3:  175:		sc->params = tmp1;
        3:  176:		sc->params_state = tmp2;
        -:  177:	}
        7:  178:	u64 index = sc->params_count - 1;
        -:  179:
        7:  180:	sc->params[index].name = mymalloc((strlen(ap->name) + 1) * sizeof(char));
        7:  181:	strcpy(sc->params[index].name, ap->name);
        -:  182:
        7:  183:	sc->params[index].help = mymalloc((strlen(ap->help) + 1) * sizeof(char));
        7:  184:	strcpy(sc->params[index].help, ap->help);
        -:  185:
        7:  186:	sc->params[index].short_name = mymalloc((strlen(ap->short_name) + 1) * sizeof(char));
        7:  187:	strcpy(sc->params[index].short_name, ap->short_name);
        -:  188:
        7:  189:	sc->params[index].takes_value = ap->takes_value;
        7:  190:	sc->params[index].multiple = ap->multiple;
        -:  191:
        7:  192:	if (ap->default_value) {
        5:  193:		sc->params[index].default_value = mymalloc((strlen(ap->default_value) + 1) * sizeof(char));
        5:  194:		if (sc->params[index].default_value == NULL) {
    #####:  195:			sub_command_cleanup(sc);
    #####:  196:			return -1;
        -:  197:		}
        5:  198:		strcpy(sc->params[index].default_value, ap->default_value);
        -:  199:	} else {
        2:  200:		sc->params[index].default_value = NULL;
        -:  201:	}
        -:  202:
        7:  203:	sc->params_state[index].specified = false;
        -:  204:
        7:  205:	if (sc->params[index].name == NULL || sc->params[index].help == NULL ||
        7:  206:		sc->params[index].short_name == NULL) {
    #####:  207:		sub_command_cleanup(sc);
    #####:  208:		return -1;
        -:  209:	}
        -:  210:
        7:  211:	return 0;
        -:  212:}
        -:  213:
        1:  214:int args_build(Args *args, char *prog, char *version, char *author, u32 min_args, u32 max_args,
        -:  215:			   u64 debug_flags) {
       1*:  216:	if (prog == NULL && version == NULL && author == NULL) {
    #####:  217:		errno = EINVAL;
    #####:  218:		return -1;
        -:  219:	}
        1:  220:	args->subs_count = 0;
        1:  221:	args->argc = 0;
        1:  222:	args->debug_flags = debug_flags;
        -:  223:
        1:  224:	args->prog = mymalloc(sizeof(char) * (1 + strlen(prog)));
        1:  225:	args->version = mymalloc(sizeof(char) * (1 + strlen(version)));
        1:  226:	args->author = mymalloc(sizeof(char) * (1 + strlen(author)));
        -:  227:
        1:  228:	if (args->prog == NULL || args->version == NULL || args->author == NULL) {
    #####:  229:		args_cleanup(args);
    #####:  230:		return -1;
        -:  231:	}
        1:  232:	strcpy(args->prog, prog);
        1:  233:	strcpy(args->version, version);
        1:  234:	strcpy(args->author, author);
        -:  235:
        -:  236:	// first subcommand is our params
        -:  237:	SubCommand sc;
        1:  238:	sub_command_build(&sc, "", "", min_args, max_args, "");
        1:  239:	args_add_sub_command(args, &sc);
        1:  240:	sub_command_cleanup(&sc);
        -:  241:
        1:  242:	return 0;
        -:  243:}
        -:  244:
        1:  245:void args_cleanup(Args *args) {
        1:  246:	if (args->argc) {
        3:  247:		for (u64 i = 0; i < args->argc; i++) {
        2:  248:			myfree(args->argv[i]);
        -:  249:		}
        1:  250:		myfree(args->argv);
        1:  251:		args->argc = 0;
        -:  252:	}
        -:  253:
        1:  254:	if (args->prog) {
        1:  255:		myfree(args->prog);
        1:  256:		args->prog = NULL;
        -:  257:	}
        -:  258:
        1:  259:	if (args->author) {
        1:  260:		myfree(args->author);
        1:  261:		args->author = NULL;
        -:  262:	}
        -:  263:
        1:  264:	if (args->version) {
        1:  265:		myfree(args->version);
        1:  266:		args->version = NULL;
        -:  267:	}
        -:  268:
        1:  269:	if (args->subs_count) {
        3:  270:		for (u64 i = 0; i < args->subs_count; i++) {
        2:  271:			sub_command_cleanup(args->subs[i]);
        2:  272:			myfree(args->subs[i]);
        -:  273:		}
        -:  274:
        1:  275:		myfree(args->subs);
        -:  276:	}
        1:  277:}
        2:  278:int args_add_param(Args *args, ArgsParam *ap) {
        2:  279:	return sub_command_add_param(args->subs[0], ap);
        -:  280:}
        -:  281:
        2:  282:int args_add_sub_command(Args *args, SubCommand *sc) {
        2:  283:	if (args->subs_count == 0) {
        1:  284:		args->subs = mymalloc(sizeof(SubCommand *));
        1:  285:		if (args->subs == NULL) {
    #####:  286:			fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  287:			return -1;
        -:  288:		}
        -:  289:	} else {
        1:  290:		SubCommand **tmp = myrealloc(args->subs, sizeof(SubCommand *) * (1 + args->subs_count));
        -:  291:
        1:  292:		if (tmp == NULL) {
    #####:  293:			fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  294:			return -1;
        -:  295:		}
        -:  296:
        1:  297:		args->subs = tmp;
        -:  298:	}
        -:  299:
        2:  300:	args->subs[args->subs_count] = mymalloc(sizeof(SubCommand));
        2:  301:	if (args->subs[args->subs_count] == NULL) {
    #####:  302:		fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  303:		return -1;
        -:  304:	}
        -:  305:
        2:  306:	if (sub_command_build(args->subs[args->subs_count], sc->name, sc->help, sc->min_args,
        -:  307:						  sc->max_args, sc->arg_doc)) {
    #####:  308:		fprintf(stderr, "add subcommand %s failed!\n", sc->name);
    #####:  309:		myfree(args->subs[args->subs_count]);
    #####:  310:		return -1;
        -:  311:	}
        3:  312:	for (u64 i = 0; i < sc->params_count; i++) {
        1:  313:		if (sub_command_add_param(args->subs[args->subs_count], &sc->params[i])) {
    #####:  314:			fprintf(stderr, "add param [%s] subcommand %s failed!\n", sc->params[i].name, sc->name);
        -:  315:		}
        -:  316:	}
        -:  317:
        2:  318:	args->subs_count += 1;
        2:  319:	return 0;
        -:  320:}
        -:  321:
    #####:  322:bool args_sub_takes_value(Args *args, u64 subi, char *name, bool is_short) {
    #####:  323:	for (u64 i = 0; i < args->subs[subi]->params_count; i++) {
    #####:  324:		if (is_short && !strcmp(name, args->subs[subi]->params[i].short_name)) {
    #####:  325:			if (args->subs[subi]->params[i].takes_value) {
    #####:  326:				return true;
        -:  327:			} else
    #####:  328:				break;
    #####:  329:		} else if (!strcmp(name, args->subs[subi]->params[i].name)) {
    #####:  330:			if (args->subs[subi]->params[i].takes_value) {
    #####:  331:				return true;
        -:  332:			} else
    #####:  333:				break;
        -:  334:		}
        -:  335:	}
    #####:  336:	return false;
        -:  337:}
        -:  338:
    #####:  339:void args_exit_error(Args *args, char *format, ...) {
        -:  340:	va_list va_args;
    #####:  341:	va_start(va_args, format);
    #####:  342:	fprintf(stderr, "%sError%s: ", BRIGHT_RED, RESET);
    #####:  343:	vfprintf(stderr, format, va_args);
    #####:  344:	fprintf(stderr, "\n\n");
    #####:  345:	fprintf(stderr,
        -:  346:			"%sUSAGE%s:\n    %s%s%s [%sOPTIONS%s]\n\nFor more information "
        -:  347:			"try %s--help%s\n",
        -:  348:			DIMMED, RESET, BRIGHT_RED, args->prog, RESET, DIMMED, RESET, GREEN, RESET);
    #####:  349:	va_end(va_args);
    #####:  350:	u64 debug_flags = args->debug_flags;
    #####:  351:	if (!(debug_flags & DEBUG_INIT_NO_EXIT))
    #####:  352:		exit(-1);
    #####:  353:}
        -:  354:
    #####:  355:u64 args_subi_for(Args *args, char *sub) {
    #####:  356:	u64 subi = 0;
    #####:  357:	for (u64 i = 1; i < args->subs_count; i++) {
    #####:  358:		if (!strcmp(sub, args->subs[i]->name)) {
    #####:  359:			subi = i;
        -:  360:		}
        -:  361:	}
    #####:  362:	return subi;
        -:  363:}
        -:  364:
    #####:  365:bool args_check_option(Args *args, u64 subi, char *name, bool is_short, char *argv) {
    #####:  366:	bool found = false;
    #####:  367:	for (u64 j = 0; j < args->subs[subi]->params_count; j++) {
    #####:  368:		bool multi = args->subs[subi]->params[j].multiple;
    #####:  369:		if (is_short && !strcmp(args->subs[subi]->params[j].short_name, name)) {
    #####:  370:			found = true;
    #####:  371:			if (args->subs[subi]->params_state[j].specified && !multi)
    #####:  372:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
    #####:  373:			args->subs[subi]->params_state[j].specified = true;
    #####:  374:			break;
    #####:  375:		} else if (!is_short && !strcmp(args->subs[subi]->params[j].name, name)) {
    #####:  376:			found = true;
    #####:  377:			if (args->subs[subi]->params_state[j].specified && !multi)
    #####:  378:				args_exit_error(args, "Option: %s was spsecified more than once ", argv);
    #####:  379:			args->subs[subi]->params_state[j].specified = true;
    #####:  380:			break;
        -:  381:		}
        -:  382:	}
    #####:  383:	return found;
        -:  384:}
        -:  385:
        1:  386:void args_check_validity(Args *args, int argc, char **argv) {
        -:  387:	// check if there's a sub command and check arg count
        1:  388:	char *sub = NULL;
        1:  389:	u32 arg_count = 0;
        1:  390:	u64 subi = 0;
        1:  391:	u64 sub_arg = ULONG_MAX;
        2:  392:	for (u64 i = 1; i < argc; i++) {
        1:  393:		u64 len = strlen(argv[i]);
       1*:  394:		if (len > 0 && argv[i][0] == '-') {
    #####:  395:			char name[len];
        -:  396:			bool is_short;
    #####:  397:			bool found = false;
    #####:  398:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  399:				strcpy(name, args->argv[i] + 2);
    #####:  400:				is_short = false;
        -:  401:			} else {
    #####:  402:				strcpy(name, args->argv[i] + 1);
    #####:  403:				is_short = true;
        -:  404:			}
    #####:  405:			if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  406:				i += 1;
        -:  407:			}
        -:  408:		} else {
        1:  409:			if (!sub && args->subs_count > 1) {
    #####:  410:				sub = argv[i];
    #####:  411:				sub_arg = i;
    #####:  412:				subi = args_subi_for(args, sub);
        -:  413:			} else
        1:  414:				arg_count += 1;
        -:  415:		}
        -:  416:	}
        -:  417:
        1:  418:	u64 sub_index = 0;
        -:  419:
        1:  420:	if (sub) {
        -:  421:		// there's a sub so validate it
    #####:  422:		bool valid = false;
    #####:  423:		for (u64 i = 1; i < args->subs_count; i++) {
    #####:  424:			if (!strcmp(sub, args->subs[i]->name)) {
    #####:  425:				valid = true;
    #####:  426:				if (arg_count > args->subs[i]->max_args || arg_count < args->subs[i]->min_args) {
    #####:  427:					args_exit_error(args,
        -:  428:									"Incorrect number of "
        -:  429:									"arguments for sub command '%s' "
        -:  430:									"(%i specified). "
        -:  431:									"Number of arguments must be "
        -:  432:									"between %i and %i.",
    #####:  433:									args->subs[i]->name, arg_count, args->subs[i]->min_args,
    #####:  434:									args->subs[i]->max_args);
        -:  435:				}
    #####:  436:				sub_index = i;
        -:  437:
    #####:  438:				break;
        -:  439:			}
        -:  440:		}
    #####:  441:		if (!valid) {
    #####:  442:			args_exit_error(args, "Unknown SubCommand \"%s\"", sub);
        -:  443:		}
        1:  444:	} else if (args->subs_count > 1) {
    #####:  445:		args_usage(args, NULL);
        -:  446:	} else {
        -:  447:		// check number of args
        1:  448:		if (arg_count > args->subs[0]->max_args || arg_count < args->subs[0]->min_args) {
    #####:  449:			args_exit_error(args,
        -:  450:							"Incorrect number of arguments "
        -:  451:							"(%i specified). "
        -:  452:							"Number of arguments must be "
        -:  453:							"between %i and %i.",
    #####:  454:							arg_count, args->subs[0]->min_args, args->subs[0]->max_args);
        -:  455:		}
        -:  456:	}
        -:  457:
        -:  458:	// check options
        2:  459:	for (u64 i = 1; i < argc; i++) {
        -:  460:		u64 subi;
        1:  461:		if (i <= sub_arg) {
        1:  462:			subi = 0;
        -:  463:		} else {
    #####:  464:			subi = sub_index;
        -:  465:		}
        -:  466:
        1:  467:		u64 len = strlen(argv[i]);
       1*:  468:		if (len > 0 && argv[i][0] == '-') {
        -:  469:			// option to check
    #####:  470:			char name[len];
        -:  471:			bool is_short;
    #####:  472:			bool found = false;
    #####:  473:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  474:				strcpy(name, args->argv[i] + 2);
    #####:  475:				is_short = false;
        -:  476:			} else {
    #####:  477:				strcpy(name, args->argv[i] + 1);
    #####:  478:				is_short = true;
        -:  479:			}
        -:  480:
    #####:  481:			found = args_check_option(args, subi, name, is_short, argv[i]);
    #####:  482:			if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  483:				i += 1;
        -:  484:			}
    #####:  485:			if (!found) {
    #####:  486:				if (subi == 0) {
    #####:  487:					args_exit_error(args, "Unknown option: %s", argv[i]);
        -:  488:				} else {
    #####:  489:					args_exit_error(args,
        -:  490:									"Unknown option: %s. Not valid for "
        -:  491:									"SubCommand \"%s\".",
    #####:  492:									argv[i], args->subs[subi]->name);
        -:  493:				}
        -:  494:			}
        -:  495:		}
        -:  496:	}
        1:  497:}
        -:  498:
        1:  499:int args_init(Args *args, int argc, char **argv) {
        1:  500:	args->argc = argc;
        1:  501:	args->argv = mymalloc(sizeof(char *) * argc);
        -:  502:
        1:  503:	if (args->argv == NULL) {
    #####:  504:		args->argc = 0;
    #####:  505:		return -1;
        -:  506:	}
        -:  507:
        3:  508:	for (u64 i = 0; i < argc; i++) {
        2:  509:		args->argv[i] = mymalloc(sizeof(char) * (strlen(argv[i]) + 1));
        2:  510:		if (args->argv[i]) {
        2:  511:			strcpy(args->argv[i], argv[i]);
        -:  512:		} else {
    #####:  513:			for (u64 j = i - 1; j >= 0; j--) {
    #####:  514:				myfree(args->argv[j]);
        -:  515:			}
        -:  516:			myfree(args->argv);
        -:  517:			args->argc = 0;
        -:  518:			return -1;
        -:  519:		}
        -:  520:	}
        -:  521:
        2:  522:	for (u64 i = 1; i < argc; i++) {
        1:  523:		if (!strcmp(argv[i], "--version") || !strcmp(argv[i], "-V")) {
    #####:  524:			args_print_version(args);
        -:  525:		}
        1:  526:		if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
    #####:  527:			char *sub = NULL;
    #####:  528:			for (u64 j = 1; j < i; j++) {
    #####:  529:				u64 len = strlen(argv[j]);
    #####:  530:				if (len > 0) {
    #####:  531:					if (argv[j][0] != '-') {
    #####:  532:						sub = argv[j];
    #####:  533:						break;
    #####:  534:					} else {
    #####:  535:						char name[len];
        -:  536:						bool is_short;
    #####:  537:						if (len > 1 && args->argv[j][1] == '-') {
    #####:  538:							strcpy(name, args->argv[j] + 2);
    #####:  539:							is_short = false;
        -:  540:						} else {
    #####:  541:							strcpy(name, args->argv[j] + 1);
    #####:  542:							is_short = true;
        -:  543:						}
        -:  544:
    #####:  545:						u64 subi = 0;
    #####:  546:						if (sub)
    #####:  547:							subi = args_subi_for(args, sub);
        -:  548:
    #####:  549:						if (args_sub_takes_value(args, subi, name, is_short)) {
    #####:  550:							j += 1;
        -:  551:						}
        -:  552:					}
        -:  553:				}
        -:  554:			}
    #####:  555:			args_usage(args, sub);
        -:  556:		}
        -:  557:	}
        -:  558:
        1:  559:	args_check_validity(args, argc, argv);
        -:  560:
        1:  561:	return 0;
        -:  562:}
        -:  563:
    #####:  564:int args_value_of(Args *args, char *param_name, char *value_buf, u64 max_value_len, u64 index) {
    #####:  565:	if (args == NULL || param_name == NULL) {
    #####:  566:		errno = EINVAL;
    #####:  567:		return -1;
        -:  568:	}
        -:  569:
    #####:  570:	char param_name_buf[strlen(param_name) + 3];
    #####:  571:	strcpy(param_name_buf, "--");
    #####:  572:	strcat(param_name_buf, param_name);
        -:  573:
    #####:  574:	char short_name_buf[strlen(param_name) + 3];
    #####:  575:	strcpy(short_name_buf, "-");
    #####:  576:	bool found = false;
    #####:  577:	char *default_value = NULL;
    #####:  578:	bool takes_value = false;
    #####:  579:	for (u64 i = 0; i < args->subs_count; i++) {
    #####:  580:		for (u64 j = 0; j < args->subs[i]->params_count; j++) {
    #####:  581:			if (!strcmp(args->subs[i]->params[j].name, param_name)) {
    #####:  582:				found = true;
    #####:  583:				strcat(short_name_buf, args->subs[i]->params[j].short_name);
    #####:  584:				default_value = args->subs[i]->params[j].default_value;
    #####:  585:				takes_value = args->subs[i]->params[j].takes_value;
        -:  586:			}
        -:  587:		}
        -:  588:	}
        -:  589:
    #####:  590:	if (!found) {
    #####:  591:		errno = ENOENT;
    #####:  592:		return -1;
        -:  593:	}
    #####:  594:	u64 itt_index = 0;
    #####:  595:	for (u64 i = 1; i < args->argc; i++) {
    #####:  596:		if (!strcmp(args->argv[i], param_name_buf) || !strcmp(args->argv[i], short_name_buf)) {
    #####:  597:			if (itt_index == index) {
    #####:  598:				if (takes_value && i + 1 < args->argc) {
    #####:  599:					return snprintf(value_buf, max_value_len, "%s", args->argv[i + 1]);
    #####:  600:				} else if (takes_value && max_value_len > 1) {
    #####:  601:					strcpy(value_buf, "");
    #####:  602:					return 0;
        -:  603:				} else {
    #####:  604:					return 0;
        -:  605:				}
        -:  606:			} else {
    #####:  607:				itt_index += 1;
        -:  608:			}
        -:  609:		}
        -:  610:	}
        -:  611:
    #####:  612:	if (default_value != NULL && index == 0) {
    #####:  613:		return snprintf(value_buf, max_value_len, "%s", default_value);
        -:  614:	}
        -:  615:
    #####:  616:	errno = ENOENT;
    #####:  617:	return -1;
        -:  618:}
    #####:  619:int args_get_argument(Args *args, u64 index, char *value_buf, u64 max_value_len) {
    #####:  620:	u64 index_itt = 0;
    #####:  621:	for (u64 i = 1; i < args->argc; i++) {
    #####:  622:		i32 len = strlen(args->argv[i]);
    #####:  623:		if (len > 1 && args->argv[i][0] == '-') {
    #####:  624:			char name[len];
        -:  625:			bool is_short;
    #####:  626:			bool found = false;
    #####:  627:			if (len > 1 && args->argv[i][1] == '-') {
    #####:  628:				strcpy(name, args->argv[i] + 2);
    #####:  629:				is_short = false;
        -:  630:			} else {
    #####:  631:				strcpy(name, args->argv[i] + 1);
    #####:  632:				is_short = true;
        -:  633:			}
        -:  634:
    #####:  635:			for (u64 k = 0; k < args->subs_count; k++) {
    #####:  636:				for (u64 j = 0; j < args->subs[k]->params_count; j++) {
    #####:  637:					if (is_short && !strcmp(name, args->subs[k]->params[j].short_name)) {
    #####:  638:						if (args->subs[k]->params[j].takes_value) {
    #####:  639:							i += 1;
    #####:  640:							found = true;
    #####:  641:							break;
        -:  642:						}
    #####:  643:					} else if (!strcmp(name, args->subs[k]->params[j].name)) {
    #####:  644:						if (args->subs[k]->params[j].takes_value) {
    #####:  645:							i += 1;
    #####:  646:							found = true;
    #####:  647:							break;
        -:  648:						}
        -:  649:					}
        -:  650:				}
        -:  651:			}
        -:  652:		} else {
    #####:  653:			if (index_itt == index) {
    #####:  654:				snprintf(value_buf, max_value_len, "%s", args->argv[i]);
    #####:  655:				return 1;
        -:  656:			}
    #####:  657:			index_itt += 1;
        -:  658:		}
        -:  659:	}
    #####:  660:	return 0;
        -:  661:}
        -:  662:
    #####:  663:void args_print_version(Args *args) {
    #####:  664:	char *prog = args->prog;
    #####:  665:	char *version = args->version;
    #####:  666:	fprintf(stderr, "%s%s%s %s%s%s\n", BRIGHT_RED, prog, RESET, CYAN, version, RESET);
    #####:  667:	exit(0);
        -:  668:}
        -:  669:
    #####:  670:void args_usage(Args *args, char *sub_command) {
    #####:  671:	bool found = false;
    #####:  672:	u64 subs_count = args->subs_count;
    #####:  673:	u64 sub_index = 0;
        -:  674:
    #####:  675:	if (sub_command) {
    #####:  676:		for (u64 i = 1; i < subs_count; i++) {
    #####:  677:			char *name = args->subs[i]->name;
    #####:  678:			if (!strcmp(name, sub_command)) {
    #####:  679:				sub_index = i;
    #####:  680:				found = true;
        -:  681:			}
        -:  682:		}
        -:  683:	} else // general help displayed
    #####:  684:		found = true;
        -:  685:
    #####:  686:	if (!found) {
    #####:  687:		args_exit_error(args, "Unknown SubCommand \"%s\"", sub_command);
        -:  688:	}
        -:  689:
    #####:  690:	SubCommand **subs = args->subs;
    #####:  691:	ArgsParam *params = args->subs[0]->params;
    #####:  692:	u64 count = args->subs[0]->params_count;
    #####:  693:	u64 max_len = 0;
    #####:  694:	for (u64 i = 0; i < count; i++) {
    #####:  695:		bool takes_value = args->subs[0]->params[i].takes_value;
    #####:  696:		bool multi = args->subs[0]->params[i].multiple;
    #####:  697:		char *name = args->subs[0]->params[i].name;
    #####:  698:		char *short_name = args->subs[0]->params[i].short_name;
        -:  699:		u64 len;
    #####:  700:		if (!takes_value)
    #####:  701:			len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
    #####:  702:		else if (multi)
    #####:  703:			len = snprintf(NULL, 0, "    -%s, --%s (<%s>, ...)", short_name, name, name);
        -:  704:		else
    #####:  705:			len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
    #####:  706:		if (len > max_len)
    #####:  707:			max_len = len;
        -:  708:	}
        -:  709:
    #####:  710:	max_len += 4;
        -:  711:
    #####:  712:	if (max_len < 17)
    #####:  713:		max_len = 17;
        -:  714:
    #####:  715:	char *prog = args->prog;
    #####:  716:	char *author = args->author;
    #####:  717:	char *version = args->version;
        -:  718:	char buffer[1025];
        -:  719:	char buffer2[1025];
        -:  720:	u64 i;
    #####:  721:	for (i = 0; i < max_len - 13 && i < 1024; i++)
    #####:  722:		buffer[i] = ' ';
    #####:  723:	buffer[i] = 0;
        -:  724:
    #####:  725:	for (i = 0; i < max_len - 16 && i < 1024; i++)
    #####:  726:		buffer2[i] = ' ';
    #####:  727:	buffer2[i] = 0;
        -:  728:	u64 sub_command_str_len;
    #####:  729:	if (sub_command)
    #####:  730:		sub_command_str_len = strlen(sub_command);
        -:  731:	else
    #####:  732:		sub_command_str_len = 0;
    #####:  733:	char sub_command_str[sub_command_str_len + 30];
    #####:  734:	char *sub_arg_doc_str = "";
    #####:  735:	if (sub_command) {
    #####:  736:		snprintf(sub_command_str, sub_command_str_len + 30, "%s%s%s", BRIGHT_RED, sub_command,
        -:  737:				 RESET);
    #####:  738:		sub_arg_doc_str = args->subs[sub_index]->arg_doc;
        -:  739:	} else {
    #####:  740:		snprintf(sub_command_str, sub_command_str_len + 30, "[%sSUB_COMMAND%s]", DIMMED, RESET);
        -:  741:	}
        -:  742:
    #####:  743:	fprintf(stderr,
        -:  744:			"%s%s%s %s%s%s\n%s%s%s\n\n%sUSAGE%s:\n    %s%s%s "
        -:  745:			"[%sCORE_OPTIONS%s] %s [%sSUB_OPTIONS%s] %s\n\n"
        -:  746:			"%sCORE_FLAGS%s:\n"
        -:  747:			"    %s-h%s, %s--help%s%sPrints help information\n"
        -:  748:			"    %s-V%s, %s--version%s%sPrints version "
        -:  749:			"information\n",
        -:  750:			CYAN, prog, RESET, YELLOW, version, RESET, GREEN, author, RESET, DIMMED, RESET,
        -:  751:			BRIGHT_RED, prog, RESET, DIMMED, RESET, sub_command_str, DIMMED, RESET, sub_arg_doc_str,
        -:  752:			DIMMED, RESET, CYAN, RESET, YELLOW, RESET, buffer, CYAN, RESET, YELLOW, RESET, buffer2);
        -:  753:
    #####:  754:	for (u64 i = 0; i < count; i++) {
    #####:  755:		bool takes_value = params[i].takes_value;
    #####:  756:		if (!takes_value) {
    #####:  757:			char *name = params[i].name;
    #####:  758:			char *short_name = params[i].short_name;
    #####:  759:			char *help = params[i].help;
    #####:  760:			u64 len = snprintf(NULL, 0, "    -%s, --%s", short_name, name);
    #####:  761:			if (len > max_len)
    #####:  762:				len = max_len;
        -:  763:			u64 i;
    #####:  764:			for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  765:				buffer[i] = ' ';
    #####:  766:			buffer[i] = 0;
    #####:  767:			fprintf(stderr, "    %s-%s%s, %s--%s%s %s%s\n", CYAN, short_name, RESET, YELLOW, name,
        -:  768:					RESET, buffer, help);
        -:  769:		}
        -:  770:	}
        -:  771:
    #####:  772:	if (count) {
    #####:  773:		fprintf(stderr, "\n%sCORE_OPTIONS%s:\n", DIMMED, RESET);
        -:  774:
    #####:  775:		for (u64 i = 0; i < count; i++) {
    #####:  776:			bool takes_value = params[i].takes_value;
    #####:  777:			if (takes_value) {
    #####:  778:				char *name = params[i].name;
    #####:  779:				char *short_name = params[i].short_name;
    #####:  780:				char *help = params[i].help;
    #####:  781:				bool multi = params[i].multiple;
    #####:  782:				char *default_value = params[i].default_value;
        -:  783:				u64 default_value_str_len;
    #####:  784:				if (default_value == NULL) {
    #####:  785:					default_value_str_len = 1;
        -:  786:				} else {
    #####:  787:					default_value_str_len = strlen(default_value) + 100;
        -:  788:				}
    #####:  789:				char default_value_str[default_value_str_len];
    #####:  790:				if (default_value == NULL)
    #####:  791:					strcpy(default_value_str, "");
        -:  792:				else
    #####:  793:					snprintf(default_value_str, default_value_str_len, " (default value: '%s')",
        -:  794:							 default_value);
        -:  795:
    #####:  796:				if (multi) {
    #####:  797:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>, ...", short_name, name, name);
    #####:  798:					if (len > max_len)
    #####:  799:						len = max_len;
        -:  800:					u64 i;
    #####:  801:					for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  802:						buffer[i] = ' ';
    #####:  803:					buffer[i] = 0;
    #####:  804:					fprintf(stderr,
        -:  805:							"    %s-%s%s, %s--%s%s "
        -:  806:							"<%s>, "
        -:  807:							"... %s%s%s\n",
        -:  808:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  809:							default_value_str);
        -:  810:				} else {
        -:  811:
    #####:  812:					u64 len = snprintf(NULL, 0, "    -%s, --%s <%s>", short_name, name, name);
    #####:  813:					if (len > max_len)
    #####:  814:						len = max_len;
        -:  815:					u64 i;
    #####:  816:					for (i = 0; i < max_len - len && i < 1024; i++)
    #####:  817:						buffer[i] = ' ';
    #####:  818:					buffer[i] = 0;
        -:  819:
    #####:  820:					fprintf(stderr,
        -:  821:							"    %s-%s%s, %s--%s%s "
        -:  822:							"<%s> "
        -:  823:							"%s%s%s\n",
        -:  824:							CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  825:							default_value_str);
        -:  826:				}
        -:  827:			}
        -:  828:		}
        -:  829:	}
        -:  830:
    #####:  831:	if (subs_count > 1 && sub_command == NULL) {
    #####:  832:		fprintf(stderr, "\n%sSUB_COMMANDS%s:\n", DIMMED, RESET);
    #####:  833:		for (u64 i = 1; i < subs_count; i++) {
        -:  834:
    #####:  835:			char *name = args->subs[i]->name;
    #####:  836:			char *help = args->subs[i]->help;
    #####:  837:			char *arg_doc = args->subs[i]->arg_doc;
        -:  838:
    #####:  839:			u64 len = strlen(name) + strlen(arg_doc) + 4;
    #####:  840:			if (len > max_len)
    #####:  841:				len = max_len;
        -:  842:			char buffer[1025];
        -:  843:			u64 j;
    #####:  844:			for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  845:				buffer[j] = ' ';
    #####:  846:			buffer[j] = 0;
        -:  847:
    #####:  848:			fprintf(stderr, "    %s%s%s %s%s%s\n", CYAN, name, RESET, arg_doc, buffer, help);
        -:  849:		}
        -:  850:	}
        -:  851:
    #####:  852:	if (sub_command) {
    #####:  853:		u64 param_index = 0;
    #####:  854:		for (u64 i = 1; i < subs_count; i++) {
    #####:  855:			char *name = args->subs[i]->name;
    #####:  856:			if (!strcmp(name, sub_command)) {
    #####:  857:				param_index = i;
        -:  858:			}
        -:  859:		}
        -:  860:
    #####:  861:		if (param_index > 0) {
    #####:  862:			params = args->subs[param_index]->params;
        -:  863:
    #####:  864:			count = args->subs[param_index]->params_count;
    #####:  865:			fprintf(stderr, "\n%sSUB_FLAGS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -:  866:					RESET);
        -:  867:
    #####:  868:			for (u64 i = 0; i < count; i++) {
    #####:  869:				char *name = params[i].name;
    #####:  870:				char *short_name = params[i].short_name;
    #####:  871:				bool takes_value = params[i].takes_value;
    #####:  872:				char *help = params[i].help;
        -:  873:
    #####:  874:				if (!takes_value) {
    #####:  875:					u64 len = strlen(name) + 10;
    #####:  876:					if (len > max_len)
    #####:  877:						len = max_len;
        -:  878:					char buffer[1025];
        -:  879:					u64 j;
    #####:  880:					for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  881:						buffer[j] = ' ';
    #####:  882:					buffer[j] = 0;
    #####:  883:					fprintf(stderr,
        -:  884:							"    %s-%s%s, "
        -:  885:							"%s--%s%s%s %s\n",
        -:  886:							CYAN, short_name, RESET, YELLOW, name, RESET, buffer, help);
        -:  887:				}
        -:  888:			}
    #####:  889:			fprintf(stderr, "\n%sSUB_OPTIONS%s (%s%s%s):\n", DIMMED, RESET, BRIGHT_RED, sub_command,
        -:  890:					RESET);
    #####:  891:			for (u64 i = 0; i < count; i++) {
    #####:  892:				char *name = params[i].name;
    #####:  893:				char *short_name = params[i].short_name;
    #####:  894:				bool takes_value = params[i].takes_value;
    #####:  895:				char *help = params[i].help;
    #####:  896:				bool multiple = params[i].multiple;
        -:  897:
    #####:  898:				char *default_value = params[i].default_value;
        -:  899:				u64 default_value_str_len;
    #####:  900:				if (default_value == NULL) {
    #####:  901:					default_value_str_len = 1;
        -:  902:				} else {
    #####:  903:					default_value_str_len = strlen(default_value) + 100;
        -:  904:				}
    #####:  905:				char default_value_str[default_value_str_len];
    #####:  906:				if (default_value == NULL)
    #####:  907:					strcpy(default_value_str, "");
        -:  908:				else
    #####:  909:					snprintf(default_value_str, default_value_str_len, " (default value: %s)",
        -:  910:							 default_value);
        -:  911:
    #####:  912:				if (takes_value) {
    #####:  913:					if (multiple) {
    #####:  914:						u64 len = 2 * strlen(name) + 19;
        -:  915:						char buffer[1025];
        -:  916:						u64 j;
    #####:  917:						if (len > max_len)
    #####:  918:							len = max_len;
    #####:  919:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  920:							buffer[j] = ' ';
    #####:  921:						buffer[j] = 0;
    #####:  922:						fprintf(stderr,
        -:  923:								"    %s-%s%s, "
        -:  924:								"%s--%s%s "
        -:  925:								"<%s>, ...%s %s"
        -:  926:								"%s\n",
        -:  927:								CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  928:								default_value_str);
        -:  929:					} else {
    #####:  930:						u64 len = 2 * strlen(name) + 13;
        -:  931:						char buffer[1025];
        -:  932:						u64 j;
    #####:  933:						if (len > max_len)
    #####:  934:							len = max_len;
    #####:  935:						for (j = 0; j < (max_len - len) && j < 1024; j++)
    #####:  936:							buffer[j] = ' ';
    #####:  937:						buffer[j] = 0;
    #####:  938:						fprintf(stderr,
        -:  939:								"    %s-%s%s, "
        -:  940:								"%s--%s%s "
        -:  941:								"<%s>%s "
        -:  942:								"%s%s\n",
        -:  943:								CYAN, short_name, RESET, YELLOW, name, RESET, name, buffer, help,
        -:  944:								default_value_str);
        -:  945:					}
        -:  946:				}
        -:  947:			}
        -:  948:		}
        -:  949:	}
        -:  950:
    #####:  951:	exit(0);
        -:  952:}
        -:    0:Source:bible.c
        -:    0:Graph:bible.gcno
        -:    0:Data:bible.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <bible/bible.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:
        2:   21:int bible_checksum(char *data) {
        -:   22:	char sha[65];
        2:   23:	SHA256(data, sha);
        -:   24:
        -:   25:	// sha 256 checksum of the akjv bible from
        -:   26:	// https://github.com/bible-hub/Bibles/blob/master/English__American_King_James_Version__akjv__LTR.txt
        2:   27:	if (strcmp(sha, "9fac349223681483dd1d225cd04a298cef93f3efeb21b562469a1a"
        -:   28:					"8efa7069ff")) {
    #####:   29:		errno = EPERM;
    #####:   30:		return -1;
        -:   31:	}
        2:   32:	return 0;
        -:   33:}
        -:   34:
    62204:   35:int bible_parse_verse(Bible *bible, u64 index, char *buf) {
    62204:   36:	const char *strstr_res = strstr(buf, "|");
    62204:   37:	if (strstr_res == NULL) {
    #####:   38:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   39:		errno = EINVAL;
    #####:   40:		return -1;
        -:   41:	}
    62204:   42:	int end_book = strstr_res - buf;
    62204:   43:	if (end_book < 0) {
    #####:   44:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   45:		errno = EINVAL;
    #####:   46:		return -1;
        -:   47:	}
    62204:   48:	char bookname[end_book + 1];
    62204:   49:	memcpy(bookname, buf, end_book);
    62204:   50:	bookname[end_book] = 0;
        -:   51:
    62204:   52:	int start_chapter = end_book + 2;
    62204:   53:	const char *end_chapter_str = strstr(buf + start_chapter, "|");
    62204:   54:	if (end_chapter_str == NULL) {
    #####:   55:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   56:		errno = EINVAL;
    #####:   57:		return -1;
        -:   58:	}
    62204:   59:	int end_chapter = end_chapter_str - buf;
    62204:   60:	if (end_chapter < start_chapter) {
    #####:   61:		fprintf(stderr, "invalid line %s, index=%" PRIu64 ", end_chapter=%i,start_chap=%i\n", buf,
        -:   62:				index, end_chapter, start_chapter);
    #####:   63:		errno = EINVAL;
    #####:   64:		return -1;
        -:   65:	}
        -:   66:
    62204:   67:	char chapter[(end_chapter - start_chapter) + 1];
    62204:   68:	memcpy(chapter, buf + start_chapter, end_chapter - start_chapter);
    62204:   69:	chapter[end_chapter - start_chapter] = 0;
        -:   70:
    62204:   71:	int start_verse = end_chapter + 2;
    62204:   72:	const char *end_verse_str = strstr(buf + start_verse, "|");
    62204:   73:	if (end_verse_str == NULL) {
    #####:   74:		fprintf(stderr, "invalid line %s, index=%" PRIu64 "\n", buf, index);
    #####:   75:		errno = EINVAL;
    #####:   76:		return -1;
        -:   77:	}
    62204:   78:	int end_verse = end_verse_str - buf;
        -:   79:
    62204:   80:	if (end_verse < start_verse) {
    #####:   81:		fprintf(stderr, "invalid line %s, index=%" PRIu64 ", end_chapter=%i,start_chap=%i\n", buf,
        -:   82:				index, end_verse, start_verse);
    #####:   83:		errno = EINVAL;
    #####:   84:		return -1;
        -:   85:	}
        -:   86:
    62204:   87:	char verse[(end_verse - start_verse) + 1];
    62204:   88:	memcpy(verse, buf + start_verse, end_verse - start_verse);
    62204:   89:	verse[end_verse - start_verse] = 0;
        -:   90:
    62204:   91:	int start_text = end_verse + 2;
        -:   92:
        -:   93:	int end_text;
    62204:   94:	const char *end_text_res = strstr(buf, "\n");
    62204:   95:	if (end_text_res == NULL) {
        -:   96:		// last line has no newline so just use entire line here
        2:   97:		end_text = strlen(buf);
        -:   98:	} else
    62202:   99:		end_text = end_text_res - buf;
        -:  100:
    62204:  101:	char text[(end_text - start_text) + 1];
    62204:  102:	memcpy(text, buf + start_text, end_text - start_text);
    62204:  103:	text[end_text - start_text] = 0;
        -:  104:
    62204:  105:	bible->verses[index].text = mymalloc(sizeof(char) * (end_text - start_text) + 1);
    62204:  106:	strcpy(bible->verses[index].text, text);
    62204:  107:	bible->verses[index].chapter_id = strtol(chapter, NULL, 10);
    62204:  108:	bible->verses[index].verse_id = strtol(verse, NULL, 10);
        -:  109:
        -:  110:	// find book
    62204:  111:	if (bible->book_id_count == 0) {
        -:  112:		// first book
        2:  113:		bible->book_ids = mymalloc(sizeof(BibleBookIdMap));
        2:  114:		bible->book_ids[0].book_id = 0;
        2:  115:		bible->book_ids[0].name = mymalloc(sizeof(char) * (strlen(bookname) + 1));
        2:  116:		strcpy(bible->book_ids[0].name, bookname);
        2:  117:		bible->book_id_count += 1;
        2:  118:		bible->verses[index].book_id = 0;
        -:  119:	} else {
    62202:  120:		char *cur_book = bible->book_ids[bible->book_id_count - 1].name;
        -:  121:		// check for new book
    62202:  122:		if (!strcmp(cur_book, bookname)) {
        -:  123:			// we're still in the same book
    62072:  124:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count - 1].book_id;
        -:  125:		} else {
        -:  126:			// new book, update book ids
      130:  127:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count - 1].book_id + 1;
        -:  128:			void *tmp =
      130:  129:				myrealloc(bible->book_ids, sizeof(BibleBookIdMap) * (bible->book_id_count + 1));
      130:  130:			if (!tmp)
    #####:  131:				return -1;
      130:  132:			bible->book_ids = tmp;
        -:  133:			// next higher book id
      130:  134:			bible->book_ids[bible->book_id_count].book_id =
      130:  135:				bible->book_ids[bible->book_id_count - 1].book_id + 1;
      260:  136:			bible->book_ids[bible->book_id_count].name =
      130:  137:				mymalloc(sizeof(char) * (strlen(bookname) + 1));
      130:  138:			strcpy(bible->book_ids[bible->book_id_count].name, bookname);
      130:  139:			bible->verses[index].book_id = bible->book_ids[bible->book_id_count].book_id;
      130:  140:			bible->book_id_count += 1;
        -:  141:		}
        -:  142:	}
        -:  143:
    62204:  144:	return 0;
        -:  145:}
        -:  146:
      620:  147:int bible_book_id_map_compare(const void *a, const void *b) {
      620:  148:	return strcmp(((BibleBookIdMap *)a)->name, ((BibleBookIdMap *)b)->name);
        -:  149:}
        -:  150:
        2:  151:int bible_build(Bible *bible, char *path) {
        2:  152:	FILE *fp = myfopen(path, "r");
        2:  153:	if (fp == NULL) {
    #####:  154:		return -1;
        -:  155:	}
        -:  156:
        -:  157:	char bible_check[BIBLE_CHECKSUM_SCAN_BUF_SIZE];
        2:  158:	int len = fread(bible_check, sizeof(*bible_check), BIBLE_CHECKSUM_SCAN_BUF_SIZE, fp);
        2:  159:	bible_check[len] = 0;
        -:  160:
        2:  161:	if (bible_checksum(bible_check))
    #####:  162:		return -1;
        -:  163:
        2:  164:	fseek(fp, 0, SEEK_SET);
        -:  165:
        -:  166:	char buf[VERSE_BUF_LEN];
        -:  167:
        2:  168:	bible->verses = NULL;
        2:  169:	bible->verse_count = 0;
        2:  170:	bible->book_ids = NULL;
        2:  171:	bible->book_id_count = 0;
        -:  172:
        2:  173:	int max_len = 0;
    62216:  174:	while (fgets(buf, VERSE_BUF_LEN, fp)) {
    62214:  175:		if (strlen(buf) > max_len)
       36:  176:			max_len = strlen(buf);
    62214:  177:		if (bible->verse_count == 0) {
        2:  178:			bible->verses = mymalloc(sizeof(BibleVerse));
        2:  179:			if (bible->verses == NULL)
    #####:  180:				return -1;
        -:  181:		} else {
    62212:  182:			void *tmp = myrealloc(bible->verses, sizeof(BibleVerse) * (bible->verse_count + 1));
    62212:  183:			if (tmp == NULL)
    #####:  184:				return -1;
    62212:  185:			bible->verses = tmp;
        -:  186:		}
    62214:  187:		const char *strstr_res = strstr(buf, "|");
    62214:  188:		if (strstr_res == NULL) {
        -:  189:			// there is an empty line in the file. Skip it.
       10:  190:			continue;
        -:  191:		}
    62204:  192:		int end_book = strstr_res - buf;
    62204:  193:		if (bible_parse_verse(bible, bible->verse_count, buf))
    #####:  194:			return -1;
    62204:  195:		bible->verse_count += 1;
        -:  196:	}
        -:  197:
        -:  198:	// sort the books for quicker lookups
        2:  199:	bible->book_ids_sorted = mymalloc(sizeof(BibleVerse) * (bible->verse_count));
        2:  200:	if (bible->book_ids_sorted == NULL)
    #####:  201:		return -1;
        2:  202:	memcpy(bible->book_ids_sorted, bible->book_ids, bible->book_id_count * sizeof(BibleBookIdMap));
        2:  203:	qsort(bible->book_ids_sorted, bible->book_id_count, sizeof(BibleBookIdMap),
        -:  204:		  bible_book_id_map_compare);
        -:  205:
        2:  206:	myfclose(fp);
        2:  207:	return 0;
        -:  208:}
        -:  209:
        2:  210:void bible_cleanup(Bible *bible) {
    62206:  211:	for (int i = 0; i < bible->verse_count; i++)
    62204:  212:		myfree(bible->verses[i].text);
      134:  213:	for (int i = 0; i < bible->book_id_count; i++)
      132:  214:		myfree(bible->book_ids[i].name);
        2:  215:	myfree(bible->verses);
        2:  216:	myfree(bible->book_ids);
        2:  217:	myfree(bible->book_ids_sorted);
        2:  218:}
        -:  219:
    31102:  220:int format_verse(Bible *bible, int index, char *buf, int buf_len, bool colors) {
        -:  221:
    31102:  222:	if (colors)
    #####:  223:		return snprintf(buf, buf_len, "[%s%s%s:%s%i:%i%s] %s%s%s", GREEN,
    #####:  224:						bible->book_ids[bible->verses[index].book_id].name, RESET, CYAN,
    #####:  225:						bible->verses[index].chapter_id, bible->verses[index].verse_id, RESET,
    #####:  226:						YELLOW, bible->verses[index].text, RESET);
        -:  227:	else
    31102:  228:		return snprintf(buf, buf_len, "[%s:%i:%i] %s",
    31102:  229:						bible->book_ids[bible->verses[index].book_id].name,
    31102:  230:						bible->verses[index].chapter_id, bible->verses[index].verse_id,
    31102:  231:						bible->verses[index].text);
        -:  232:}
        -:  233:
    32350:  234:int bible_book_index(Bible *bible, char *book) {
        -:  235:	// use binary search to find the book
        -:  236:	int index;
    32350:  237:	int min = 0;
    32350:  238:	int max = bible->book_id_count - 1;
        -:  239:	int book_id;
   132081:  240:	while (true) {
   164431:  241:		if (max < min) {
    #####:  242:			errno = EINVAL;
    #####:  243:			return -1;
        -:  244:		}
   164431:  245:		index = min + ((max - min) / 2);
   164431:  246:		int strcmp_res = strcmp(book, bible->book_ids_sorted[index].name);
   164431:  247:		if (strcmp_res == 0) {
    32350:  248:			book_id = bible->book_ids_sorted[index].book_id;
    32350:  249:			break;
   132081:  250:		} else if (strcmp_res < 0) {
    65983:  251:			max = index - 1;
        -:  252:		} else {
    66098:  253:			min = index + 1;
        -:  254:		}
        -:  255:	}
    32350:  256:	return book_id;
        -:  257:}
        -:  258:
    32351:  259:int bible_verse_to_string(Bible *bible, char *book, u8 chapter, u8 verse, char *buf, int buf_len,
        -:  260:						  bool colors) {
    32351:  261:	if (book == NULL || strlen(book) == 0) {
        1:  262:		errno = EINVAL;
        1:  263:		return -1;
        -:  264:	}
    32350:  265:	return bible_random_verse_to_string(bible, buf, buf_len, colors, book, &chapter, &verse);
        -:  266:}
        -:  267:
    32350:  268:int bible_random_verse_to_string(Bible *bible, char *buf, int buf_len, bool colors,
        -:  269:								 char *optional_book, u8 *optional_chapter, u8 *optional_verse) {
        -:  270:	u16 r;
    32350:  271:	if (rand_u16(&r))
    #####:  272:		return -1;
        -:  273:
    32350:  274:	if (optional_book && strlen(optional_book) > 0) {
    32350:  275:		int book_id = bible_book_index(bible, optional_book);
    32350:  276:		if (book_id < 0)
    #####:  277:			return -1;
        -:  278:
        -:  279:		int index;
    32350:  280:		int min = 0;
    32350:  281:		int max = bible->verse_count;
        -:  282:
        -:  283:		// use binary search to find the verse
        -:  284:
        -:  285:		while (true) {
   140658:  286:			if (max < min) {
    #####:  287:				errno = EINVAL;
    #####:  288:				return -1;
        -:  289:			}
   140658:  290:			index = min + ((max - min) / 2);
   140658:  291:			if (book_id == bible->verses[index].book_id) {
    32350:  292:				min = index;
    32350:  293:				max = index;
 15912881:  294:				while (min - 1 >= 0 && bible->verses[min - 1].book_id == book_id)
 15880531:  295:					min--;
 16589666:  296:				while (max + 1 < bible->verse_count && bible->verses[max + 1].book_id == book_id)
 16557316:  297:					max++;
    32350:  298:				break;
   108308:  299:			} else if (book_id < bible->verses[index].book_id) {
    54604:  300:				max = index - 1;
        -:  301:			} else {
    53704:  302:				min = index + 1;
        -:  303:			}
        -:  304:		}
        -:  305:
    32350:  306:		if (optional_chapter) {
    32350:  307:			u8 target_chapter = *optional_chapter;
        -:  308:			while (true) {
   133500:  309:				if (max < min) {
       65:  310:					errno = EINVAL;
       65:  311:					return -1;
        -:  312:				}
   133435:  313:				index = min + ((max - min) / 2);
   133435:  314:				if (target_chapter == bible->verses[index].chapter_id) {
    32285:  315:					min = index;
    32285:  316:					max = index;
   527723:  317:					while (min - 1 >= 0 && bible->verses[min - 1].chapter_id == target_chapter &&
   495531:  318:						   bible->verses[min - 1].book_id == book_id)
   495438:  319:						min--;
    32285:  320:					while (max + 1 < bible->verse_count &&
   564609:  321:						   bible->verses[max + 1].chapter_id == target_chapter &&
   532422:  322:						   bible->verses[max + 1].book_id == book_id)
   532324:  323:						max++;
        -:  324:
    32285:  325:					if (optional_verse) {
    32285:  326:						u8 target_verse = *optional_verse;
    32285:  327:						if (target_verse > (1 + max) - min) {
     1183:  328:							errno = EINVAL;
     1183:  329:							return -1;
        -:  330:						}
    31102:  331:						min += target_verse - 1;
    31102:  332:						max = min + 2;
        -:  333:					}
    31102:  334:					break;
   101150:  335:				} else if (target_chapter < bible->verses[index].chapter_id) {
    50430:  336:					max = index - 1;
        -:  337:				} else {
    50720:  338:					min = index + 1;
        -:  339:				}
        -:  340:			}
        -:  341:		}
        -:  342:
    31102:  343:		r %= ((max - 1) - min);
    31102:  344:		r += (min);
        -:  345:	} else
    #####:  346:		r %= bible->verse_count;
    31102:  347:	return format_verse(bible, r, buf, buf_len, colors);
        -:  348:}
