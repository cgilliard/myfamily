        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/os.h>
        -:   17:
    #####:   18:byte *get_dimmed() {
    #####:   19:	if (env("NO_COLOR") != NULL) {
    #####:   20:		return "";
        -:   21:	} else {
    #####:   22:		return "\x1b[2m";
        -:   23:	}
        -:   24:}
        -:   25:
    #####:   26:byte *get_red() {
    #####:   27:	if (env("NO_COLOR") != NULL) {
    #####:   28:		return "";
        -:   29:	} else {
    #####:   30:		return "\x1b[31m";
        -:   31:	}
        -:   32:}
        -:   33:
    #####:   34:byte *get_bright_red() {
    #####:   35:	if (env("NO_COLOR") != NULL) {
    #####:   36:		return "";
        -:   37:	} else {
    #####:   38:		return "\x1b[91m";
        -:   39:	}
        -:   40:}
        -:   41:
    #####:   42:byte *get_green() {
    #####:   43:	if (env("NO_COLOR") != NULL) {
    #####:   44:		return "";
        -:   45:	} else {
    #####:   46:		return "\x1b[32m";
        -:   47:	}
        -:   48:}
        -:   49:
    #####:   50:byte *get_yellow() {
    #####:   51:	if (env("NO_COLOR") != NULL) {
    #####:   52:		return "";
        -:   53:	} else {
    #####:   54:		return "\x1b[33m";
        -:   55:	}
        -:   56:}
        -:   57:
    #####:   58:byte *get_cyan() {
    #####:   59:	if (env("NO_COLOR") != NULL) {
    #####:   60:		return "";
        -:   61:	} else {
    #####:   62:		return "\x1b[36m";
        -:   63:	}
        -:   64:}
        -:   65:
    #####:   66:byte *get_magenta() {
    #####:   67:	if (env("NO_COLOR") != NULL) {
    #####:   68:		return "";
        -:   69:	} else {
    #####:   70:		return "\x1b[35m";
        -:   71:	}
        -:   72:}
        -:   73:
    #####:   74:byte *get_blue() {
    #####:   75:	if (env("NO_COLOR") != NULL) {
    #####:   76:		return "";
        -:   77:	} else {
    #####:   78:		return "\x1b[34m";
        -:   79:	}
        -:   80:}
        -:   81:
    #####:   82:byte *get_reset() {
    #####:   83:	if (env("NO_COLOR") != NULL) {
    #####:   84:		return "";
        -:   85:	} else {
    #####:   86:		return "\x1b[0m";
        -:   87:	}
        -:   88:}
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/macro_util.h>
        -:   17:#include <base/os.h>
        -:   18:// #include <base/print_util.h>
        -:   19:#include <base/string.h>
        -:   20:
        -:   21:_Thread_local byte fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local int64 fam_err = NoErrors;
        -:   24://_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const byte *get_err() {
        -:   27:	// return strncpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
    #####:   28:	return NULL;
        -:   29:}
        -:   30:
    #####:   31:void print_err(const byte *text) {
        -:   32:	// println("{}: {}", FamErrText[fam_err], text);
        -:   33:	// backtrace_print(&thread_local_bt__);
    #####:   34:}
        -:   35:
        -:   36:// void do_backtrace_generate(Backtrace *bt) {
        -:   37:// if (env("CBACKTRACE") != NULL) {
        -:   38://  backtrace_generate(bt);
        -:   39://	}
        -:   40://}
        -:    0:Source:os.c
        -:    0:Graph:os.gcno
        -:    0:Data:os.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/osdef.h>
        -:   18:
        -:   19:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   20:
       38:   21:void *alloc(int64 size, int64 zeroed) {
       38:   22:	if (!size) {
    #####:   23:		SetErr(IllegalArgument);
    #####:   24:		return NULL;
        -:   25:	}
        -:   26:	void *ret;
       38:   27:	ret = malloc(size);
        -:   28:
       38:   29:	if (ret) {
       38:   30:		THREAD_LOCAL_RESOURCE_STATS.alloc_sum += 1;
       38:   31:		if (zeroed)
    #####:   32:			memset(ret, 0, size);
        -:   33:	} else
    #####:   34:		SetErr(AllocErr);
        -:   35:
       38:   36:	return ret;
        -:   37:}
        5:   38:void *resize(void *ptr, int64 size) {
        5:   39:	if (!ptr || !size) {
    #####:   40:		SetErr(IllegalArgument);
    #####:   41:		return NULL;
        -:   42:	}
        -:   43:	void *ret;
        5:   44:	ret = realloc(ptr, size);
        -:   45:
        5:   46:	if (ret) {
        5:   47:		THREAD_LOCAL_RESOURCE_STATS.resize_sum += 1;
        -:   48:	} else
    #####:   49:		SetErr(AllocErr);
        5:   50:	return ret;
        -:   51:}
        -:   52:
       37:   53:void release(void *ptr) {
       37:   54:	if (!ptr) {
    #####:   55:		SetErr(IllegalArgument);
    #####:   56:		return;
        -:   57:	}
       37:   58:	THREAD_LOCAL_RESOURCE_STATS.release_sum += 1;
       37:   59:	free(ptr);
        -:   60:}
        -:   61:
        4:   62:int64 alloc_sum() {
        4:   63:	return THREAD_LOCAL_RESOURCE_STATS.alloc_sum;
        -:   64:}
    #####:   65:int64 resize_sum() {
    #####:   66:	return THREAD_LOCAL_RESOURCE_STATS.resize_sum;
        -:   67:}
        4:   68:int64 release_sum() {
        4:   69:	return THREAD_LOCAL_RESOURCE_STATS.release_sum;
        -:   70:}
        -:   71:
        -:   72:char *getenv(const char *name);
        -:   73:
    #####:   74:byte *env(const byte *name) {
    #####:   75:	return getenv(name);
        -:   76:}
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/os.h>
        -:   16:#include <base/slabs.h>
        -:   17:
        -:   18:typedef struct PtrImpl {
        -:   19:	int64 id;	 // slab id
        -:   20:	int64 len;	 // length of data in this slab
        -:   21:	byte data[]; // user data
        -:   22:} PtrImpl;
        -:   23:
        -:   24://  returns the slab's length
        2:   25:int ptr_len(const Ptr ptr) {
        2:   26:	return ptr->len;
        -:   27:}
        -:   28:
        -:   29:// returns the slabs id
        2:   30:int64 ptr_id(const Ptr ptr) {
        -:   31:	// mask off flag byte (top byte)
        2:   32:	return ptr->id & 0x00FFFFFFFFFFFFFFULL;
        -:   33:}
        -:   34:
        -:   35:// reutrn pointer to slab data
    #####:   36:void *ptr_data(const Ptr ptr) {
    #####:   37:	return ptr->data;
        -:   38:}
        -:   39:
        -:   40:// check whether a flag is set (0-7 are possible values)
      115:   41:bool ptr_flag_check(const Ptr ptr, byte flag) {
      115:   42:	return flag < 8 && ((int64)(ptr->id >> 56)) & (1ULL << flag);
        -:   43:}
        -:   44:
        -:   45:// set/unset a flag
        1:   46:void ptr_flag_set(const Ptr ptr, byte flag, bool value) {
        1:   47:	if (flag >= 8)
    #####:   48:		return;
        1:   49:	if (value)
        1:   50:		ptr->id |= (int64)(1ULL << (int64)flag) << 56;
        -:   51:	else
    #####:   52:		ptr->id &= ~((int64)(1ULL << (int64)flag) << 56);
        -:   53:}
        -:   54:
        -:   55:// return true if this Ptr is nil (unallocated)
    #####:   56:bool ptr_is_nil(const Ptr ptr) {
    #####:   57:	return ptr->len; // a nil pointer has 0 len
        -:   58:}
        -:   59:
        1:   60:void slab_allocator_config_cleanup(SlabAllocatorConfigNc *ptr) {
        1:   61:}
        -:   62:
        -:   63:typedef struct SlabAllocatorImpl {
        -:   64:	int x;
        -:   65:	int y;
        -:   66:	byte slabs[];
        -:   67:} SlabAllocatorImpl;
        -:   68:
        1:   69:void slab_allocator_cleanup(SlabAllocator *ptr) {
        1:   70:	SlabAllocatorNc sa = *ptr;
        1:   71:}
        -:   72:
        1:   73:SlabAllocator slab_allocator_create(SlabAllocatorConfig *sc) {
        1:   74:	SlabAllocatorNc ret = (SlabAllocatorImpl *)alloc(sizeof(SlabAllocatorImpl) + 3, false);
        1:   75:	return ret;
        -:   76:}
        -:   77:
        1:   78:void slab_allocator_print(SlabAllocator ptr) {
        1:   79:}
        -:   80:
        -:   81:#ifdef TEST
        1:   82:Ptr ptr_test_obj(int id, int len, byte flags) {
        1:   83:	Ptr ptr = (PtrImpl *)alloc(sizeof(PtrImpl) + len, false);
        1:   84:	ptr->id = id;
        1:   85:	ptr->len = len;
        1:   86:	ptr->id |= ((int64)flags) << 56;
        1:   87:	return ptr;
        -:   88:}
        -:   89:
        1:   90:void ptr_free_test_obj(Ptr ptr) {
        1:   91:	release(ptr);
        1:   92:}
        -:   93:#endif // TEST
        -:    0:Source:string.c
        -:    0:Graph:string.gcno
        -:    0:Data:string.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/os.h>
        -:   17:#include <base/osdef.h>
        -:   18:#include <base/string.h>
        -:   19:
        -:   20:typedef struct stringImpl {
        -:   21:	int64 len;
        -:   22:	byte data[];
        -:   23:} stringImpl;
        -:   24:
       26:   25:int64 cstring_len(const byte *S) {
       26:   26:	int64 ret = 0;
      192:   27:	while (*S != '\0') {
      166:   28:		S++;
      166:   29:		ret++;
        -:   30:	}
       26:   31:	return ret;
        -:   32:}
        -:   33:
       41:   34:void string_cleanup(stringNc *ptr) {
       41:   35:	if (ptr == NULL || ptr->impl == NULL)
        5:   36:		return;
       36:   37:	release(ptr->impl);
       36:   38:	ptr->impl = NULL;
        -:   39:}
        -:   40:
        1:   41:int64 string_create(string *s) {
        1:   42:	return string_create_cs(s, "");
        -:   43:}
        -:   44:
       25:   45:int64 string_create_cs(string *s, const char *s2) {
       25:   46:	if (s2 == NULL) {
    #####:   47:		SetErr(IllegalArgument);
    #####:   48:		return -1;
        -:   49:	}
       25:   50:	return string_create_ch(s, s2, cstring_len(s2));
        -:   51:}
        -:   52:
       36:   53:int64 string_create_ch(string *s, const byte *s2, int64 len) {
       36:   54:	if (s == NULL || s2 == NULL || len < 0) {
    #####:   55:		SetErr(IllegalArgument);
    #####:   56:		return -1;
        -:   57:	}
        -:   58:
       36:   59:	s->impl = alloc(1 + len + sizeof(stringImpl), false);
       36:   60:	if (s->impl == NULL)
    #####:   61:		return -1;
       36:   62:	stringImpl *si = s->impl;
       36:   63:	si->len = len;
       36:   64:	memcpy(si->data, s2, len);
       36:   65:	si->data[len] = 0;
        -:   66:
       36:   67:	return 0;
        -:   68:}
        -:   69:
        1:   70:int64 string_create_s(string *s, const string *s2) {
        1:   71:	return string_create_cs(s, cstring(s2));
        -:   72:}
        -:   73:
        3:   74:int64 string_append_s(string *s, const string *s2) {
        3:   75:	stringImpl *si2 = s2->impl;
        3:   76:	return string_append_ch(s, si2->data, si2->len);
        -:   77:}
        -:   78:
        5:   79:int64 string_append_ch(string *s, const byte *s2, int64 len) {
        5:   80:	if (s == NULL || s2 == NULL || len < 0) {
    #####:   81:		SetErr(IllegalArgument);
    #####:   82:		return -1;
        -:   83:	}
        -:   84:
        5:   85:	stringImpl *si = s->impl;
        5:   86:	if (si == NULL) {
    #####:   87:		SetErr(IllegalState);
    #####:   88:		return -1;
        -:   89:	}
        5:   90:	int64 len_sum = si->len + len;
        5:   91:	void *tmp = resize(si, 1 + len_sum + sizeof(stringImpl));
        -:   92:
        5:   93:	if (tmp == NULL) {
    #####:   94:		return -1;
        -:   95:	}
        -:   96:
        5:   97:	s->impl = si = tmp;
        -:   98:
        5:   99:	memcpy(si->data + si->len, s2, len);
        5:  100:	si->data[len_sum] = 0;
        -:  101:
        5:  102:	si->len = len_sum;
        -:  103:
        5:  104:	return 0;
        -:  105:}
        -:  106:
       11:  107:int64 string_len(const string *s) {
       11:  108:	if (s == NULL)
    #####:  109:		return 0;
       11:  110:	stringImpl *si = s->impl;
       11:  111:	if (si == NULL)
        1:  112:		return 0;
       10:  113:	return si->len;
        -:  114:}
        -:  115:
       11:  116:int64 string_index_of(const string *s1, const string *s2) {
       11:  117:	if (s1 == NULL || s2 == NULL) {
    #####:  118:		SetErr(IllegalArgument);
    #####:  119:		return -1;
        -:  120:	}
       11:  121:	stringImpl *si1 = s1->impl;
       11:  122:	stringImpl *si2 = s2->impl;
        -:  123:
       11:  124:	if (si1 == NULL || si2 == NULL) {
    #####:  125:		SetErr(IllegalState);
    #####:  126:		return -1;
        -:  127:	}
        -:  128:
       11:  129:	int64 s1len = si1->len;
       11:  130:	int64 s2len = si2->len;
        -:  131:
       11:  132:	if (s2len > s1len)
        1:  133:		return -1;
        -:  134:
       10:  135:	if (s2len == 0)
    #####:  136:		return 0;
        -:  137:
       10:  138:	int64 max = 1 + (s1len - s2len);
       48:  139:	for (int64 i = 0; i < max; i++) {
       47:  140:		if (!memcmp(si1->data + i, si2->data, s2len))
        9:  141:			return i;
        -:  142:	}
        -:  143:
        1:  144:	return -1;
        -:  145:}
        -:  146:
        4:  147:int64 string_last_index_of(const string *s1, const string *s2) {
        4:  148:	if (s1 == NULL || s2 == NULL) {
    #####:  149:		SetErr(IllegalArgument);
    #####:  150:		return -1;
        -:  151:	}
        4:  152:	stringImpl *si1 = s1->impl;
        4:  153:	stringImpl *si2 = s2->impl;
        -:  154:
        4:  155:	if (si1 == NULL || si2 == NULL) {
    #####:  156:		SetErr(IllegalState);
    #####:  157:		return -1;
        -:  158:	}
        -:  159:
        4:  160:	int64 s1len = si1->len;
        4:  161:	int64 s2len = si2->len;
        -:  162:
        4:  163:	if (s2len > s1len)
    #####:  164:		return -1;
        -:  165:
        4:  166:	if (s2len == 0)
    #####:  167:		return s1len;
        -:  168:
        4:  169:	int64 max = s1len - s2len;
        9:  170:	for (int64 i = max; i >= 0; i--) {
        8:  171:		if (!memcmp(si1->data + i, si2->data, s2len))
        3:  172:			return i;
        -:  173:	}
        -:  174:
        1:  175:	return -1;
        -:  176:}
        -:  177:
    #####:  178:int64 string_substring(string *dst, const string *src, int64 begin) {
    #####:  179:	return string_substring_s(dst, src, begin, string_len(src));
        -:  180:}
        -:  181:
       11:  182:int64 string_substring_s(string *dst, const string *src, int64 begin, int64 end) {
       11:  183:	byte ret = '\0';
       11:  184:	if (src == NULL || end < begin) {
    #####:  185:		SetErr(IllegalArgument);
    #####:  186:		return ret;
        -:  187:	}
        -:  188:
       11:  189:	stringImpl *si = src->impl;
       11:  190:	if (si == NULL) {
    #####:  191:		SetErr(IllegalState);
    #####:  192:		return ret;
        -:  193:	}
        -:  194:
       11:  195:	if (end > si->len || begin < 0) {
    #####:  196:		SetErr(IndexOutOfBounds);
    #####:  197:		return ret;
        -:  198:	}
        -:  199:
       11:  200:	return string_create_ch(dst, si->data + begin, end - begin);
        -:  201:}
        6:  202:byte string_char_at(const string *s, int64 index) {
        6:  203:	byte ret = '\0';
        6:  204:	if (s == NULL) {
    #####:  205:		SetErr(IllegalArgument);
    #####:  206:		return ret;
        -:  207:	}
        -:  208:
        6:  209:	stringImpl *si = s->impl;
        6:  210:	if (si == NULL) {
    #####:  211:		SetErr(IllegalState);
    #####:  212:		return ret;
        -:  213:	}
        -:  214:
        6:  215:	if (index >= si->len || index < 0) {
        3:  216:		SetErr(IndexOutOfBounds);
        3:  217:		return ret;
        -:  218:	}
        -:  219:
        3:  220:	ret = si->data[index];
        3:  221:	return ret;
        -:  222:}
        -:  223:
       14:  224:int64 string_equal(const string *s1, const string *s2) {
      14*:  225:	if (s1 == NULL && s2 == NULL)
    #####:  226:		return true;
       14:  227:	if (s1 == NULL || s2 == NULL)
    #####:  228:		return false;
        -:  229:
       14:  230:	stringImpl *si1 = s1->impl;
       14:  231:	stringImpl *si2 = s2->impl;
      14*:  232:	if (si1 == NULL && si2 == NULL)
    #####:  233:		return true;
       14:  234:	if (si1 == NULL || si2 == NULL)
        1:  235:		return false;
       13:  236:	if (si1->len != si2->len)
        2:  237:		return false;
        -:  238:
      140:  239:	for (int64 i = 0; i < si1->len; i++) {
      129:  240:		if (si1->data[i] != si2->data[i])
    #####:  241:			return false;
        -:  242:	}
        -:  243:
       11:  244:	return true;
        -:  245:}
        -:  246:
        4:  247:void string_move(string *dst, string *src) {
        4:  248:	string_cleanup(dst);
        4:  249:	dst->impl = src->impl;
        4:  250:	src->impl = NULL;
        4:  251:}
        -:  252:
        8:  253:byte *cstring(const string *s) {
        8:  254:	if (s == NULL || s->impl == NULL) {
    #####:  255:		SetErr(IllegalArgument);
    #####:  256:		return NULL;
        -:  257:	}
        8:  258:	stringImpl *si = s->impl;
        8:  259:	return si->data;
        -:  260:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:7
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/types.h>
        -:   17:#include <stdio.h>
        -:   18:
    #####:   19:void __attribute__((no_return)) panic(const char *message) {
    #####:   20:	fprintf(stderr, "%s\n", message);
    #####:   21:	exit(-1);
        -:   22:}
        -:   23:
        7:   24:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   25:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   26:	panic("Supported architectures: __x86_64__, _M_X64, and __aarch64__");
        -:   27:#endif // arch
        -:   28:
        -:   29:	// check size_t
        -:   30:	if (__SIZEOF_SIZE_T__ != 8)
        -:   31:		panic("size_t must be 8 bytes. Invalid arch!");
        -:   32:	// check primitive types
        -:   33:	if (sizeof(byte) != 1)
        -:   34:		panic("byte must be 1 byte. Invalid arch!");
        -:   35:
        -:   36:	if (sizeof(int64) != 8)
        -:   37:		panic("must be 8 bytes. Invalid arch!");
        -:   38:
        -:   39:	if (sizeof(int) != 4)
        -:   40:		panic("int must be 4 bytes. Invalid arch!");
        -:   41:
        -:   42:	if (sizeof(float64) != 8)
        -:   43:		panic("float64 must be 8 bytes. Invalid arch!");
        -:   44:
        -:   45:	if (sizeof(bool) != 1)
        -:   46:		panic("bool must be 1 byte. Invalid arch!");
        -:   47:
        -:   48:	if (sizeof(aint64) != 8)
        -:   49:		panic("aint64 must be 8 bytes. Invalid arch!");
        -:   50:
        -:   51:	if (sizeof(abool) != 1)
        -:   52:		panic("abool must be 1 byte. Invalid arch!");
        -:   53:
        -:   54:	// little endian check
        7:   55:	int test = 0x1;
        7:   56:	if (*(byte *)&test != 0x1) {
    #####:   57:		panic("Big endian is not supported!");
        -:   58:	}
        7:   59:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
