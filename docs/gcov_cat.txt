        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
    #####:   16:int main(int argc, char** argv) { return 0; }
        -:    0:Source:toml.c
        -:    0:Graph:toml.gcno
        -:    0:Data:toml.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2:
        -:    3:  MIT License
        -:    4:
        -:    5:  Copyright (c) CK Tan
        -:    6:  https://github.com/cktan/tomlc99
        -:    7:
        -:    8:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    9:  of this software and associated documentation files (the "Software"), to deal
        -:   10:  in the Software without restriction, including without limitation the rights
        -:   11:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   12:  copies of the Software, and to permit persons to whom the Software is
        -:   13:  furnished to do so, subject to the following conditions:
        -:   14:
        -:   15:  The above copyright notice and this permission notice shall be included in all
        -:   16:  copies or substantial portions of the Software.
        -:   17:
        -:   18:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   19:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   20:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   21:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   22:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   23:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   24:  SOFTWARE.
        -:   25:
        -:   26:*/
        -:   27:#define _POSIX_C_SOURCE 200809L
        -:   28:#include <assert.h>
        -:   29:#include <ctype.h>
        -:   30:#include <errno.h>
        -:   31:#include <stdbool.h>
        -:   32:#include <stdint.h>
        -:   33:#include <stdio.h>
        -:   34:#include <stdlib.h>
        -:   35:#include <string.h>
        -:   36:#include <toml/toml.h>
        -:   37:
        -:   38:static void* (*ppmalloc)(size_t) = malloc;
        -:   39:static void (*ppfree)(void*) = free;
        -:   40:
    #####:   41:void toml_set_memutil(void* (*xxmalloc)(size_t), void (*xxfree)(void*))
        -:   42:{
    #####:   43:	if (xxmalloc)
    #####:   44:		ppmalloc = xxmalloc;
    #####:   45:	if (xxfree)
    #####:   46:		ppfree = xxfree;
    #####:   47:}
        -:   48:
        -:   49:#define ALIGN8(sz) (((sz) + 7) & ~7)
        -:   50:#define MALLOC(a) ppmalloc(a)
        -:   51:#define FREE(a) ppfree(a)
        -:   52:
        -:   53:#define malloc(x) error - forbidden - use MALLOC instead
        -:   54:#define free(x) error - forbidden - use FREE instead
        -:   55:#define calloc(x, y) error - forbidden - use CALLOC instead
        -:   56:
    #####:   57:static void* CALLOC(size_t nmemb, size_t sz)
        -:   58:{
    #####:   59:	int nb = ALIGN8(sz) * nmemb;
    #####:   60:	void* p = MALLOC(nb);
    #####:   61:	if (p)
        -:   62:	{
    #####:   63:		memset(p, 0, nb);
        -:   64:	}
    #####:   65:	return p;
        -:   66:}
        -:   67:
        -:   68:// some old platforms define strdup macro -- drop it.
        -:   69:#undef strdup
        -:   70:#define strdup(x) error - forbidden - use STRDUP instead
        -:   71:
    #####:   72:static char* STRDUP(const char* s)
        -:   73:{
    #####:   74:	int len = strlen(s);
    #####:   75:	char* p = MALLOC(len + 1);
    #####:   76:	if (p)
        -:   77:	{
    #####:   78:		memcpy(p, s, len);
    #####:   79:		p[len] = 0;
        -:   80:	}
    #####:   81:	return p;
        -:   82:}
        -:   83:
        -:   84:// some old platforms define strndup macro -- drop it.
        -:   85:#undef strndup
        -:   86:#define strndup(x) error - forbiden - use STRNDUP instead
        -:   87:
    #####:   88:static char* STRNDUP(const char* s, size_t n)
        -:   89:{
    #####:   90:	size_t len = strnlen(s, n);
    #####:   91:	char* p = MALLOC(len + 1);
    #####:   92:	if (p)
        -:   93:	{
    #####:   94:		memcpy(p, s, len);
    #####:   95:		p[len] = 0;
        -:   96:	}
    #####:   97:	return p;
        -:   98:}
        -:   99:
        -:  100:/**
        -:  101: * Convert a char in utf8 into UCS, and store it in *ret.
        -:  102: * Return bytes consumed or -1 on failure.
        -:  103: */
    #####:  104:int toml_utf8_to_ucs(const char* orig, int len, int64_t* ret)
        -:  105:{
    #####:  106:	const unsigned char* buf = (const unsigned char*)orig;
    #####:  107:	unsigned i = *buf++;
        -:  108:	int64_t v;
        -:  109:
        -:  110:	/* 0x00000000 - 0x0000007F:
        -:  111:	   0xxxxxxx
        -:  112:	*/
    #####:  113:	if (0 == (i >> 7))
        -:  114:	{
    #####:  115:		if (len < 1)
    #####:  116:			return -1;
    #####:  117:		v = i;
    #####:  118:		return *ret = v, 1;
        -:  119:	}
        -:  120:	/* 0x00000080 - 0x000007FF:
        -:  121:	   110xxxxx 10xxxxxx
        -:  122:	*/
    #####:  123:	if (0x6 == (i >> 5))
        -:  124:	{
    #####:  125:		if (len < 2)
    #####:  126:			return -1;
    #####:  127:		v = i & 0x1f;
    #####:  128:		for (int j = 0; j < 1; j++)
        -:  129:		{
    #####:  130:			i = *buf++;
    #####:  131:			if (0x2 != (i >> 6))
    #####:  132:				return -1;
    #####:  133:			v = (v << 6) | (i & 0x3f);
        -:  134:		}
    #####:  135:		return *ret = v, (const char*)buf - orig;
        -:  136:	}
        -:  137:
        -:  138:	/* 0x00000800 - 0x0000FFFF:
        -:  139:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  140:	*/
    #####:  141:	if (0xE == (i >> 4))
        -:  142:	{
    #####:  143:		if (len < 3)
    #####:  144:			return -1;
    #####:  145:		v = i & 0x0F;
    #####:  146:		for (int j = 0; j < 2; j++)
        -:  147:		{
    #####:  148:			i = *buf++;
    #####:  149:			if (0x2 != (i >> 6))
    #####:  150:				return -1;
    #####:  151:			v = (v << 6) | (i & 0x3f);
        -:  152:		}
    #####:  153:		return *ret = v, (const char*)buf - orig;
        -:  154:	}
        -:  155:
        -:  156:	/* 0x00010000 - 0x001FFFFF:
        -:  157:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  158:	*/
    #####:  159:	if (0x1E == (i >> 3))
        -:  160:	{
    #####:  161:		if (len < 4)
    #####:  162:			return -1;
    #####:  163:		v = i & 0x07;
    #####:  164:		for (int j = 0; j < 3; j++)
        -:  165:		{
    #####:  166:			i = *buf++;
    #####:  167:			if (0x2 != (i >> 6))
    #####:  168:				return -1;
    #####:  169:			v = (v << 6) | (i & 0x3f);
        -:  170:		}
    #####:  171:		return *ret = v, (const char*)buf - orig;
        -:  172:	}
        -:  173:
        -:  174:	/* 0x00200000 - 0x03FFFFFF:
        -:  175:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  176:	*/
    #####:  177:	if (0x3E == (i >> 2))
        -:  178:	{
    #####:  179:		if (len < 5)
    #####:  180:			return -1;
    #####:  181:		v = i & 0x03;
    #####:  182:		for (int j = 0; j < 4; j++)
        -:  183:		{
    #####:  184:			i = *buf++;
    #####:  185:			if (0x2 != (i >> 6))
    #####:  186:				return -1;
    #####:  187:			v = (v << 6) | (i & 0x3f);
        -:  188:		}
    #####:  189:		return *ret = v, (const char*)buf - orig;
        -:  190:	}
        -:  191:
        -:  192:	/* 0x04000000 - 0x7FFFFFFF:
        -:  193:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  194:	*/
    #####:  195:	if (0x7e == (i >> 1))
        -:  196:	{
    #####:  197:		if (len < 6)
    #####:  198:			return -1;
    #####:  199:		v = i & 0x01;
    #####:  200:		for (int j = 0; j < 5; j++)
        -:  201:		{
    #####:  202:			i = *buf++;
    #####:  203:			if (0x2 != (i >> 6))
    #####:  204:				return -1;
    #####:  205:			v = (v << 6) | (i & 0x3f);
        -:  206:		}
    #####:  207:		return *ret = v, (const char*)buf - orig;
        -:  208:	}
    #####:  209:	return -1;
        -:  210:}
        -:  211:
        -:  212:/**
        -:  213: *	Convert a UCS char to utf8 code, and return it in buf.
        -:  214: *	Return bytes used in buf to encode the char, or
        -:  215: *	-1 on error.
        -:  216: */
    #####:  217:int toml_ucs_to_utf8(int64_t code, char buf[6])
        -:  218:{
        -:  219:	/* http://stackoverflow.com/questions/6240055/manually-converting-unicode-codepoints-into-utf-8-and-utf-16
        -:  220:	 */
        -:  221:	/* The UCS code values 0xd800â€“0xdfff (UTF-16 surrogates) as well
        -:  222:	 * as 0xfffe and 0xffff (UCS noncharacters) should not appear in
        -:  223:	 * conforming UTF-8 streams.
        -:  224:	 */
    #####:  225:	if (0xd800 <= code && code <= 0xdfff)
    #####:  226:		return -1;
    #####:  227:	if (0xfffe <= code && code <= 0xffff)
    #####:  228:		return -1;
        -:  229:
        -:  230:	/* 0x00000000 - 0x0000007F:
        -:  231:	   0xxxxxxx
        -:  232:	*/
    #####:  233:	if (code < 0)
    #####:  234:		return -1;
    #####:  235:	if (code <= 0x7F)
        -:  236:	{
    #####:  237:		buf[0] = (unsigned char)code;
    #####:  238:		return 1;
        -:  239:	}
        -:  240:
        -:  241:	/* 0x00000080 - 0x000007FF:
        -:  242:	   110xxxxx 10xxxxxx
        -:  243:	*/
    #####:  244:	if (code <= 0x000007FF)
        -:  245:	{
    #####:  246:		buf[0] = (unsigned char)(0xc0 | (code >> 6));
    #####:  247:		buf[1] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  248:		return 2;
        -:  249:	}
        -:  250:
        -:  251:	/* 0x00000800 - 0x0000FFFF:
        -:  252:	   1110xxxx 10xxxxxx 10xxxxxx
        -:  253:	*/
    #####:  254:	if (code <= 0x0000FFFF)
        -:  255:	{
    #####:  256:		buf[0] = (unsigned char)(0xe0 | (code >> 12));
    #####:  257:		buf[1] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  258:		buf[2] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  259:		return 3;
        -:  260:	}
        -:  261:
        -:  262:	/* 0x00010000 - 0x001FFFFF:
        -:  263:	   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  264:	*/
    #####:  265:	if (code <= 0x001FFFFF)
        -:  266:	{
    #####:  267:		buf[0] = (unsigned char)(0xf0 | (code >> 18));
    #####:  268:		buf[1] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  269:		buf[2] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  270:		buf[3] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  271:		return 4;
        -:  272:	}
        -:  273:
        -:  274:	/* 0x00200000 - 0x03FFFFFF:
        -:  275:	   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  276:	*/
    #####:  277:	if (code <= 0x03FFFFFF)
        -:  278:	{
    #####:  279:		buf[0] = (unsigned char)(0xf8 | (code >> 24));
    #####:  280:		buf[1] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  281:		buf[2] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  282:		buf[3] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  283:		buf[4] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  284:		return 5;
        -:  285:	}
        -:  286:
        -:  287:	/* 0x04000000 - 0x7FFFFFFF:
        -:  288:	   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        -:  289:	*/
    #####:  290:	if (code <= 0x7FFFFFFF)
        -:  291:	{
    #####:  292:		buf[0] = (unsigned char)(0xfc | (code >> 30));
    #####:  293:		buf[1] = (unsigned char)(0x80 | ((code >> 24) & 0x3f));
    #####:  294:		buf[2] = (unsigned char)(0x80 | ((code >> 18) & 0x3f));
    #####:  295:		buf[3] = (unsigned char)(0x80 | ((code >> 12) & 0x3f));
    #####:  296:		buf[4] = (unsigned char)(0x80 | ((code >> 6) & 0x3f));
    #####:  297:		buf[5] = (unsigned char)(0x80 | (code & 0x3f));
    #####:  298:		return 6;
        -:  299:	}
        -:  300:
    #####:  301:	return -1;
        -:  302:}
        -:  303:
        -:  304:/*
        -:  305: *	TOML has 3 data structures: value, array, table.
        -:  306: *	Each of them can have identification key.
        -:  307: */
        -:  308:typedef struct toml_keyval_t toml_keyval_t;
        -:  309:struct toml_keyval_t
        -:  310:{
        -:  311:	const char* key; /* key to this value */
        -:  312:	const char* val; /* the raw value */
        -:  313:};
        -:  314:
        -:  315:typedef struct toml_arritem_t toml_arritem_t;
        -:  316:struct toml_arritem_t
        -:  317:{
        -:  318:	int valtype; /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring,
        -:  319:			't'ime, 'D'ate, 'T'imestamp */
        -:  320:	char* val;
        -:  321:	toml_array_t* arr;
        -:  322:	toml_table_t* tab;
        -:  323:};
        -:  324:
        -:  325:struct toml_array_t
        -:  326:{
        -:  327:	const char* key; /* key to this array */
        -:  328:	int kind;	 /* element kind: 'v'alue, 'a'rray, or 't'able, 'm'ixed */
        -:  329:	int type;	 /* for value kind: 'i'nt, 'd'ouble, 'b'ool, 's'tring, 't'ime,
        -:  330:			    'D'ate, 'T'imestamp, 'm'ixed */
        -:  331:
        -:  332:	int nitem; /* number of elements */
        -:  333:	toml_arritem_t* item;
        -:  334:};
        -:  335:
        -:  336:struct toml_table_t
        -:  337:{
        -:  338:	const char* key; /* key to this table */
        -:  339:	bool implicit;	 /* table was created implicitly */
        -:  340:	bool readonly;	 /* no more modification allowed */
        -:  341:
        -:  342:	/* key-values in the table */
        -:  343:	int nkval;
        -:  344:	toml_keyval_t** kval;
        -:  345:
        -:  346:	/* arrays in the table */
        -:  347:	int narr;
        -:  348:	toml_array_t** arr;
        -:  349:
        -:  350:	/* tables in the table */
        -:  351:	int ntab;
        -:  352:	toml_table_t** tab;
        -:  353:};
        -:  354:
    #####:  355:static inline void xfree(const void* x)
        -:  356:{
    #####:  357:	if (x)
    #####:  358:		FREE((void*)(intptr_t)x);
    #####:  359:}
        -:  360:
        -:  361:enum tokentype_t
        -:  362:{
        -:  363:	INVALID,
        -:  364:	DOT,
        -:  365:	COMMA,
        -:  366:	EQUAL,
        -:  367:	LBRACE,
        -:  368:	RBRACE,
        -:  369:	NEWLINE,
        -:  370:	LBRACKET,
        -:  371:	RBRACKET,
        -:  372:	STRING,
        -:  373:};
        -:  374:typedef enum tokentype_t tokentype_t;
        -:  375:
        -:  376:typedef struct token_t token_t;
        -:  377:struct token_t
        -:  378:{
        -:  379:	tokentype_t tok;
        -:  380:	int lineno;
        -:  381:	char* ptr; /* points into context->start */
        -:  382:	int len;
        -:  383:	int eof;
        -:  384:};
        -:  385:
        -:  386:typedef struct context_t context_t;
        -:  387:struct context_t
        -:  388:{
        -:  389:	char* start;
        -:  390:	char* stop;
        -:  391:	char* errbuf;
        -:  392:	int errbufsz;
        -:  393:
        -:  394:	token_t tok;
        -:  395:	toml_table_t* root;
        -:  396:	toml_table_t* curtab;
        -:  397:
        -:  398:	struct
        -:  399:	{
        -:  400:		int top;
        -:  401:		char* key[10];
        -:  402:		token_t tok[10];
        -:  403:	} tpath;
        -:  404:};
        -:  405:
        -:  406:#define STRINGIFY(x) #x
        -:  407:#define TOSTRING(x) STRINGIFY(x)
        -:  408:#define FLINE __FILE__ ":" TOSTRING(__LINE__)
        -:  409:
        -:  410:static int next_token(context_t* ctx, int dotisspecial);
        -:  411:
        -:  412:/*
        -:  413:  Error reporting. Call when an error is detected. Always return -1.
        -:  414:*/
    #####:  415:static int e_outofmemory(context_t* ctx, const char* fline)
        -:  416:{
    #####:  417:	snprintf(ctx->errbuf, ctx->errbufsz, "ERROR: out of memory (%s)",
        -:  418:		 fline);
    #####:  419:	return -1;
        -:  420:}
        -:  421:
    #####:  422:static int e_internal(context_t* ctx, const char* fline)
        -:  423:{
    #####:  424:	snprintf(ctx->errbuf, ctx->errbufsz, "internal error (%s)", fline);
    #####:  425:	return -1;
        -:  426:}
        -:  427:
    #####:  428:static int e_syntax(context_t* ctx, int lineno, const char* msg)
        -:  429:{
    #####:  430:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  431:	return -1;
        -:  432:}
        -:  433:
    #####:  434:static int e_badkey(context_t* ctx, int lineno)
        -:  435:{
    #####:  436:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: bad key", lineno);
    #####:  437:	return -1;
        -:  438:}
        -:  439:
    #####:  440:static int e_keyexists(context_t* ctx, int lineno)
        -:  441:{
    #####:  442:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: key exists", lineno);
    #####:  443:	return -1;
        -:  444:}
        -:  445:
    #####:  446:static int e_forbid(context_t* ctx, int lineno, const char* msg)
        -:  447:{
    #####:  448:	snprintf(ctx->errbuf, ctx->errbufsz, "line %d: %s", lineno, msg);
    #####:  449:	return -1;
        -:  450:}
        -:  451:
    #####:  452:static void* expand(void* p, int sz, int newsz)
        -:  453:{
    #####:  454:	void* s = MALLOC(newsz);
    #####:  455:	if (!s)
    #####:  456:		return 0;
        -:  457:
    #####:  458:	if (p)
        -:  459:	{
    #####:  460:		memcpy(s, p, sz);
    #####:  461:		FREE(p);
        -:  462:	}
    #####:  463:	return s;
        -:  464:}
        -:  465:
    #####:  466:static void** expand_ptrarr(void** p, int n)
        -:  467:{
    #####:  468:	void** s = MALLOC((n + 1) * sizeof(void*));
    #####:  469:	if (!s)
    #####:  470:		return 0;
        -:  471:
    #####:  472:	s[n] = 0;
    #####:  473:	if (p)
        -:  474:	{
    #####:  475:		memcpy(s, p, n * sizeof(void*));
    #####:  476:		FREE(p);
        -:  477:	}
    #####:  478:	return s;
        -:  479:}
        -:  480:
    #####:  481:static toml_arritem_t* expand_arritem(toml_arritem_t* p, int n)
        -:  482:{
    #####:  483:	toml_arritem_t* pp = expand(p, n * sizeof(*p), (n + 1) * sizeof(*p));
    #####:  484:	if (!pp)
    #####:  485:		return 0;
        -:  486:
    #####:  487:	memset(&pp[n], 0, sizeof(pp[n]));
    #####:  488:	return pp;
        -:  489:}
        -:  490:
    #####:  491:static char* norm_lit_str(const char* src, int srclen, int multiline,
        -:  492:			  char* errbuf, int errbufsz)
        -:  493:{
    #####:  494:	char* dst = 0; /* will write to dst[] and return it */
    #####:  495:	int max = 0;   /* max size of dst[] */
    #####:  496:	int off = 0;   /* cur offset in dst[] */
    #####:  497:	const char* sp = src;
    #####:  498:	const char* sq = src + srclen;
        -:  499:	int ch;
        -:  500:
        -:  501:	/* scan forward on src */
        -:  502:	for (;;)
        -:  503:	{
    #####:  504:		if (off >= max - 10)
        -:  505:		{ /* have some slack for misc stuff */
    #####:  506:			int newmax = max + 50;
    #####:  507:			char* x = expand(dst, max, newmax);
    #####:  508:			if (!x)
        -:  509:			{
    #####:  510:				xfree(dst);
    #####:  511:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  512:				return 0;
        -:  513:			}
    #####:  514:			dst = x;
    #####:  515:			max = newmax;
        -:  516:		}
        -:  517:
        -:  518:		/* finished? */
    #####:  519:		if (sp >= sq)
    #####:  520:			break;
        -:  521:
    #####:  522:		ch = *sp++;
        -:  523:		/* control characters other than tab is not allowed */
    #####:  524:		if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f))
        -:  525:		{
    #####:  526:			if (!(multiline && (ch == '\r' || ch == '\n')))
        -:  527:			{
    #####:  528:				xfree(dst);
    #####:  529:				snprintf(errbuf, errbufsz,
        -:  530:					 "invalid char U+%04x", ch);
    #####:  531:				return 0;
        -:  532:			}
        -:  533:		}
        -:  534:
        -:  535:		// a plain copy suffice
    #####:  536:		dst[off++] = ch;
        -:  537:	}
        -:  538:
    #####:  539:	dst[off++] = 0;
    #####:  540:	return dst;
        -:  541:}
        -:  542:
        -:  543:/*
        -:  544: * Convert src to raw unescaped utf-8 string.
        -:  545: * Returns NULL if error with errmsg in errbuf.
        -:  546: */
    #####:  547:static char* norm_basic_str(const char* src, int srclen, int multiline,
        -:  548:			    char* errbuf, int errbufsz)
        -:  549:{
    #####:  550:	char* dst = 0; /* will write to dst[] and return it */
    #####:  551:	int max = 0;   /* max size of dst[] */
    #####:  552:	int off = 0;   /* cur offset in dst[] */
    #####:  553:	const char* sp = src;
    #####:  554:	const char* sq = src + srclen;
        -:  555:	int ch;
        -:  556:
        -:  557:	/* scan forward on src */
        -:  558:	for (;;)
        -:  559:	{
    #####:  560:		if (off >= max - 10)
        -:  561:		{ /* have some slack for misc stuff */
    #####:  562:			int newmax = max + 50;
    #####:  563:			char* x = expand(dst, max, newmax);
    #####:  564:			if (!x)
        -:  565:			{
    #####:  566:				xfree(dst);
    #####:  567:				snprintf(errbuf, errbufsz, "out of memory");
    #####:  568:				return 0;
        -:  569:			}
    #####:  570:			dst = x;
    #####:  571:			max = newmax;
        -:  572:		}
        -:  573:
        -:  574:		/* finished? */
    #####:  575:		if (sp >= sq)
    #####:  576:			break;
        -:  577:
    #####:  578:		ch = *sp++;
    #####:  579:		if (ch != '\\')
        -:  580:		{
        -:  581:			/* these chars must be escaped: U+0000 to U+0008, U+000A
        -:  582:			 * to U+001F, U+007F
        -:  583:			 */
    #####:  584:			if ((0 <= ch && ch <= 0x08) || (0x0a <= ch && ch <= 0x1f) || (ch == 0x7f))
        -:  585:			{
    #####:  586:				if (!(multiline && (ch == '\r' || ch == '\n')))
        -:  587:				{
    #####:  588:					xfree(dst);
    #####:  589:					snprintf(errbuf, errbufsz,
        -:  590:						 "invalid char U+%04x", ch);
    #####:  591:					return 0;
        -:  592:				}
        -:  593:			}
        -:  594:
        -:  595:			// a plain copy suffice
    #####:  596:			dst[off++] = ch;
    #####:  597:			continue;
        -:  598:		}
        -:  599:
        -:  600:		/* ch was backslash. we expect the escape char. */
    #####:  601:		if (sp >= sq)
        -:  602:		{
    #####:  603:			snprintf(errbuf, errbufsz, "last backslash is invalid");
    #####:  604:			xfree(dst);
    #####:  605:			return 0;
        -:  606:		}
        -:  607:
        -:  608:		/* for multi-line, we want to kill line-ending-backslash ... */
    #####:  609:		if (multiline)
        -:  610:		{
        -:  611:
        -:  612:			// if there is only whitespace after the backslash ...
    #####:  613:			if (sp[strspn(sp, " \t\r")] == '\n')
        -:  614:			{
        -:  615:				/* skip all the following whitespaces */
    #####:  616:				sp += strspn(sp, " \t\r\n");
    #####:  617:				continue;
        -:  618:			}
        -:  619:		}
        -:  620:
        -:  621:		/* get the escaped char */
    #####:  622:		ch = *sp++;
    #####:  623:		switch (ch)
        -:  624:		{
    #####:  625:		case 'u':
        -:  626:		case 'U':
        -:  627:		{
    #####:  628:			int64_t ucs = 0;
    #####:  629:			int nhex = (ch == 'u' ? 4 : 8);
    #####:  630:			for (int i = 0; i < nhex; i++)
        -:  631:			{
    #####:  632:				if (sp >= sq)
        -:  633:				{
    #####:  634:					snprintf(errbuf, errbufsz,
        -:  635:						 "\\%c expects %d hex chars",
        -:  636:						 ch, nhex);
    #####:  637:					xfree(dst);
    #####:  638:					return 0;
        -:  639:				}
    #####:  640:				ch = *sp++;
    #####:  641:				int v = ('0' <= ch && ch <= '9')
        -:  642:					    ? ch - '0'
    #####:  643:					    : (('A' <= ch && ch <= 'F')
        -:  644:						   ? ch - 'A' + 10
    #####:  645:						   : -1);
    #####:  646:				if (-1 == v)
        -:  647:				{
    #####:  648:					snprintf(
        -:  649:					    errbuf, errbufsz,
        -:  650:					    "invalid hex chars for \\u or \\U");
    #####:  651:					xfree(dst);
    #####:  652:					return 0;
        -:  653:				}
    #####:  654:				ucs = ucs * 16 + v;
        -:  655:			}
    #####:  656:			int n = toml_ucs_to_utf8(ucs, &dst[off]);
    #####:  657:			if (-1 == n)
        -:  658:			{
    #####:  659:				snprintf(errbuf, errbufsz,
        -:  660:					 "illegal ucs code in \\u or \\U");
    #####:  661:				xfree(dst);
    #####:  662:				return 0;
        -:  663:			}
    #####:  664:			off += n;
        -:  665:		}
    #####:  666:			continue;
        -:  667:
    #####:  668:		case 'b':
    #####:  669:			ch = '\b';
    #####:  670:			break;
    #####:  671:		case 't':
    #####:  672:			ch = '\t';
    #####:  673:			break;
    #####:  674:		case 'n':
    #####:  675:			ch = '\n';
    #####:  676:			break;
    #####:  677:		case 'f':
    #####:  678:			ch = '\f';
    #####:  679:			break;
    #####:  680:		case 'r':
    #####:  681:			ch = '\r';
    #####:  682:			break;
    #####:  683:		case '"':
    #####:  684:			ch = '"';
    #####:  685:			break;
    #####:  686:		case '\\':
    #####:  687:			ch = '\\';
    #####:  688:			break;
    #####:  689:		default:
    #####:  690:			snprintf(errbuf, errbufsz, "illegal escape char \\%c",
        -:  691:				 ch);
    #####:  692:			xfree(dst);
    #####:  693:			return 0;
        -:  694:		}
        -:  695:
    #####:  696:		dst[off++] = ch;
        -:  697:	}
        -:  698:
        -:  699:	// Cap with NUL and return it.
    #####:  700:	dst[off++] = 0;
    #####:  701:	return dst;
        -:  702:}
        -:  703:
        -:  704:/* Normalize a key. Convert all special chars to raw unescaped utf-8 chars. */
    #####:  705:static char* normalize_key(context_t* ctx, token_t strtok)
        -:  706:{
    #####:  707:	const char* sp = strtok.ptr;
    #####:  708:	const char* sq = strtok.ptr + strtok.len;
    #####:  709:	int lineno = strtok.lineno;
        -:  710:	char* ret;
    #####:  711:	int ch = *sp;
        -:  712:	char ebuf[80];
        -:  713:
        -:  714:	/* handle quoted string */
    #####:  715:	if (ch == '\'' || ch == '\"')
        -:  716:	{
        -:  717:		/* if ''' or """, take 3 chars off front and back. Else, take 1
        -:  718:		 * char off. */
    #####:  719:		int multiline = 0;
    #####:  720:		if (sp[1] == ch && sp[2] == ch)
        -:  721:		{
    #####:  722:			sp += 3, sq -= 3;
    #####:  723:			multiline = 1;
        -:  724:		}
        -:  725:		else
    #####:  726:			sp++, sq--;
        -:  727:
    #####:  728:		if (ch == '\'')
        -:  729:		{
        -:  730:			/* for single quote, take it verbatim. */
    #####:  731:			if (!(ret = STRNDUP(sp, sq - sp)))
        -:  732:			{
    #####:  733:				e_outofmemory(ctx, FLINE);
    #####:  734:				return 0;
        -:  735:			}
        -:  736:		}
        -:  737:		else
        -:  738:		{
        -:  739:			/* for double quote, we need to normalize */
    #####:  740:			ret = norm_basic_str(sp, sq - sp, multiline, ebuf,
        -:  741:					     sizeof(ebuf));
    #####:  742:			if (!ret)
        -:  743:			{
    #####:  744:				e_syntax(ctx, lineno, ebuf);
    #####:  745:				return 0;
        -:  746:			}
        -:  747:		}
        -:  748:
        -:  749:		/* newlines are not allowed in keys */
    #####:  750:		if (strchr(ret, '\n'))
        -:  751:		{
    #####:  752:			xfree(ret);
    #####:  753:			e_badkey(ctx, lineno);
    #####:  754:			return 0;
        -:  755:		}
    #####:  756:		return ret;
        -:  757:	}
        -:  758:
        -:  759:	/* for bare-key allow only this regex: [A-Za-z0-9_-]+ */
        -:  760:	const char* xp;
    #####:  761:	for (xp = sp; xp != sq; xp++)
        -:  762:	{
    #####:  763:		int k = *xp;
    #####:  764:		if (isalnum(k))
    #####:  765:			continue;
    #####:  766:		if (k == '_' || k == '-')
    #####:  767:			continue;
    #####:  768:		e_badkey(ctx, lineno);
    #####:  769:		return 0;
        -:  770:	}
        -:  771:
        -:  772:	/* dup and return it */
    #####:  773:	if (!(ret = STRNDUP(sp, sq - sp)))
        -:  774:	{
    #####:  775:		e_outofmemory(ctx, FLINE);
    #####:  776:		return 0;
        -:  777:	}
    #####:  778:	return ret;
        -:  779:}
        -:  780:
        -:  781:/*
        -:  782: * Look up key in tab. Return 0 if not found, or
        -:  783: * 'v'alue, 'a'rray or 't'able depending on the element.
        -:  784: */
    #####:  785:static int check_key(toml_table_t* tab, const char* key,
        -:  786:		     toml_keyval_t** ret_val, toml_array_t** ret_arr,
        -:  787:		     toml_table_t** ret_tab)
        -:  788:{
        -:  789:	int i;
        -:  790:	void* dummy;
        -:  791:
    #####:  792:	if (!ret_tab)
    #####:  793:		ret_tab = (toml_table_t**)&dummy;
    #####:  794:	if (!ret_arr)
    #####:  795:		ret_arr = (toml_array_t**)&dummy;
    #####:  796:	if (!ret_val)
    #####:  797:		ret_val = (toml_keyval_t**)&dummy;
        -:  798:
    #####:  799:	*ret_tab = 0;
    #####:  800:	*ret_arr = 0;
    #####:  801:	*ret_val = 0;
        -:  802:
    #####:  803:	for (i = 0; i < tab->nkval; i++)
        -:  804:	{
    #####:  805:		if (0 == strcmp(key, tab->kval[i]->key))
        -:  806:		{
    #####:  807:			*ret_val = tab->kval[i];
    #####:  808:			return 'v';
        -:  809:		}
        -:  810:	}
    #####:  811:	for (i = 0; i < tab->narr; i++)
        -:  812:	{
    #####:  813:		if (0 == strcmp(key, tab->arr[i]->key))
        -:  814:		{
    #####:  815:			*ret_arr = tab->arr[i];
    #####:  816:			return 'a';
        -:  817:		}
        -:  818:	}
    #####:  819:	for (i = 0; i < tab->ntab; i++)
        -:  820:	{
    #####:  821:		if (0 == strcmp(key, tab->tab[i]->key))
        -:  822:		{
    #####:  823:			*ret_tab = tab->tab[i];
    #####:  824:			return 't';
        -:  825:		}
        -:  826:	}
    #####:  827:	return 0;
        -:  828:}
        -:  829:
    #####:  830:static int key_kind(toml_table_t* tab, const char* key)
        -:  831:{
    #####:  832:	return check_key(tab, key, 0, 0, 0);
        -:  833:}
        -:  834:
        -:  835:/* Create a keyval in the table.
        -:  836: */
    #####:  837:static toml_keyval_t* create_keyval_in_table(context_t* ctx, toml_table_t* tab,
        -:  838:					     token_t keytok)
        -:  839:{
        -:  840:	/* first, normalize the key to be used for lookup.
        -:  841:	 * remember to free it if we error out.
        -:  842:	 */
    #####:  843:	char* newkey = normalize_key(ctx, keytok);
    #####:  844:	if (!newkey)
    #####:  845:		return 0;
        -:  846:
        -:  847:	/* if key exists: error out. */
    #####:  848:	toml_keyval_t* dest = 0;
    #####:  849:	if (key_kind(tab, newkey))
        -:  850:	{
    #####:  851:		xfree(newkey);
    #####:  852:		e_keyexists(ctx, keytok.lineno);
    #####:  853:		return 0;
        -:  854:	}
        -:  855:
        -:  856:	/* make a new entry */
    #####:  857:	int n = tab->nkval;
        -:  858:	toml_keyval_t** base;
    #####:  859:	if (0 == (base = (toml_keyval_t**)expand_ptrarr((void**)tab->kval, n)))
        -:  860:	{
    #####:  861:		xfree(newkey);
    #####:  862:		e_outofmemory(ctx, FLINE);
    #####:  863:		return 0;
        -:  864:	}
    #####:  865:	tab->kval = base;
        -:  866:
    #####:  867:	if (0 == (base[n] = (toml_keyval_t*)CALLOC(1, sizeof(*base[n]))))
        -:  868:	{
    #####:  869:		xfree(newkey);
    #####:  870:		e_outofmemory(ctx, FLINE);
    #####:  871:		return 0;
        -:  872:	}
    #####:  873:	dest = tab->kval[tab->nkval++];
        -:  874:
        -:  875:	/* save the key in the new value struct */
    #####:  876:	dest->key = newkey;
    #####:  877:	return dest;
        -:  878:}
        -:  879:
        -:  880:/* Create a table in the table.
        -:  881: */
    #####:  882:static toml_table_t* create_keytable_in_table(context_t* ctx, toml_table_t* tab,
        -:  883:					      token_t keytok)
        -:  884:{
        -:  885:	/* first, normalize the key to be used for lookup.
        -:  886:	 * remember to free it if we error out.
        -:  887:	 */
    #####:  888:	char* newkey = normalize_key(ctx, keytok);
    #####:  889:	if (!newkey)
    #####:  890:		return 0;
        -:  891:
        -:  892:	/* if key exists: error out */
    #####:  893:	toml_table_t* dest = 0;
    #####:  894:	if (check_key(tab, newkey, 0, 0, &dest))
        -:  895:	{
    #####:  896:		xfree(newkey); /* don't need this anymore */
        -:  897:
        -:  898:		/* special case: if table exists, but was created implicitly ...
        -:  899:		 */
    #####:  900:		if (dest && dest->implicit)
        -:  901:		{
        -:  902:			/* we make it explicit now, and simply return it. */
    #####:  903:			dest->implicit = false;
    #####:  904:			return dest;
        -:  905:		}
    #####:  906:		e_keyexists(ctx, keytok.lineno);
    #####:  907:		return 0;
        -:  908:	}
        -:  909:
        -:  910:	/* create a new table entry */
    #####:  911:	int n = tab->ntab;
        -:  912:	toml_table_t** base;
    #####:  913:	if (0 == (base = (toml_table_t**)expand_ptrarr((void**)tab->tab, n)))
        -:  914:	{
    #####:  915:		xfree(newkey);
    #####:  916:		e_outofmemory(ctx, FLINE);
    #####:  917:		return 0;
        -:  918:	}
    #####:  919:	tab->tab = base;
        -:  920:
    #####:  921:	if (0 == (base[n] = (toml_table_t*)CALLOC(1, sizeof(*base[n]))))
        -:  922:	{
    #####:  923:		xfree(newkey);
    #####:  924:		e_outofmemory(ctx, FLINE);
    #####:  925:		return 0;
        -:  926:	}
    #####:  927:	dest = tab->tab[tab->ntab++];
        -:  928:
        -:  929:	/* save the key in the new table struct */
    #####:  930:	dest->key = newkey;
    #####:  931:	return dest;
        -:  932:}
        -:  933:
        -:  934:/* Create an array in the table.
        -:  935: */
    #####:  936:static toml_array_t* create_keyarray_in_table(context_t* ctx, toml_table_t* tab,
        -:  937:					      token_t keytok, char kind)
        -:  938:{
        -:  939:	/* first, normalize the key to be used for lookup.
        -:  940:	 * remember to free it if we error out.
        -:  941:	 */
    #####:  942:	char* newkey = normalize_key(ctx, keytok);
    #####:  943:	if (!newkey)
    #####:  944:		return 0;
        -:  945:
        -:  946:	/* if key exists: error out */
    #####:  947:	if (key_kind(tab, newkey))
        -:  948:	{
    #####:  949:		xfree(newkey); /* don't need this anymore */
    #####:  950:		e_keyexists(ctx, keytok.lineno);
    #####:  951:		return 0;
        -:  952:	}
        -:  953:
        -:  954:	/* make a new array entry */
    #####:  955:	int n = tab->narr;
        -:  956:	toml_array_t** base;
    #####:  957:	if (0 == (base = (toml_array_t**)expand_ptrarr((void**)tab->arr, n)))
        -:  958:	{
    #####:  959:		xfree(newkey);
    #####:  960:		e_outofmemory(ctx, FLINE);
    #####:  961:		return 0;
        -:  962:	}
    #####:  963:	tab->arr = base;
        -:  964:
    #####:  965:	if (0 == (base[n] = (toml_array_t*)CALLOC(1, sizeof(*base[n]))))
        -:  966:	{
    #####:  967:		xfree(newkey);
    #####:  968:		e_outofmemory(ctx, FLINE);
    #####:  969:		return 0;
        -:  970:	}
    #####:  971:	toml_array_t* dest = tab->arr[tab->narr++];
        -:  972:
        -:  973:	/* save the key in the new array struct */
    #####:  974:	dest->key = newkey;
    #####:  975:	dest->kind = kind;
    #####:  976:	return dest;
        -:  977:}
        -:  978:
    #####:  979:static toml_arritem_t* create_value_in_array(context_t* ctx,
        -:  980:					     toml_array_t* parent)
        -:  981:{
    #####:  982:	const int n = parent->nitem;
    #####:  983:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####:  984:	if (!base)
        -:  985:	{
    #####:  986:		e_outofmemory(ctx, FLINE);
    #####:  987:		return 0;
        -:  988:	}
    #####:  989:	parent->item = base;
    #####:  990:	parent->nitem++;
    #####:  991:	return &parent->item[n];
        -:  992:}
        -:  993:
        -:  994:/* Create an array in an array
        -:  995: */
    #####:  996:static toml_array_t* create_array_in_array(context_t* ctx, toml_array_t* parent)
        -:  997:{
    #####:  998:	const int n = parent->nitem;
    #####:  999:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####: 1000:	if (!base)
        -: 1001:	{
    #####: 1002:		e_outofmemory(ctx, FLINE);
    #####: 1003:		return 0;
        -: 1004:	}
    #####: 1005:	toml_array_t* ret = (toml_array_t*)CALLOC(1, sizeof(toml_array_t));
    #####: 1006:	if (!ret)
        -: 1007:	{
    #####: 1008:		e_outofmemory(ctx, FLINE);
    #####: 1009:		return 0;
        -: 1010:	}
    #####: 1011:	base[n].arr = ret;
    #####: 1012:	parent->item = base;
    #####: 1013:	parent->nitem++;
    #####: 1014:	return ret;
        -: 1015:}
        -: 1016:
        -: 1017:/* Create a table in an array
        -: 1018: */
    #####: 1019:static toml_table_t* create_table_in_array(context_t* ctx, toml_array_t* parent)
        -: 1020:{
    #####: 1021:	int n = parent->nitem;
    #####: 1022:	toml_arritem_t* base = expand_arritem(parent->item, n);
    #####: 1023:	if (!base)
        -: 1024:	{
    #####: 1025:		e_outofmemory(ctx, FLINE);
    #####: 1026:		return 0;
        -: 1027:	}
    #####: 1028:	toml_table_t* ret = (toml_table_t*)CALLOC(1, sizeof(toml_table_t));
    #####: 1029:	if (!ret)
        -: 1030:	{
    #####: 1031:		e_outofmemory(ctx, FLINE);
    #####: 1032:		return 0;
        -: 1033:	}
    #####: 1034:	base[n].tab = ret;
    #####: 1035:	parent->item = base;
    #####: 1036:	parent->nitem++;
    #####: 1037:	return ret;
        -: 1038:}
        -: 1039:
    #####: 1040:static int skip_newlines(context_t* ctx, int isdotspecial)
        -: 1041:{
    #####: 1042:	while (ctx->tok.tok == NEWLINE)
        -: 1043:	{
    #####: 1044:		if (next_token(ctx, isdotspecial))
    #####: 1045:			return -1;
    #####: 1046:		if (ctx->tok.eof)
    #####: 1047:			break;
        -: 1048:	}
    #####: 1049:	return 0;
        -: 1050:}
        -: 1051:
        -: 1052:static int parse_keyval(context_t* ctx, toml_table_t* tab);
        -: 1053:
    #####: 1054:static inline int eat_token(context_t* ctx, tokentype_t typ, int isdotspecial,
        -: 1055:			    const char* fline)
        -: 1056:{
    #####: 1057:	if (ctx->tok.tok != typ)
    #####: 1058:		return e_internal(ctx, fline);
        -: 1059:
    #####: 1060:	if (next_token(ctx, isdotspecial))
    #####: 1061:		return -1;
        -: 1062:
    #####: 1063:	return 0;
        -: 1064:}
        -: 1065:
        -: 1066:/* We are at '{ ... }'.
        -: 1067: * Parse the table.
        -: 1068: */
    #####: 1069:static int parse_inline_table(context_t* ctx, toml_table_t* tab)
        -: 1070:{
    #####: 1071:	if (eat_token(ctx, LBRACE, 1, FLINE))
    #####: 1072:		return -1;
        -: 1073:
        -: 1074:	for (;;)
        -: 1075:	{
    #####: 1076:		if (ctx->tok.tok == NEWLINE)
    #####: 1077:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1078:					"newline not allowed in inline table");
        -: 1079:
        -: 1080:		/* until } */
    #####: 1081:		if (ctx->tok.tok == RBRACE)
    #####: 1082:			break;
        -: 1083:
    #####: 1084:		if (ctx->tok.tok != STRING)
    #####: 1085:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1086:					"expect a string");
        -: 1087:
    #####: 1088:		if (parse_keyval(ctx, tab))
    #####: 1089:			return -1;
        -: 1090:
    #####: 1091:		if (ctx->tok.tok == NEWLINE)
    #####: 1092:			return e_syntax(ctx, ctx->tok.lineno,
        -: 1093:					"newline not allowed in inline table");
        -: 1094:
        -: 1095:		/* on comma, continue to scan for next keyval */
    #####: 1096:		if (ctx->tok.tok == COMMA)
        -: 1097:		{
    #####: 1098:			if (eat_token(ctx, COMMA, 1, FLINE))
    #####: 1099:				return -1;
    #####: 1100:			continue;
        -: 1101:		}
    #####: 1102:		break;
        -: 1103:	}
        -: 1104:
    #####: 1105:	if (eat_token(ctx, RBRACE, 1, FLINE))
    #####: 1106:		return -1;
        -: 1107:
    #####: 1108:	tab->readonly = 1;
        -: 1109:
    #####: 1110:	return 0;
        -: 1111:}
        -: 1112:
    #####: 1113:static int valtype(const char* val)
        -: 1114:{
        -: 1115:	toml_timestamp_t ts;
    #####: 1116:	if (*val == '\'' || *val == '"')
    #####: 1117:		return 's';
    #####: 1118:	if (0 == toml_rtob(val, 0))
    #####: 1119:		return 'b';
    #####: 1120:	if (0 == toml_rtoi(val, 0))
    #####: 1121:		return 'i';
    #####: 1122:	if (0 == toml_rtod(val, 0))
    #####: 1123:		return 'd';
    #####: 1124:	if (0 == toml_rtots(val, &ts))
        -: 1125:	{
    #####: 1126:		if (ts.year && ts.hour)
    #####: 1127:			return 'T'; /* timestamp */
    #####: 1128:		if (ts.year)
    #####: 1129:			return 'D'; /* date */
    #####: 1130:		return 't';	    /* time */
        -: 1131:	}
    #####: 1132:	return 'u'; /* unknown */
        -: 1133:}
        -: 1134:
        -: 1135:/* We are at '[...]' */
    #####: 1136:static int parse_array(context_t* ctx, toml_array_t* arr)
        -: 1137:{
    #####: 1138:	if (eat_token(ctx, LBRACKET, 0, FLINE))
    #####: 1139:		return -1;
        -: 1140:
        -: 1141:	for (;;)
        -: 1142:	{
    #####: 1143:		if (skip_newlines(ctx, 0))
    #####: 1144:			return -1;
        -: 1145:
        -: 1146:		/* until ] */
    #####: 1147:		if (ctx->tok.tok == RBRACKET)
    #####: 1148:			break;
        -: 1149:
    #####: 1150:		switch (ctx->tok.tok)
        -: 1151:		{
    #####: 1152:		case STRING:
        -: 1153:		{
        -: 1154:			/* set array kind if this will be the first entry */
    #####: 1155:			if (arr->kind == 0)
    #####: 1156:				arr->kind = 'v';
    #####: 1157:			else if (arr->kind != 'v')
    #####: 1158:				arr->kind = 'm';
        -: 1159:
    #####: 1160:			char* val = ctx->tok.ptr;
    #####: 1161:			int vlen = ctx->tok.len;
        -: 1162:
        -: 1163:			/* make a new value in array */
        -: 1164:			toml_arritem_t* newval =
    #####: 1165:			    create_value_in_array(ctx, arr);
    #####: 1166:			if (!newval)
    #####: 1167:				return e_outofmemory(ctx, FLINE);
        -: 1168:
    #####: 1169:			if (!(newval->val = STRNDUP(val, vlen)))
    #####: 1170:				return e_outofmemory(ctx, FLINE);
        -: 1171:
    #####: 1172:			newval->valtype = valtype(newval->val);
        -: 1173:
        -: 1174:			/* set array type if this is the first entry */
    #####: 1175:			if (arr->nitem == 1)
    #####: 1176:				arr->type = newval->valtype;
    #####: 1177:			else if (arr->type != newval->valtype)
    #####: 1178:				arr->type = 'm'; /* mixed */
        -: 1179:
    #####: 1180:			if (eat_token(ctx, STRING, 0, FLINE))
    #####: 1181:				return -1;
    #####: 1182:			break;
        -: 1183:		}
        -: 1184:
    #####: 1185:		case LBRACKET:
        -: 1186:		{ /* [ [array], [array] ... ] */
        -: 1187:			/* set the array kind if this will be the first entry */
    #####: 1188:			if (arr->kind == 0)
    #####: 1189:				arr->kind = 'a';
    #####: 1190:			else if (arr->kind != 'a')
    #####: 1191:				arr->kind = 'm';
        -: 1192:
    #####: 1193:			toml_array_t* subarr = create_array_in_array(ctx, arr);
    #####: 1194:			if (!subarr)
    #####: 1195:				return -1;
    #####: 1196:			if (parse_array(ctx, subarr))
    #####: 1197:				return -1;
    #####: 1198:			break;
        -: 1199:		}
        -: 1200:
    #####: 1201:		case LBRACE:
        -: 1202:		{ /* [ {table}, {table} ... ] */
        -: 1203:			/* set the array kind if this will be the first entry */
    #####: 1204:			if (arr->kind == 0)
    #####: 1205:				arr->kind = 't';
    #####: 1206:			else if (arr->kind != 't')
    #####: 1207:				arr->kind = 'm';
        -: 1208:
    #####: 1209:			toml_table_t* subtab = create_table_in_array(ctx, arr);
    #####: 1210:			if (!subtab)
    #####: 1211:				return -1;
    #####: 1212:			if (parse_inline_table(ctx, subtab))
    #####: 1213:				return -1;
    #####: 1214:			break;
        -: 1215:		}
        -: 1216:
    #####: 1217:		default:
    #####: 1218:			return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1219:		}
        -: 1220:
    #####: 1221:		if (skip_newlines(ctx, 0))
    #####: 1222:			return -1;
        -: 1223:
        -: 1224:		/* on comma, continue to scan for next element */
    #####: 1225:		if (ctx->tok.tok == COMMA)
        -: 1226:		{
    #####: 1227:			if (eat_token(ctx, COMMA, 0, FLINE))
    #####: 1228:				return -1;
    #####: 1229:			continue;
        -: 1230:		}
    #####: 1231:		break;
        -: 1232:	}
        -: 1233:
    #####: 1234:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1235:		return -1;
    #####: 1236:	return 0;
        -: 1237:}
        -: 1238:
        -: 1239:/* handle lines like these:
        -: 1240:   key = "value"
        -: 1241:   key = [ array ]
        -: 1242:   key = { table }
        -: 1243:*/
    #####: 1244:static int parse_keyval(context_t* ctx, toml_table_t* tab)
        -: 1245:{
    #####: 1246:	if (tab->readonly)
        -: 1247:	{
    #####: 1248:		return e_forbid(ctx, ctx->tok.lineno,
        -: 1249:				"cannot insert new entry into existing table");
        -: 1250:	}
        -: 1251:
    #####: 1252:	token_t key = ctx->tok;
    #####: 1253:	if (eat_token(ctx, STRING, 1, FLINE))
    #####: 1254:		return -1;
        -: 1255:
    #####: 1256:	if (ctx->tok.tok == DOT)
        -: 1257:	{
        -: 1258:		/* handle inline dotted key.
        -: 1259:		   e.g.
        -: 1260:		   physical.color = "orange"
        -: 1261:		   physical.shape = "round"
        -: 1262:		*/
    #####: 1263:		toml_table_t* subtab = 0;
        -: 1264:		{
    #####: 1265:			char* subtabstr = normalize_key(ctx, key);
    #####: 1266:			if (!subtabstr)
    #####: 1267:				return -1;
        -: 1268:
    #####: 1269:			subtab = toml_table_in(tab, subtabstr);
    #####: 1270:			xfree(subtabstr);
        -: 1271:		}
    #####: 1272:		if (!subtab)
        -: 1273:		{
    #####: 1274:			subtab = create_keytable_in_table(ctx, tab, key);
    #####: 1275:			if (!subtab)
    #####: 1276:				return -1;
        -: 1277:		}
    #####: 1278:		if (next_token(ctx, 1))
    #####: 1279:			return -1;
    #####: 1280:		if (parse_keyval(ctx, subtab))
    #####: 1281:			return -1;
    #####: 1282:		return 0;
        -: 1283:	}
        -: 1284:
    #####: 1285:	if (ctx->tok.tok != EQUAL)
        -: 1286:	{
    #####: 1287:		return e_syntax(ctx, ctx->tok.lineno, "missing =");
        -: 1288:	}
        -: 1289:
    #####: 1290:	if (next_token(ctx, 0))
    #####: 1291:		return -1;
        -: 1292:
    #####: 1293:	switch (ctx->tok.tok)
        -: 1294:	{
    #####: 1295:	case STRING:
        -: 1296:	{ /* key = "value" */
    #####: 1297:		toml_keyval_t* keyval = create_keyval_in_table(ctx, tab, key);
    #####: 1298:		if (!keyval)
    #####: 1299:			return -1;
    #####: 1300:		token_t val = ctx->tok;
        -: 1301:
    #####: 1302:		assert(keyval->val == 0);
    #####: 1303:		if (!(keyval->val = STRNDUP(val.ptr, val.len)))
    #####: 1304:			return e_outofmemory(ctx, FLINE);
        -: 1305:
    #####: 1306:		if (next_token(ctx, 1))
    #####: 1307:			return -1;
        -: 1308:
    #####: 1309:		return 0;
        -: 1310:	}
        -: 1311:
    #####: 1312:	case LBRACKET:
        -: 1313:	{ /* key = [ array ] */
    #####: 1314:		toml_array_t* arr = create_keyarray_in_table(ctx, tab, key, 0);
    #####: 1315:		if (!arr)
    #####: 1316:			return -1;
    #####: 1317:		if (parse_array(ctx, arr))
    #####: 1318:			return -1;
    #####: 1319:		return 0;
        -: 1320:	}
        -: 1321:
    #####: 1322:	case LBRACE:
        -: 1323:	{ /* key = { table } */
    #####: 1324:		toml_table_t* nxttab = create_keytable_in_table(ctx, tab, key);
    #####: 1325:		if (!nxttab)
    #####: 1326:			return -1;
    #####: 1327:		if (parse_inline_table(ctx, nxttab))
    #####: 1328:			return -1;
    #####: 1329:		return 0;
        -: 1330:	}
        -: 1331:
    #####: 1332:	default:
    #####: 1333:		return e_syntax(ctx, ctx->tok.lineno, "syntax error");
        -: 1334:	}
        -: 1335:	return 0;
        -: 1336:}
        -: 1337:
        -: 1338:typedef struct tabpath_t tabpath_t;
        -: 1339:struct tabpath_t
        -: 1340:{
        -: 1341:	int cnt;
        -: 1342:	token_t key[10];
        -: 1343:};
        -: 1344:
        -: 1345:/* at [x.y.z] or [[x.y.z]]
        -: 1346: * Scan forward and fill tabpath until it enters ] or ]]
        -: 1347: * There will be at least one entry on return.
        -: 1348: */
    #####: 1349:static int fill_tabpath(context_t* ctx)
        -: 1350:{
    #####: 1351:	int lineno = ctx->tok.lineno;
        -: 1352:	int i;
        -: 1353:
        -: 1354:	/* clear tpath */
    #####: 1355:	for (i = 0; i < ctx->tpath.top; i++)
        -: 1356:	{
    #####: 1357:		char** p = &ctx->tpath.key[i];
    #####: 1358:		xfree(*p);
    #####: 1359:		*p = 0;
        -: 1360:	}
    #####: 1361:	ctx->tpath.top = 0;
        -: 1362:
        -: 1363:	for (;;)
    #####: 1364:	{
    #####: 1365:		if (ctx->tpath.top >= 10)
    #####: 1366:			return e_syntax(
        -: 1367:			    ctx, lineno,
        -: 1368:			    "table path is too deep; max allowed is 10.");
        -: 1369:
    #####: 1370:		if (ctx->tok.tok != STRING)
    #####: 1371:			return e_syntax(ctx, lineno, "invalid or missing key");
        -: 1372:
    #####: 1373:		char* key = normalize_key(ctx, ctx->tok);
    #####: 1374:		if (!key)
    #####: 1375:			return -1;
    #####: 1376:		ctx->tpath.tok[ctx->tpath.top] = ctx->tok;
    #####: 1377:		ctx->tpath.key[ctx->tpath.top] = key;
    #####: 1378:		ctx->tpath.top++;
        -: 1379:
    #####: 1380:		if (next_token(ctx, 1))
    #####: 1381:			return -1;
        -: 1382:
    #####: 1383:		if (ctx->tok.tok == RBRACKET)
    #####: 1384:			break;
        -: 1385:
    #####: 1386:		if (ctx->tok.tok != DOT)
    #####: 1387:			return e_syntax(ctx, lineno, "invalid key");
        -: 1388:
    #####: 1389:		if (next_token(ctx, 1))
    #####: 1390:			return -1;
        -: 1391:	}
        -: 1392:
    #####: 1393:	if (ctx->tpath.top <= 0)
    #####: 1394:		return e_syntax(ctx, lineno, "empty table selector");
        -: 1395:
    #####: 1396:	return 0;
        -: 1397:}
        -: 1398:
        -: 1399:/* Walk tabpath from the root, and create new tables on the way.
        -: 1400: * Sets ctx->curtab to the final table.
        -: 1401: */
    #####: 1402:static int walk_tabpath(context_t* ctx)
        -: 1403:{
        -: 1404:	/* start from root */
    #####: 1405:	toml_table_t* curtab = ctx->root;
        -: 1406:
    #####: 1407:	for (int i = 0; i < ctx->tpath.top; i++)
        -: 1408:	{
    #####: 1409:		const char* key = ctx->tpath.key[i];
        -: 1410:
    #####: 1411:		toml_keyval_t* nextval = 0;
    #####: 1412:		toml_array_t* nextarr = 0;
    #####: 1413:		toml_table_t* nexttab = 0;
    #####: 1414:		switch (check_key(curtab, key, &nextval, &nextarr, &nexttab))
        -: 1415:		{
    #####: 1416:		case 't':
        -: 1417:			/* found a table. nexttab is where we will go next. */
    #####: 1418:			break;
        -: 1419:
    #####: 1420:		case 'a':
        -: 1421:			/* found an array. nexttab is the last table in the
        -: 1422:			 * array. */
    #####: 1423:			if (nextarr->kind != 't')
    #####: 1424:				return e_internal(ctx, FLINE);
        -: 1425:
    #####: 1426:			if (nextarr->nitem == 0)
    #####: 1427:				return e_internal(ctx, FLINE);
        -: 1428:
    #####: 1429:			nexttab = nextarr->item[nextarr->nitem - 1].tab;
    #####: 1430:			break;
        -: 1431:
    #####: 1432:		case 'v':
    #####: 1433:			return e_keyexists(ctx, ctx->tpath.tok[i].lineno);
        -: 1434:
    #####: 1435:		default:
        -: 1436:		{ /* Not found. Let's create an implicit table. */
    #####: 1437:			int n = curtab->ntab;
    #####: 1438:			toml_table_t** base = (toml_table_t**)expand_ptrarr(
    #####: 1439:			    (void**)curtab->tab, n);
    #####: 1440:			if (0 == base)
    #####: 1441:				return e_outofmemory(ctx, FLINE);
        -: 1442:
    #####: 1443:			curtab->tab = base;
        -: 1444:
    #####: 1445:			if (0 == (base[n] = (toml_table_t*)CALLOC(1, sizeof(*base[n]))))
    #####: 1446:				return e_outofmemory(ctx, FLINE);
        -: 1447:
    #####: 1448:			if (0 == (base[n]->key = STRDUP(key)))
    #####: 1449:				return e_outofmemory(ctx, FLINE);
        -: 1450:
    #####: 1451:			nexttab = curtab->tab[curtab->ntab++];
        -: 1452:
        -: 1453:			/* tabs created by walk_tabpath are considered implicit
        -: 1454:			 */
    #####: 1455:			nexttab->implicit = true;
        -: 1456:		}
    #####: 1457:		break;
        -: 1458:		}
        -: 1459:
        -: 1460:		/* switch to next tab */
    #####: 1461:		curtab = nexttab;
        -: 1462:	}
        -: 1463:
        -: 1464:	/* save it */
    #####: 1465:	ctx->curtab = curtab;
        -: 1466:
    #####: 1467:	return 0;
        -: 1468:}
        -: 1469:
        -: 1470:/* handle lines like [x.y.z] or [[x.y.z]] */
    #####: 1471:static int parse_select(context_t* ctx)
        -: 1472:{
    #####: 1473:	assert(ctx->tok.tok == LBRACKET);
        -: 1474:
        -: 1475:	/* true if [[ */
    #####: 1476:	int llb = (ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == '[');
        -: 1477:	/* need to detect '[[' on our own because next_token() will skip
        -: 1478:	   whitespace, and '[ [' would be taken as '[[', which is wrong. */
        -: 1479:
        -: 1480:	/* eat [ or [[ */
    #####: 1481:	if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1482:		return -1;
    #####: 1483:	if (llb)
        -: 1484:	{
    #####: 1485:		assert(ctx->tok.tok == LBRACKET);
    #####: 1486:		if (eat_token(ctx, LBRACKET, 1, FLINE))
    #####: 1487:			return -1;
        -: 1488:	}
        -: 1489:
    #####: 1490:	if (fill_tabpath(ctx))
    #####: 1491:		return -1;
        -: 1492:
        -: 1493:	/* For [x.y.z] or [[x.y.z]], remove z from tpath.
        -: 1494:	 */
    #####: 1495:	token_t z = ctx->tpath.tok[ctx->tpath.top - 1];
    #####: 1496:	xfree(ctx->tpath.key[ctx->tpath.top - 1]);
    #####: 1497:	ctx->tpath.top--;
        -: 1498:
        -: 1499:	/* set up ctx->curtab */
    #####: 1500:	if (walk_tabpath(ctx))
    #####: 1501:		return -1;
        -: 1502:
    #####: 1503:	if (!llb)
        -: 1504:	{
        -: 1505:		/* [x.y.z] -> create z = {} in x.y */
        -: 1506:		toml_table_t* curtab =
    #####: 1507:		    create_keytable_in_table(ctx, ctx->curtab, z);
    #####: 1508:		if (!curtab)
    #####: 1509:			return -1;
    #####: 1510:		ctx->curtab = curtab;
        -: 1511:	}
        -: 1512:	else
        -: 1513:	{
        -: 1514:		/* [[x.y.z]] -> create z = [] in x.y */
    #####: 1515:		toml_array_t* arr = 0;
        -: 1516:		{
    #####: 1517:			char* zstr = normalize_key(ctx, z);
    #####: 1518:			if (!zstr)
    #####: 1519:				return -1;
    #####: 1520:			arr = toml_array_in(ctx->curtab, zstr);
    #####: 1521:			xfree(zstr);
        -: 1522:		}
    #####: 1523:		if (!arr)
        -: 1524:		{
        -: 1525:			arr =
    #####: 1526:			    create_keyarray_in_table(ctx, ctx->curtab, z, 't');
    #####: 1527:			if (!arr)
    #####: 1528:				return -1;
        -: 1529:		}
    #####: 1530:		if (arr->kind != 't')
    #####: 1531:			return e_syntax(ctx, z.lineno, "array mismatch");
        -: 1532:
        -: 1533:		/* add to z[] */
        -: 1534:		toml_table_t* dest;
        -: 1535:		{
    #####: 1536:			toml_table_t* t = create_table_in_array(ctx, arr);
    #####: 1537:			if (!t)
    #####: 1538:				return -1;
        -: 1539:
    #####: 1540:			if (0 == (t->key = STRDUP("__anon__")))
    #####: 1541:				return e_outofmemory(ctx, FLINE);
        -: 1542:
    #####: 1543:			dest = t;
        -: 1544:		}
        -: 1545:
    #####: 1546:		ctx->curtab = dest;
        -: 1547:	}
        -: 1548:
    #####: 1549:	if (ctx->tok.tok != RBRACKET)
        -: 1550:	{
    #####: 1551:		return e_syntax(ctx, ctx->tok.lineno, "expects ]");
        -: 1552:	}
    #####: 1553:	if (llb)
        -: 1554:	{
    #####: 1555:		if (!(ctx->tok.ptr + 1 < ctx->stop && ctx->tok.ptr[1] == ']'))
        -: 1556:		{
    #####: 1557:			return e_syntax(ctx, ctx->tok.lineno, "expects ]]");
        -: 1558:		}
    #####: 1559:		if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1560:			return -1;
        -: 1561:	}
        -: 1562:
    #####: 1563:	if (eat_token(ctx, RBRACKET, 1, FLINE))
    #####: 1564:		return -1;
        -: 1565:
    #####: 1566:	if (ctx->tok.tok != NEWLINE)
    #####: 1567:		return e_syntax(ctx, ctx->tok.lineno,
        -: 1568:				"extra chars after ] or ]]");
        -: 1569:
    #####: 1570:	return 0;
        -: 1571:}
        -: 1572:
    #####: 1573:toml_table_t* toml_parse(char* conf, char* errbuf, int errbufsz)
        -: 1574:{
        -: 1575:	context_t ctx;
        -: 1576:
        -: 1577:	// clear errbuf
    #####: 1578:	if (errbufsz <= 0)
    #####: 1579:		errbufsz = 0;
    #####: 1580:	if (errbufsz > 0)
    #####: 1581:		errbuf[0] = 0;
        -: 1582:
        -: 1583:	// init context
    #####: 1584:	memset(&ctx, 0, sizeof(ctx));
    #####: 1585:	ctx.start = conf;
    #####: 1586:	ctx.stop = ctx.start + strlen(conf);
    #####: 1587:	ctx.errbuf = errbuf;
    #####: 1588:	ctx.errbufsz = errbufsz;
        -: 1589:
        -: 1590:	// start with an artificial newline of length 0
    #####: 1591:	ctx.tok.tok = NEWLINE;
    #####: 1592:	ctx.tok.lineno = 1;
    #####: 1593:	ctx.tok.ptr = conf;
    #####: 1594:	ctx.tok.len = 0;
        -: 1595:
        -: 1596:	// make a root table
    #####: 1597:	if (0 == (ctx.root = CALLOC(1, sizeof(*ctx.root))))
        -: 1598:	{
    #####: 1599:		e_outofmemory(&ctx, FLINE);
        -: 1600:		// Do not goto fail, root table not set up yet
    #####: 1601:		return 0;
        -: 1602:	}
        -: 1603:
        -: 1604:	// set root as default table
    #####: 1605:	ctx.curtab = ctx.root;
        -: 1606:
        -: 1607:	/* Scan forward until EOF */
    #####: 1608:	for (token_t tok = ctx.tok; !tok.eof; tok = ctx.tok)
        -: 1609:	{
    #####: 1610:		switch (tok.tok)
        -: 1611:		{
        -: 1612:
    #####: 1613:		case NEWLINE:
    #####: 1614:			if (next_token(&ctx, 1))
    #####: 1615:				goto fail;
    #####: 1616:			break;
        -: 1617:
    #####: 1618:		case STRING:
    #####: 1619:			if (parse_keyval(&ctx, ctx.curtab))
    #####: 1620:				goto fail;
        -: 1621:
    #####: 1622:			if (ctx.tok.tok != NEWLINE)
        -: 1623:			{
    #####: 1624:				e_syntax(&ctx, ctx.tok.lineno,
        -: 1625:					 "extra chars after value");
    #####: 1626:				goto fail;
        -: 1627:			}
        -: 1628:
    #####: 1629:			if (eat_token(&ctx, NEWLINE, 1, FLINE))
    #####: 1630:				goto fail;
    #####: 1631:			break;
        -: 1632:
    #####: 1633:		case LBRACKET: /* [ x.y.z ] or [[ x.y.z ]] */
    #####: 1634:			if (parse_select(&ctx))
    #####: 1635:				goto fail;
    #####: 1636:			break;
        -: 1637:
    #####: 1638:		default:
    #####: 1639:			e_syntax(&ctx, tok.lineno, "syntax error");
    #####: 1640:			goto fail;
        -: 1641:		}
        -: 1642:	}
        -: 1643:
        -: 1644:	/* success */
    #####: 1645:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1646:		xfree(ctx.tpath.key[i]);
    #####: 1647:	return ctx.root;
        -: 1648:
    #####: 1649:fail:
        -: 1650:	// Something bad has happened. Free resources and return error.
    #####: 1651:	for (int i = 0; i < ctx.tpath.top; i++)
    #####: 1652:		xfree(ctx.tpath.key[i]);
    #####: 1653:	toml_free(ctx.root);
    #####: 1654:	return 0;
        -: 1655:}
        -: 1656:
    #####: 1657:toml_table_t* toml_parse_file(FILE* fp, char* errbuf, int errbufsz)
        -: 1658:{
    #####: 1659:	int bufsz = 0;
    #####: 1660:	char* buf = 0;
    #####: 1661:	int off = 0;
        -: 1662:
        -: 1663:	/* read from fp into buf */
    #####: 1664:	while (!feof(fp))
        -: 1665:	{
        -: 1666:
    #####: 1667:		if (off == bufsz)
        -: 1668:		{
    #####: 1669:			int xsz = bufsz + 1000;
    #####: 1670:			char* x = expand(buf, bufsz, xsz);
    #####: 1671:			if (!x)
        -: 1672:			{
    #####: 1673:				snprintf(errbuf, errbufsz, "out of memory");
    #####: 1674:				xfree(buf);
    #####: 1675:				return 0;
        -: 1676:			}
    #####: 1677:			buf = x;
    #####: 1678:			bufsz = xsz;
        -: 1679:		}
        -: 1680:
    #####: 1681:		errno = 0;
    #####: 1682:		int n = fread(buf + off, 1, bufsz - off, fp);
    #####: 1683:		if (ferror(fp))
        -: 1684:		{
    #####: 1685:			snprintf(errbuf, errbufsz, "%s",
    #####: 1686:				 errno ? strerror(errno)
        -: 1687:				       : "Error reading file");
    #####: 1688:			xfree(buf);
    #####: 1689:			return 0;
        -: 1690:		}
    #####: 1691:		off += n;
        -: 1692:	}
        -: 1693:
        -: 1694:	/* tag on a NUL to cap the string */
    #####: 1695:	if (off == bufsz)
        -: 1696:	{
    #####: 1697:		int xsz = bufsz + 1;
    #####: 1698:		char* x = expand(buf, bufsz, xsz);
    #####: 1699:		if (!x)
        -: 1700:		{
    #####: 1701:			snprintf(errbuf, errbufsz, "out of memory");
    #####: 1702:			xfree(buf);
    #####: 1703:			return 0;
        -: 1704:		}
    #####: 1705:		buf = x;
    #####: 1706:		bufsz = xsz;
        -: 1707:	}
    #####: 1708:	buf[off] = 0;
        -: 1709:
        -: 1710:	/* parse it, cleanup and finish */
    #####: 1711:	toml_table_t* ret = toml_parse(buf, errbuf, errbufsz);
    #####: 1712:	xfree(buf);
    #####: 1713:	return ret;
        -: 1714:}
        -: 1715:
    #####: 1716:static void xfree_kval(toml_keyval_t* p)
        -: 1717:{
    #####: 1718:	if (!p)
    #####: 1719:		return;
    #####: 1720:	xfree(p->key);
    #####: 1721:	xfree(p->val);
    #####: 1722:	xfree(p);
        -: 1723:}
        -: 1724:
        -: 1725:static void xfree_tab(toml_table_t* p);
        -: 1726:
    #####: 1727:static void xfree_arr(toml_array_t* p)
        -: 1728:{
    #####: 1729:	if (!p)
    #####: 1730:		return;
        -: 1731:
    #####: 1732:	xfree(p->key);
    #####: 1733:	const int n = p->nitem;
    #####: 1734:	for (int i = 0; i < n; i++)
        -: 1735:	{
    #####: 1736:		toml_arritem_t* a = &p->item[i];
    #####: 1737:		if (a->val)
    #####: 1738:			xfree(a->val);
    #####: 1739:		else if (a->arr)
    #####: 1740:			xfree_arr(a->arr);
    #####: 1741:		else if (a->tab)
    #####: 1742:			xfree_tab(a->tab);
        -: 1743:	}
    #####: 1744:	xfree(p->item);
    #####: 1745:	xfree(p);
        -: 1746:}
        -: 1747:
    #####: 1748:static void xfree_tab(toml_table_t* p)
        -: 1749:{
        -: 1750:	int i;
        -: 1751:
    #####: 1752:	if (!p)
    #####: 1753:		return;
        -: 1754:
    #####: 1755:	xfree(p->key);
        -: 1756:
    #####: 1757:	for (i = 0; i < p->nkval; i++)
    #####: 1758:		xfree_kval(p->kval[i]);
    #####: 1759:	xfree(p->kval);
        -: 1760:
    #####: 1761:	for (i = 0; i < p->narr; i++)
    #####: 1762:		xfree_arr(p->arr[i]);
    #####: 1763:	xfree(p->arr);
        -: 1764:
    #####: 1765:	for (i = 0; i < p->ntab; i++)
    #####: 1766:		xfree_tab(p->tab[i]);
    #####: 1767:	xfree(p->tab);
        -: 1768:
    #####: 1769:	xfree(p);
        -: 1770:}
        -: 1771:
    #####: 1772:void toml_free(toml_table_t* tab) { xfree_tab(tab); }
        -: 1773:
    #####: 1774:static void set_token(context_t* ctx, tokentype_t tok, int lineno, char* ptr,
        -: 1775:		      int len)
        -: 1776:{
        -: 1777:	token_t t;
    #####: 1778:	t.tok = tok;
    #####: 1779:	t.lineno = lineno;
    #####: 1780:	t.ptr = ptr;
    #####: 1781:	t.len = len;
    #####: 1782:	t.eof = 0;
    #####: 1783:	ctx->tok = t;
    #####: 1784:}
        -: 1785:
    #####: 1786:static void set_eof(context_t* ctx, int lineno)
        -: 1787:{
    #####: 1788:	set_token(ctx, NEWLINE, lineno, ctx->stop, 0);
    #####: 1789:	ctx->tok.eof = 1;
    #####: 1790:}
        -: 1791:
        -: 1792:/* Scan p for n digits compositing entirely of [0-9] */
    #####: 1793:static int scan_digits(const char* p, int n)
        -: 1794:{
    #####: 1795:	int ret = 0;
    #####: 1796:	for (; n > 0 && isdigit(*p); n--, p++)
        -: 1797:	{
    #####: 1798:		ret = 10 * ret + (*p - '0');
        -: 1799:	}
    #####: 1800:	return n ? -1 : ret;
        -: 1801:}
        -: 1802:
    #####: 1803:static int scan_date(const char* p, int* YY, int* MM, int* DD)
        -: 1804:{
        -: 1805:	int year, month, day;
    #####: 1806:	year = scan_digits(p, 4);
    #####: 1807:	month = (year >= 0 && p[4] == '-') ? scan_digits(p + 5, 2) : -1;
    #####: 1808:	day = (month >= 0 && p[7] == '-') ? scan_digits(p + 8, 2) : -1;
    #####: 1809:	if (YY)
    #####: 1810:		*YY = year;
    #####: 1811:	if (MM)
    #####: 1812:		*MM = month;
    #####: 1813:	if (DD)
    #####: 1814:		*DD = day;
    #####: 1815:	return (year >= 0 && month >= 0 && day >= 0) ? 0 : -1;
        -: 1816:}
        -: 1817:
    #####: 1818:static int scan_time(const char* p, int* hh, int* mm, int* ss)
        -: 1819:{
        -: 1820:	int hour, minute, second;
    #####: 1821:	hour = scan_digits(p, 2);
    #####: 1822:	minute = (hour >= 0 && p[2] == ':') ? scan_digits(p + 3, 2) : -1;
    #####: 1823:	second = (minute >= 0 && p[5] == ':') ? scan_digits(p + 6, 2) : -1;
    #####: 1824:	if (hh)
    #####: 1825:		*hh = hour;
    #####: 1826:	if (mm)
    #####: 1827:		*mm = minute;
    #####: 1828:	if (ss)
    #####: 1829:		*ss = second;
    #####: 1830:	return (hour >= 0 && minute >= 0 && second >= 0) ? 0 : -1;
        -: 1831:}
        -: 1832:
    #####: 1833:static int scan_string(context_t* ctx, char* p, int lineno, int dotisspecial)
        -: 1834:{
    #####: 1835:	char* orig = p;
    #####: 1836:	if (0 == strncmp(p, "'''", 3))
        -: 1837:	{
    #####: 1838:		char* q = p + 3;
        -: 1839:
        -: 1840:		while (1)
        -: 1841:		{
    #####: 1842:			q = strstr(q, "'''");
    #####: 1843:			if (0 == q)
        -: 1844:			{
    #####: 1845:				return e_syntax(ctx, lineno,
        -: 1846:						"unterminated triple-s-quote");
        -: 1847:			}
    #####: 1848:			while (q[3] == '\'')
    #####: 1849:				q++;
    #####: 1850:			break;
        -: 1851:		}
        -: 1852:
    #####: 1853:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1854:		return 0;
        -: 1855:	}
        -: 1856:
    #####: 1857:	if (0 == strncmp(p, "\"\"\"", 3))
        -: 1858:	{
    #####: 1859:		char* q = p + 3;
        -: 1860:
        -: 1861:		while (1)
        -: 1862:		{
    #####: 1863:			q = strstr(q, "\"\"\"");
    #####: 1864:			if (0 == q)
        -: 1865:			{
    #####: 1866:				return e_syntax(ctx, lineno,
        -: 1867:						"unterminated triple-d-quote");
        -: 1868:			}
    #####: 1869:			if (q[-1] == '\\')
        -: 1870:			{
    #####: 1871:				q++;
    #####: 1872:				continue;
        -: 1873:			}
    #####: 1874:			while (q[3] == '\"')
    #####: 1875:				q++;
    #####: 1876:			break;
        -: 1877:		}
        -: 1878:
        -: 1879:		// the string is [p+3, q-1]
        -: 1880:
    #####: 1881:		int hexreq = 0; /* #hex required */
    #####: 1882:		int escape = 0;
    #####: 1883:		for (p += 3; p < q; p++)
        -: 1884:		{
    #####: 1885:			if (escape)
        -: 1886:			{
    #####: 1887:				escape = 0;
    #####: 1888:				if (strchr("btnfr\"\\", *p))
    #####: 1889:					continue;
    #####: 1890:				if (*p == 'u')
        -: 1891:				{
    #####: 1892:					hexreq = 4;
    #####: 1893:					continue;
        -: 1894:				}
    #####: 1895:				if (*p == 'U')
        -: 1896:				{
    #####: 1897:					hexreq = 8;
    #####: 1898:					continue;
        -: 1899:				}
    #####: 1900:				if (p[strspn(p, " \t\r")] == '\n')
    #####: 1901:					continue; /* allow for line ending
        -: 1902:						     backslash */
    #####: 1903:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1904:			}
    #####: 1905:			if (hexreq)
        -: 1906:			{
    #####: 1907:				hexreq--;
    #####: 1908:				if (strchr("0123456789ABCDEF", *p))
    #####: 1909:					continue;
    #####: 1910:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1911:			}
    #####: 1912:			if (*p == '\\')
        -: 1913:			{
    #####: 1914:				escape = 1;
    #####: 1915:				continue;
        -: 1916:			}
        -: 1917:		}
    #####: 1918:		if (escape)
    #####: 1919:			return e_syntax(ctx, lineno, "expect an escape char");
    #####: 1920:		if (hexreq)
    #####: 1921:			return e_syntax(ctx, lineno, "expected more hex char");
        -: 1922:
    #####: 1923:		set_token(ctx, STRING, lineno, orig, q + 3 - orig);
    #####: 1924:		return 0;
        -: 1925:	}
        -: 1926:
    #####: 1927:	if ('\'' == *p)
        -: 1928:	{
    #####: 1929:		for (p++; *p && *p != '\n' && *p != '\''; p++)
        -: 1930:			;
    #####: 1931:		if (*p != '\'')
        -: 1932:		{
    #####: 1933:			return e_syntax(ctx, lineno, "unterminated s-quote");
        -: 1934:		}
        -: 1935:
    #####: 1936:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1937:		return 0;
        -: 1938:	}
        -: 1939:
    #####: 1940:	if ('\"' == *p)
        -: 1941:	{
    #####: 1942:		int hexreq = 0; /* #hex required */
    #####: 1943:		int escape = 0;
    #####: 1944:		for (p++; *p; p++)
        -: 1945:		{
    #####: 1946:			if (escape)
        -: 1947:			{
    #####: 1948:				escape = 0;
    #####: 1949:				if (strchr("btnfr\"\\", *p))
    #####: 1950:					continue;
    #####: 1951:				if (*p == 'u')
        -: 1952:				{
    #####: 1953:					hexreq = 4;
    #####: 1954:					continue;
        -: 1955:				}
    #####: 1956:				if (*p == 'U')
        -: 1957:				{
    #####: 1958:					hexreq = 8;
    #####: 1959:					continue;
        -: 1960:				}
    #####: 1961:				return e_syntax(ctx, lineno, "bad escape char");
        -: 1962:			}
    #####: 1963:			if (hexreq)
        -: 1964:			{
    #####: 1965:				hexreq--;
    #####: 1966:				if (strchr("0123456789ABCDEF", *p))
    #####: 1967:					continue;
    #####: 1968:				return e_syntax(ctx, lineno, "expect hex char");
        -: 1969:			}
    #####: 1970:			if (*p == '\\')
        -: 1971:			{
    #####: 1972:				escape = 1;
    #####: 1973:				continue;
        -: 1974:			}
    #####: 1975:			if (*p == '\'')
        -: 1976:			{
    #####: 1977:				if (p[1] == '\'' && p[2] == '\'')
        -: 1978:				{
    #####: 1979:					return e_syntax(
        -: 1980:					    ctx, lineno,
        -: 1981:					    "triple-s-quote inside string lit");
        -: 1982:				}
    #####: 1983:				continue;
        -: 1984:			}
    #####: 1985:			if (*p == '\n')
    #####: 1986:				break;
    #####: 1987:			if (*p == '"')
    #####: 1988:				break;
        -: 1989:		}
    #####: 1990:		if (*p != '"')
        -: 1991:		{
    #####: 1992:			return e_syntax(ctx, lineno, "unterminated quote");
        -: 1993:		}
        -: 1994:
    #####: 1995:		set_token(ctx, STRING, lineno, orig, p + 1 - orig);
    #####: 1996:		return 0;
        -: 1997:	}
        -: 1998:
        -: 1999:	/* check for timestamp without quotes */
    #####: 2000:	if (0 == scan_date(p, 0, 0, 0) || 0 == scan_time(p, 0, 0, 0))
        -: 2001:	{
        -: 2002:		// forward thru the timestamp
    #####: 2003:		p += strspn(p, "0123456789.:+-Tt Zz");
        -: 2004:		// squeeze out any spaces at end of string
    #####: 2005:		for (; p[-1] == ' '; p--)
        -: 2006:			;
        -: 2007:		// tokenize
    #####: 2008:		set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 2009:		return 0;
        -: 2010:	}
        -: 2011:
        -: 2012:	/* literals */
    #####: 2013:	for (; *p && *p != '\n'; p++)
        -: 2014:	{
    #####: 2015:		int ch = *p;
    #####: 2016:		if (ch == '.' && dotisspecial)
    #####: 2017:			break;
    #####: 2018:		if ('A' <= ch && ch <= 'Z')
    #####: 2019:			continue;
    #####: 2020:		if ('a' <= ch && ch <= 'z')
    #####: 2021:			continue;
    #####: 2022:		if (strchr("0123456789+-_.", ch))
    #####: 2023:			continue;
    #####: 2024:		break;
        -: 2025:	}
        -: 2026:
    #####: 2027:	set_token(ctx, STRING, lineno, orig, p - orig);
    #####: 2028:	return 0;
        -: 2029:}
        -: 2030:
    #####: 2031:static int next_token(context_t* ctx, int dotisspecial)
        -: 2032:{
    #####: 2033:	int lineno = ctx->tok.lineno;
    #####: 2034:	char* p = ctx->tok.ptr;
        -: 2035:	int i;
        -: 2036:
        -: 2037:	/* eat this tok */
    #####: 2038:	for (i = 0; i < ctx->tok.len; i++)
        -: 2039:	{
    #####: 2040:		if (*p++ == '\n')
    #####: 2041:			lineno++;
        -: 2042:	}
        -: 2043:
        -: 2044:	/* make next tok */
    #####: 2045:	while (p < ctx->stop)
        -: 2046:	{
        -: 2047:		/* skip comment. stop just before the \n. */
    #####: 2048:		if (*p == '#')
        -: 2049:		{
    #####: 2050:			for (p++; p < ctx->stop && *p != '\n'; p++)
        -: 2051:				;
    #####: 2052:			continue;
        -: 2053:		}
        -: 2054:
    #####: 2055:		if (dotisspecial && *p == '.')
        -: 2056:		{
    #####: 2057:			set_token(ctx, DOT, lineno, p, 1);
    #####: 2058:			return 0;
        -: 2059:		}
        -: 2060:
    #####: 2061:		switch (*p)
        -: 2062:		{
    #####: 2063:		case ',':
    #####: 2064:			set_token(ctx, COMMA, lineno, p, 1);
    #####: 2065:			return 0;
    #####: 2066:		case '=':
    #####: 2067:			set_token(ctx, EQUAL, lineno, p, 1);
    #####: 2068:			return 0;
    #####: 2069:		case '{':
    #####: 2070:			set_token(ctx, LBRACE, lineno, p, 1);
    #####: 2071:			return 0;
    #####: 2072:		case '}':
    #####: 2073:			set_token(ctx, RBRACE, lineno, p, 1);
    #####: 2074:			return 0;
    #####: 2075:		case '[':
    #####: 2076:			set_token(ctx, LBRACKET, lineno, p, 1);
    #####: 2077:			return 0;
    #####: 2078:		case ']':
    #####: 2079:			set_token(ctx, RBRACKET, lineno, p, 1);
    #####: 2080:			return 0;
    #####: 2081:		case '\n':
    #####: 2082:			set_token(ctx, NEWLINE, lineno, p, 1);
    #####: 2083:			return 0;
    #####: 2084:		case '\r':
        -: 2085:		case ' ':
        -: 2086:		case '\t':
        -: 2087:			/* ignore white spaces */
    #####: 2088:			p++;
    #####: 2089:			continue;
        -: 2090:		}
        -: 2091:
    #####: 2092:		return scan_string(ctx, p, lineno, dotisspecial);
        -: 2093:	}
        -: 2094:
    #####: 2095:	set_eof(ctx, lineno);
    #####: 2096:	return 0;
        -: 2097:}
        -: 2098:
    #####: 2099:const char* toml_key_in(const toml_table_t* tab, int keyidx)
        -: 2100:{
    #####: 2101:	if (keyidx < tab->nkval)
    #####: 2102:		return tab->kval[keyidx]->key;
        -: 2103:
    #####: 2104:	keyidx -= tab->nkval;
    #####: 2105:	if (keyidx < tab->narr)
    #####: 2106:		return tab->arr[keyidx]->key;
        -: 2107:
    #####: 2108:	keyidx -= tab->narr;
    #####: 2109:	if (keyidx < tab->ntab)
    #####: 2110:		return tab->tab[keyidx]->key;
        -: 2111:
    #####: 2112:	return 0;
        -: 2113:}
        -: 2114:
    #####: 2115:int toml_key_exists(const toml_table_t* tab, const char* key)
        -: 2116:{
        -: 2117:	int i;
    #####: 2118:	for (i = 0; i < tab->nkval; i++)
        -: 2119:	{
    #####: 2120:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 2121:			return 1;
        -: 2122:	}
    #####: 2123:	for (i = 0; i < tab->narr; i++)
        -: 2124:	{
    #####: 2125:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 2126:			return 1;
        -: 2127:	}
    #####: 2128:	for (i = 0; i < tab->ntab; i++)
        -: 2129:	{
    #####: 2130:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 2131:			return 1;
        -: 2132:	}
    #####: 2133:	return 0;
        -: 2134:}
        -: 2135:
    #####: 2136:toml_raw_t toml_raw_in(const toml_table_t* tab, const char* key)
        -: 2137:{
        -: 2138:	int i;
    #####: 2139:	for (i = 0; i < tab->nkval; i++)
        -: 2140:	{
    #####: 2141:		if (0 == strcmp(key, tab->kval[i]->key))
    #####: 2142:			return tab->kval[i]->val;
        -: 2143:	}
    #####: 2144:	return 0;
        -: 2145:}
        -: 2146:
    #####: 2147:toml_array_t* toml_array_in(const toml_table_t* tab, const char* key)
        -: 2148:{
        -: 2149:	int i;
    #####: 2150:	for (i = 0; i < tab->narr; i++)
        -: 2151:	{
    #####: 2152:		if (0 == strcmp(key, tab->arr[i]->key))
    #####: 2153:			return tab->arr[i];
        -: 2154:	}
    #####: 2155:	return 0;
        -: 2156:}
        -: 2157:
    #####: 2158:toml_table_t* toml_table_in(const toml_table_t* tab, const char* key)
        -: 2159:{
        -: 2160:	int i;
    #####: 2161:	for (i = 0; i < tab->ntab; i++)
        -: 2162:	{
    #####: 2163:		if (0 == strcmp(key, tab->tab[i]->key))
    #####: 2164:			return tab->tab[i];
        -: 2165:	}
    #####: 2166:	return 0;
        -: 2167:}
        -: 2168:
    #####: 2169:toml_raw_t toml_raw_at(const toml_array_t* arr, int idx)
        -: 2170:{
    #####: 2171:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].val : 0;
        -: 2172:}
        -: 2173:
    #####: 2174:char toml_array_kind(const toml_array_t* arr) { return arr->kind; }
        -: 2175:
    #####: 2176:char toml_array_type(const toml_array_t* arr)
        -: 2177:{
    #####: 2178:	if (arr->kind != 'v')
    #####: 2179:		return 0;
        -: 2180:
    #####: 2181:	if (arr->nitem == 0)
    #####: 2182:		return 0;
        -: 2183:
    #####: 2184:	return arr->type;
        -: 2185:}
        -: 2186:
    #####: 2187:int toml_array_nelem(const toml_array_t* arr) { return arr->nitem; }
        -: 2188:
    #####: 2189:const char* toml_array_key(const toml_array_t* arr)
        -: 2190:{
    #####: 2191:	return arr ? arr->key : (const char*)NULL;
        -: 2192:}
        -: 2193:
    #####: 2194:int toml_table_nkval(const toml_table_t* tab) { return tab->nkval; }
        -: 2195:
    #####: 2196:int toml_table_narr(const toml_table_t* tab) { return tab->narr; }
        -: 2197:
    #####: 2198:int toml_table_ntab(const toml_table_t* tab) { return tab->ntab; }
        -: 2199:
    #####: 2200:const char* toml_table_key(const toml_table_t* tab)
        -: 2201:{
    #####: 2202:	return tab ? tab->key : (const char*)NULL;
        -: 2203:}
        -: 2204:
    #####: 2205:toml_array_t* toml_array_at(const toml_array_t* arr, int idx)
        -: 2206:{
    #####: 2207:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].arr : 0;
        -: 2208:}
        -: 2209:
    #####: 2210:toml_table_t* toml_table_at(const toml_array_t* arr, int idx)
        -: 2211:{
    #####: 2212:	return (0 <= idx && idx < arr->nitem) ? arr->item[idx].tab : 0;
        -: 2213:}
        -: 2214:
        -: 2215:static int parse_millisec(const char* p, const char** endp);
        -: 2216:
    #####: 2217:int toml_rtots(toml_raw_t src_, toml_timestamp_t* ret)
        -: 2218:{
    #####: 2219:	if (!src_)
    #####: 2220:		return -1;
        -: 2221:
    #####: 2222:	const char* p = src_;
    #####: 2223:	int must_parse_time = 0;
        -: 2224:
    #####: 2225:	memset(ret, 0, sizeof(*ret));
        -: 2226:
    #####: 2227:	int* year = &ret->__buffer.year;
    #####: 2228:	int* month = &ret->__buffer.month;
    #####: 2229:	int* day = &ret->__buffer.day;
    #####: 2230:	int* hour = &ret->__buffer.hour;
    #####: 2231:	int* minute = &ret->__buffer.minute;
    #####: 2232:	int* second = &ret->__buffer.second;
    #####: 2233:	int* millisec = &ret->__buffer.millisec;
        -: 2234:
        -: 2235:	/* parse date YYYY-MM-DD */
    #####: 2236:	if (0 == scan_date(p, year, month, day))
        -: 2237:	{
    #####: 2238:		ret->year = year;
    #####: 2239:		ret->month = month;
    #####: 2240:		ret->day = day;
        -: 2241:
    #####: 2242:		p += 10;
    #####: 2243:		if (*p)
        -: 2244:		{
        -: 2245:			// parse the T or space separator
    #####: 2246:			if (*p != 'T' && *p != 't' && *p != ' ')
    #####: 2247:				return -1;
    #####: 2248:			must_parse_time = 1;
    #####: 2249:			p++;
        -: 2250:		}
        -: 2251:	}
        -: 2252:
        -: 2253:	/* parse time HH:MM:SS */
    #####: 2254:	if (0 == scan_time(p, hour, minute, second))
        -: 2255:	{
    #####: 2256:		ret->hour = hour;
    #####: 2257:		ret->minute = minute;
    #####: 2258:		ret->second = second;
        -: 2259:
        -: 2260:		/* optionally, parse millisec */
    #####: 2261:		p += 8;
    #####: 2262:		if (*p == '.')
        -: 2263:		{
    #####: 2264:			p++; /* skip '.' */
        -: 2265:			const char* qq;
    #####: 2266:			*millisec = parse_millisec(p, &qq);
    #####: 2267:			ret->millisec = millisec;
    #####: 2268:			p = qq;
        -: 2269:		}
        -: 2270:
    #####: 2271:		if (*p)
        -: 2272:		{
        -: 2273:			/* parse and copy Z */
    #####: 2274:			char* z = ret->__buffer.z;
    #####: 2275:			ret->z = z;
    #####: 2276:			if (*p == 'Z' || *p == 'z')
        -: 2277:			{
    #####: 2278:				*z++ = 'Z';
    #####: 2279:				p++;
    #####: 2280:				*z = 0;
        -: 2281:			}
    #####: 2282:			else if (*p == '+' || *p == '-')
        -: 2283:			{
    #####: 2284:				*z++ = *p++;
        -: 2285:
    #####: 2286:				if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2287:					return -1;
    #####: 2288:				*z++ = *p++;
    #####: 2289:				*z++ = *p++;
        -: 2290:
    #####: 2291:				if (*p == ':')
        -: 2292:				{
    #####: 2293:					*z++ = *p++;
        -: 2294:
    #####: 2295:					if (!(isdigit(p[0]) && isdigit(p[1])))
    #####: 2296:						return -1;
    #####: 2297:					*z++ = *p++;
    #####: 2298:					*z++ = *p++;
        -: 2299:				}
        -: 2300:
    #####: 2301:				*z = 0;
        -: 2302:			}
        -: 2303:		}
        -: 2304:	}
    #####: 2305:	if (*p != 0)
    #####: 2306:		return -1;
        -: 2307:
    #####: 2308:	if (must_parse_time && !ret->hour)
    #####: 2309:		return -1;
        -: 2310:
    #####: 2311:	return 0;
        -: 2312:}
        -: 2313:
        -: 2314:/* Raw to boolean */
    #####: 2315:int toml_rtob(toml_raw_t src, int* ret_)
        -: 2316:{
    #####: 2317:	if (!src)
    #####: 2318:		return -1;
        -: 2319:	int dummy;
    #####: 2320:	int* ret = ret_ ? ret_ : &dummy;
        -: 2321:
    #####: 2322:	if (0 == strcmp(src, "true"))
        -: 2323:	{
    #####: 2324:		*ret = 1;
    #####: 2325:		return 0;
        -: 2326:	}
    #####: 2327:	if (0 == strcmp(src, "false"))
        -: 2328:	{
    #####: 2329:		*ret = 0;
    #####: 2330:		return 0;
        -: 2331:	}
    #####: 2332:	return -1;
        -: 2333:}
        -: 2334:
        -: 2335:/* Raw to integer */
    #####: 2336:int toml_rtoi(toml_raw_t src, int64_t* ret_)
        -: 2337:{
    #####: 2338:	if (!src)
    #####: 2339:		return -1;
        -: 2340:
        -: 2341:	char buf[100];
    #####: 2342:	char* p = buf;
    #####: 2343:	char* q = p + sizeof(buf);
    #####: 2344:	const char* s = src;
    #####: 2345:	int base = 0;
        -: 2346:	int64_t dummy;
    #####: 2347:	int64_t* ret = ret_ ? ret_ : &dummy;
        -: 2348:
        -: 2349:	/* allow +/- */
    #####: 2350:	if (s[0] == '+' || s[0] == '-')
    #####: 2351:		*p++ = *s++;
        -: 2352:
        -: 2353:	/* disallow +_100 */
    #####: 2354:	if (s[0] == '_')
    #####: 2355:		return -1;
        -: 2356:
        -: 2357:	/* if 0* ... */
    #####: 2358:	if ('0' == s[0])
        -: 2359:	{
    #####: 2360:		switch (s[1])
        -: 2361:		{
    #####: 2362:		case 'x':
    #####: 2363:			base = 16;
    #####: 2364:			s += 2;
    #####: 2365:			break;
    #####: 2366:		case 'o':
    #####: 2367:			base = 8;
    #####: 2368:			s += 2;
    #####: 2369:			break;
    #####: 2370:		case 'b':
    #####: 2371:			base = 2;
    #####: 2372:			s += 2;
    #####: 2373:			break;
    #####: 2374:		case '\0':
    #####: 2375:			return *ret = 0, 0;
    #####: 2376:		default:
        -: 2377:			/* ensure no other digits after it */
    #####: 2378:			if (s[1])
    #####: 2379:				return -1;
        -: 2380:		}
        -: 2381:	}
        -: 2382:
        -: 2383:	/* just strip underscores and pass to strtoll */
    #####: 2384:	while (*s && p < q)
        -: 2385:	{
    #####: 2386:		int ch = *s++;
    #####: 2387:		if (ch == '_')
        -: 2388:		{
        -: 2389:			// disallow '__'
    #####: 2390:			if (s[0] == '_')
    #####: 2391:				return -1;
        -: 2392:			// numbers cannot end with '_'
    #####: 2393:			if (s[0] == '\0')
    #####: 2394:				return -1;
    #####: 2395:			continue; /* skip _ */
        -: 2396:		}
    #####: 2397:		*p++ = ch;
        -: 2398:	}
        -: 2399:
        -: 2400:	// if not at end-of-string or we ran out of buffer ...
    #####: 2401:	if (*s || p == q)
    #####: 2402:		return -1;
        -: 2403:
        -: 2404:	/* cap with NUL */
    #####: 2405:	*p = 0;
        -: 2406:
        -: 2407:	/* Run strtoll on buf to get the integer */
        -: 2408:	char* endp;
    #####: 2409:	errno = 0;
    #####: 2410:	*ret = strtoll(buf, &endp, base);
    #####: 2411:	return (errno || *endp) ? -1 : 0;
        -: 2412:}
        -: 2413:
    #####: 2414:int toml_rtod_ex(toml_raw_t src, double* ret_, char* buf, int buflen)
        -: 2415:{
    #####: 2416:	if (!src)
    #####: 2417:		return -1;
        -: 2418:
    #####: 2419:	char* p = buf;
    #####: 2420:	char* q = p + buflen;
    #####: 2421:	const char* s = src;
        -: 2422:	double dummy;
    #####: 2423:	double* ret = ret_ ? ret_ : &dummy;
        -: 2424:
        -: 2425:	/* allow +/- */
    #####: 2426:	if (s[0] == '+' || s[0] == '-')
    #####: 2427:		*p++ = *s++;
        -: 2428:
        -: 2429:	/* disallow +_1.00 */
    #####: 2430:	if (s[0] == '_')
    #####: 2431:		return -1;
        -: 2432:
        -: 2433:	/* decimal point, if used, must be surrounded by at least one digit on
        -: 2434:	 * each side */
        -: 2435:	{
    #####: 2436:		char* dot = strchr(s, '.');
    #####: 2437:		if (dot)
        -: 2438:		{
    #####: 2439:			if (dot == s || !isdigit(dot[-1]) || !isdigit(dot[1]))
    #####: 2440:				return -1;
        -: 2441:		}
        -: 2442:	}
        -: 2443:
        -: 2444:	/* zero must be followed by . or 'e', or NUL */
    #####: 2445:	if (s[0] == '0' && s[1] && !strchr("eE.", s[1]))
    #####: 2446:		return -1;
        -: 2447:
        -: 2448:	/* just strip underscores and pass to strtod */
    #####: 2449:	while (*s && p < q)
        -: 2450:	{
    #####: 2451:		int ch = *s++;
    #####: 2452:		if (ch == '_')
        -: 2453:		{
        -: 2454:			// disallow '__'
    #####: 2455:			if (s[0] == '_')
    #####: 2456:				return -1;
        -: 2457:			// disallow last char '_'
    #####: 2458:			if (s[0] == 0)
    #####: 2459:				return -1;
    #####: 2460:			continue; /* skip _ */
        -: 2461:		}
    #####: 2462:		*p++ = ch;
        -: 2463:	}
    #####: 2464:	if (*s || p == q)
    #####: 2465:		return -1; /* reached end of string or buffer is full? */
        -: 2466:
        -: 2467:	/* cap with NUL */
    #####: 2468:	*p = 0;
        -: 2469:
        -: 2470:	/* Run strtod on buf to get the value */
        -: 2471:	char* endp;
    #####: 2472:	errno = 0;
    #####: 2473:	*ret = strtod(buf, &endp);
    #####: 2474:	return (errno || *endp) ? -1 : 0;
        -: 2475:}
        -: 2476:
    #####: 2477:int toml_rtod(toml_raw_t src, double* ret_)
        -: 2478:{
        -: 2479:	char buf[100];
    #####: 2480:	return toml_rtod_ex(src, ret_, buf, sizeof(buf));
        -: 2481:}
        -: 2482:
    #####: 2483:int toml_rtos(toml_raw_t src, char** ret)
        -: 2484:{
    #####: 2485:	int multiline = 0;
        -: 2486:	const char* sp;
        -: 2487:	const char* sq;
        -: 2488:
    #####: 2489:	*ret = 0;
    #####: 2490:	if (!src)
    #####: 2491:		return -1;
        -: 2492:
        -: 2493:	// for strings, first char must be a s-quote or d-quote
    #####: 2494:	int qchar = src[0];
    #####: 2495:	int srclen = strlen(src);
    #####: 2496:	if (!(qchar == '\'' || qchar == '"'))
        -: 2497:	{
    #####: 2498:		return -1;
        -: 2499:	}
        -: 2500:
        -: 2501:	// triple quotes?
    #####: 2502:	if (qchar == src[1] && qchar == src[2])
        -: 2503:	{
    #####: 2504:		multiline = 1;	       // triple-quote implies multiline
    #####: 2505:		sp = src + 3;	       // first char after quote
    #####: 2506:		sq = src + srclen - 3; // first char of ending quote
        -: 2507:
    #####: 2508:		if (!(sp <= sq && sq[0] == qchar && sq[1] == qchar && sq[2] == qchar))
        -: 2509:		{
        -: 2510:			// last 3 chars in src must be qchar
    #####: 2511:			return -1;
        -: 2512:		}
        -: 2513:
        -: 2514:		/* skip new line immediate after qchar */
    #####: 2515:		if (sp[0] == '\n')
    #####: 2516:			sp++;
    #####: 2517:		else if (sp[0] == '\r' && sp[1] == '\n')
    #####: 2518:			sp += 2;
        -: 2519:	}
        -: 2520:	else
        -: 2521:	{
    #####: 2522:		sp = src + 1;	       // first char after quote
    #####: 2523:		sq = src + srclen - 1; // ending quote
    #####: 2524:		if (!(sp <= sq && *sq == qchar))
        -: 2525:		{
        -: 2526:			/* last char in src must be qchar */
    #####: 2527:			return -1;
        -: 2528:		}
        -: 2529:	}
        -: 2530:
        -: 2531:	// at this point:
        -: 2532:	//     sp points to first valid char after quote.
        -: 2533:	//     sq points to one char beyond last valid char.
        -: 2534:	//     string len is (sq - sp).
    #####: 2535:	if (qchar == '\'')
        -: 2536:	{
    #####: 2537:		*ret = norm_lit_str(sp, sq - sp, multiline, 0, 0);
        -: 2538:	}
        -: 2539:	else
        -: 2540:	{
    #####: 2541:		*ret = norm_basic_str(sp, sq - sp, multiline, 0, 0);
        -: 2542:	}
        -: 2543:
    #####: 2544:	return *ret ? 0 : -1;
        -: 2545:}
        -: 2546:
    #####: 2547:toml_datum_t toml_string_at(const toml_array_t* arr, int idx)
        -: 2548:{
        -: 2549:	toml_datum_t ret;
    #####: 2550:	memset(&ret, 0, sizeof(ret));
    #####: 2551:	ret.ok = (0 == toml_rtos(toml_raw_at(arr, idx), &ret.u.s));
    #####: 2552:	return ret;
        -: 2553:}
        -: 2554:
    #####: 2555:toml_datum_t toml_bool_at(const toml_array_t* arr, int idx)
        -: 2556:{
        -: 2557:	toml_datum_t ret;
    #####: 2558:	memset(&ret, 0, sizeof(ret));
    #####: 2559:	ret.ok = (0 == toml_rtob(toml_raw_at(arr, idx), &ret.u.b));
    #####: 2560:	return ret;
        -: 2561:}
        -: 2562:
    #####: 2563:toml_datum_t toml_int_at(const toml_array_t* arr, int idx)
        -: 2564:{
        -: 2565:	toml_datum_t ret;
    #####: 2566:	memset(&ret, 0, sizeof(ret));
    #####: 2567:	ret.ok = (0 == toml_rtoi(toml_raw_at(arr, idx), &ret.u.i));
    #####: 2568:	return ret;
        -: 2569:}
        -: 2570:
    #####: 2571:toml_datum_t toml_double_at(const toml_array_t* arr, int idx)
        -: 2572:{
        -: 2573:	toml_datum_t ret;
    #####: 2574:	memset(&ret, 0, sizeof(ret));
    #####: 2575:	ret.ok = (0 == toml_rtod(toml_raw_at(arr, idx), &ret.u.d));
    #####: 2576:	return ret;
        -: 2577:}
        -: 2578:
    #####: 2579:toml_datum_t toml_timestamp_at(const toml_array_t* arr, int idx)
        -: 2580:{
        -: 2581:	toml_timestamp_t ts;
        -: 2582:	toml_datum_t ret;
    #####: 2583:	memset(&ret, 0, sizeof(ret));
    #####: 2584:	ret.ok = (0 == toml_rtots(toml_raw_at(arr, idx), &ts));
    #####: 2585:	if (ret.ok)
        -: 2586:	{
    #####: 2587:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2588:		if (ret.ok)
        -: 2589:		{
    #####: 2590:			*ret.u.ts = ts;
    #####: 2591:			if (ret.u.ts->year)
    #####: 2592:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2593:			if (ret.u.ts->month)
    #####: 2594:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2595:			if (ret.u.ts->day)
    #####: 2596:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2597:			if (ret.u.ts->hour)
    #####: 2598:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2599:			if (ret.u.ts->minute)
    #####: 2600:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2601:			if (ret.u.ts->second)
    #####: 2602:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2603:			if (ret.u.ts->millisec)
    #####: 2604:				ret.u.ts->millisec =
    #####: 2605:				    &ret.u.ts->__buffer.millisec;
    #####: 2606:			if (ret.u.ts->z)
    #####: 2607:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2608:		}
        -: 2609:	}
    #####: 2610:	return ret;
        -: 2611:}
        -: 2612:
    #####: 2613:toml_datum_t toml_string_in(const toml_table_t* arr, const char* key)
        -: 2614:{
        -: 2615:	toml_datum_t ret;
    #####: 2616:	memset(&ret, 0, sizeof(ret));
    #####: 2617:	toml_raw_t raw = toml_raw_in(arr, key);
    #####: 2618:	if (raw)
        -: 2619:	{
    #####: 2620:		ret.ok = (0 == toml_rtos(raw, &ret.u.s));
        -: 2621:	}
    #####: 2622:	return ret;
        -: 2623:}
        -: 2624:
    #####: 2625:toml_datum_t toml_bool_in(const toml_table_t* arr, const char* key)
        -: 2626:{
        -: 2627:	toml_datum_t ret;
    #####: 2628:	memset(&ret, 0, sizeof(ret));
    #####: 2629:	ret.ok = (0 == toml_rtob(toml_raw_in(arr, key), &ret.u.b));
    #####: 2630:	return ret;
        -: 2631:}
        -: 2632:
    #####: 2633:toml_datum_t toml_int_in(const toml_table_t* arr, const char* key)
        -: 2634:{
        -: 2635:	toml_datum_t ret;
    #####: 2636:	memset(&ret, 0, sizeof(ret));
    #####: 2637:	ret.ok = (0 == toml_rtoi(toml_raw_in(arr, key), &ret.u.i));
    #####: 2638:	return ret;
        -: 2639:}
        -: 2640:
    #####: 2641:toml_datum_t toml_double_in(const toml_table_t* arr, const char* key)
        -: 2642:{
        -: 2643:	toml_datum_t ret;
    #####: 2644:	memset(&ret, 0, sizeof(ret));
    #####: 2645:	ret.ok = (0 == toml_rtod(toml_raw_in(arr, key), &ret.u.d));
    #####: 2646:	return ret;
        -: 2647:}
        -: 2648:
    #####: 2649:toml_datum_t toml_timestamp_in(const toml_table_t* arr, const char* key)
        -: 2650:{
        -: 2651:	toml_timestamp_t ts;
        -: 2652:	toml_datum_t ret;
    #####: 2653:	memset(&ret, 0, sizeof(ret));
    #####: 2654:	ret.ok = (0 == toml_rtots(toml_raw_in(arr, key), &ts));
    #####: 2655:	if (ret.ok)
        -: 2656:	{
    #####: 2657:		ret.ok = !!(ret.u.ts = MALLOC(sizeof(*ret.u.ts)));
    #####: 2658:		if (ret.ok)
        -: 2659:		{
    #####: 2660:			*ret.u.ts = ts;
    #####: 2661:			if (ret.u.ts->year)
    #####: 2662:				ret.u.ts->year = &ret.u.ts->__buffer.year;
    #####: 2663:			if (ret.u.ts->month)
    #####: 2664:				ret.u.ts->month = &ret.u.ts->__buffer.month;
    #####: 2665:			if (ret.u.ts->day)
    #####: 2666:				ret.u.ts->day = &ret.u.ts->__buffer.day;
    #####: 2667:			if (ret.u.ts->hour)
    #####: 2668:				ret.u.ts->hour = &ret.u.ts->__buffer.hour;
    #####: 2669:			if (ret.u.ts->minute)
    #####: 2670:				ret.u.ts->minute = &ret.u.ts->__buffer.minute;
    #####: 2671:			if (ret.u.ts->second)
    #####: 2672:				ret.u.ts->second = &ret.u.ts->__buffer.second;
    #####: 2673:			if (ret.u.ts->millisec)
    #####: 2674:				ret.u.ts->millisec =
    #####: 2675:				    &ret.u.ts->__buffer.millisec;
    #####: 2676:			if (ret.u.ts->z)
    #####: 2677:				ret.u.ts->z = ret.u.ts->__buffer.z;
        -: 2678:		}
        -: 2679:	}
    #####: 2680:	return ret;
        -: 2681:}
        -: 2682:
    #####: 2683:static int parse_millisec(const char* p, const char** endp)
        -: 2684:{
    #####: 2685:	int ret = 0;
    #####: 2686:	int unit = 100; /* unit in millisec */
    #####: 2687:	for (; '0' <= *p && *p <= '9'; p++, unit /= 10)
        -: 2688:	{
    #####: 2689:		ret += (*p - '0') * unit;
        -: 2690:	}
    #####: 2691:	*endp = p;
    #####: 2692:	return ret;
        -: 2693:}
        -:    0:Source:chain_allocator.c
        -:    0:Graph:chain_allocator.gcno
        -:    0:Data:chain_allocator.gcda
        -:    0:Runs:26
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/chain_allocator.h>
        -:   16:#include <core/panic.h>
        -:   17:#include <errno.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:
        -:   21:// the default heap allocator for the current thread
        -:   22:_Thread_local HeapAllocator* __default_tl_heap_allocator = NULL;
        -:   23:
        -:   24:// the global heap allocator (used when the memory will potentially be
        -:   25:// deallocated in a different thread than it was created in
        -:   26:HeapAllocator* __global_sync_allocator = NULL;
        -:   27:// lock for the global heap allocator
        -:   28:Lock* __global_sync_allocator_lock = NULL;
        -:   29:
        -:   30:// default heap allocator config (no_malloc and zeroed are disabled)
        -:   31:HeapAllocatorConfig __default_hconfig_ = {false, false};
        -:   32:
        -:   33:// create default slab sizes for the heap allocator with alignment in mind
        -:   34:#define HD_CFG(size) \
        -:   35:	{            \
        -:   36:	    size, 10, 0, UINT32_MAX}
        -:   37:HeapDataParamsConfig __default_hdpc_arr_value[] = {HD_CFG(8),
        -:   38:						   HD_CFG(16),
        -:   39:						   HD_CFG(32),
        -:   40:						   HD_CFG(48),
        -:   41:						   HD_CFG(64),
        -:   42:						   HD_CFG(80),
        -:   43:						   HD_CFG(96),
        -:   44:						   HD_CFG(112),
        -:   45:						   HD_CFG(128),
        -:   46:						   HD_CFG(144),
        -:   47:						   HD_CFG(160),
        -:   48:						   HD_CFG(176),
        -:   49:						   HD_CFG(192),
        -:   50:						   HD_CFG(208),
        -:   51:						   HD_CFG(224),
        -:   52:						   HD_CFG(240),
        -:   53:						   HD_CFG(256),
        -:   54:						   HD_CFG(272),
        -:   55:						   HD_CFG(288),
        -:   56:						   HD_CFG(304),
        -:   57:						   HD_CFG(320),
        -:   58:						   HD_CFG(336),
        -:   59:						   HD_CFG(352),
        -:   60:						   HD_CFG(368),
        -:   61:						   HD_CFG(384),
        -:   62:						   HD_CFG(400),
        -:   63:						   HD_CFG(416),
        -:   64:						   HD_CFG(432),
        -:   65:						   HD_CFG(448),
        -:   66:						   HD_CFG(464),
        -:   67:						   HD_CFG(480),
        -:   68:						   HD_CFG(496),
        -:   69:						   HD_CFG(512),
        -:   70:						   HD_CFG(1024),
        -:   71:						   HD_CFG(2048),
        -:   72:						   HD_CFG(4096),
        -:   73:						   HD_CFG(8192),
        -:   74:						   {16384, 5, 0, UINT32_MAX},
        -:   75:						   {32768, 5, 0, UINT32_MAX},
        -:   76:						   {65536, 2, 0, UINT32_MAX}};
        -:   77:
        -:   78:// heap allocator config
        -:   79:HeapDataParamsConfig* __default_hdpc_arr_ = __default_hdpc_arr_value;
        -:   80:
        -:   81:// the size of the default array
        -:   82:u64 __default_hdpc_arr_size =
        -:   83:    sizeof(__default_hdpc_arr_value) / sizeof(__default_hdpc_arr_value[0]);
        -:   84:
        -:   85:// allows for overwriting the hconfig
    #####:   86:void set_default_hconfig(HeapAllocatorConfig* hconfig)
        -:   87:{
    #####:   88:	__default_hconfig_ = *hconfig;
    #####:   89:}
        -:   90:
        -:   91:// allows for overwriting of the default hdpc array
        2:   92:void set_default_hdpc_arr(HeapDataParamsConfig arr[], u64 size)
        -:   93:{
        2:   94:	__default_hdpc_arr_ = arr;
        2:   95:	__default_hdpc_arr_size = size;
        2:   96:}
        -:   97:
        -:   98:// build the using the default heap allocator config
       16:   99:int build_default_heap_allocator(HeapAllocator* ptr)
        -:  100:{
       16:  101:	return heap_allocator_build_arr(ptr, &__default_hconfig_,
        -:  102:					__default_hdpc_arr_,
        -:  103:					__default_hdpc_arr_size);
        -:  104:}
        -:  105:
        -:  106:// init the global sync allocator
        4:  107:void global_sync_allocator_init()
        -:  108:{
        -:  109:	// allocate for the data structure
        4:  110:	__global_sync_allocator = malloc(sizeof(HeapAllocator));
        4:  111:	__global_sync_allocator_lock = malloc(sizeof(Lock));
        -:  112:
        -:  113:	// check for failures
        4:  114:	if (__global_sync_allocator_lock == NULL || __global_sync_allocator == NULL)
        -:  115:	{
        -:  116:		// deallocate and panic
    #####:  117:		if (__global_sync_allocator_lock != NULL)
    #####:  118:			free(__global_sync_allocator_lock);
    #####:  119:		if (__global_sync_allocator != NULL)
    #####:  120:			free(__global_sync_allocator);
    #####:  121:		panic("Could not initialize the global sync HeapAllocator");
        -:  122:	}
        -:  123:
        -:  124:	// setup the lock
        4:  125:	*__global_sync_allocator_lock = LOCK();
        -:  126:
        -:  127:	// build with the default configurations
        4:  128:	if (build_default_heap_allocator(__global_sync_allocator))
        -:  129:	{
    #####:  130:		free(__global_sync_allocator);
    #####:  131:		panic("Could not initialize the global sync HeapAllocator");
        -:  132:	}
        4:  133:}
        -:  134:
        -:  135:// Entry for the chain allocator stack.
        -:  136:typedef struct ChainGuardEntry
        -:  137:{
        -:  138:	HeapAllocator* ha;
        -:  139:	bool is_sync;
        -:  140:	Lock* lock;
        -:  141:} ChainGuardEntry;
        -:  142:
        -:  143:// stack for chain allocators
        -:  144:_Thread_local ChainGuardEntry
        -:  145:    __thread_local_chain_allocator[MAX_CHAIN_ALLOCATOR_DEPTH];
        -:  146:_Thread_local u64 __thread_local_chain_allocator_index = 0;
        -:  147:
        -:  148:// cleanup the local thread allocator (used when threads terminate)
        1:  149:void thread_local_allocator_cleanup()
        -:  150:{
        1:  151:	if (__thread_local_chain_allocator_index > 0)
        1:  152:		heap_allocator_cleanup(
        -:  153:		    __thread_local_chain_allocator
        -:  154:			[__thread_local_chain_allocator_index]
        -:  155:			    .ha);
        1:  156:}
        -:  157:
        1:  158:void global_sync_allocator_cleanup()
        -:  159:{
        1:  160:	if (__global_sync_allocator != NULL)
        1:  161:		heap_allocator_cleanup(__global_sync_allocator);
        1:  162:}
        -:  163:
        7:  164:void chain_guard_cleanup(ChainGuard* ptr)
        -:  165:{
        7:  166:	__thread_local_chain_allocator_index--;
        7:  167:}
        -:  168:
       10:  169:ChainGuard chain_guard(ChainConfig* config)
        -:  170:{
       10:  171:	if (__thread_local_chain_allocator_index >= MAX_CHAIN_ALLOCATOR_DEPTH)
    #####:  172:		panic("too many chain allocators");
        -:  173:
       10:  174:	ChainGuardPtr ret = {__thread_local_chain_allocator_index, config->ha,
       10:  175:			     config->is_sync, config->lock};
        -:  176:
        -:  177:	__thread_local_chain_allocator[__thread_local_chain_allocator_index]
       10:  178:	    .ha = config->ha;
        -:  179:	__thread_local_chain_allocator[__thread_local_chain_allocator_index]
       10:  180:	    .is_sync = config->is_sync;
        -:  181:	__thread_local_chain_allocator[__thread_local_chain_allocator_index]
       10:  182:	    .lock = config->lock;
        -:  183:
       10:  184:	__thread_local_chain_allocator_index++;
       10:  185:	return ret;
        -:  186:}
        -:  187:
       37:  188:int chain_malloc(FatPtr* ptr, u64 size)
        -:  189:{
       37:  190:	if (__thread_local_chain_allocator_index == 0)
        -:  191:	{
        -:  192:		// thread local allocator has not been initialized. Create it
        -:  193:		// now.
       12:  194:		HeapAllocator* ha = malloc(sizeof(HeapAllocator));
       12:  195:		if (!ha)
    #####:  196:			return -1;
        -:  197:
       12:  198:		if (build_default_heap_allocator(ha))
        -:  199:		{
    #####:  200:			free(ha);
    #####:  201:			return -1;
        -:  202:		};
        -:  203:
       12:  204:		__default_tl_heap_allocator = ha;
       12:  205:		__thread_local_chain_allocator[0].ha = ha;
       12:  206:		__thread_local_chain_allocator[0].is_sync = false;
       12:  207:		__thread_local_chain_allocator_index++;
        -:  208:	}
       37:  209:	if (size == 0)
    #####:  210:		return -1;
        -:  211:
       37:  212:	u64 index = __thread_local_chain_allocator_index - 1;
       37:  213:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  214:
        -:  215:	int ret;
        -:  216:	{
       37:  217:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
       37:  218:		if (is_sync)
        5:  219:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  220:
       37:  221:		ret = heap_allocator_allocate(
        -:  222:		    __thread_local_chain_allocator[index].ha, size, ptr);
        -:  223:	}
        -:  224:
       37:  225:	return ret;
        -:  226:}
        1:  227:int chain_realloc(FatPtr* dst, FatPtr* src, u64 size)
        -:  228:{
        1:  229:	if (__thread_local_chain_allocator_index == 0)
        -:  230:	{
    #####:  231:		return -1;
        -:  232:	}
        1:  233:	if (size == 0)
        -:  234:	{
    #####:  235:		errno = EINVAL;
    #####:  236:		return -1;
        -:  237:	}
        1:  238:	u64 index = __thread_local_chain_allocator_index - 1;
        1:  239:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  240:
        -:  241:	int ret;
        -:  242:	{
        1:  243:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
        1:  244:		if (is_sync)
    #####:  245:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  246:
        1:  247:		ret = heap_allocator_allocate(
        -:  248:		    __thread_local_chain_allocator[index].ha, size, dst);
        1:  249:		if (!ret)
        -:  250:		{
        1:  251:			void* src_data = fat_ptr_data(src);
        1:  252:			void* dst_data = fat_ptr_data(dst);
        1:  253:			u64 len = fat_ptr_len(src);
        1:  254:			memcpy(dst_data, src_data, len);
        1:  255:			ret = chain_free(src);
        -:  256:		}
        -:  257:	}
        -:  258:
        1:  259:	return ret;
        -:  260:}
       37:  261:int chain_free(FatPtr* ptr)
        -:  262:{
       37:  263:	if (__thread_local_chain_allocator_index == 0)
        -:  264:	{
    #####:  265:		errno = ERANGE;
    #####:  266:		return -1;
        -:  267:	}
       37:  268:	u64 index = __thread_local_chain_allocator_index - 1;
       37:  269:	bool is_sync = __thread_local_chain_allocator[index].is_sync;
        -:  270:
        -:  271:	int ret;
        -:  272:	{
       37:  273:		LockGuard lg = LOCK_GUARD_CLEANUP_SAFE;
       37:  274:		if (is_sync)
        4:  275:			lg = lock(__thread_local_chain_allocator[index].lock);
        -:  276:
       37:  277:		ret = heap_allocator_free(
        -:  278:		    __thread_local_chain_allocator[index].ha, ptr);
        -:  279:	}
       37:  280:	return ret;
        -:  281:}
        -:    0:Source:heap.c
        -:    0:Graph:heap.gcno
        -:    0:Data:heap.gcda
        -:    0:Runs:26
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/heap.h>
        -:   16:#include <errno.h>
        -:   17:#include <stdlib.h>
        -:   18:
        -:   19:// internal representation of the HeapDataParamsConfig with the required
        -:   20:// free_list_head value.
        -:   21:typedef struct HeapDataParams
        -:   22:{
        -:   23:	HeapDataParamsConfig config;
        -:   24:	u32 free_list_head; // The next slab that is free
        -:   25:} HeapDataParams;
        -:   26:
        -:   27:// The data associated with each slab_size.
        -:   28:typedef struct HeapData
        -:   29:{
        -:   30:	void** data;	    // pointers to each chunk of data
        -:   31:	u32* free_list;	    // the pointers for free slabs.
        -:   32:	u32 count;	    // the number of chunks currently allocated
        -:   33:	u32 cur_slabs;	    // the number of slabs currently allocated
        -:   34:	HeapDataParams hdp; // The heap data params for this HeapData
        -:   35:} HeapData;
        -:   36:
        -:   37:// The opaque pointer type which is stored in the HeapAllocator data structure
        -:   38:// which is used to access a HeapAllocator.
        -:   39:typedef struct HeapAllocatorImpl
        -:   40:{
        -:   41:	u32 hd_size;		    // number of sizes available
        -:   42:	HeapAllocatorConfig config; // the configuration
        -:   43:	HeapData* hd_arr;	    // The array of heap data.
        -:   44:} HeapAllocatorImpl;
        -:   45:
        -:   46:// debugging options/counters
        -:   47:u64 __malloc_count = 0;
        -:   48:u64 __free_count = 0;
        -:   49:bool __debug_build_allocator_malloc_fail1 = false;
        -:   50:bool __debug_build_allocator_malloc_fail2 = false;
        -:   51:bool __debug_build_allocator_malloc_fail3 = false;
        -:   52:bool __debug_build_allocator_malloc_fail4 = false;
        -:   53:bool __debug_build_allocator_malloc_fail5 = false;
        -:   54:bool __debug_build_allocator_malloc_fail6 = false;
        -:   55:bool __debug_build_allocator_malloc_fail7 = false;
        -:   56:bool __debug_build_allocator_malloc_fail8 = false;
        -:   57:
      233:   58:void* do_malloc(size_t size)
        -:   59:{
      233:   60:	__malloc_count += 1;
      233:   61:	void* ret = malloc(size);
        -:   62:	// printf("malloc %zu [%p (%llu)]\n", size, ret, __malloc_count);
      233:   63:	return ret;
        -:   64:}
        -:   65:
      143:   66:void do_free(void* ptr)
        -:   67:{
      143:   68:	__free_count += 1;
        -:   69:	// printf("free %p (%llu)\n", ptr, __free_count);
      143:   70:	free(ptr);
      143:   71:}
        -:   72:
       21:   73:void* do_realloc(void* ptr, size_t size)
        -:   74:{
       21:   75:	void* ret = realloc(ptr, size);
        -:   76:	// printf("realloc %zu [old=%p,new=%p]\n", size, ptr, ret);
       21:   77:	return ret;
        -:   78:}
        -:   79:
       29:   80:void* fat_ptr_data(const FatPtr* ptr) { return ptr->data; }
        -:   81:
       13:   82:u64 fat_ptr_len(const FatPtr* ptr) { return ptr->len; }
        -:   83:
        5:   84:u64 fat_ptr_id(const FatPtr* ptr) { return ptr->id; }
        -:   85:
       56:   86:int heap_allocator_init_free_list(HeapData* hd, u64 index, u32 slabs,
        -:   87:				  bool last_is_uint_max)
        -:   88:{
       56:   89:	hd->data[index] = NULL; // set to NULL for cleanup consistency
        -:   90:
        -:   91:	// allocate memory for slabs
       56:   92:	if (!__debug_build_allocator_malloc_fail4)
       54:   93:		hd->data[index] = do_malloc(hd->hdp.config.slab_size * slabs);
       56:   94:	if (hd->data[index] == NULL)
        2:   95:		return -1;
        -:   96:
       54:   97:	void* tmp = NULL;
        -:   98:
        -:   99:	// allocate / or reallocate the freelist
       54:  100:	if (!__debug_build_allocator_malloc_fail5)
        -:  101:	{
       52:  102:		if (index == 0)
       42:  103:			tmp = do_malloc(sizeof(u32) * slabs);
        -:  104:		else
        -:  105:		{
       10:  106:			tmp = do_realloc(hd->free_list,
       10:  107:					 sizeof(u32) * (hd->cur_slabs + slabs));
        -:  108:		}
        -:  109:	}
        -:  110:
       54:  111:	if (!tmp)
        -:  112:	{
        2:  113:		do_free(hd->data[index]);
        2:  114:		return -1;
        -:  115:	}
        -:  116:
       52:  117:	hd->free_list = tmp;
        -:  118:
        -:  119:	// initialize the values of the free list.
       52:  120:	u32 offset = index * hd->hdp.config.slabs_per_resize;
      700:  121:	for (u64 i = 0; i < slabs; i++)
        -:  122:	{
      648:  123:		if ((i == (slabs - 1)) && last_is_uint_max)
       51:  124:			hd->free_list[i + offset] = UINT32_MAX;
        -:  125:		else
      597:  126:			hd->free_list[i + offset] = offset + i + 1;
        -:  127:	}
        -:  128:
       52:  129:	return 0;
        -:  130:}
        -:  131:
        -:  132:// compare function used for sorting.
     1415:  133:int heap_data_compare(const void* p1, const void* p2)
        -:  134:{
     1415:  135:	int ret = 0;
        -:  136:
     1415:  137:	HeapData d1 = *(HeapData*)p1;
     1415:  138:	HeapData d2 = *(HeapData*)p2;
        -:  139:
     1415:  140:	if (d1.hdp.config.slab_size > d2.hdp.config.slab_size)
        1:  141:		ret = 1;
     1414:  142:	else if (d1.hdp.config.slab_size < d2.hdp.config.slab_size)
     1413:  143:		ret = -1;
        -:  144:
     1415:  145:	return ret;
        -:  146:}
        -:  147:
        -:  148:// initialize the heap data params
      595:  149:int heap_allocator_init_hdp(HeapAllocator* ptr, HeapDataParamsConfig* hdp,
        -:  150:			    u64 index)
        -:  151:{
        -:  152:
        -:  153:	// set some value in case of a failure below such that cleanup can
        -:  154:	// succeed
      595:  155:	int ret = 0;
      595:  156:	ptr->impl->hd_arr[index].hdp.config = *hdp;
      595:  157:	ptr->impl->hd_arr[index].hdp.free_list_head = 0;
      595:  158:	ptr->impl->hd_arr[index].cur_slabs = 0;
      595:  159:	ptr->impl->hd_arr[index].count =
      595:  160:	    ptr->impl->hd_arr[index].hdp.config.initial_chunks;
        -:  161:
        -:  162:	// if we have initial chunks, initialize them
      595:  163:	if (ptr->impl->hd_arr[index].hdp.config.initial_chunks)
        -:  164:	{
       23:  165:		ptr->impl->hd_arr[index].data = NULL;
        -:  166:
        -:  167:		// try to allocate space for the data for this size
       23:  168:		if (!__debug_build_allocator_malloc_fail8)
       22:  169:			ptr->impl->hd_arr[index].data = do_malloc(
       22:  170:			    ptr->impl->hd_arr[index].hdp.config.initial_chunks * sizeof(void*));
        -:  171:
        -:  172:		// if NULL return error
       23:  173:		if (ptr->impl->hd_arr[index].data == NULL)
        1:  174:			return -1;
        -:  175:
        -:  176:		// set cur_slabs value
       22:  177:		ptr->impl->hd_arr[index].cur_slabs =
       22:  178:		    ptr->impl->hd_arr[index].hdp.config.initial_chunks * ptr->impl->hd_arr[index].hdp.config.slabs_per_resize;
        -:  179:
        -:  180:		// initialize the initial_chunks of the free list
       22:  181:		bool last_is_uint_max = false;
       22:  182:		ptr->impl->hd_arr[index].free_list = NULL;
       22:  183:		for (u64 i = 0;
       45:  184:		     i < ptr->impl->hd_arr[index].hdp.config.initial_chunks;
       23:  185:		     i++)
        -:  186:		{
        -:  187:
       23:  188:			if (i == ptr->impl->hd_arr[index].hdp.config.initial_chunks - 1)
       22:  189:				last_is_uint_max = true;
       23:  190:			if (heap_allocator_init_free_list(
       23:  191:				&ptr->impl->hd_arr[index], i,
       23:  192:				ptr->impl->hd_arr[index]
        -:  193:				    .hdp.config.slabs_per_resize,
        -:  194:				last_is_uint_max))
        2:  195:				ret = -1;
        -:  196:		}
        -:  197:	}
        -:  198:	else
      572:  199:		ptr->impl->hd_arr[index].data = NULL;
      594:  200:	return ret;
        -:  201:}
        -:  202:
       42:  203:int heap_allocator_build_arr(HeapAllocator* ptr, HeapAllocatorConfig* config,
        -:  204:			     HeapDataParamsConfig arr[],
        -:  205:			     u64 heap_data_params_count)
        -:  206:{
        -:  207:	// check inputs
       42:  208:	if (ptr == NULL || config == NULL || heap_data_params_count >= 256)
        -:  209:	{
        1:  210:		errno = EINVAL;
        1:  211:		return -1;
        -:  212:	}
        -:  213:
        -:  214:	// allocate the HeapAllocatorImpl
       41:  215:	if (!__debug_build_allocator_malloc_fail1)
       40:  216:		ptr->impl = do_malloc(sizeof(HeapAllocatorImpl));
       41:  217:	if (ptr->impl == NULL || __debug_build_allocator_malloc_fail1)
        1:  218:		return -1;
        -:  219:
       40:  220:	ptr->impl->hd_size = 0;
        -:  221:
        -:  222:	// copy the config
       40:  223:	ptr->impl->config = *config;
        -:  224:
        -:  225:	// allocate heap data array
       40:  226:	ptr->impl->hd_arr = NULL;
       40:  227:	if (!__debug_build_allocator_malloc_fail2)
       39:  228:		ptr->impl->hd_arr =
       39:  229:		    do_malloc(sizeof(HeapData) * heap_data_params_count);
       40:  230:	if (ptr->impl->hd_arr == NULL || __debug_build_allocator_malloc_fail2)
        -:  231:	{
        1:  232:		heap_allocator_cleanup(ptr);
        1:  233:		return -1;
        -:  234:	}
       39:  235:	ptr->impl->hd_size = heap_data_params_count;
        -:  236:
        -:  237:	// iterate through specified heap data params
      631:  238:	for (u64 i = 0; i < heap_data_params_count; i++)
        -:  239:	{
      596:  240:		HeapDataParamsConfig hdp = arr[i];
      596:  241:		ptr->impl->hd_arr[i].count = 0; // init to 0 for safe cleanup
      596:  242:		ptr->impl->hd_arr[i].data = NULL;
      596:  243:		if ((__debug_build_allocator_malloc_fail3 && i > 0) || heap_allocator_init_hdp(ptr, &hdp, i))
        -:  244:		{
        4:  245:			ptr->impl->hd_size = i; // update for cleanup, others
        -:  246:						// did not get allocated
        4:  247:			if (ptr->impl->hd_arr[i].data)
        -:  248:			{
        2:  249:				do_free(ptr->impl->hd_arr[i].data);
        -:  250:			}
        4:  251:			heap_allocator_cleanup(ptr);
        4:  252:			return -1;
        -:  253:		}
        -:  254:	}
        -:  255:
       35:  256:	if (heap_data_params_count)
        -:  257:	{
       33:  258:		qsort(ptr->impl->hd_arr, heap_data_params_count,
        -:  259:		      sizeof(HeapData), heap_data_compare);
        -:  260:	}
        -:  261:
        -:  262:	// check invalid configurations
       35:  263:	u64 last_size = 0;
      624:  264:	for (u64 i = 0; i < heap_data_params_count; i++)
        -:  265:	{
      591:  266:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == 0)
        -:  267:		{
        -:  268:			// no 0 sized slabs allowed
        1:  269:			errno = EINVAL;
        1:  270:			heap_allocator_cleanup(ptr);
        1:  271:			return -1;
        -:  272:		}
        -:  273:		// note: logic correct because array is sorted.
      590:  274:		if (ptr->impl->hd_arr[i].hdp.config.slab_size == last_size)
        -:  275:		{
        -:  276:			// Duplicate slab_size
        1:  277:			errno = EEXIST;
        1:  278:			heap_allocator_cleanup(ptr);
        1:  279:			return -1;
        -:  280:		}
      589:  281:		last_size = ptr->impl->hd_arr[i].hdp.config.slab_size;
        -:  282:	}
        -:  283:
       33:  284:	return 0;
        -:  285:}
        -:  286:
       26:  287:int heap_allocator_build(HeapAllocator* ptr, HeapAllocatorConfig* config,
        -:  288:			 int heap_data_params_count, ...)
       26:  289:{
       26:  290:	int arr_size = heap_data_params_count;
        -:  291:
        -:  292:	// 0 size is allowed, so we update to address sanitizer warning.
       26:  293:	if (arr_size <= 0)
        -:  294:	{
        5:  295:		arr_size = 1;
        -:  296:	}
       26:  297:	HeapDataParamsConfig arr[arr_size];
        -:  298:	va_list hdps;
       26:  299:	va_start(hdps, heap_data_params_count);
        -:  300:	// build the array to pass to heap_allocator_build_arr
       55:  301:	for (u64 i = 0; i < heap_data_params_count; i++)
        -:  302:	{
       29:  303:		HeapDataParamsConfig hdp = va_arg(hdps, HeapDataParamsConfig);
       29:  304:		arr[i] = hdp;
        -:  305:	}
        -:  306:
       26:  307:	va_end(hdps);
        -:  308:	// call the array version of the function
       26:  309:	return heap_allocator_build_arr(ptr, config, arr,
        -:  310:					heap_data_params_count);
        -:  311:}
        -:  312:
        -:  313:// binary search for the correct slab size
      428:  314:int heap_allocator_index(HeapAllocator* ptr, u64 size)
        -:  315:{
      428:  316:	int ret = -1;
      428:  317:	if (ptr->impl->hd_size == 0)
        2:  318:		return ret;
        -:  319:
      426:  320:	int left = 0;
      426:  321:	int right = ptr->impl->hd_size - 1;
        -:  322:
      661:  323:	while (left <= right)
        -:  324:	{
      602:  325:		int mid = left + (right - left) / 2;
      602:  326:		u64 slab_size = ptr->impl->hd_arr[mid].hdp.config.slab_size;
      602:  327:		if (slab_size == size)
        -:  328:		{
      367:  329:			ret = mid;
      367:  330:			break;
        -:  331:		}
      235:  332:		else if (slab_size > size)
      141:  333:			right = mid - 1;
        -:  334:		else
       94:  335:			left = mid + 1;
        -:  336:	}
        -:  337:
      426:  338:	if (ret == -1 && right + 1 <= ptr->impl->hd_size - 1)
        -:  339:	{
       47:  340:		return right + 1;
        -:  341:	}
        -:  342:
      379:  343:	return ret;
        -:  344:}
        -:  345:
       41:  346:int heap_data_resize(u64 index, HeapData* hd)
        -:  347:{
        -:  348:	// check that we can resize this hdp
       41:  349:	if (hd->cur_slabs < hd->hdp.config.max_slabs)
        -:  350:	{
        -:  351:		// calculate the new slabs
       34:  352:		u32 nslabs_count =
       34:  353:		    hd->hdp.config.slabs_per_resize + hd->cur_slabs;
       34:  354:		if (nslabs_count > hd->hdp.config.max_slabs)
        2:  355:			nslabs_count = hd->hdp.config.max_slabs;
        -:  356:
        -:  357:		// determine slabs to allocate
       34:  358:		u32 slabs_to_alloc = nslabs_count - hd->cur_slabs;
        -:  359:
        -:  360:		// attempt to allocate
       34:  361:		void* tmp = NULL;
       34:  362:		if (!__debug_build_allocator_malloc_fail7)
        -:  363:		{
       33:  364:			if (hd->data)
       11:  365:				tmp = do_realloc(hd->data, (hd->count + 1) * sizeof(void*));
        -:  366:			else
       22:  367:				tmp = do_malloc((hd->count + 1) * sizeof(void**));
        -:  368:		}
        -:  369:
       34:  370:		if (tmp == NULL)
        1:  371:			return -1;
       33:  372:		hd->data = tmp;
        -:  373:
        -:  374:		// initialize the new part of the free list
       33:  375:		if (heap_allocator_init_free_list(hd, hd->count, slabs_to_alloc,
        -:  376:						  true))
        2:  377:			return -1;
       31:  378:		hd->hdp.free_list_head = hd->cur_slabs;
       31:  379:		hd->cur_slabs = nslabs_count;
       31:  380:		hd->count += 1;
       31:  381:		return 0;
        -:  382:	}
        7:  383:	return -1;
        -:  384:}
        -:  385:
      423:  386:int heap_data_allocate(u64 index, HeapData* hd, FatPtr* fptr)
        -:  387:{
      423:  388:	if (hd->cur_slabs == 0)
        -:  389:	{
        -:  390:		// this hd initially had 0 slabs
        -:  391:		// resize it
       23:  392:		if (heap_data_resize(index, hd))
        1:  393:			return -1;
        -:  394:	}
        -:  395:
        -:  396:	// no more slabs, return error
      422:  397:	if (hd->hdp.free_list_head == UINT32_MAX)
       17:  398:		return -1;
        -:  399:
        -:  400:	// get next free slab
      405:  401:	u64 id = hd->hdp.free_list_head;
        -:  402:
        -:  403:	// update free list head
      405:  404:	hd->hdp.free_list_head = hd->free_list[id];
        -:  405:
        -:  406:	// update with the specific index (differing slab sizes)
      405:  407:	fptr->id = id | (index << 56);
      405:  408:	fptr->len = hd->hdp.config.slab_size;
        -:  409:
      405:  410:	u64 heap_data_index = id / hd->hdp.config.slabs_per_resize;
      405:  411:	u64 offset_mod = id % hd->hdp.config.slabs_per_resize;
        -:  412:
        -:  413:	// set the data of the fptr
      405:  414:	fptr->data =
      405:  415:	    hd->data[heap_data_index] + offset_mod * hd->hdp.config.slab_size;
        -:  416:
      405:  417:	return 0;
        -:  418:}
        -:  419:
        -:  420:// free data in this HeapData
      154:  421:int heap_data_free(u64 index, HeapData* hd, FatPtr* fptr)
        -:  422:{
      154:  423:	u64 rel = fptr->id & 0x00FFFFFFFFFFFFFF; // Extract the relative ID
        -:  424:
        -:  425:	// if this is invalid return an error
      154:  426:	if (rel >= hd->cur_slabs)
        1:  427:		return -1;
        -:  428:
        -:  429:	// update head and rest of the list
      153:  430:	u64 head = hd->hdp.free_list_head;
      153:  431:	hd->hdp.free_list_head = rel;
      153:  432:	hd->free_list[rel] = head;
        -:  433:
      153:  434:	return 0;
        -:  435:}
        -:  436:
        -:  437:// main allocation function
      428:  438:int heap_allocator_allocate(HeapAllocator* ptr, u64 size, FatPtr* fptr)
        -:  439:{
      428:  440:	int ret = -1;
        -:  441:	// determine the index via binary search
      428:  442:	int index = heap_allocator_index(ptr, size);
        -:  443:
        -:  444:	// if this index is not found (too big) fall back to malloc
      428:  445:	if (index < 0)
        -:  446:	{
       14:  447:		if (!ptr->impl->config.no_malloc)
        -:  448:		{
       12:  449:			fptr->data = NULL;
       12:  450:			if (!__debug_build_allocator_malloc_fail6)
       11:  451:				fptr->data = do_malloc(size);
       12:  452:			if (fptr->data == NULL)
        -:  453:			{
        1:  454:				fptr->len = 0;
        1:  455:				ret = -1;
        -:  456:			}
        -:  457:			else
        -:  458:			{
       11:  459:				fptr->len = size;
       11:  460:				fptr->id = UINT64_MAX;
       11:  461:				ret = 0;
        -:  462:			}
        -:  463:		}
        -:  464:	}
        -:  465:	else
        -:  466:	{
      414:  467:		HeapData* hd = &ptr->impl->hd_arr[index];
      414:  468:		ret = heap_data_allocate(index, hd, fptr);
      414:  469:		if (ret)
        -:  470:		{
        -:  471:			// there are no more slabs. Try to resize
       18:  472:			if (!heap_data_resize(index, hd))
        -:  473:			{
        -:  474:				// successful resize, allocate should always
        -:  475:				// succeed here
        9:  476:				ret = heap_data_allocate(index, hd, fptr);
        -:  477:			}
        9:  478:			else if (!ptr->impl->config.no_malloc)
        -:  479:			{
        -:  480:				// could not allocate, so we fall back to malloc
        -:  481:				// if configured
        4:  482:				fptr->data = NULL;
        4:  483:				if (!__debug_build_allocator_malloc_fail6)
        3:  484:					fptr->data = do_malloc(size);
        4:  485:				if (fptr->data == NULL)
        -:  486:				{
        1:  487:					fptr->len = 0;
        1:  488:					ret = -1;
        -:  489:				}
        -:  490:				else
        -:  491:				{
        3:  492:					fptr->len = size;
        3:  493:					fptr->id = UINT64_MAX;
        3:  494:					ret = 0;
        -:  495:				}
        -:  496:			}
        -:  497:		}
        -:  498:	}
        -:  499:
      428:  500:	if (!ret && ptr->impl->config.zeroed)
        -:  501:	{
      924:  502:		for (u64 i = 0; i < fptr->len; i++)
        -:  503:		{
      880:  504:			((char*)fptr->data)[i] = 0;
        -:  505:		}
        -:  506:	}
        -:  507:
        -:  508:	// printf("allocate size=%llu,id=%llu,p=%p\n", size, fptr->id,
        -:  509:	// fptr->data);
        -:  510:
      428:  511:	return ret;
        -:  512:}
        -:  513:
      169:  514:int heap_allocator_free(HeapAllocator* ptr, FatPtr* fptr)
        -:  515:{
      169:  516:	int ret = 0;
      169:  517:	if (fptr->id == UINT64_MAX)
        -:  518:	{
        -:  519:		// malloc allocated
        -:  520:
       14:  521:		if (fptr->data)
        -:  522:		{
       14:  523:			do_free(fptr->data);
       14:  524:			fptr->data = NULL;
        -:  525:		}
        -:  526:
       14:  527:		ret = 0;
        -:  528:	}
        -:  529:	else
        -:  530:	{
        -:  531:
      155:  532:		u64 index = (fptr->id >> 56) & 0xFF; // Extract the index
        -:  533:
      155:  534:		if (index >= ptr->impl->hd_size)
        -:  535:		{
        1:  536:			errno = EINVAL;
        1:  537:			ret = -1; // invalid index
        -:  538:		}
        -:  539:		else
        -:  540:		{
      154:  541:			HeapData* hd = &ptr->impl->hd_arr[index];
      154:  542:			ret = heap_data_free(index, hd, fptr);
        -:  543:		}
        -:  544:	}
        -:  545:
      169:  546:	if (!ret && ptr->impl->config.zeroed)
        -:  547:	{
       17:  548:		for (u64 i = 0; i < fptr->len; i++)
        -:  549:		{
       16:  550:			((char*)fptr->data)[i] = 0;
        -:  551:		}
        -:  552:	}
        -:  553:
        -:  554:	// printf("free id=%llu,p=%p\n", fptr->id, fptr->data);
        -:  555:
      169:  556:	return ret;
        -:  557:}
        -:  558:
       29:  559:int heap_allocator_cleanup(HeapAllocator* ptr)
        -:  560:{
        -:  561:	// check for impl and deallocate
       29:  562:	if (ptr->impl)
        -:  563:	{
       53:  564:		for (u32 i = 0; i < ptr->impl->hd_size; i++)
        -:  565:		{
       28:  566:			if (ptr->impl->hd_arr[i].count)
        -:  567:			{
        -:  568:				// check that it's not an unallocated heap data
       22:  569:				if (ptr->impl->hd_arr[i].free_list)
        -:  570:				{
       22:  571:					do_free(ptr->impl->hd_arr[i].free_list);
       22:  572:					ptr->impl->hd_arr[i].free_list = NULL;
        -:  573:				}
       54:  574:				for (u64 j = 0; j < ptr->impl->hd_arr[i].count;
       32:  575:				     j++)
        -:  576:				{
       32:  577:					do_free(ptr->impl->hd_arr[i].data[j]);
        -:  578:				}
       22:  579:				if (ptr->impl->hd_arr[i].data)
        -:  580:				{
       22:  581:					do_free(ptr->impl->hd_arr[i].data);
       22:  582:					ptr->impl->hd_arr[i].data = NULL;
        -:  583:				}
        -:  584:			}
        -:  585:		}
        -:  586:
       25:  587:		if (ptr->impl->hd_arr)
        -:  588:		{
       24:  589:			do_free(ptr->impl->hd_arr);
       24:  590:			ptr->impl->hd_arr = NULL;
        -:  591:		}
       25:  592:		do_free(ptr->impl);
       25:  593:		ptr->impl = NULL;
        -:  594:	}
       29:  595:	return 0;
        -:  596:}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:26
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/lock.h>
        -:   16:#include <core/panic.h>
        -:   17:#include <stdio.h>
        -:   18:#include <unistd.h>
        -:   19:
        -:   20:#define MAX_LOCKS 100
        -:   21:_Thread_local Lock* __active_locks_[MAX_LOCKS];
        -:   22:_Thread_local u64 __active_lock_count_ = 0;
        -:   23:
       15:   24:void insert_active_lock(Lock* ptr)
        -:   25:{
       15:   26:	if (__active_lock_count_ >= MAX_LOCKS)
    #####:   27:		panic("too many locks!");
       15:   28:	__active_locks_[__active_lock_count_] = ptr;
       15:   29:	__active_lock_count_++;
       15:   30:}
       14:   31:void delete_active_lock(Lock* ptr)
        -:   32:{
        -:   33:	// note: locks are removed in reverse order
        -:   34:	// It's possible that cleanup occurs in slightly different order
        -:   35:	// but the effect is the same each lock would be invalidated at the end
        -:   36:	// of a scope. For simplicity we just decrement here.
       14:   37:	if (__active_lock_count_ == 0)
    #####:   38:		panic("active lock stack underflow. Unexpected error!");
       14:   39:	__active_lock_count_--;
       14:   40:}
        -:   41:
        8:   42:Lock Lock_build()
        -:   43:{
        -:   44:	LockPtr ret;
        8:   45:	pthread_mutex_init(&ret.lock, NULL);
        8:   46:	pthread_cond_init(&ret.cond, NULL);
        8:   47:	atomic_init(&ret.poison, false);
        8:   48:	atomic_init(&ret.is_locked, false);
        8:   49:	atomic_init(&ret.tid, 0);
        8:   50:	return ret;
        -:   51:}
        -:   52:
        4:   53:void Lock_cleanup(LockPtr* ptr)
        -:   54:{
        4:   55:	pthread_mutex_destroy(&ptr->lock);
        4:   56:	pthread_cond_destroy(&ptr->cond);
        4:   57:}
        -:   58:
        1:   59:void Lock_set_poison(Lock* ptr) { atomic_exchange(&ptr->poison, true); }
        1:   60:bool Lock_is_poisoned(Lock* ptr) { return atomic_load(&ptr->poison); }
    #####:   61:void Lock_clear_poison(Lock* ptr) { atomic_exchange(&ptr->poison, false); }
       15:   62:u64 Lock_get_tid()
        -:   63:{
        -:   64:	u64 tid;
        -:   65:#ifdef __APPLE__
        -:   66:	pthread_threadid_np(NULL, &tid);
        -:   67:#else
       15:   68:	tid = gettid();
        -:   69:#endif // tid code
       15:   70:	return tid;
        -:   71:}
        -:   72:
       15:   73:LockGuard lock(Lock* ptr)
        -:   74:{
       15:   75:	if (atomic_load(&ptr->poison))
    #####:   76:		panic("Lock %p: poisoned!", ptr);
        -:   77:
       15:   78:	u64 tid = Lock_get_tid();
        -:   79:
        -:   80:	// check if this would be a deadlock
      15*:   81:	if (atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid)
    #####:   82:		panic("Lock %p: attempt to lock would deadlock!", lock);
        -:   83:
        -:   84:	// obtain lock
       15:   85:	pthread_mutex_lock(&ptr->lock);
       15:   86:	if (atomic_load(&ptr->poison))
    #####:   87:		panic("Lock %p: poisoned!", ptr);
        -:   88:
       15:   89:	insert_active_lock(ptr);
        -:   90:
        -:   91:	// set tid/is_locked and return
       15:   92:	atomic_exchange(&ptr->tid, tid);
       15:   93:	atomic_exchange(&ptr->is_locked, true);
       15:   94:	LockGuardPtr ret = {ptr};
       15:   95:	return ret;
        -:   96:}
        -:   97:
       80:   98:void Lockguard_cleanup(LockGuardPtr* ptr)
        -:   99:{
       80:  100:	if (ptr && ptr->ref)
        -:  101:	{
       14:  102:		atomic_exchange(&ptr->ref->is_locked, false);
       14:  103:		pthread_mutex_unlock(&ptr->ref->lock);
       14:  104:		delete_active_lock(ptr->ref);
        -:  105:	}
       80:  106:}
        -:  107:
        3:  108:void Lock_mark_poisoned()
        -:  109:{
        3:  110:	if (__active_lock_count_)
        -:  111:	{
        1:  112:		u64 i = __active_lock_count_ - 1;
        -:  113:		while (true)
        -:  114:		{
        1:  115:			Lock_set_poison(__active_locks_[i]);
        1:  116:			atomic_exchange(&__active_locks_[i]->is_locked, false);
        1:  117:			pthread_mutex_unlock(&__active_locks_[i]->lock);
        1:  118:			if (i == 0)
        1:  119:				break;
    #####:  120:			i--;
        -:  121:		}
        -:  122:	}
        3:  123:}
        -:  124:
    #####:  125:void Lock_wait(Lock* ptr, u64 nanoseconds)
        -:  126:{
    #####:  127:	u64 tid = Lock_get_tid();
    #####:  128:	if (!(atomic_load(&ptr->is_locked) && atomic_load(&ptr->tid) == tid))
    #####:  129:		panic("Attempt to wait on lock %p without first obtaining the "
        -:  130:		      "lock!",
        -:  131:		      ptr);
    #####:  132:	if (nanoseconds == 0)
        -:  133:	{
    #####:  134:		pthread_cond_wait(&ptr->cond, &ptr->lock);
        -:  135:	}
        -:  136:	else
        -:  137:	{
        -:  138:		struct timespec ts;
    #####:  139:		clock_gettime(CLOCK_REALTIME, &ts);
        -:  140:
        -:  141:		// Convert the wait time into seconds and nanoseconds
    #####:  142:		ts.tv_sec += nanoseconds / 1000000000;
    #####:  143:		ts.tv_nsec += nanoseconds % 1000000000;
        -:  144:
        -:  145:		// Normalize the timespec structure in case of overflow in
        -:  146:		// nanoseconds
    #####:  147:		if (ts.tv_nsec >= 1000000000)
        -:  148:		{
    #####:  149:			ts.tv_sec += ts.tv_nsec / 1000000000;
    #####:  150:			ts.tv_nsec %= 1000000000;
        -:  151:		}
    #####:  152:		pthread_cond_timedwait(&ptr->cond, &ptr->lock, &ts);
        -:  153:	}
    #####:  154:}
        -:  155:
        2:  156:void Lock_notify(Lock* ptr) { pthread_cond_signal(&ptr->cond); }
        -:  157:
    #####:  158:void Lock_notify_all(Lock* ptr) { pthread_cond_broadcast(&ptr->cond); }
        -:    0:Source:panic.c
        -:    0:Graph:panic.gcno
        -:    0:Data:panic.gcda
        -:    0:Runs:26
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/chain_allocator.h>
        -:   16:#include <core/lock.h>
        -:   17:#include <core/panic.h>
        -:   18:#include <setjmp.h>
        -:   19:#include <stdarg.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <stdnoreturn.h>
        -:   23:
        -:   24:_Thread_local jmp_buf return_jmp;
        -:   25:_Thread_local bool jmp_return_set = false;
        -:   26:
        3:   27:void panic(const char* fmt, ...)
        -:   28:{
        -:   29:	va_list args;
        -:   30:
        3:   31:	fprintf(stderr, "thread panicked: ");
        3:   32:	va_start(args, fmt);
        3:   33:	vfprintf(stderr, fmt, args);
        3:   34:	va_end(args);
        3:   35:	fprintf(stderr, "\n");
        -:   36:
        3:   37:	Lock_mark_poisoned();
        -:   38:
        3:   39:	if (__default_tl_heap_allocator != NULL)
        -:   40:	{
    #####:   41:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   42:	}
        -:   43:
        -:   44:	// If jump return has not been set, we resort to an exit with an error
        -:   45:	// status.
        3:   46:	if (!jmp_return_set)
    #####:   47:		exit(-1);
        3:   48:	longjmp(return_jmp, THREAD_PANIC);
        -:   49:}
        -:    0:Source:thread.c
        -:    0:Graph:thread.gcno
        -:    0:Data:thread.gcda
        -:    0:Runs:26
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <assert.h>
        -:   16:#include <core/chain_allocator.h>
        -:   17:#include <core/panic.h>
        -:   18:#include <core/thread.h>
        -:   19:#include <errno.h>
        -:   20:#include <pthread.h>
        -:   21:#include <stdlib.h>
        -:   22:
        -:   23:int PANIC_TRUE = 1;
        -:   24:int PANIC_FALSE = 0;
        -:   25:
        -:   26:typedef struct ThreadArgsWrapper
        -:   27:{
        -:   28:	void (*start_routine)(void*);
        -:   29:	void* args;
        -:   30:	FatPtr self;
        -:   31:} ThreadArgsWrapper;
        -:   32:
        -:   33:typedef struct ThreadImpl
        -:   34:{
        -:   35:	pthread_t pth;
        -:   36:	u64 tid;
        -:   37:	FatPtr self;
        -:   38:} ThreadImpl;
        -:   39:
        4:   40:void Thread_cleanup(Thread* ptr)
        -:   41:{
        4:   42:	if (chain_free(&ptr->impl))
    #####:   43:		panic("Could not free Thread");
        4:   44:}
        -:   45:
        4:   46:void* Thread_proc_start(void* arg)
        -:   47:{
        -:   48:	// set jmp return point for panics
        4:   49:	if (PANIC_RETURN())
        -:   50:	{
        1:   51:		pthread_exit(&PANIC_TRUE);
        -:   52:	}
        -:   53:
        4:   54:	ThreadArgsWrapper* taw = arg;
        4:   55:	(taw->start_routine)(taw->args);
        -:   56:
       3*:   57:	ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        3:   58:	if (chain_free(&taw->self))
    #####:   59:		panic("Could not free ThreadArgsWrapper");
        -:   60:
        3:   61:	if (__default_tl_heap_allocator != NULL)
        -:   62:	{
    #####:   63:		heap_allocator_cleanup(__default_tl_heap_allocator);
        -:   64:	}
        -:   65:
        3:   66:	pthread_exit(&PANIC_FALSE);
        -:   67:}
        -:   68:
        4:   69:int Thread_start(Thread* th, void (*start_routine)(void*), void* args)
        -:   70:{
        4:   71:	int ret = 0;
        4:   72:	ret = chain_malloc(&th->impl, sizeof(ThreadImpl));
        -:   73:
        4:   74:	if (!ret)
        -:   75:	{
        -:   76:
        8:   77:		ChainGuard guard = GLOBAL_SYNC_ALLOCATOR();
        4:   78:		ThreadImpl* ti = th->impl.data;
        -:   79:
        -:   80:		FatPtr tawptr;
        4:   81:		ret = chain_malloc(&tawptr, sizeof(ThreadArgsWrapper));
        -:   82:
        4:   83:		if (!ret)
        -:   84:		{
        4:   85:			ThreadArgsWrapper* data = tawptr.data;
        4:   86:			data->start_routine = start_routine;
        4:   87:			data->args = args;
        4:   88:			data->self = tawptr;
        -:   89:
        4:   90:			ret = pthread_create(&ti->pth, NULL, Thread_proc_start,
        -:   91:					     data);
        -:   92:		}
        -:   93:	}
        4:   94:	return ret;
        -:   95:}
        -:   96:
        4:   97:JoinResult Thread_join(Thread* ptr)
        -:   98:{
        4:   99:	int result = -1;
        4:  100:	int* status = &PANIC_FALSE;
        -:  101:
        4:  102:	if (ptr == NULL)
    #####:  103:		errno = EINVAL;
        -:  104:	else
        -:  105:	{
        4:  106:		ThreadImpl* ti = ptr->impl.data;
        4:  107:		result = pthread_join(ti->pth, (void*)&status);
        -:  108:	}
        4:  109:	JoinResult jr = {*status == PANIC_TRUE, result != 0};
        4:  110:	return jr;
        -:  111:}
        -:  112:
        4:  113:bool JoinResult_is_panic(JoinResult* jr) { return jr->is_panic; }
        -:  114:
        4:  115:bool JoinResult_is_error(JoinResult* jr) { return jr->is_error; }
        -:    0:Source:traits.c
        -:    0:Graph:traits.gcno
        -:    0:Data:traits.gcda
        -:    0:Runs:26
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/traits.h>
        -:   16:
        1:   17:void drop(Object* self)
        -:   18:{
        1:   19:	if (self->flags & OBJECT_FLAGS_CONSUMED)
    #####:   20:		panic("Runtime error: Object [%s@%" PRIu64
        -:   21:		      "] has already been consumed!",
    #####:   22:		      self->vtable->name, self->id);
        1:   23:	void (*impl)() = find_fn(self, "drop");
        1:   24:	if (!impl)
    #####:   25:		panic("Runtime error: Trait bound violation! "
        -:   26:		      "Type "
        -:   27:		      "'%s' does "
        -:   28:		      "not implement the "
        -:   29:		      "required function [%s]",
    #####:   30:		      TypeName((*self)), "drop");
        1:   31:	SelfCleanup sc = {__thread_local_self_Const, __thread_local_self_Var};
        1:   32:	__thread_local_self_Const = self;
        1:   33:	__thread_local_self_Var = self;
        -:   34:
        -:   35:	// custom code here (set no cleanup since we're already done and consume
        -:   36:	// the object):
        1:   37:	self->flags |= OBJECT_FLAGS_NO_CLEANUP | OBJECT_FLAGS_CONSUMED;
        -:   38:	// free the pointer here as well since cleanup will not be called
        1:   39:	if (fat_ptr_data(&self->ptr))
        -:   40:	{
        1:   41:		chain_free(&self->ptr);
        -:   42:	}
        1:   43:	return impl();
        -:   44:}
        -:    0:Source:type.c
        -:    0:Graph:type.gcno
        -:    0:Data:type.gcda
        -:    0:Runs:26
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <core/panic.h>
        -:   16:#include <core/type.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:
        -:   20:_Thread_local const Object* __thread_local_self_Const = NULL;
        -:   21:_Thread_local Object* __thread_local_self_Var = NULL;
        -:   22:
        -:   23:atomic_ullong __global_counter__;
       26:   24:void __attribute__((constructor)) init_global_counter()
        -:   25:{
       26:   26:	atomic_init(&__global_counter__, 1);
       26:   27:}
        -:   28:
       19:   29:u64 unique_id()
        -:   30:{
       19:   31:	u64 ret = atomic_fetch_add(&__global_counter__, 1);
       19:   32:	return ret;
        -:   33:}
        -:   34:
       19:   35:FatPtr build_fat_ptr(u64 size)
        -:   36:{
        -:   37:	FatPtr ret;
       19:   38:	if (chain_malloc(&ret, size))
        -:   39:	{
        -:   40:		// if chain_malloc is an error we set data to NULL and caller to
        -:   41:		// handle
    #####:   42:		ret.data = NULL;
        -:   43:	}
       19:   44:	return ret;
        -:   45:}
        -:   46:
     5675:   47:int compare_vtable_entry(const void* ent1, const void* ent2)
        -:   48:{
     5675:   49:	const VtableEntry* vtent1 = ent1;
     5675:   50:	const VtableEntry* vtent2 = ent2;
     5675:   51:	return strcmp(vtent1->name, vtent2->name);
        -:   52:}
        -:   53:
     1275:   54:void sort_vtable(Vtable* table)
        -:   55:{
     1275:   56:	qsort(table->entries, table->len, sizeof(VtableEntry),
        -:   57:	      compare_vtable_entry);
     1275:   58:}
        -:   59:
     1275:   60:void vtable_add_entry(Vtable* table, VtableEntry entry)
        -:   61:{
     1275:   62:	if (table->entries == NULL)
        -:   63:	{
      200:   64:		table->entries = malloc(sizeof(VtableEntry) * (table->len + 1));
      200:   65:		if (table->entries == NULL)
    #####:   66:			panic("Couldn't allocate memory for vtable");
        -:   67:	}
        -:   68:	else
        -:   69:	{
     1075:   70:		void* tmp = realloc(table->entries,
     1075:   71:				    sizeof(VtableEntry) * (table->len + 1));
     1075:   72:		if (tmp == NULL)
    #####:   73:			panic("Couldn't allocate memory for vtable");
     1075:   74:		table->entries = tmp;
        -:   75:	}
        -:   76:
     1275:   77:	memcpy(&table->entries[table->len], &entry, sizeof(VtableEntry));
     1275:   78:	table->len += 1;
     1275:   79:	sort_vtable(table);
     1275:   80:}
        -:   81:
       25:   82:bool vtable_check_impl_trait(Vtable* table, char* trait)
        -:   83:{
       25:   84:	bool ret = false;
        -:   85:
      25*:   86:	for (u64 i = 0; i < table->trait_len; i++)
        -:   87:	{
       25:   88:		if (!strcmp(table->trait_entries[i].trait_name, trait))
        -:   89:		{
       25:   90:			ret = true;
       25:   91:			break;
        -:   92:		}
        -:   93:	}
        -:   94:
       25:   95:	return ret;
        -:   96:}
        -:   97:
      500:   98:void vtable_add_trait(Vtable* table, char* trait)
        -:   99:{
      500:  100:	if (table->trait_entries == NULL)
        -:  101:	{
      200:  102:		table->trait_entries =
      200:  103:		    malloc(sizeof(VtableTraitEntry) * (table->trait_len + 1));
      200:  104:		if (table->trait_entries == NULL)
    #####:  105:			panic("Couldn't allocate memory for vtable");
        -:  106:	}
        -:  107:	else
        -:  108:	{
        -:  109:		void* tmp =
      300:  110:		    realloc(table->trait_entries,
      300:  111:			    sizeof(VtableTraitEntry) * (table->trait_len + 1));
      300:  112:		if (tmp == NULL)
    #####:  113:			panic("Couldn't allocate memory for vtable");
      300:  114:		table->trait_entries = tmp;
        -:  115:	}
        -:  116:
        -:  117:	VtableTraitEntry entry;
      500:  118:	if (strlen(trait) >= MAX_TRAIT_NAME_LEN)
    #####:  119:		panic("trait name [%s] is too long. MAX_TRAIT_NAME_LEN = %i\n",
        -:  120:		      trait, MAX_TRAIT_NAME_LEN - 1);
      500:  121:	strcpy(entry.trait_name, trait);
        -:  122:
      500:  123:	memcpy(&table->trait_entries[table->trait_len], &entry,
        -:  124:	       sizeof(VtableTraitEntry));
      500:  125:	table->trait_len += 1;
      500:  126:}
        -:  127:
      105:  128:void* find_fn(const Object* obj, const char* name)
        -:  129:{
      105:  130:	int left = 0;
      105:  131:	int right = obj->vtable->len - 1;
      256:  132:	while (left <= right)
        -:  133:	{
      247:  134:		int mid = left + (right - left) / 2;
      247:  135:		int cmp = strcmp(name, obj->vtable->entries[mid].name);
        -:  136:
      247:  137:		if (cmp == 0)
        -:  138:		{
       96:  139:			return obj->vtable->entries[mid].fn_ptr;
        -:  140:		}
      151:  141:		else if (cmp < 0)
        -:  142:		{
       84:  143:			right = mid - 1;
        -:  144:		}
        -:  145:		else
        -:  146:		{
       67:  147:			left = mid + 1;
        -:  148:		}
        -:  149:	}
        9:  150:	return NULL;
        -:  151:}
        -:  152:
       31:  153:void SelfCleanupImpl_update(SelfCleanupImpl* ptr)
        -:  154:{
       31:  155:	__thread_local_self_Const = ptr->prev_tl_self_Const;
       31:  156:	__thread_local_self_Var = ptr->prev_tl_self_Var;
       31:  157:}
        -:  158:
        7:  159:void Object_check_param(const Object* obj)
        -:  160:{
        7:  161:	if (obj && (obj->flags & OBJECT_FLAGS_CONSUMED) != 0)
    #####:  162:		panic("Passing a consumed object as a function "
        -:  163:		      "parameter!");
        7:  164:}
        -:  165:
       19:  166:void Object_build_int(Object* ptr)
        -:  167:{
        -:  168:	// call internal build handler
       19:  169:	void (*build_int)(Object* ptr) = find_fn(ptr, "build_internal");
       19:  170:	if (!build_int)
    #####:  171:		panic("no internal build handler found");
       19:  172:	build_int(ptr);
       19:  173:}
        -:  174:
       19:  175:void Object_build(Object* ptr)
        -:  176:{
       19:  177:	void (*do_build)(Object* ptr) = find_fn(ptr, "build");
       19:  178:	if (do_build)
        -:  179:	{
        -:  180:		// setup self references
       11:  181:		Object* tmp_Var = __thread_local_self_Var;
       11:  182:		const Object* tmp_Const = __thread_local_self_Const;
       11:  183:		__thread_local_self_Const = ptr;
       11:  184:		__thread_local_self_Var = ptr;
       11:  185:		do_build(ptr);
        -:  186:		// revert
       11:  187:		__thread_local_self_Var = tmp_Var;
       11:  188:		__thread_local_self_Const = tmp_Const;
        -:  189:	}
       19:  190:}
        -:  191:
        -:  192:#if defined(__clang__)
        -:  193:// Clang-specific pragma
        -:  194:#pragma clang diagnostic ignored \
        -:  195:    "-Wincompatible-pointer-types-discards-qualifiers"
        -:  196:#elif defined(__GNUC__) && !defined(__clang__)
        -:  197:// GCC-specific pragma
        -:  198:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  199:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  200:#else
        -:  201:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  202:#endif
       25:  203:void Object_cleanup(const Object* ptr)
        -:  204:{
       25:  205:	Object* unconst = ptr;
       25:  206:	if ((unconst->flags & OBJECT_FLAGS_NO_CLEANUP) == 0)
        -:  207:	{
        -:  208:		// call internal drop handler
       18:  209:		void (*drop_int)(Object* ptr) = find_fn(ptr, "drop_internal");
       18:  210:		if (!drop_int)
    #####:  211:			panic("no internal drop handler found");
       18:  212:		drop_int(unconst);
        -:  213:
        -:  214:		// call defined drop handler
       18:  215:		void (*drop)(Object* ptr) = find_fn(ptr, "drop");
       18:  216:		if (drop)
        -:  217:		{
        -:  218:			// setup self references
       17:  219:			Object* tmp_Var = __thread_local_self_Var;
       17:  220:			Object* tmp_Const = __thread_local_self_Const;
       17:  221:			__thread_local_self_Const = unconst;
       17:  222:			__thread_local_self_Var = unconst;
       17:  223:			drop(ptr);
        -:  224:			// revert
       17:  225:			__thread_local_self_Var = tmp_Var;
       17:  226:			__thread_local_self_Const = tmp_Const;
        -:  227:		}
       18:  228:		if (fat_ptr_data(&unconst->ptr))
        -:  229:		{
       18:  230:			chain_free(&unconst->ptr);
        -:  231:		}
        -:  232:	}
       25:  233:}
        -:  234:
        -:  235:#if defined(__clang__)
        -:  236:// Clang-specific pragma
        -:  237:#pragma GCC diagnostic push
        -:  238:#pragma clang diagnostic ignored \
        -:  239:    "-Wincompatible-pointer-types-discards-qualifiers"
        -:  240:#elif defined(__GNUC__) && !defined(__clang__)
        -:  241:// GCC-specific pragma
        -:  242:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:  243:#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
        -:  244:#else
        -:  245:#warning "Unknown compiler or platform. No specific warning pragmas applied."
        -:  246:#endif
    #####:  247:void Object_mark_consumed(const Object* ptr)
        -:  248:{
    #####:  249:	Object* unconst = ptr;
    #####:  250:	unconst->flags |= OBJECT_FLAGS_NO_CLEANUP | OBJECT_FLAGS_CONSUMED;
    #####:  251:}
        -:  252:#pragma GCC diagnostic pop
