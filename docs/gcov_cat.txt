        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/osdef.h>
        -:   17:
    #####:   18:byte *get_dimmed() {
    #####:   19:	if (getenv("NO_COLOR") != NULL) {
    #####:   20:		return "";
        -:   21:	} else {
    #####:   22:		return "\x1b[2m";
        -:   23:	}
        -:   24:}
        -:   25:
    #####:   26:byte *get_red() {
    #####:   27:	if (getenv("NO_COLOR") != NULL) {
    #####:   28:		return "";
        -:   29:	} else {
    #####:   30:		return "\x1b[31m";
        -:   31:	}
        -:   32:}
        -:   33:
    #####:   34:byte *get_bright_red() {
    #####:   35:	if (getenv("NO_COLOR") != NULL) {
    #####:   36:		return "";
        -:   37:	} else {
    #####:   38:		return "\x1b[91m";
        -:   39:	}
        -:   40:}
        -:   41:
        2:   42:byte *get_green() {
        2:   43:	if (getenv("NO_COLOR") != NULL) {
    #####:   44:		return "";
        -:   45:	} else {
        2:   46:		return "\x1b[32m";
        -:   47:	}
        -:   48:}
        -:   49:
    #####:   50:byte *get_yellow() {
    #####:   51:	if (getenv("NO_COLOR") != NULL) {
    #####:   52:		return "";
        -:   53:	} else {
    #####:   54:		return "\x1b[33m";
        -:   55:	}
        -:   56:}
        -:   57:
    #####:   58:byte *get_cyan() {
    #####:   59:	if (getenv("NO_COLOR") != NULL) {
    #####:   60:		return "";
        -:   61:	} else {
    #####:   62:		return "\x1b[36m";
        -:   63:	}
        -:   64:}
        -:   65:
    #####:   66:byte *get_magenta() {
    #####:   67:	if (getenv("NO_COLOR") != NULL) {
    #####:   68:		return "";
        -:   69:	} else {
    #####:   70:		return "\x1b[35m";
        -:   71:	}
        -:   72:}
        -:   73:
        2:   74:byte *get_blue() {
        2:   75:	if (getenv("NO_COLOR") != NULL) {
    #####:   76:		return "";
        -:   77:	} else {
        2:   78:		return "\x1b[34m";
        -:   79:	}
        -:   80:}
        -:   81:
        4:   82:byte *get_reset() {
        4:   83:	if (getenv("NO_COLOR") != NULL) {
    #####:   84:		return "";
        -:   85:	} else {
        4:   86:		return "\x1b[0m";
        -:   87:	}
        -:   88:}
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:// #include <base/macro_util.h>
        -:   17:// #include <base/os.h>
        -:   18://  #include <base/print_util.h>
        -:   19://  #include <base/string.h>
        -:   20:
        -:   21:_Thread_local byte fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local int64 fam_err = NoErrors;
        -:   24://_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const byte *get_err() {
        -:   27:	// return strncpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
    #####:   28:	return NULL;
        -:   29:}
        -:   30:
    #####:   31:void print_err(const byte *text) {
        -:   32:	// println("{}: {}", FamErrText[fam_err], text);
        -:   33:	// backtrace_print(&thread_local_bt__);
    #####:   34:}
        -:   35:
        -:   36:// void do_backtrace_generate(Backtrace *bt) {
        -:   37:// if (env("CBACKTRACE") != NULL) {
        -:   38://  backtrace_generate(bt);
        -:   39://	}
        -:   40://}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/lock.h>
        -:   16:#include <base/macros.h>
        -:   17:#include <base/print_util.h>
        -:   18:
        -:   19:_Thread_local bool _lock_is_write__ = false;
        -:   20:
    #####:   21:Lock lock_create() {
    #####:   22:	return 0;
        -:   23:}
        2:   24:void lock_read(Lock *lock) {
        2:   25:	_lock_is_write__ = false;
        -:   26:	unsigned long long state;
        -:   27:	unsigned long long state_update;
        -:   28:	do {
        -:   29:		// get current state set the write_pending bit to false
        2:   30:		state = ALOAD(lock) & ~0x80000000ULL;
        -:   31:		// increment the read counter and add 1 to the sequence number (upper 32
        -:   32:		// bits)
        2:   33:		state_update = (state + 0x100000000ULL) + 1ULL;
        -:   34:		// while our target state (no change including sequence number and
        -:   35:		// write_pending != false, we spin)
        2:   36:	} while (!CAS_ACQUIRE(lock, &state, state_update));
        2:   37:}
        2:   38:void lock_write(Lock *lock) {
        2:   39:	_lock_is_write__ = true;
        -:   40:	unsigned long long state;
        -:   41:	unsigned long long state_update;
        -:   42:
        -:   43:	// first step, set write bit true indicating a writer is waiting
        -:   44:	// this lock should be obtained soon after the previous writer
        -:   45:	// is complete indicating to readers our desire to write
        -:   46:	// this avoids write starvation
        -:   47:	do {
        2:   48:		state = ALOAD(lock) & ~0x80000000ULL;
        2:   49:		state_update = (state + 0x100000000ULL) | 0x80000000ULL;
        2:   50:	} while (!CAS(lock, &state, state_update));
        -:   51:
        -:   52:	// second step, obtain total lock before proceeding
        -:   53:	do {
        -:   54:		// get current state. We will wait for the read count to go to 0.
        2:   55:		state = ALOAD(lock) & 0xFFFFFFFF80000000ULL;
        -:   56:		// set the updated value to set the write bit true and read count to 0,
        -:   57:		// increment the sequence number
        2:   58:		state_update = (state + 0x100000000ULL) & 0xFFFFFFFF80000000ULL;
        2:   59:	} while (!CAS_ACQUIRE(lock, &state, state_update));
        2:   60:}
        -:   61:
        4:   62:void lock_unlock(Lock *lock) {
        -:   63:	unsigned long long state;
        -:   64:	unsigned long long state_update;
        -:   65:	// check thread local write variable
        4:   66:	if (_lock_is_write__) {
        -:   67:		// writer
        -:   68:		do {
        -:   69:			// get current state
        2:   70:			state = ALOAD(lock);
        -:   71:			// unset the write bit and increment the sequence number
        2:   72:			state_update = (state + 0x100000000ULL) & ~0x80000000ULL;
        2:   73:		} while (!CAS_RELEASE(lock, &state, state_update));
        -:   74:	} else {
        -:   75:		// reader
        -:   76:		do {
        -:   77:			// get current state
        2:   78:			state = ALOAD(lock);
       2*:   79:			if ((state & 0x7FFFFFFF) == 0) panic("underflow!");
        -:   80:			// subtract 1 from the read count and increment the sequence number
        2:   81:			state_update = (state + 0x100000000ULL) - 1ULL;
        2:   82:		} while (!CAS_RELEASE(lock, &state, state_update));
        -:   83:	}
        4:   84:}
        -:   85:
        2:   86:void lock_guard_cleanup(LockGuard *l) {
        2:   87:	lock_unlock(l);
        2:   88:}
        -:   89:
        1:   90:LockGuard lock_guard_read(Lock l) {
        1:   91:	lock_read(&l);
        1:   92:	return l;
        -:   93:}
        1:   94:LockGuard lock_guard_write(Lock l) {
        1:   95:	lock_write(&l);
        1:   96:	return l;
        -:   97:}
        -:    0:Source:memmap.c
        -:    0:Graph:memmap.gcno
        -:    0:Data:memmap.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/memmap.h>
        -:   17:#include <base/osdef.h>
        -:   18:#include <base/print_util.h>
        -:   19:#include <sys/mman.h>
        -:   20:
        -:   21:void *memset(void *ptr, int x, size_t n);
        -:   22:size_t getpagesize();
        -:   23:
        -:   24:#define MEMMAP_ENTRY_PER_LEVEL 256
        -:   25:#define BITMAP_SIZE 32
        -:   26:#define MEMMAP_SHIFT 8
        -:   27:
        -:   28:_Thread_local int last_i = 0, last_j = 0, last_k = 0, last_l = 0;
        -:   29:
        -:   30:typedef struct MemMapImpl {
        -:   31:	byte ****data;
        -:   32:	unsigned int size;
        -:   33:} MemMapImpl;
        -:   34:
       14:   35:void __attribute__((constructor)) __memmap_check_sizes() {
        -:   36:	if (sizeof(MemMapImpl) != sizeof(MemMap))
        -:   37:		panic("sizeof(MemMapImpl) (%i) != sizeof(MemMap) (%i)",
        -:   38:			  sizeof(MemMapImpl), sizeof(MemMap));
       14:   39:}
        -:   40:
 12053892:   41:unsigned long long *memmap_itt_for(MemMapImpl *impl, int i, int j, int k,
        -:   42:								   int l) {
 12053892:   43:	bool mmapped = false;
 12053892:   44:	byte ****nullvalue1 = NULL;
 12053892:   45:	byte ****data1 = NULL;
        -:   46:	// load data
        -:   47:	do {
 12053892:   48:		if (mmapped) {
    #####:   49:			MUNMAP(data1, MEMMAP_ENTRY_PER_LEVEL * sizeof(byte ***));
        -:   50:		}
 12053892:   51:		data1 = ALOAD(&impl->data);
 12053892:   52:		if (data1 == NULL) {
        6:   53:			data1 = MMAP(MEMMAP_ENTRY_PER_LEVEL * sizeof(byte ***));
        6:   54:			if (data1 == NULL) {
    #####:   55:				SetErr(AllocErr);
    #####:   56:				return NULL;
        -:   57:			}
        6:   58:			mmapped = true;
        6:   59:			memset(data1, '\0', MEMMAP_ENTRY_PER_LEVEL * sizeof(byte ***));
        -:   60:		} else
 12053886:   61:			break;
        6:   62:	} while (!CAS(&impl->data, &nullvalue1, data1));
        -:   63:
        -:   64:	// load second level
 12053892:   65:	byte ***nullvalue2 = NULL;
        -:   66:	byte ***data2;
 12053892:   67:	mmapped = false;
        -:   68:	do {
 12053892:   69:		if (mmapped) {
    #####:   70:			MUNMAP(data2, MEMMAP_ENTRY_PER_LEVEL * sizeof(byte **));
        -:   71:		}
 12053892:   72:		data2 = ALOAD(&impl->data[i]);
 12053892:   73:		if (data2 == NULL) {
        6:   74:			data2 = MMAP(MEMMAP_ENTRY_PER_LEVEL * sizeof(byte **));
        6:   75:			if (data2 == NULL) {
    #####:   76:				SetErr(AllocErr);
    #####:   77:				return NULL;
        -:   78:			}
        6:   79:			mmapped = true;
        6:   80:			memset(data2, '\0', MEMMAP_ENTRY_PER_LEVEL * sizeof(byte **));
        -:   81:		} else
 12053886:   82:			break;
        6:   83:	} while (!CAS(&impl->data[i], &nullvalue2, data2));
        -:   84:
        -:   85:	// load third level
 12053892:   86:	byte **nullvalue3 = NULL;
        -:   87:	byte **data3;
 12053892:   88:	mmapped = false;
        -:   89:	do {
 12053892:   90:		if (mmapped) {
    #####:   91:			MUNMAP(data3, MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:   92:		}
 12053892:   93:		data3 = ALOAD(&impl->data[i][j]);
 12053892:   94:		if (data3 == NULL) {
        6:   95:			data3 = MMAP(MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        6:   96:			if (data3 == NULL) {
    #####:   97:				SetErr(AllocErr);
    #####:   98:				return NULL;
        -:   99:			}
        6:  100:			mmapped = true;
        6:  101:			memset(data3, '\0', MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:  102:		} else
 12053886:  103:			break;
        6:  104:	} while (!CAS(&impl->data[i][j], &nullvalue3, data3));
        -:  105:
        -:  106:	// load fourth and final level
 12053892:  107:	byte *nullvalue4 = NULL;
        -:  108:	byte *data4;
 12053892:  109:	mmapped = false;
        -:  110:	// add 32 bytes for the bitmap
        -:  111:	do {
 12053892:  112:		if (mmapped) {
    #####:  113:			MUNMAP(data4, MEMMAP_ENTRY_PER_LEVEL * impl->size * sizeof(byte) +
        -:  114:							  BITMAP_SIZE);
        -:  115:		}
 12053892:  116:		data4 = ALOAD(&impl->data[i][j][k]);
 12053892:  117:		if (data4 == NULL) {
      212:  118:			data4 = MMAP(MEMMAP_ENTRY_PER_LEVEL * impl->size * sizeof(byte) +
        -:  119:						 BITMAP_SIZE);
      212:  120:			if (data4 == NULL) {
    #####:  121:				SetErr(AllocErr);
    #####:  122:				return NULL;
        -:  123:			}
      212:  124:			mmapped = true;
      212:  125:			memset(data4, '\0',
      212:  126:				   MEMMAP_ENTRY_PER_LEVEL * impl->size * sizeof(byte) +
        -:  127:					   BITMAP_SIZE);
        -:  128:			// set Ptr=0 to allocated so we never return null / also reserve the
        -:  129:			// first value for other purposes
      212:  130:			if (i == 0 && j == 0 && k == 0) data4[0] = 0x3;
        -:  131:		} else
 12053680:  132:			break;
      212:  133:	} while (!CAS(&impl->data[i][j][k], &nullvalue4, data4));
        -:  134:
        -:  135:	// return the lth item at the begining of the data array (32 bytes reserved)
        -:  136:	// l is between 0-3.
 12053892:  137:	unsigned long long *ret = ((unsigned long long *)impl->data[i][j][k]) + l;
 12053892:  138:	return ret;
        -:  139:}
        -:  140:
 21327573:  141:void *memmap_data(const MemMap *mm, Ptr ptr) {
 21327573:  142:	const MemMapImpl *impl = (const MemMapImpl *)mm;
 21327573:  143:	byte *block = impl->data[ptr >> (MEMMAP_SHIFT * 3)]
 21327573:  144:							[(ptr >> (MEMMAP_SHIFT * 2)) & 0xFF]
 21327573:  145:							[(ptr >> (MEMMAP_SHIFT)) & 0xFF];
 21327573:  146:	return (byte *)(block + ((ptr & 0xFF) * impl->size + 32));
        -:  147:}
        6:  148:int memmap_init(MemMap *mm, unsigned int size) {
        6:  149:	MemMapImpl *impl = (MemMapImpl *)mm;
        6:  150:	impl->size = size;
        6:  151:	impl->data = NULL;
        6:  152:	return 0;
        -:  153:}
        -:  154:
 12053019:  155:Ptr memmap_allocate(MemMap *mm) {
 12053019:  156:	Ptr ret = null;
 12053019:  157:	MemMapImpl *impl = (MemMapImpl *)mm;
 12053019:  158:	int i = last_i, j = last_j, k = last_k, l = last_l;
        -:  159:	unsigned long long *current, desired, v;
        -:  160:
        -:  161:	do {
        -:  162:		loop {
        -:  163:			// load section of bitmap
 12053892:  164:			current = memmap_itt_for(impl, i, j, k, l);
12053892*:  165:			if (current == NULL) return null;
 12053892:  166:			v = ALOAD(current);
 12053892:  167:			if (v != ((unsigned long long)0) - 1) break;
        -:  168:			// l is 4 because 64 bits are used in the atomic load
        -:  169:			// the other 4 combinations cover all 256 entries
      873:  170:			if (++l >= 4) {
      217:  171:				l = 0;
      217:  172:				if (++k >= MEMMAP_ENTRY_PER_LEVEL) {
    #####:  173:					k = 0;
    #####:  174:					if (++j >= MEMMAP_ENTRY_PER_LEVEL) {
    #####:  175:						j = 0;
    #####:  176:						i++;
    #####:  177:						if (i == last_i) {
    #####:  178:							SetErr(CapacityExceeded);
    #####:  179:							return null;
        -:  180:						}
        -:  181:					}
        -:  182:				}
        -:  183:			}
        -:  184:		}
        -:  185:
        -:  186:		// find open bit
        -:  187:		int x;
 55722244:  188:		for (x = 0; (v & (0x1ULL << x)) != 0; x++);
 12053019:  189:		ret = (i << (MEMMAP_SHIFT * 3)) | (j << (2 * MEMMAP_SHIFT)) |
 12053019:  190:			  (k << MEMMAP_SHIFT) | (l << 6) | x;
        -:  191:		// set bit
 12053019:  192:		desired = v | (0x1ULL << x);
 12053019:  193:	} while (!CAS(current, &v, desired));
        -:  194:
 12053019:  195:	last_i = i;
 12053019:  196:	last_j = j;
 12053019:  197:	last_k = k;
 12053019:  198:	last_l = l;
        -:  199:
 12053019:  200:	return ret;
        -:  201:}
        -:  202:
 12050016:  203:void memmap_free(MemMap *mm, Ptr ptr) {
12050016*:  204:	if (ptr == null) panic("attempt to free null!");
12050016*:  205:	if (ptr == ptr_reserved) panic("attempt to free a reserved ptr = 1");
12050016*:  206:	if (mm == NULL) panic("invalid (null) memmap");
 12050016:  207:	MemMapImpl *impl = (MemMapImpl *)mm;
        -:  208:	unsigned long long nv, *v, vo;
        -:  209:	int i, j, k, l;
        -:  210:
 12050016:  211:	i = (ptr >> (MEMMAP_SHIFT * 3)) & 0xFF;
 12050016:  212:	j = (ptr >> (MEMMAP_SHIFT * 2)) & 0xFF;
 12050016:  213:	k = (ptr >> (MEMMAP_SHIFT)) & 0xFF;
 12050016:  214:	l = (ptr >> 6) & 0x3;
        -:  215:
        -:  216:	do {
 12050016:  217:		v = (unsigned long long *)impl->data[i][j][k] + l;
 12050016:  218:		vo = ALOAD((unsigned long long *)(v));
12050016*:  219:		if ((vo & (0x1ULL << (ptr & 0x3F))) == 0) panic("double free attempt!");
 12050016:  220:		nv = vo & ~(0x1ULL << (ptr & 0x3F));
 12050016:  221:	} while (!CAS(&*v, &vo, nv));
        -:  222:
 12050016:  223:	last_i = i;
 12050016:  224:	last_j = j;
 12050016:  225:	last_k = k;
 12050016:  226:	last_l = 0;
 12050016:  227:}
        -:  228:
        5:  229:void memmap_cleanup(MemMap *mm) {
        5:  230:	MemMapImpl *impl = (MemMapImpl *)mm;
       5*:  231:	if (impl->data == NULL) return;
       10:  232:	for (int i = 0; impl->data[i] && i < MEMMAP_ENTRY_PER_LEVEL; i++) {
       10:  233:		for (int j = 0; impl->data[i][j] && j < MEMMAP_ENTRY_PER_LEVEL; j++) {
      216:  234:			for (int k = 0; impl->data[i][j][k] && k < MEMMAP_ENTRY_PER_LEVEL;
      211:  235:				 k++) {
      211:  236:				MUNMAP(impl->data[i][j][k],
        -:  237:					   MEMMAP_ENTRY_PER_LEVEL * impl->size * sizeof(byte) +
        -:  238:						   BITMAP_SIZE);
      211:  239:				impl->data[i][j][k] = NULL;
        -:  240:			}
        5:  241:			MUNMAP(impl->data[i][j], MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:  242:		}
        5:  243:		MUNMAP(impl->data[i], MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:  244:	}
        5:  245:	MUNMAP(impl->data, MEMMAP_ENTRY_PER_LEVEL * sizeof(byte *));
        -:  246:}
        -:    0:Source:orbtree.c
        -:    0:Graph:orbtree.gcno
        -:    0:Data:orbtree.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/orbtree.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <base/slabs.h>
        -:   18:
        -:   19:typedef struct OrbTreeNodeImpl {
        -:   20:	Ptr parent;
        -:   21:	Ptr right;
        -:   22:	Ptr left;
        -:   23:	unsigned int right_subtree_height_color;
        -:   24:	unsigned int left_subtree_height;
        -:   25:} OrbTreeNodeImpl;
        -:   26:
       14:   27:void __attribute__((constructor)) __orbtree_check_sizes() {
        -:   28:	if (sizeof(OrbTreeNodeImpl) != sizeof(OrbTreeNode))
        -:   29:		panic("sizeof(OrbTreeNodeImpl) (%i) != sizeof(OrbTreeNode) (%i)",
        -:   30:			  sizeof(OrbTreeNodeImpl), sizeof(OrbTreeNode));
       14:   31:}
        -:   32:
    #####:   33:OrbTreeNode *orbtree_node_right(const OrbTreeNode *tree) {
    #####:   34:	return NULL;
        -:   35:}
        -:   36:
    #####:   37:OrbTreeNode *orbtree_node_left(const OrbTreeNode *tree) {
    #####:   38:	return NULL;
        -:   39:}
        -:   40:
    #####:   41:OrbTree orbtree_create(const SlabAllocator *sa) {
    #####:   42:	OrbTree ret = {};
    #####:   43:	return ret;
        -:   44:}
    #####:   45:OrbTreeNode *orbtree_get(const OrbTree *tree, const OrbTreeNodeWrapper *value,
        -:   46:						 const OrbTreeSearch *search, unsigned int offset) {
    #####:   47:	return NULL;
        -:   48:}
        1:   49:OrbTreeNodeWrapper *orbtree_put(OrbTree *tree, const OrbTreeNodeWrapper *value,
        -:   50:								const OrbTreeSearch *search) {
        1:   51:	return NULL;
        -:   52:}
        -:   53:
    #####:   54:OrbTreeNodeWrapper *orbtree_remove(OrbTree *tree,
        -:   55:								   const OrbTreeNodeWrapper *value,
        -:   56:								   const OrbTreeSearch *search) {
    #####:   57:	return NULL;
        -:   58:}
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/print_util.h>
        -:   17:
        -:   18:// currently using stdio, will move to write
        -:   19:#include <stdio.h>
        -:   20:
    #####:   21:void __attribute__((no_return)) panic(const char *fmt, ...) {
        -:   22:	char buf[1024];
        -:   23:	__builtin_va_list args;
    #####:   24:	print("Panic: ");
    #####:   25:	__builtin_va_start(args, fmt);
    #####:   26:	vfprintf(stderr, fmt, args);
        -:   27:	// vsnprintf(buf, 1024, fmt, args);
    #####:   28:	__builtin_va_end(args);
    #####:   29:	fprintf(stderr, "\n");
        -:   30:
    #####:   31:	exit(-1);
        -:   32:}
        -:   33:
        2:   34:int println(const char *fmt, ...) {
        -:   35:	__builtin_va_list args;
        2:   36:	__builtin_va_start(args, fmt);
        2:   37:	vfprintf(stderr, fmt, args);
        2:   38:	__builtin_va_end(args);
        2:   39:	fprintf(stderr, "\n");
        2:   40:	return 0;
        -:   41:}
        -:   42:
    #####:   43:int print(const char *fmt, ...) {
        -:   44:	__builtin_va_list args;
    #####:   45:	__builtin_va_start(args, fmt);
    #####:   46:	vfprintf(stderr, fmt, args);
    #####:   47:	__builtin_va_end(args);
    #####:   48:	return 0;
        -:   49:}
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/lock.h>
        -:   17:#include <base/macros.h>
        -:   18:#include <base/osdef.h>
        -:   19:#include <base/print_util.h>
        -:   20:#include <base/slabs.h>
        -:   21:
        -:   22:static Ptr RESERVED_PTR = 1;
        -:   23:
        -:   24:typedef struct SlabList {
        -:   25:	Ptr next;
        -:   26:	byte data[];
        -:   27:} SlabList;
        -:   28:
        -:   29:typedef struct SlabAllocatorImpl {
        -:   30:	MemMap mm;
        -:   31:	unsigned int slab_size;
        -:   32:	unsigned int max_free_slabs;
        -:   33:	unsigned int max_total_slabs;
        -:   34:	unsigned int free_size;
        -:   35:	unsigned int total_slabs;
        -:   36:	Ptr head;
        -:   37:	Ptr tail;
        -:   38:} SlabAllocatorImpl;
        -:   39:
       14:   40:void __attribute__((constructor)) __slabs_check_sizes() {
        -:   41:	if (sizeof(SlabAllocatorImpl) != sizeof(SlabAllocator))
        -:   42:		panic("sizeof(SlabAllocatorImpl) (%i) != sizeof(SlabAllocator) (%i)",
        -:   43:			  sizeof(SlabAllocatorImpl), sizeof(SlabAllocator));
       14:   44:}
        -:   45:
   100010:   46:byte *slab_get(SlabAllocator *sa, Ptr ptr) {
   100010:   47:	if (sa == NULL || nil(ptr)) {
    #####:   48:		SetErr(IllegalArgument);
    #####:   49:		return NULL;
        -:   50:	}
   100010:   51:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
   100010:   52:	SlabList *sl = memmap_data(&impl->mm, ptr);
   100010:   53:	if (sl == NULL) {
    #####:   54:		SetErr(IllegalState);
    #####:   55:		return NULL;
        -:   56:	}
   100010:   57:	return sl->data;
        -:   58:}
        -:   59:
    50015:   60:Ptr slab_allocator_grow(SlabAllocatorImpl *impl) {
    50015:   61:	if (AADD(&impl->total_slabs, 1) > impl->max_total_slabs) {
    #####:   62:		ASUB(&impl->total_slabs, 1);
    #####:   63:		SetErr(CapacityExceeded);
    #####:   64:		return null;
        -:   65:	}
    50015:   66:	Ptr ret = memmap_allocate(&impl->mm);
   50015*:   67:	if (nil(ret)) return null;
    50015:   68:	SlabList *sl = memmap_data(&impl->mm, ret);
   50015*:   69:	if (sl == NULL) return null;
    50015:   70:	sl->next = ptr_reserved;
        -:   71:
    50015:   72:	return ret;
        -:   73:}
        -:   74:
        4:   75:int slab_allocator_init(SlabAllocator *sa, unsigned int slab_size,
        -:   76:						unsigned long long max_free_slabs,
        -:   77:						unsigned long long max_total_slabs) {
        4:   78:	if (sa == NULL || slab_size == 0 || max_free_slabs < 5 ||
        -:   79:		max_total_slabs < 5) {
    #####:   80:		SetErr(IllegalArgument);
    #####:   81:		return -1;
        -:   82:	}
        4:   83:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        -:   84:
       4*:   85:	if (memmap_init(&impl->mm, slab_size + sizeof(SlabList))) return -1;
        4:   86:	ASTORE(&impl->free_size, 1);
        4:   87:	ASTORE(&impl->total_slabs, 0);
        4:   88:	impl->slab_size = slab_size;
        4:   89:	impl->max_free_slabs = max_free_slabs;
        4:   90:	impl->max_total_slabs = max_total_slabs;
        -:   91:
        4:   92:	Ptr ptr = slab_allocator_grow(impl);
        4:   93:	if (ptr == null) {
    #####:   94:		return -1;
        -:   95:	}
        -:   96:
        4:   97:	SlabList *sl = memmap_data(&impl->mm, ptr);
        4:   98:	if (sl == NULL) {
    #####:   99:		SetErr(IllegalState);
    #####:  100:		return -1;
        -:  101:	}
        4:  102:	sl->next = null;
        4:  103:	impl->head = impl->tail = ptr;
        -:  104:
        4:  105:	return 0;
        -:  106:}
        -:  107:
        3:  108:void slab_allocator_cleanup(SlabAllocator *sa) {
       3*:  109:	if (sa == NULL) panic("slab_allocator_cleanup with sa = NULL!");
        -:  110:
        3:  111:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        3:  112:	Ptr itt = impl->head;
    50016:  113:	while (itt) {
    50013:  114:		Ptr to_delete = itt;
    50013:  115:		SlabList *sl = memmap_data(&impl->mm, itt);
   50013*:  116:		if (sl == NULL) panic("slab_allocator_cleanup: memmap_data ret NULL!");
    50013:  117:		itt = sl->next;
    50013:  118:		memmap_free(&impl->mm, to_delete);
        -:  119:	}
        -:  120:
        3:  121:	memmap_cleanup(&impl->mm);
        3:  122:}
        -:  123:
  5292886:  124:Ptr slab_allocator_allocate(SlabAllocator *sa) {
  5292886:  125:	if (sa == NULL) {
    #####:  126:		SetErr(IllegalArgument);
    #####:  127:		return null;
        -:  128:	}
  5292886:  129:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        -:  130:	Ptr head, tail, next, ret;
    #####:  131:	loop {
  5292886:  132:		head = impl->head;
  5292886:  133:		tail = impl->tail;
  5292886:  134:		SlabList *sl = memmap_data(&impl->mm, head);
  5292886:  135:		if (sl == NULL) {
    #####:  136:			SetErr(IllegalState);
    #####:  137:			return null;
        -:  138:		}
  5292886:  139:		next = sl->next;
  5292886:  140:		if (head == impl->head) {
  5292886:  141:			if (head == tail) {
    50011:  142:				if (next == null) {
    50011:  143:					return slab_allocator_grow(impl);
        -:  144:				}
    #####:  145:				CAS_SEQ(&impl->tail, &tail, next);
        -:  146:			} else {
  5242875:  147:				ret = head;
  5242875:  148:				if (CAS_SEQ(&impl->head, &head, next)) break;
        -:  149:			}
        -:  150:		}
        -:  151:	}
        -:  152:
  5242875:  153:	ASUB(&impl->free_size, 1);
  5242875:  154:	SlabList *sl = memmap_data(&impl->mm, ret);
  5242875:  155:	if (sl == NULL) {
    #####:  156:		SetErr(IllegalState);
    #####:  157:		return null;
        -:  158:	}
  5242875:  159:	sl->next = ptr_reserved;
  5242875:  160:	return ret;
        -:  161:}
  5292885:  162:void slab_allocator_free(SlabAllocator *sa, Ptr ptr) {
 5292885*:  163:	if (sa == NULL) panic("slab_allocator_free with sa = NULL!");
  5292885:  164:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
        -:  165:
  5292885:  166:	SlabList *slptr = memmap_data(&impl->mm, ptr);
 5292885*:  167:	if (slptr == NULL) panic("cannot retrieve data for a freed ptr!");
        -:  168:
  5292885:  169:	if (!CAS(&slptr->next, &RESERVED_PTR, null))
    #####:  170:		panic("Double free attempt! ptr=%u", ptr);
  5292885:  171:	if (AADD(&impl->free_size, 1) > impl->max_free_slabs) {
    #####:  172:		memmap_free(&impl->mm, ptr);
    #####:  173:		ASUB(&impl->total_slabs, 1);
    #####:  174:		return;
        -:  175:	}
        -:  176:
        -:  177:	Ptr tail, next;
        -:  178:
    #####:  179:	loop {
  5292885:  180:		tail = impl->tail;
  5292885:  181:		SlabList *sltail = memmap_data(&impl->mm, tail);
 5292885*:  182:		if (sltail == NULL) panic("cannot retrieve data for tail!");
  5292885:  183:		next = sltail->next;
  5292885:  184:		if (tail == impl->tail) {
  5292885:  185:			if (next == null) {
  5292885:  186:				if (CAS_SEQ(&sltail->next, &next, ptr)) {
  5292885:  187:					CAS_SEQ(&impl->tail, &tail, ptr);
  5292885:  188:					break;
        -:  189:				}
        -:  190:			} else {
    #####:  191:				CAS_SEQ(&impl->tail, &tail, next);
        -:  192:			}
        -:  193:		}
        -:  194:	}
        -:  195:}
        -:  196:
        -:  197:#ifdef TEST
    #####:  198:unsigned long long slab_allocator_free_size(SlabAllocator *sa) {
    #####:  199:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
    #####:  200:	return ALOAD(&impl->free_size);
        -:  201:}
        -:  202:
    #####:  203:unsigned long long slab_allocator_total_slabs(SlabAllocator *sa) {
    #####:  204:	SlabAllocatorImpl *impl = (SlabAllocatorImpl *)sa;
    #####:  205:	return ALOAD(&impl->total_slabs);
        -:  206:}
        -:  207:#endif	// TEST
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:14
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <base/types.h>
        -:   18:
       14:   19:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   20:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   21:	panic("Supported architectures: __x86_64__, _M_X64, and __aarch64__");
        -:   22:#endif	// arch
        -:   23:
        -:   24:	// check size_t
        -:   25:	if (__SIZEOF_SIZE_T__ != 8) panic("size_t must be 8 bytes. Invalid arch!");
        -:   26:	// check primitive types
        -:   27:	if (sizeof(byte) != 1) panic("byte must be 1 byte. Invalid arch!");
        -:   28:
        -:   29:	if (sizeof(int64) != 8) panic("must be 8 bytes. Invalid arch!");
        -:   30:
        -:   31:	if (sizeof(int) != 4) panic("int must be 4 bytes. Invalid arch!");
        -:   32:
        -:   33:	if (sizeof(float64) != 8) panic("float64 must be 8 bytes. Invalid arch!");
        -:   34:
        -:   35:	if (sizeof(bool) != 1) panic("bool must be 1 byte. Invalid arch!");
        -:   36:
        -:   37:	// little endian check
       14:   38:	int test = 0x1;
       14:   39:	if (*(byte *)&test != 0x1) {
    #####:   40:		panic("Big endian is not supported!");
        -:   41:	}
       14:   42:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:3
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
