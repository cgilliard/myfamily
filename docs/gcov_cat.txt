        -:    0:Source:colors.c
        -:    0:Graph:colors.gcno
        -:    0:Data:colors.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/colors.h>
        -:   16:#include <base/osdef.h>
        -:   17:
    #####:   18:byte *get_dimmed() {
    #####:   19:	if (getenv("NO_COLOR") != NULL) {
    #####:   20:		return "";
        -:   21:	} else {
    #####:   22:		return "\x1b[2m";
        -:   23:	}
        -:   24:}
        -:   25:
    #####:   26:byte *get_red() {
    #####:   27:	if (getenv("NO_COLOR") != NULL) {
    #####:   28:		return "";
        -:   29:	} else {
    #####:   30:		return "\x1b[31m";
        -:   31:	}
        -:   32:}
        -:   33:
    #####:   34:byte *get_bright_red() {
    #####:   35:	if (getenv("NO_COLOR") != NULL) {
    #####:   36:		return "";
        -:   37:	} else {
    #####:   38:		return "\x1b[91m";
        -:   39:	}
        -:   40:}
        -:   41:
    #####:   42:byte *get_green() {
    #####:   43:	if (getenv("NO_COLOR") != NULL) {
    #####:   44:		return "";
        -:   45:	} else {
    #####:   46:		return "\x1b[32m";
        -:   47:	}
        -:   48:}
        -:   49:
    #####:   50:byte *get_yellow() {
    #####:   51:	if (getenv("NO_COLOR") != NULL) {
    #####:   52:		return "";
        -:   53:	} else {
    #####:   54:		return "\x1b[33m";
        -:   55:	}
        -:   56:}
        -:   57:
    #####:   58:byte *get_cyan() {
    #####:   59:	if (getenv("NO_COLOR") != NULL) {
    #####:   60:		return "";
        -:   61:	} else {
    #####:   62:		return "\x1b[36m";
        -:   63:	}
        -:   64:}
        -:   65:
    #####:   66:byte *get_magenta() {
    #####:   67:	if (getenv("NO_COLOR") != NULL) {
    #####:   68:		return "";
        -:   69:	} else {
    #####:   70:		return "\x1b[35m";
        -:   71:	}
        -:   72:}
        -:   73:
    #####:   74:byte *get_blue() {
    #####:   75:	if (getenv("NO_COLOR") != NULL) {
    #####:   76:		return "";
        -:   77:	} else {
    #####:   78:		return "\x1b[34m";
        -:   79:	}
        -:   80:}
        -:   81:
    #####:   82:byte *get_reset() {
    #####:   83:	if (getenv("NO_COLOR") != NULL) {
    #####:   84:		return "";
        -:   85:	} else {
    #####:   86:		return "\x1b[0m";
        -:   87:	}
        -:   88:}
        -:    0:Source:context.c
        -:    0:Graph:context.gcno
        -:    0:Data:context.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#define _XOPEN_SOURCE
        -:   16:
        -:   17:#include <base/context.h>
        -:   18:#include <base/osdef.h>
        -:   19:#include <base/print_util.h>
        -:   20:#include <ucontext.h>
        -:   21:
        -:   22:ucontext_t uctx_main, uctx_return;
        -:   23:
        -:   24:int context_execution_count = 0;
        -:   25:int context_next = 0;
        -:   26:void (*context_fn_array[10])();
        -:   27:
        -:   28:#pragma clang diagnostic ignored "-Wdeprecated-declarations"
        -:   29:#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        -:   30:
        4:   31:void Topic_cleanup(const Topic *ptr) {
        4:   32:}
        -:   33:
        1:   34:int init(void (*main)()) {
        -:   35:	char main_stack[16384];
        -:   36:
        1:   37:	println("init %i", 3);
        1:   38:	if (getcontext(&uctx_main)) {
    #####:   39:		panic("getcontext");
        -:   40:	}
        -:   41:
        1:   42:	uctx_main.uc_stack.ss_sp = main_stack;
        1:   43:	uctx_main.uc_stack.ss_size = sizeof(main_stack);
        1:   44:	uctx_main.uc_link = &uctx_return;
        1:   45:	makecontext(&uctx_main, main, 0);
        -:   46:
        1:   47:	if (swapcontext(&uctx_return, &uctx_main)) {
    #####:   48:		panic("swapcontext");
        -:   49:	}
        1:   50:	println("continue");
        -:   51:
        3:   52:	while (context_next < context_execution_count) {
        2:   53:		if (getcontext(&uctx_main)) {
    #####:   54:			panic("getcontext");
        -:   55:		}
        2:   56:		uctx_main.uc_stack.ss_sp = main_stack;
        2:   57:		uctx_main.uc_stack.ss_size = sizeof(main_stack);
        2:   58:		uctx_main.uc_link = &uctx_return;
        2:   59:		makecontext(&uctx_main, context_fn_array[context_next], 0);
        -:   60:
        2:   61:		println("exe");
        2:   62:		if (swapcontext(&uctx_return, &uctx_main)) {
    #####:   63:			panic("swapcontext");
        -:   64:		}
        2:   65:		println("exe complete");
        2:   66:		context_next++;
        -:   67:	}
        1:   68:	return 0;
        -:   69:}
        -:   70:
        -:   71:ucontext_t uctx_spawn, uctx_spawn_return, uctx_spawn_finalize;
        -:   72:
        2:   73:Topic spawn(void (*fn)()) {
        2:   74:	context_fn_array[context_execution_count] = fn;
        2:   75:	context_execution_count++;
        2:   76:	Topic t;
        2:   77:	return t;
        -:   78:}
        -:    0:Source:fam_alloc.c
        -:    0:Graph:fam_alloc.gcno
        -:    0:Data:fam_alloc.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/fam_err.h>
        -:   17:#include <base/macros.h>
        -:   18:#include <base/osdef.h>
        -:   19:#include <base/print_util.h>
        -:   20:
        -:   21:SlabAllocator global_slab_allocator = NULL;
        -:   22:
        1:   23:Ptr fam_ptr_for(unsigned int id, unsigned int len) {
       1*:   24:	if (len > MAX_SLAB_SIZE) return NULL;
        1:   25:	return ptr_for(global_slab_allocator, id, len);
        -:   26:}
        -:   27:
        -:   28:void __get_page_size__();
       13:   29:void __attribute__((constructor)) __init_sa() {
       13:   30:	if (global_slab_allocator == NULL) {
        -:   31:		// ensure page size set before we continue
       13:   32:		__get_page_size__();
       13:   33:		global_slab_allocator = slab_allocator_create();
       13:   34:		if (global_slab_allocator == NULL) {
    #####:   35:			panic("Could not initialize global slab allocator!");
        -:   36:		}
        -:   37:	}
       13:   38:}
        -:   39:
    #####:   40:void __attribute__((destuctor)) __init_sa_tear_down() {
    #####:   41:	if (global_slab_allocator) slab_allocator_cleanup(&global_slab_allocator);
    #####:   42:	global_slab_allocator = NULL;
    #####:   43:}
        -:   44:
        -:   45:// use highest byte in aux for flags
       29:   46:void ptr_flag_set(Ptr ptr, byte flag, bool value) {
       29:   47:	int64 *aux = ptr_aux(ptr);
       29:   48:	if (value)
        2:   49:		*aux |= (0x1ULL << (unsigned long long)flag) << 56;
        -:   50:	else
       27:   51:		*aux &= ~((0x1ULL << (unsigned long long)flag) << 56);
       29:   52:}
        -:   53:
       29:   54:bool ptr_flag_check(Ptr ptr, byte flag) {
       29:   55:	int64 *aux = ptr_aux(ptr);
       29:   56:	return (*aux) & ((0x1ULL << (unsigned long long)flag) << 56);
        -:   57:}
        -:   58:
       29:   59:Ptr fam_alloc(unsigned int size) {
        -:   60:	// this size is reserved for 'null'
       29:   61:	if (size == UINT32_MAX) {
    #####:   62:		SetErr(Overflow);
    #####:   63:		return NULL;
        -:   64:	}
        -:   65:	Ptr ret;
       29:   66:	if (size > MAX_SLAB_SIZE)
        2:   67:		ret = ptr_direct_alloc(size);
        -:   68:	else {
       27:   69:		ret = slab_allocator_allocate(global_slab_allocator, size);
        -:   70:	}
        -:   71:
       29:   72:	if (ret) {
       29:   73:		int64 *aux = ptr_aux(ret);
       29:   74:		*aux = 0;
       29:   75:		ptr_flag_set(ret, PTR_FLAGS_DIRECT, size > MAX_SLAB_SIZE);
        -:   76:	}
        -:   77:
       29:   78:	return ret;
        -:   79:}
        3:   80:Ptr fam_resize(Ptr ptr, unsigned int size) {
        -:   81:	// this size is reserved for 'null'
        3:   82:	if (size == UINT32_MAX) {
    #####:   83:		SetErr(Overflow);
    #####:   84:		return NULL;
        -:   85:	}
        -:   86:
        3:   87:	if (ptr == NULL) {
    #####:   88:		SetErr(IllegalArgument);
    #####:   89:		return NULL;
        -:   90:	}
        -:   91:
        3:   92:	Ptr ret = fam_alloc(size);
        3:   93:	if (ret) {
        3:   94:		unsigned int len = $len(ptr);
       3*:   95:		if (len > size) len = size;
        3:   96:		memcpy($(ret), $(ptr), len);
        3:   97:		fam_release(ptr);
        -:   98:	}
        -:   99:
        3:  100:	return ret;
        -:  101:}
        -:  102:
       29:  103:void fam_release(Ptr ptr) {
      29*:  104:	if (nil(ptr) || ptr_len(ptr) == UINT32_MAX) {
    #####:  105:		panic("fam_free on nil or special ptr!");
       29:  106:	} else if (ptr_flag_check(ptr, PTR_FLAGS_DIRECT)) {
        2:  107:		ptr_direct_release(ptr);
        -:  108:	} else {
       27:  109:		slab_allocator_free(global_slab_allocator, ptr);
        -:  110:	}
       29:  111:}
        -:  112:
        -:  113:#ifdef TEST
       10:  114:void fam_alloc_cleanup() {
       10:  115:	if (global_slab_allocator) slab_allocator_cleanup(&global_slab_allocator);
       10:  116:	global_slab_allocator = NULL;
       10:  117:}
       10:  118:int64 fam_alloc_count_global_allocator() {
       10:  119:	return slab_allocator_cur_slabs_allocated(global_slab_allocator);
        -:  120:}
        -:  121:#endif	// TEST
        -:    0:Source:fam_err.c
        -:    0:Graph:fam_err.gcno
        -:    0:Data:fam_err.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:// #include <base/macro_util.h>
        -:   17:// #include <base/os.h>
        -:   18://  #include <base/print_util.h>
        -:   19://  #include <base/string.h>
        -:   20:
        -:   21:_Thread_local byte fam_err_last[ERR_LEN + 1] = {""};
        -:   22:
        -:   23:_Thread_local int64 fam_err = NoErrors;
        -:   24://_Thread_local Backtrace thread_local_bt__;
        -:   25:
    #####:   26:const byte *get_err() {
        -:   27:	// return strncpy(fam_err_last, FamErrText[fam_err], ERR_LEN);
    #####:   28:	return NULL;
        -:   29:}
        -:   30:
    #####:   31:void print_err(const byte *text) {
        -:   32:	// println("{}: {}", FamErrText[fam_err], text);
        -:   33:	// backtrace_print(&thread_local_bt__);
    #####:   34:}
        -:   35:
        -:   36:// void do_backtrace_generate(Backtrace *bt) {
        -:   37:// if (env("CBACKTRACE") != NULL) {
        -:   38://  backtrace_generate(bt);
        -:   39://	}
        -:   40://}
        -:    0:Source:lock.c
        -:    0:Graph:lock.gcno
        -:    0:Data:lock.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/lock.h>
        -:   17:#include <base/print_util.h>
        -:   18:
        -:   19:_Thread_local bool _lock_is_write__ = false;
        -:   20:
        -:   21:typedef struct LockImpl {
        -:   22:	// state defines our state. The upper 32 bits are a sequence number which
        -:   23:	// ensures proper ordering the lower 32 bits are: 1.) The higest bit
        -:   24:	// indicates 'write pending' - a writer would like to write the lower 31
        -:   25:	// bits are used as a counter for active readers.
        -:   26:	unsigned long long state;
        -:   27:} LockImpl;
        -:   28:
     7443:   29:Lock lock_create() {
     7443:   30:	Ptr ret = ptr_direct_alloc(sizeof(LockImpl));
    7443*:   31:	if (nil(ret)) return NULL;
     7443:   32:	LockImpl *impl = $(ret);
     7443:   33:	impl->state = 0;
     7443:   34:	return ret;
        -:   35:}
     2068:   36:void lock_read(Lock lock) {
     2068:   37:	_lock_is_write__ = false;
     2068:   38:	LockImpl *impl = $(lock);
        -:   39:
        -:   40:	unsigned long long state;
        -:   41:	unsigned long long state_update;
        -:   42:	do {
        -:   43:		// get current state set the write_pending bit to false
     2068:   44:		state =
     2068:   45:			__atomic_load_n(&impl->state, __ATOMIC_SEQ_CST) & ~0x80000000ULL;
        -:   46:		// increment the read counter and add 1 to the sequence number (upper 32
        -:   47:		// bits)
     2068:   48:		state_update = (state + 0x100000000ULL) + 1ULL;
        -:   49:		// while our target state (no change including sequence number and
        -:   50:		// write_pending = false, we spin)
     2068:   51:	} while (!__atomic_compare_exchange_n(&impl->state, &state, state_update,
        -:   52:										  false, __ATOMIC_SEQ_CST,
        -:   53:										  __ATOMIC_SEQ_CST));
     2068:   54:}
 77705191:   55:void lock_write(Lock lock) {
 77705191:   56:	_lock_is_write__ = true;
 77705191:   57:	LockImpl *impl = $(lock);
        -:   58:
        -:   59:	unsigned long long state;
        -:   60:	unsigned long long state_update;
        -:   61:	do {
        -:   62:		// get current state set the write_pending bit to false (we can't write
        -:   63:		// until it's false) also set the read counter to 0, we can't write
        -:   64:		// until both conditions are met
 77705201:   65:		state = __atomic_load_n(&impl->state, __ATOMIC_SEQ_CST) &
        -:   66:				0xFFFFFFFF00000000ULL;
        -:   67:		// set the updated value to set the write bit true and read count to 0,
        -:   68:		// incremenet the sequence number
 77705201:   69:		state_update = (state + 0x180000000ULL) & 0xFFFFFFFF80000000ULL;
 77705201:   70:	} while (!__atomic_compare_exchange_n(&impl->state, &state, state_update,
        -:   71:										  false, __ATOMIC_SEQ_CST,
        -:   72:										  __ATOMIC_SEQ_CST));
 77705191:   73:}
 77707259:   74:void lock_unlock(Lock lock) {
 77707259:   75:	LockImpl *impl = $(lock);
        -:   76:	unsigned long long state;
        -:   77:	unsigned long long state_update;
        -:   78:	// check thread local write variable
 77707259:   79:	if (_lock_is_write__) {
        -:   80:		// writer
        -:   81:		do {
        -:   82:			// get current state
 77705191:   83:			state = __atomic_load_n(&impl->state, __ATOMIC_SEQ_CST);
        -:   84:			// unset the write bit and increment the sequence number
 77705191:   85:			state_update = (state + 0x100000000ULL) & ~0x80000000ULL;
 77705191:   86:		} while (!__atomic_compare_exchange_n(
 77705191:   87:			&impl->state, &state, state_update, false, __ATOMIC_SEQ_CST,
        -:   88:			__ATOMIC_SEQ_CST));
        -:   89:	} else {
        -:   90:		// reader
        -:   91:		do {
        -:   92:			// get current state
     2068:   93:			state = __atomic_load_n(&impl->state, __ATOMIC_SEQ_CST);
    2068*:   94:			if ((state & 0x7FFFFFFF) == 0) panic("underflow!");
        -:   95:			// subtract 1 from the read count and increment the sequence number
     2068:   96:			state_update = (state + 0x100000000ULL) - 1ULL;
     2068:   97:		} while (!__atomic_compare_exchange_n(
     2068:   98:			&impl->state, &state, state_update, false, __ATOMIC_SEQ_CST,
        -:   99:			__ATOMIC_SEQ_CST));
        -:  100:	}
 77707259:  101:}
        -:  102:
     5955:  103:void Lock_cleanup(const Lock *ptr) {
    5955*:  104:	if (!nil(*ptr)) {
     5955:  105:		ptr_direct_release(*ptr);
        -:  106:	}
     5955:  107:}
        -:  108:
        -:  109:typedef struct LockGuardImpl {
        -:  110:	Lock lock;
        -:  111:} LockGuardImpl;
        -:  112:
       10:  113:LockGuard lock_guard_read(Lock l) {
       10:  114:	LockImpl *li = $(l);
       10:  115:	Ptr ret = fam_alloc(sizeof(LockGuardImpl));
       10:  116:	LockGuardImpl *lgi = $(ret);
       10:  117:	lgi->lock = l;
       10:  118:	lock_read(lgi->lock);
       10:  119:	return ret;
        -:  120:}
       10:  121:LockGuard lock_guard_write(Lock l) {
       10:  122:	LockImpl *li = $(l);
       10:  123:	Ptr ret = fam_alloc(sizeof(LockGuardImpl));
       10:  124:	LockGuardImpl *lgi = $(ret);
       10:  125:	lgi->lock = l;
       10:  126:	lock_write(lgi->lock);
       10:  127:	return ret;
        -:  128:}
        -:  129:
       20:  130:void LockGuard_cleanup(const LockGuard *lg) {
       20:  131:	if (initialized(*lg)) {
       20:  132:		LockGuardImpl *lgi = $(*lg);
       20:  133:		lock_unlock(lgi->lock);
       20:  134:		fam_release(*lg);
        -:  135:	}
       20:  136:}
        -:  137:
        -:  138:#ifdef TEST
        5:  139:unsigned long long lock_get_state(Lock lock) {
        5:  140:	LockImpl *impl = $(lock);
        5:  141:	return impl->state;
        -:  142:}
        -:  143:#endif	// TEST
        -:    0:Source:print_util.c
        -:    0:Graph:print_util.gcno
        -:    0:Data:print_util.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <stdio.h>
        -:   18:
    #####:   19:void __attribute__((no_return)) panic(const char *fmt, ...) {
        -:   20:	char buf[1024];
        -:   21:	__builtin_va_list args;
    #####:   22:	print("Panic: ");
    #####:   23:	__builtin_va_start(args, fmt);
    #####:   24:	vfprintf(stderr, fmt, args);
        -:   25:	// vsnprintf(buf, 1024, fmt, args);
    #####:   26:	__builtin_va_end(args);
    #####:   27:	print("\n");
        -:   28:
    #####:   29:	exit(-1);
        -:   30:}
        -:   31:
        6:   32:int println(const char *fmt, ...) {
        -:   33:	__builtin_va_list args;
        6:   34:	__builtin_va_start(args, fmt);
        6:   35:	vfprintf(stderr, fmt, args);
        6:   36:	__builtin_va_end(args);
        6:   37:	printf("\n");
        6:   38:	return 0;
        -:   39:}
        -:   40:
    #####:   41:int print(const char *fmt, ...) {
        -:   42:	__builtin_va_list args;
    #####:   43:	__builtin_va_start(args, fmt);
    #####:   44:	vfprintf(stderr, fmt, args);
    #####:   45:	__builtin_va_end(args);
    #####:   46:	return 0;
        -:   47:}
        -:    0:Source:queue.c
        -:    0:Graph:queue.gcno
        -:    0:Data:queue.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_alloc.h>
        -:   16:#include <base/queue.h>
        -:   17:
        -:   18:typedef struct QueueNode {
        -:   19:	byte b;
        -:   20:	Ptr next;
        -:   21:} QueueNode;
        -:   22:
        -:   23:typedef struct QueueImpl {
        -:   24:	Ptr head;
        -:   25:	Ptr tail;
        -:   26:} QueueImpl;
        -:   27:
        1:   28:Queue queue_create() {
        1:   29:	Ptr ret = $alloc(sizeof(QueueImpl));
       1*:   30:	if (ret == NULL) return NULL;
        1:   31:	Ptr node = $alloc(sizeof(QueueNode));
        1:   32:	if (node == NULL) {
    #####:   33:		$release(ret);
    #####:   34:		return NULL;
        -:   35:	}
        1:   36:	QueueNode *qnode = $(node);
        1:   37:	qnode->next = NULL;
        1:   38:	QueueImpl *impl = $(ret);
        1:   39:	impl->head = impl->tail = node;
        1:   40:	return ret;
        -:   41:}
    #####:   42:int queue_enqueue(Ptr data) {
    #####:   43:	return 0;
        -:   44:}
    #####:   45:Ptr queue_dequeue() {
    #####:   46:	return NULL;
        -:   47:}
        -:   48:
        -:   49:// Functions that require override of const
        -:   50:#pragma clang diagnostic ignored \
        -:   51:	"-Wincompatible-pointer-types-discards-qualifiers"
        -:   52:#pragma clang diagnostic ignored "-Wunknown-warning-option"
        -:   53:#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
        -:   54:
        1:   55:void Queue_cleanup(const Queue *queue) {
       1*:   56:	if (!nil(*queue)) {
        1:   57:		QueueImpl *impl = $(*queue);
        1:   58:		$release(impl->head);
        1:   59:		fam_release(*queue);
        -:   60:	}
        1:   61:}
        -:    0:Source:slabs.c
        -:    0:Graph:slabs.gcno
        -:    0:Data:slabs.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/fam_err.h>
        -:   16:#include <base/lock.h>
        -:   17:#include <base/macros.h>
        -:   18:#include <base/osdef.h>
        -:   19:#include <base/print_util.h>
        -:   20:#include <base/slabs.h>
        -:   21:
        -:   22:// Alloc/release
        -:   23:
        -:   24:#define SLAB_SIZES 496
        -:   25:#define SLABS_PER_RESIZE 128
        -:   26:#define INITIAL_CHUNKS 0
        -:   27:
        -:   28:int slabs_page_size = 0;
        -:   29:
       26:   30:void __attribute__((constructor)) __get_page_size__() {
       26:   31:	slabs_page_size = getpagesize();
       26:   32:}
        -:   33:
        -:   34:_Thread_local ResourceStats THREAD_LOCAL_RESOURCE_STATS = {0, 0, 0, 0, 0};
        -:   35:
     7686:   36:unsigned int slabs_aligned_size(unsigned int size) {
     7686:   37:	size_t aligned_size =
     7686:   38:		((size_t)size + slabs_page_size - 1) & ~(slabs_page_size - 1);
     7686:   39:	if (aligned_size >= UINT32_MAX) {
    #####:   40:		SetErr(Overflow);
    #####:   41:		return UINT32_MAX;
        -:   42:	}
     7686:   43:	return aligned_size;
        -:   44:}
        -:   45:
     7674:   46:Alloc alloc(unsigned int size) {
     7674:   47:	unsigned int aligned_size = slabs_aligned_size(size);
     7674:   48:	if (aligned_size >= UINT32_MAX) {
    #####:   49:		SetErr(Overflow);
    #####:   50:		Alloc ret = {};
    #####:   51:		return ret;
        -:   52:	}
     7674:   53:	void *ret = mmap(NULL, aligned_size, PROT_READ | PROT_WRITE,
        -:   54:					 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
     7674:   55:	if (ret) {
     7674:   56:		THREAD_LOCAL_RESOURCE_STATS.alloc_sum += 1;
        -:   57:	} else {
    #####:   58:		SetErr(AllocErr);
        -:   59:	}
        -:   60:
     7674:   61:	Alloc aret = {.ptr = ret, .size = aligned_size};
     7674:   62:	return aret;
        -:   63:}
        -:   64:
     6183:   65:void release(Alloc ptr) {
        -:   66:	int code;
     6183:   67:	if ((code = munmap(ptr.ptr, ptr.size))) {
    #####:   68:		panic("munmap error = %i\n", code);
        -:   69:	}
     6183:   70:	THREAD_LOCAL_RESOURCE_STATS.release_sum += 1;
     6183:   71:}
        -:   72:
       22:   73:int64 alloc_sum() {
       22:   74:	return THREAD_LOCAL_RESOURCE_STATS.alloc_sum;
        -:   75:}
    #####:   76:int64 resize_sum() {
    #####:   77:	return THREAD_LOCAL_RESOURCE_STATS.resize_sum;
        -:   78:}
       20:   79:int64 release_sum() {
       20:   80:	return THREAD_LOCAL_RESOURCE_STATS.release_sum;
        -:   81:}
        -:   82:
        -:   83:typedef struct Type {
        -:   84:	// slab id used internally by sa
        -:   85:	unsigned int id;
        -:   86:	// len of slab
        -:   87:	unsigned int len;
        -:   88:	// aux data can be used by caller as desired
        -:   89:	int64 aux;
        -:   90:	// user data
        -:   91:	byte data[];
        -:   92:} Type;
        -:   93:
    10613:   94:unsigned int slab_overhead() {
    10613:   95:	return sizeof(Type);
        -:   96:}
        -:   97:
    29896:   98:unsigned int ptr_len(const Ptr ptr) {
    29896:   99:	return ptr->len - sizeof(Type);
        -:  100:}
        1:  101:unsigned int ptr_id(const Ptr ptr) {
        1:  102:	return ptr->id;
        -:  103:}
155628791:  104:void *ptr_data(const Ptr ptr) {
155628791:  105:	return ptr->data;
        -:  106:}
       87:  107:void *ptr_aux(const Ptr ptr) {
       87:  108:	return &ptr->aux;
        -:  109:}
        -:  110:
     7657:  111:Ptr ptr_direct_alloc(unsigned int size) {
     7657:  112:	Alloc a = alloc(size + sizeof(Type));
     7657:  113:	Ptr ret = a.ptr;
    7657*:  114:	if (a.ptr == NULL) return NULL;
     7657:  115:	ret->len = a.size;
     7657:  116:	ret->id = 0;
     7657:  117:	ret->aux = 0;
     7657:  118:	return ret;
        -:  119:}
        -:  120:
        1:  121:Ptr ptr_direct_resize(Ptr ptr, unsigned int size) {
        1:  122:	Alloc a = alloc(size + sizeof(Type));
       1*:  123:	if (a.ptr == NULL) return NULL;
        1:  124:	Ptr nptr = a.ptr;
        1:  125:	nptr->len = a.size;
        1:  126:	nptr->id = ptr->id;
        1:  127:	nptr->aux = ptr->aux;
        -:  128:	unsigned int copy_sz;
        1:  129:	if (a.size < ptr->len)
    #####:  130:		copy_sz = a.size;
        -:  131:	else
        1:  132:		copy_sz = ptr->len;
        1:  133:	memcpy($(nptr), $(ptr), copy_sz);
        1:  134:	ptr_direct_release(ptr);
        1:  135:	return nptr;
        -:  136:}
        -:  137:
     6170:  138:void ptr_direct_release(Ptr ptr) {
     6170:  139:	Alloc a = {.ptr = ptr, .size = ptr_len(ptr)};
     6170:  140:	release(a);
     6170:  141:}
        -:  142:
        -:  143:typedef struct SlabType {
        -:  144:	unsigned int slab_size;
        -:  145:	unsigned int slabs_per_resize;
        -:  146:	unsigned int initial_chunks;
        -:  147:	unsigned int max_slabs;
        -:  148:} SlabType;
        -:  149:
        -:  150:typedef struct SlabData {
        -:  151:	SlabType type;
        -:  152:	Ptr data;
        -:  153:	Ptr free_list;
        -:  154:	unsigned int cur_chunks;
        -:  155:	unsigned int cur_slabs;
        -:  156:	unsigned int free_list_head;
        -:  157:	Ptr lock;
        -:  158:} SlabData;
        -:  159:
        -:  160:typedef struct SlabAllocatorImpl {
        -:  161:	int64 sd_count;
        -:  162:	SlabData sd_arr[];
        -:  163:} SlabAllocatorImpl;
        -:  164:
       12:  165:void slab_allocator_cleanup(SlabAllocator *ptr) {
      12*:  166:	if (ptr == NULL) return;
       12:  167:	SlabAllocatorNc sa = *ptr;
       12:  168:	if (sa) {
       12:  169:		if (sa->sd_count) {
     5964:  170:			for (int i = 0; i < sa->sd_count; i++) {
     5952:  171:				SlabData *sd = &sa->sd_arr[i];
     5952:  172:				if (sd->cur_chunks) {
       70:  173:					ptr_direct_release(sd->free_list);
       70:  174:					Ptr *datalist = ptr_data(sd->data);
      140:  175:					for (int64 j = 0; j < sd->cur_chunks; j++) {
       70:  176:						ptr_direct_release(datalist[j]);
        -:  177:					}
       70:  178:					ptr_direct_release(sd->data);
       70:  179:					sd->cur_chunks = 0;
        -:  180:				}
     5952:  181:				Lock_cleanup(&sd->lock);
        -:  182:			}
        -:  183:		}
        -:  184:
       12:  185:		int size = sizeof(SlabAllocatorImpl) + SLAB_SIZES * sizeof(SlabData);
       12:  186:		unsigned int aligned = slabs_aligned_size(size);
       12:  187:		Alloc saa = {.ptr = sa, .size = aligned};
       12:  188:		release(saa);
       12:  189:		*ptr = NULL;
        -:  190:	}
        -:  191:}
        -:  192:
       70:  193:void slab_allocator_init_free_list(SlabData *sd, int64 chunks) {
       70:  194:	sd->free_list_head = sd->cur_chunks * sd->type.slabs_per_resize;
       70:  195:	int64 count = chunks * (int64)sd->type.slabs_per_resize;
     1334:  196:	for (int64 i = 0; i < count; i++) {
     1264:  197:		if (i == count - 1) {
       70:  198:			*(unsigned int *)$(&sd->free_list[i + sd->free_list_head]) =
        -:  199:				UINT32_MAX;
        -:  200:		} else {
     2388:  201:			*(unsigned int *)$(&sd->free_list[i + sd->free_list_head]) =
     1194:  202:				1 + i + sd->free_list_head;
        -:  203:		}
        -:  204:	}
       70:  205:}
        -:  206:
       70:  207:int slab_allocator_increase_chunks(SlabData *sd, int64 chunks) {
       70:  208:	if (sd->cur_chunks == 0) {
       70:  209:		sd->free_list = ptr_direct_alloc(chunks * sd->type.slabs_per_resize *
        -:  210:										 sizeof(unsigned int));
      70*:  211:		if (sd->free_list == NULL) return -1;
       70:  212:		sd->data = ptr_direct_alloc(chunks * sizeof(Ptr));
       70:  213:		if (sd->data == NULL) {
    #####:  214:			ptr_direct_release(sd->free_list);
    #####:  215:			return -1;
        -:  216:		}
       70:  217:		Ptr *datalist = ptr_data(sd->data);
      140:  218:		for (int i = 0; i < chunks; i++) {
      140:  219:			datalist[i] =
      140:  220:				ptr_direct_alloc((chunks * sd->type.slabs_per_resize) *
       70:  221:								 (slab_overhead() + sd->type.slab_size));
       70:  222:			if (datalist[i] == NULL) {
    #####:  223:				ptr_direct_release(sd->free_list);
    #####:  224:				for (int64 j = i - 1; j >= 0; j--) {
    #####:  225:					ptr_direct_release(&sd->data[j]);
        -:  226:				}
    #####:  227:				ptr_direct_release(sd->data);
    #####:  228:				return -1;
        -:  229:			}
        -:  230:		}
        -:  231:	} else {
    #####:  232:		if (((int64)chunks + (int64)sd->cur_chunks) *
    #####:  233:				(int64)sd->type.slabs_per_resize >
    #####:  234:			sd->type.max_slabs) {
    #####:  235:			SetErr(Overflow);
    #####:  236:			return -1;
        -:  237:		}
        -:  238:
    #####:  239:		int nsize = (chunks + sd->cur_chunks) * sd->type.slabs_per_resize *
        -:  240:					sizeof(unsigned int);
    #####:  241:		Ptr tmp = ptr_direct_resize(sd->free_list, nsize);
    #####:  242:		if (nil(tmp)) return -1;
    #####:  243:		sd->free_list = tmp;
        -:  244:
    #####:  245:		Ptr tmp2 = ptr_direct_resize(
    #####:  246:			sd->data, (chunks + sd->cur_chunks) * sizeof(byte *));
    #####:  247:		if (nil(tmp2)) return -1;
    #####:  248:		sd->data = tmp2;
    #####:  249:		Ptr *data = $(sd->data);
    #####:  250:		for (int64 i = 0; i < chunks; i++) {
    #####:  251:			data[i + sd->cur_chunks] =
    #####:  252:				ptr_direct_alloc(sd->type.slabs_per_resize *
    #####:  253:								 (slab_overhead() + sd->type.slab_size));
    #####:  254:			if (data[i + sd->cur_chunks] == NULL) {
    #####:  255:				for (int64 j = i - 1; j >= 0; j--) {
    #####:  256:					ptr_direct_release(data[j + sd->cur_chunks]);
        -:  257:				}
        -:  258:			}
        -:  259:		}
        -:  260:	}
        -:  261:
       70:  262:	slab_allocator_init_free_list(sd, chunks);
       70:  263:	sd->cur_chunks += chunks;
       70:  264:	return 0;
        -:  265:}
        -:  266:
     7440:  267:int slab_allocator_init_data(SlabData *sd) {
     7440:  268:	sd->cur_slabs = 0;
     7440:  269:	sd->cur_chunks = 0;
     7440:  270:	sd->free_list_head = UINT32_MAX;
     7440:  271:	sd->free_list = NULL;
     7440:  272:	sd->data = NULL;
     7440:  273:	sd->lock = lock();
        -:  274:
     7440:  275:	if (sd->type.initial_chunks) {
    #####:  276:		if (slab_allocator_increase_chunks(sd, sd->type.initial_chunks))
    #####:  277:			return -1;
        -:  278:	}
     7440:  279:	return 0;
        -:  280:}
        -:  281:
       15:  282:int slab_allocator_init_state(SlabAllocator sa) {
     7455:  283:	for (int i = 0; i < sa->sd_count; i++) {
    7440*:  284:		if (slab_allocator_init_data(&sa->sd_arr[i])) return -1;
        -:  285:	}
        -:  286:
       15:  287:	return 0;
        -:  288:}
        -:  289:
    73007:  290:int slab_allocator_get_size(unsigned int index) {
    73007:  291:	if (index <= 256) return index * 16;
    65055:  292:	if (index <= 496) return (index - 240) * 256;
       15:  293:	return -1;
        -:  294:}
        -:  295:
    67595:  296:int slab_allocator_get_index(unsigned int size) {
    67595:  297:	if (size <= 4096) return (15 + size) / 16;
    61441:  298:	if (size <= 65536) return 240 + (255 + size) / 256;
        1:  299:	return -1;
        -:  300:}
        -:  301:
       15:  302:SlabAllocator slab_allocator_create() {
       15:  303:	if (slabs_page_size == 0) {
    #####:  304:		panic("slabs_page_size == 0");
        -:  305:	}
        -:  306:	SlabAllocatorNc ret;
       15:  307:	Alloc a = alloc(sizeof(SlabAllocatorImpl) + SLAB_SIZES * sizeof(SlabData));
      15*:  308:	if (a.ptr == NULL) return NULL;
       15:  309:	ret = a.ptr;
       15:  310:	ret->sd_count = 0;
        -:  311:
        -:  312:	int size;
     7470:  313:	while ((size = slab_allocator_get_size(ret->sd_count)) >= 0) {
     7455:  314:		SlabData *sd = &ret->sd_arr[ret->sd_count];
     7455:  315:		int slabs_per_resize = slabs_page_size / (slab_overhead() + size);
     7455:  316:		if (slabs_per_resize == 0) slabs_per_resize = 1;
     7455:  317:		sd->type = (const SlabType){.slab_size = size,
        -:  318:									.slabs_per_resize = slabs_per_resize,
        -:  319:									.initial_chunks = INITIAL_CHUNKS,
        -:  320:									.max_slabs = UINT32_MAX};
     7455:  321:		ret->sd_count++;
        -:  322:	}
       15:  323:	ret->sd_count--;
        -:  324:
       15:  325:	if (ret->sd_count != SLAB_SIZES)
    #####:  326:		panic("sd_count mismatch. Expected %i, Found %i!", SLAB_SIZES,
    #####:  327:			  ret->sd_count);
        -:  328:
       15:  329:	if (slab_allocator_init_state(ret)) {
    #####:  330:		slab_allocator_cleanup(&ret);
    #####:  331:		return NULL;
        -:  332:	}
        -:  333:
       15:  334:	return ret;
        -:  335:}
        -:  336:
     1029:  337:int64 slab_allocator_slab_data_index(SlabData *sd, int64 id) {
     1029:  338:	return id / sd->type.slabs_per_resize;
        -:  339:}
        -:  340:
     1029:  341:int64 slab_allocator_slab_data_offset(SlabData *sd, int64 id) {
     3087:  342:	return (id % sd->type.slabs_per_resize) *
     1029:  343:		   (slab_overhead() + sd->type.slab_size);
        -:  344:}
        -:  345:
     1028:  346:Ptr slab_allocator_allocate_sd(SlabData *sd, SlabAllocator sa) {
     1028:  347:	bool err_cond = false;
        -:  348:
     1028:  349:	lockw(sd->lock);
        -:  350:
     1028:  351:	if (sd->free_list_head == UINT32_MAX) {
       70:  352:		if (slab_allocator_increase_chunks(sd, 1)) {
    #####:  353:			err_cond = true;
        -:  354:		}
       70:  355:		if (!err_cond && sd->free_list_head == UINT32_MAX) {
    #####:  356:			SetErr(CapacityExceeded);
        -:  357:		}
        -:  358:	}
     1028:  359:	unlock(sd->lock);
        -:  360:
    1028*:  361:	if (err_cond) return NULL;
        -:  362:
        -:  363:	unsigned int old_free_list_head;
        -:  364:	unsigned int new_free_list_head;
        -:  365:	Ptr ptr;
        -:  366:
        -:  367:	do {
     1028:  368:		old_free_list_head = sd->free_list_head;
     1028:  369:		int64 index = slab_allocator_slab_data_index(sd, old_free_list_head);
     1028:  370:		int64 offset = slab_allocator_slab_data_offset(sd, old_free_list_head);
        -:  371:
     1028:  372:		lockr(sd->lock);
     1028:  373:		Ptr *ptrs = $(sd->data);
     1028:  374:		ptr = (Type *)($(ptrs[index]) + offset);
     1028:  375:		ptr->id = old_free_list_head;
     1028:  376:		ptr->len = sd->type.slab_size;
     1028:  377:		new_free_list_head = ((unsigned int *)$(sd->free_list))[ptr->id];
     1028:  378:		unlock(sd->lock);
        -:  379:
     1028:  380:	} while (!__atomic_compare_exchange_n(
     1028:  381:		&sd->free_list_head, &old_free_list_head, new_free_list_head, false,
        -:  382:		__ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST));
     1028:  383:	__atomic_fetch_add(&sd->cur_slabs, 1, __ATOMIC_SEQ_CST);
        -:  384:
     1028:  385:	return ptr;
        -:  386:}
        -:  387:
     1028:  388:Ptr slab_allocator_allocate(SlabAllocator sa, unsigned int size) {
     1028:  389:	int index = slab_allocator_get_index(size + slab_overhead());
    1028*:  390:	if (index < 0) return NULL;
        -:  391:
     1028:  392:	Ptr ret = slab_allocator_allocate_sd(&sa->sd_arr[index], sa);
        -:  393:
     1028:  394:	return ret;
        -:  395:}
        -:  396:
     1028:  397:void slab_allocator_data_free(SlabData *sd, unsigned int id) {
        -:  398:	unsigned int old_free_list_head;
        -:  399:	unsigned int new_free_list_head;
        -:  400:	do {
     1028:  401:		old_free_list_head = sd->free_list_head;
     1028:  402:		new_free_list_head = id;  // Calculate new_free_list_head here
     1028:  403:		lockr(sd->lock);
     1028:  404:		((unsigned int *)$(sd->free_list))[id] =
        -:  405:			old_free_list_head;	 // Update sd->free_list[id] here
     1028:  406:		unlock(sd->lock);
     1028:  407:	} while (!__atomic_compare_exchange_n(
     1028:  408:		&sd->free_list_head, &old_free_list_head, new_free_list_head, false,
        -:  409:		__ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST));
     1028:  410:	__atomic_fetch_sub(&sd->cur_slabs, 1, __ATOMIC_SEQ_CST);
     1028:  411:}
        -:  412:
     1028:  413:void slab_allocator_free(SlabAllocator sa, Ptr ptr) {
     1028:  414:	if (ptr == NULL || sa == NULL) {
    #####:  415:		panic("Invalid ptr sent to slab_allocator free!");
        -:  416:	}
     1028:  417:	unsigned int len = ptr_len(ptr) + slab_overhead();
     1028:  418:	int index = slab_allocator_get_index(len);
     1028:  419:	if (index < 0) {
    #####:  420:		panic("Invalid ptr sent to slab_allocator free! Unknown size %lli.",
        -:  421:			  len);
        -:  422:	}
     1028:  423:	if (sa->sd_arr[index].type.slab_size != len) {
    #####:  424:		panic(
        -:  425:			"Invalid ptr sent to slab_allocator free! Size mismatch %lli vs. "
        -:  426:			"%lli.",
        -:  427:			sa->sd_arr[index].type.slab_size, len);
        -:  428:	}
        -:  429:
     1028:  430:	slab_allocator_data_free(&sa->sd_arr[index], ptr->id);
     1028:  431:}
        -:  432:
        1:  433:Ptr ptr_for(SlabAllocator sa, unsigned int id, unsigned int len) {
        1:  434:	int index = slab_allocator_get_index(len + slab_overhead());
        1:  435:	if (index < 0) {
    #####:  436:		panic(
        -:  437:			"Invalid ptr sent to slab_allocator ptr_for! Unknown id=%u,len=%u.",
        -:  438:			id, len);
        -:  439:	}
        1:  440:	SlabData sd = sa->sd_arr[index];
        1:  441:	int64 offset = slab_allocator_slab_data_offset(&sd, id);
        1:  442:	index = slab_allocator_slab_data_index(&sd, id);
        1:  443:	if (index >= sd.cur_chunks) {
    #####:  444:		return NULL;
        -:  445:	}
        -:  446:
        1:  447:	lockr(sd.lock);
        1:  448:	Ptr *ptrs = $(sd.data);
        1:  449:	Ptr ptr = ptrs[index];
        1:  450:	Ptr ret = (Type *)($(ptr) + offset);
        1:  451:	unlock(sd.lock);
        1:  452:	return ret;
        -:  453:}
        -:  454:
     2012:  455:int64 slab_allocator_cur_slabs_allocated(const SlabAllocator sa) {
     2012:  456:	int64 slabs = 0;
   999964:  457:	for (int i = 0; i < sa->sd_count; i++) {
   997952:  458:		SlabData *sd = &sa->sd_arr[i];
   997952:  459:		slabs += __atomic_load_n(&sd->cur_slabs, __ATOMIC_SEQ_CST);
        -:  460:	}
     2012:  461:	return slabs;
        -:  462:}
        -:    0:Source:types.c
        -:    0:Graph:types.gcno
        -:    0:Data:types.gcda
        -:    0:Runs:13
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <base/osdef.h>
        -:   16:#include <base/print_util.h>
        -:   17:#include <base/types.h>
        -:   18:
       13:   19:void __attribute__((constructor)) __check_64bit_arch__() {
        -:   20:#if !defined(__x86_64__) && !defined(_M_X64) && !defined(__aarch64__)
        -:   21:	panic("Supported architectures: __x86_64__, _M_X64, and __aarch64__");
        -:   22:#endif // arch
        -:   23:
        -:   24:	// check size_t
        -:   25:	if (__SIZEOF_SIZE_T__ != 8)
        -:   26:		panic("size_t must be 8 bytes. Invalid arch!");
        -:   27:	// check primitive types
        -:   28:	if (sizeof(byte) != 1)
        -:   29:		panic("byte must be 1 byte. Invalid arch!");
        -:   30:
        -:   31:	if (sizeof(int64) != 8)
        -:   32:		panic("must be 8 bytes. Invalid arch!");
        -:   33:
        -:   34:	if (sizeof(int) != 4)
        -:   35:		panic("int must be 4 bytes. Invalid arch!");
        -:   36:
        -:   37:	if (sizeof(float64) != 8)
        -:   38:		panic("float64 must be 8 bytes. Invalid arch!");
        -:   39:
        -:   40:	if (sizeof(bool) != 1)
        -:   41:		panic("bool must be 1 byte. Invalid arch!");
        -:   42:
        -:   43:	if (sizeof(aint64) != 8)
        -:   44:		panic("aint64 must be 8 bytes. Invalid arch!");
        -:   45:
        -:   46:	if (sizeof(abool) != 1)
        -:   47:		panic("abool must be 1 byte. Invalid arch!");
        -:   48:
        -:   49:	/*
        -:   50:		if (getpagesize() != 4096)
        -:   51:			panic("pagesize must be 4096 bytes. Invalid arch!");
        -:   52:	*/
        -:   53:
        -:   54:	// little endian check
       13:   55:	int test = 0x1;
       13:   56:	if (*(byte *)&test != 0x1) {
    #####:   57:		panic("Big endian is not supported!");
        -:   58:	}
       13:   59:}
        -:    0:Source:real_main.c
        -:    0:Graph:real_main.gcno
        -:    0:Data:real_main.gcda
        -:    0:Runs:2
        -:    1:// Copyright (c) 2024, The MyFamily Developers
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#include <main/main.h>
        -:   16:
    #####:   17:int real_main(int argc, char **argv) {
    #####:   18:	return 0;
        -:   19:}
