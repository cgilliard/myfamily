<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Family: core/heap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Family
   </div>
   <div id="projectbrief">My Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">heap.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains definitions for the custom heap allocator.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="types_8h_source.html">core/types.h</a>&gt;</code><br />
</div>
<p><a href="heap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_heap_allocator_config.html">HeapAllocatorConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_fat_ptr.html">FatPtr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_heap_allocator.html">HeapAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a278f1e1d6c3c86f7dae9831e3b783207" id="r_a278f1e1d6c3c86f7dae9831e3b783207"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a278f1e1d6c3c86f7dae9831e3b783207">HA_CONFIG_DEFAULT</a>&#160;&#160;&#160;	{ false, false }</td></tr>
<tr class="separator:a278f1e1d6c3c86f7dae9831e3b783207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d66769b42d4381ca08d14b2141d5aa7" id="r_a1d66769b42d4381ca08d14b2141d5aa7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d66769b42d4381ca08d14b2141d5aa7">HAP_CONFIG</a>(slab_size,  slabs_per_resize,  initial_chunks,  max_slabs)</td></tr>
<tr class="separator:a1d66769b42d4381ca08d14b2141d5aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab3580ee1cd3b7571f43cfefa06f90bd3" id="r_ab3580ee1cd3b7571f43cfefa06f90bd3"><td class="memItemLeft" align="right" valign="top">typedef struct HeapDataParamsConfig&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3580ee1cd3b7571f43cfefa06f90bd3">HeapDataParamsConfig</a></td></tr>
<tr class="separator:ab3580ee1cd3b7571f43cfefa06f90bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab7807967a3bd6b6578ef41981aef1f" id="r_abab7807967a3bd6b6578ef41981aef1f"><td class="memItemLeft" align="right" valign="top">typedef struct HeapAllocatorConfig&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab7807967a3bd6b6578ef41981aef1f">HeapAllocatorConfig</a></td></tr>
<tr class="separator:abab7807967a3bd6b6578ef41981aef1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699932104dc21b9953a234a0421ed0a9" id="r_a699932104dc21b9953a234a0421ed0a9"><td class="memItemLeft" align="right" valign="top">typedef struct FatPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a699932104dc21b9953a234a0421ed0a9">FatPtr</a></td></tr>
<tr class="separator:a699932104dc21b9953a234a0421ed0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be3b2420b29c648206490facf5665dd" id="r_a9be3b2420b29c648206490facf5665dd"><td class="memItemLeft" align="right" valign="top">typedef struct HeapAllocatorImpl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be3b2420b29c648206490facf5665dd">HeapAllocatorImpl</a></td></tr>
<tr class="separator:a9be3b2420b29c648206490facf5665dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86ebae08344fd8320173256e9f59872" id="r_ae86ebae08344fd8320173256e9f59872"><td class="memItemLeft" align="right" valign="top">typedef struct HeapAllocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae86ebae08344fd8320173256e9f59872">HeapAllocator</a></td></tr>
<tr class="separator:ae86ebae08344fd8320173256e9f59872"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9883e6ead40a99cbd04b70e7078b71e1" id="r_a9883e6ead40a99cbd04b70e7078b71e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9883e6ead40a99cbd04b70e7078b71e1">heap_allocator_build</a> (<a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *ptr, <a class="el" href="struct_heap_allocator_config.html">HeapAllocatorConfig</a> *config, int heap_data_params_count,...)</td></tr>
<tr class="separator:a9883e6ead40a99cbd04b70e7078b71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2934ff095b16ad98181e25e7971b0f7" id="r_ab2934ff095b16ad98181e25e7971b0f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2934ff095b16ad98181e25e7971b0f7">heap_allocator_build_arr</a> (<a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *ptr, <a class="el" href="struct_heap_allocator_config.html">HeapAllocatorConfig</a> *config, <a class="el" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a> arr[], <a class="el" href="types_8h.html#a969c7c1ebb4f70581e040a3034b14ee0">u64</a> heap_data_params_count)</td></tr>
<tr class="separator:ab2934ff095b16ad98181e25e7971b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f08a0124120fbf0cda9563502f780fa" id="r_a9f08a0124120fbf0cda9563502f780fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f08a0124120fbf0cda9563502f780fa">heap_allocator_allocate</a> (<a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *ptr, <a class="el" href="types_8h.html#a969c7c1ebb4f70581e040a3034b14ee0">u64</a> size, <a class="el" href="struct_fat_ptr.html">FatPtr</a> *fptr)</td></tr>
<tr class="separator:a9f08a0124120fbf0cda9563502f780fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75241ce08a968d8baf3c6c8d9f97cde" id="r_ac75241ce08a968d8baf3c6c8d9f97cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac75241ce08a968d8baf3c6c8d9f97cde">heap_allocator_free</a> (<a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *ptr, <a class="el" href="struct_fat_ptr.html">FatPtr</a> *fptr)</td></tr>
<tr class="separator:ac75241ce08a968d8baf3c6c8d9f97cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa798be4af0288b37bf349b3fd178efed" id="r_aa798be4af0288b37bf349b3fd178efed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa798be4af0288b37bf349b3fd178efed">heap_allocator_cleanup</a> (<a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *ptr)</td></tr>
<tr class="separator:aa798be4af0288b37bf349b3fd178efed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c693a4fe90758b0686be84bb095f99f" id="r_a5c693a4fe90758b0686be84bb095f99f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c693a4fe90758b0686be84bb095f99f">fat_ptr_data</a> (<a class="el" href="struct_fat_ptr.html">FatPtr</a> *ptr)</td></tr>
<tr class="separator:a5c693a4fe90758b0686be84bb095f99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327a83953cdce415ac9e03c4f465540e" id="r_a327a83953cdce415ac9e03c4f465540e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a969c7c1ebb4f70581e040a3034b14ee0">u64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327a83953cdce415ac9e03c4f465540e">fat_ptr_len</a> (<a class="el" href="struct_fat_ptr.html">FatPtr</a> *ptr)</td></tr>
<tr class="separator:a327a83953cdce415ac9e03c4f465540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains definitions for the custom heap allocator. </p>
<h1><a class="anchor" id="Overview"></a>
Overview</h1>
<p>The custom heap allocator aims to provide efficient memory management for high-performance applications. It includes features such as:</p><ul>
<li>Slab allocation for reducing fragmentation</li>
<li>Support for varying block sizes</li>
</ul>
<h1><a class="anchor" id="Design"></a>
Decisions</h1>
<ul>
<li>The allocator uses a slab-based approach to minimize fragmentation and improve allocation performance.</li>
<li>It incorporates a thread-local storage mechanism to optimize for multi-threaded scenarios.</li>
</ul>
<h1><a class="anchor" id="notes"></a>
notes</h1>
<ul>
<li>Note that the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> implementation does not provide any thread safety. Externaly thread safety techniques must be employed.</li>
<li>Note that regarding alignment, the slab allocator allocates the free list independantly from the raw slab data. Free list entries are 4 bytes long so they follow standard alignment practices for 4 bytes by dividing an array into 4 byte chunks for each free list entry. The data section is split up sequentially. If a 16 byte slab_size is configured with 10 slabs_per_resize, a chunk will be a contiguous block of 160 bytes. When a slab allocated from this chunk it will be aligned to the 16 byte offsets within this chunk.</li>
</ul>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>To use the heap allocator, initialize it with the desired parameters and then use the provided API functions for allocation and deallocation. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a278f1e1d6c3c86f7dae9831e3b783207" name="a278f1e1d6c3c86f7dae9831e3b783207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278f1e1d6c3c86f7dae9831e3b783207">&#9670;&#160;</a></span>HA_CONFIG_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HA_CONFIG_DEFAULT&#160;&#160;&#160;	{ false, false }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d66769b42d4381ca08d14b2141d5aa7" name="a1d66769b42d4381ca08d14b2141d5aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d66769b42d4381ca08d14b2141d5aa7">&#9670;&#160;</a></span>HAP_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAP_CONFIG</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>slab_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>slabs_per_resize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>initial_chunks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>max_slabs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({                                                                     \</div>
<div class="line">        <a class="code hl_struct" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a> _ret__ = {                                \</div>
<div class="line">            slab_size,                                                 \</div>
<div class="line">            slabs_per_resize,                                          \</div>
<div class="line">            initial_chunks,                                            \</div>
<div class="line">            max_slabs,                                                 \</div>
<div class="line">        };                                                             \</div>
<div class="line">        _ret__;                                                        \</div>
<div class="line">    })</div>
<div class="ttc" id="astruct_heap_data_params_config_html"><div class="ttname"><a href="struct_heap_data_params_config.html">HeapDataParamsConfig</a></div><div class="ttdef"><b>Definition</b> heap.h:70</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a699932104dc21b9953a234a0421ed0a9" name="a699932104dc21b9953a234a0421ed0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699932104dc21b9953a234a0421ed0a9">&#9670;&#160;</a></span>FatPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct FatPtr FatPtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pointer structure which includes the length and ID such that the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> implementation may assign and reuse freed slabs and manage memory resources based on specifications. <a class="el" href="struct_fat_ptr.html">FatPtr</a> fields should not be accessed directly and instead the getters for data and len should be used. </p><dl class="section see"><dt>See also</dt><dd>[<a class="el" href="heap_8c.html#a5c693a4fe90758b0686be84bb095f99f">fat_ptr_data</a>] </dd>
<dd>
[<a class="el" href="heap_8c.html#a327a83953cdce415ac9e03c4f465540e">fat_ptr_len</a>] </dd></dl>

</div>
</div>
<a id="ae86ebae08344fd8320173256e9f59872" name="ae86ebae08344fd8320173256e9f59872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86ebae08344fd8320173256e9f59872">&#9670;&#160;</a></span>HeapAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct HeapAllocator HeapAllocator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper that contains the opaque pointer to the <a class="el" href="struct_heap_allocator_impl.html">HeapAllocatorImpl</a> implementation of the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. </p><dl class="section see"><dt>See also</dt><dd>[<a class="el" href="heap_8c.html#a9883e6ead40a99cbd04b70e7078b71e1">heap_allocator_build</a>] </dd>
<dd>
[<a class="el" href="heap_8c.html#a9f08a0124120fbf0cda9563502f780fa">heap_allocator_allocate</a>] </dd>
<dd>
[<a class="el" href="heap_8c.html#ac75241ce08a968d8baf3c6c8d9f97cde">heap_allocator_free</a>] </dd>
<dd>
[<a class="el" href="heap_8c.html#aa798be4af0288b37bf349b3fd178efed">heap_allocator_cleanup</a>] </dd></dl>

</div>
</div>
<a id="abab7807967a3bd6b6578ef41981aef1f" name="abab7807967a3bd6b6578ef41981aef1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab7807967a3bd6b6578ef41981aef1f">&#9670;&#160;</a></span>HeapAllocatorConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct HeapAllocatorConfig HeapAllocatorConfig</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration for a <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. This type specifies whether or not the heap allocated should be zeroed (All <a class="el" href="struct_fat_ptr.html">FatPtr</a> types returned will have all data in them set to 0), or if malloc should be enabled (If no_malloc is set to true, malloc will not be called as a backup on this <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> and the inibility to allocate a slab for the call to heap_allocator_allocate will result in an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zeroed</td><td>if set to true zeroing as described above is enabled. </td></tr>
    <tr><td class="paramname">no_malloc</td><td>if set to true no_malloc as described above is enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="heap_8c.html#a9883e6ead40a99cbd04b70e7078b71e1">heap_allocator_build</a>] </dd></dl>

</div>
</div>
<a id="a9be3b2420b29c648206490facf5665dd" name="a9be3b2420b29c648206490facf5665dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be3b2420b29c648206490facf5665dd">&#9670;&#160;</a></span>HeapAllocatorImpl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct HeapAllocatorImpl HeapAllocatorImpl</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque pointer to the implementation of the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. </p><dl class="section see"><dt>See also</dt><dd>[<a class="el" href="#a9883e6ead40a99cbd04b70e7078b71e1">heap_allocator_build</a>] </dd>
<dd>
[<a class="el" href="#a9f08a0124120fbf0cda9563502f780fa">heap_allocator_allocate</a>] </dd>
<dd>
[<a class="el" href="#ac75241ce08a968d8baf3c6c8d9f97cde">heap_allocator_free</a>] </dd>
<dd>
[<a class="el" href="#aa798be4af0288b37bf349b3fd178efed">heap_allocator_cleanup</a>] </dd></dl>

</div>
</div>
<a id="ab3580ee1cd3b7571f43cfefa06f90bd3" name="ab3580ee1cd3b7571f43cfefa06f90bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3580ee1cd3b7571f43cfefa06f90bd3">&#9670;&#160;</a></span>HeapDataParamsConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct HeapDataParamsConfig HeapDataParamsConfig</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a> specifies how individiaul slab_sizes within the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> are assigned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab_size</td><td>The size of the slabs within this <a class="el" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a>. </td></tr>
    <tr><td class="paramname">slabs_per_resize</td><td>The number of slabs that will be added when the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> runs out of slabs with this configuration size. </td></tr>
    <tr><td class="paramname">initial_chunks</td><td>The number of chunks (defined by the slabs_per_resize param) to create on initialization of the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. This value may be 0, in which case the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> will not initialize any slabs for this size and will only resize based on other configurations if a call to heap_allocator_allocate is made. </td></tr>
    <tr><td class="paramname">max_slabs</td><td>The maximum number of slabs to allocate for this particular slab_size. If more slabs are requested, the resulting behavior is that unless no_malloc is configured in the <a class="el" href="struct_heap_allocator_config.html">HeapAllocatorConfig</a> for this <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>, malloc will be called directly to attempt to allocate the required slabs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="heap_8c.html#a9883e6ead40a99cbd04b70e7078b71e1">heap_allocator_build</a>] </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5c693a4fe90758b0686be84bb095f99f" name="a5c693a4fe90758b0686be84bb095f99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c693a4fe90758b0686be84bb095f99f">&#9670;&#160;</a></span>fat_ptr_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * fat_ptr_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_fat_ptr.html">FatPtr</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the memory location of the specified <a class="el" href="struct_fat_ptr.html">FatPtr</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the location of the <a class="el" href="struct_fat_ptr.html">FatPtr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a void pointer to the data location assicated to this <a class="el" href="struct_fat_ptr.html">FatPtr</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="#a327a83953cdce415ac9e03c4f465540e">fat_ptr_len</a>] </dd></dl>

</div>
</div>
<a id="a327a83953cdce415ac9e03c4f465540e" name="a327a83953cdce415ac9e03c4f465540e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327a83953cdce415ac9e03c4f465540e">&#9670;&#160;</a></span>fat_ptr_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a969c7c1ebb4f70581e040a3034b14ee0">u64</a> fat_ptr_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_fat_ptr.html">FatPtr</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length in bytes of the specified <a class="el" href="struct_fat_ptr.html">FatPtr</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the location of the <a class="el" href="struct_fat_ptr.html">FatPtr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length in bytes that has been allocated to this <a class="el" href="struct_fat_ptr.html">FatPtr</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="#a5c693a4fe90758b0686be84bb095f99f">fat_ptr_data</a>] </dd></dl>

</div>
</div>
<a id="a9f08a0124120fbf0cda9563502f780fa" name="a9f08a0124120fbf0cda9563502f780fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f08a0124120fbf0cda9563502f780fa">&#9670;&#160;</a></span>heap_allocator_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int heap_allocator_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a969c7c1ebb4f70581e040a3034b14ee0">u64</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fat_ptr.html">FatPtr</a> *</td>          <td class="paramname"><span class="paramname"><em>fptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a <a class="el" href="struct_fat_ptr.html">FatPtr</a> from the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> (if possible). Note that The <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> will try to first allocate one of it's existing slabs for this request. If none are available, it will allocate additional slabs up to it's limit which is specified by the configured max_slabs for this <a class="el" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a>. If no more slabs are allowed (or can be created due to a failure to resize), an attempt to call malloc will be made (unless this <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> was configured with the <a class="el" href="struct_heap_allocator_config.html#af68e472fa3d04f4a3714370af1f41456">HeapAllocatorConfig::no_malloc</a> in which case an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the location of the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. </td></tr>
    <tr><td class="paramname">size</td><td>The size, in bytes, of memory to allocate to this <a class="el" href="struct_fat_ptr.html">FatPtr</a> </td></tr>
    <tr><td class="paramname">fptr</td><td>On success the <a class="el" href="struct_fat_ptr.html">FatPtr</a> pointed to by fptr will be updated with the info of the assigned slab/memory location. length of the allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 on error with the appropriate errno value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="#a9883e6ead40a99cbd04b70e7078b71e1">heap_allocator_build</a>] </dd>
<dd>
[<a class="el" href="#ac75241ce08a968d8baf3c6c8d9f97cde">heap_allocator_free</a>] </dd>
<dd>
[<a class="el" href="#aa798be4af0288b37bf349b3fd178efed">heap_allocator_cleanup</a>] </dd></dl>

</div>
</div>
<a id="a9883e6ead40a99cbd04b70e7078b71e1" name="a9883e6ead40a99cbd04b70e7078b71e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9883e6ead40a99cbd04b70e7078b71e1">&#9670;&#160;</a></span>heap_allocator_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int heap_allocator_build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_heap_allocator_config.html">HeapAllocatorConfig</a> *</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>heap_data_params_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a heap_allocator based on the specified <a class="el" href="struct_heap_allocator_config.html">HeapAllocatorConfig</a> and <a class="el" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a> configurations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the location where the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> to be configured is stored. This pointer must not be NULL. </td></tr>
    <tr><td class="paramname">config</td><td>The configuration for this <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. </td></tr>
    <tr><td class="paramname">heap_data_params_count</td><td>The number of variadic arguments being passed to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 on error with the appropriate errno value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="#a9f08a0124120fbf0cda9563502f780fa">heap_allocator_allocate</a>] </dd>
<dd>
[<a class="el" href="#ac75241ce08a968d8baf3c6c8d9f97cde">heap_allocator_free</a>] </dd>
<dd>
[<a class="el" href="#aa798be4af0288b37bf349b3fd178efed">heap_allocator_cleanup</a>] </dd>
<dd>
[<a class="el" href="#ab2934ff095b16ad98181e25e7971b0f7">heap_allocator_build_arr</a>] </dd></dl>

</div>
</div>
<a id="ab2934ff095b16ad98181e25e7971b0f7" name="ab2934ff095b16ad98181e25e7971b0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2934ff095b16ad98181e25e7971b0f7">&#9670;&#160;</a></span>heap_allocator_build_arr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int heap_allocator_build_arr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_heap_allocator_config.html">HeapAllocatorConfig</a> *</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a></td>          <td class="paramname"><span class="paramname"><em>arr</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a969c7c1ebb4f70581e040a3034b14ee0">u64</a></td>          <td class="paramname"><span class="paramname"><em>heap_data_params_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a heap_allocator based on the specified <a class="el" href="struct_heap_allocator_config.html">HeapAllocatorConfig</a> and <a class="el" href="struct_heap_data_params_config.html">HeapDataParamsConfig</a> configurations. This is the array based version of build. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the location where the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> to be configured is stored. This pointer must not be NULL. </td></tr>
    <tr><td class="paramname">config</td><td>The configuration for this <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. </td></tr>
    <tr><td class="paramname">arr</td><td>The array of HeapDataParamsConfigs which specify this <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. </td></tr>
    <tr><td class="paramname">heap_data_params_count</td><td>The number of variadic arguments being passed to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 on error with the appropriate errno value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="#a9f08a0124120fbf0cda9563502f780fa">heap_allocator_allocate</a>] </dd>
<dd>
[<a class="el" href="#ac75241ce08a968d8baf3c6c8d9f97cde">heap_allocator_free</a>] </dd>
<dd>
[<a class="el" href="#aa798be4af0288b37bf349b3fd178efed">heap_allocator_cleanup</a>] </dd>
<dd>
[<a class="el" href="#a9883e6ead40a99cbd04b70e7078b71e1">heap_allocator_build</a>] </dd></dl>

</div>
</div>
<a id="aa798be4af0288b37bf349b3fd178efed" name="aa798be4af0288b37bf349b3fd178efed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa798be4af0288b37bf349b3fd178efed">&#9670;&#160;</a></span>heap_allocator_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int heap_allocator_cleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleanup up this <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> freeing all memory resources associated with it to the operating system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the location of the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 on error with the appropriate errno value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="#ac75241ce08a968d8baf3c6c8d9f97cde">heap_allocator_free</a>] </dd></dl>

</div>
</div>
<a id="ac75241ce08a968d8baf3c6c8d9f97cde" name="ac75241ce08a968d8baf3c6c8d9f97cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75241ce08a968d8baf3c6c8d9f97cde">&#9670;&#160;</a></span>heap_allocator_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int heap_allocator_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_heap_allocator.html">HeapAllocator</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fat_ptr.html">FatPtr</a> *</td>          <td class="paramname"><span class="paramname"><em>fptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the data associated with this <a class="el" href="struct_fat_ptr.html">FatPtr</a> releasing it back to the specified <a class="el" href="struct_heap_allocator.html">HeapAllocator</a>. Note that this memory will not be released back to the operating system, unless this particular <a class="el" href="struct_fat_ptr.html">FatPtr</a> was allocated with malloc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the location of the <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> that this <a class="el" href="struct_fat_ptr.html">FatPtr</a> was assigned by. Note: if a <a class="el" href="struct_fat_ptr.html">FatPtr</a> is freed with a <a class="el" href="struct_heap_allocator.html">HeapAllocator</a> other than the one that allocated it, undefined behavior will result. </td></tr>
    <tr><td class="paramname">fptr</td><td>The <a class="el" href="struct_fat_ptr.html">FatPtr</a> to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 on error with the appropriate errno value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>[<a class="el" href="#aa798be4af0288b37bf349b3fd178efed">heap_allocator_cleanup</a>] </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
