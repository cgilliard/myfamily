// 1.) FAML Types (with defaults)

MyType {
	a = 0u8;
	b = 1u16;
	c = 2u32;
	d = 3u64;
	e = 4u128;
	f = 5i8;
	g = 6i16;
	h = -1i32;
	i = 1234i64;
	j = 5_5_5i128;
	k = 0.3f32;
	l = 0.5f64;
	m = false;
}

// 2.) Tuple-like syntax and struct-like syntax and Arrays

MyType2 {
	// struct-like
	a {
		b = 1234;     // defaults to i32
		c = "abcdef"; // String type (not char *)
	};
	// tuple-like
	d (
		true,
		1234,
		1u32
	);
	e = MyType(With(a, 10), With(b, 3)); // With a previously defined type (overrides other values default)
	f = MyType; // previously defined type with defaults
	g = [u8 | 20]; // statically sized array defaults to 0
	h = [u8]; // dynamically sized array must be allocated using $Alloc
	i = [1,2,3,4]; // static array with 4 values initailized (defaults to i32)
	j = [0u64, 1u64, 2u64]; // static array explicitly initialized to u64s.
	k = [MyType | 20]; // with 20 instances default inits
	l = [MyType(With(a, 10)), MyType, MyType, MyType(With(k, 0.3))]; // various default overrides
}

// 3.) Enums
MyEnum {
	// struct-like variant
	Variant1: {
		x = 1u32;
		y = 0i64;
	};
	// unit-like variant
	Variant2;
	// tuple-like variant
	Variant3: (-1i32, 0u32, "test");
	// type-like syntax
	Variant4: v = 1_234i32; // 1234
	// nested
	Variant5: {
		Nested1: {
			v1 = 0i32;
			v2 = 1u32;
		};
		Nested2;
		Nested3: (-1u8, "test", MyType(With(k, 0.1)));
	}
}

// 4.) Traits
// Traits begin with the '@' symbol
@MyTrait {
	// This function is required. It implicitly has the self parameter and two other
	// paramters with specified mutability. In this case self is immutable.
	@do_something(mut i32 x, u32 y);
	// This function is required. Self is mutable here as indicated by '@mut'
	@mut do_something2(mut i32 v);
	// This function does not have the '@' indicating that there is a default implementation
	// provided for this type. It is also immutable as there is no 'mut'. The parameterss include
	// types that are passed by reference and by value.
	do_something3(i64 x, mut MyType &y, MyType v);
	// Finally the mutable version with an implementation. This function also has a return type (u32).
	mut do_something4(mut i64 v) -> u32;
}

// Declare that MyType implements MyTrait. The c implementation file must include the required methods of
// the trait and any overrides.
impl MyType MyTrait;


// 5.) Super-traits
@MyOtherTrait: MyTrait, Clone, Equal {
	@do_something5(mut i32 x, u32 y);
}

// This requires that anything implemnting 'MyOtherTrait' implement  MyTrait, Clone, Equal as well.
impl MyType MyTrait;
impl MyType Clone;
impl MyType Equal;
impl MyType MyOtherTrait;

// 6.) Generics:
MyType(T) {
	value = T;
	x = 1234i32;
}
// note on defaults for generics. Default for primitives is a memzeroed value. For composite types, it's their default
// values.
// instantiation: (First parameter must be the generic with the binding type)
let x = MyType((T, i32), With(x, 0));
let y = MyType((T, u64));

// 7.) Generic with trait bound:
MyType(T[Clone]) {
	value = T ;
	v = "test";
}

// Instantiation:
let x = MyType((T, String)); // In this case 'String' type.
let y = MyType((T, i32), With(v, "ok")); // With an override of 'v'

// 8.) Trait generics with bounds
MyTrait(T[Clone]) {
	@mut set_value(T value);
}

MyType(R) {
	v = 0;
	clonable = R;
}

// implement for R bound to type String
impl MyType(R[String]) MyTrait(R);

// if you implement for a concrete type like string, you can also do the trait generic version
impl MyType(R[Clone]) MyTrait(R);

// Super traits with trait bounds
MyTrait(T[Clone], R[Equal]): MyOtherTrait(T), NextTrait(R) {
	@do_something() -> i32;
}

// Pair example

// Simple Example :
// mod.h

@Swappable(T) {
        @mut swap();
}

@AccessPair(T) {
        @set_a(T a);
        @set_b(T b);
        @get_a()->T;
        @get_b()->T;
}

Pair(T) {
        a = T;
        b = T;
}

impl Pair(T) Swapable(T);
impl Pair(T) Build;
impl Pair(T) AccessPair(T);

// In c implementation file(Pair.c)

fn(swap) {
        mut tmp = OBJECT_INIT;
        Move(&tmp, $(b));
        Move($Mut(b), $(a));
        Move(&Mut(a), &tmp);
}

fn(build) {
        $Mut(a) = $Config(a);
        $Mut(b) = $Config(b);
}

fn(get_a) {
        return $(a);
}
fn(get_b) {
        return $(b);
}
fn(set_a) {
        $Mut(a) = a;
}
fn(set_b) {
        $Mut(b) = b;
}

// In c main file (main.c)
int main() {
        mut my_pair = _(Pair, (T, u32));
        set_a(&my_pair, 1);
        set_b(&my_pair, 2);
        assert(get_a(&my_pair) == 1);
        assert(get_b(&my_pair) == 2);
        swap(&my_pair);
        assert(get_a(&my_pair) == 2);
        assert(get_b(&my_pair) == 1);
}

// Simple Example :
// mod.h

@Swappable(T) {
        @mut swap();
}

#[Derive(Get(a), Get(b), Set(a), Set(b))]
Pair(T) {
        a = T;
        b = T;
}

impl Pair(T) Swapable(T);
impl Pair(T) Build;

// In c implementation file(Pair.c)

fn(swap) {
        mut tmp = OBJECT_INIT;
        Move(&tmp, $(b));
        Move($Mut(b), $(a));
        Move(&Mut(a), &tmp);
}

fn(build) {
        $Mut(a) = $Config(a);
        $Mut(b) = $Config(b);
}

// In c main file (main.c)

int main() {
        mut my_pair = _(Pair, (T, u32));
        set_a(&my_pair, 1);
        set_b(&my_pair, 2);
        assert(get_a(&my_pair) == 1);
        assert(get_b(&my_pair) == 2);
        swap(&my_pair);
        assert(get_a(&my_pair) == 2);
        assert(get_b(&my_pair) == 1);
}

// With swap derived as well

#[Derive(Get(a), Get(b), Set(a), Set(b), Swappable)]
Pair(T) {
        T a;
        T b;
}

// In c implementation file(Pair.c)

// nothing required

// In c main file (main.c)

int main() {
        mut my_pair = _(Pair, (T, u32));
        set_a(&my_pair, 1);
        set_b(&my_pair, 2);
        assert(get_a(&my_pair) == 1);
        assert(get_b(&my_pair) == 2);
        swap(&my_pair);
        assert(get_a(&my_pair) == 2);
        assert(get_b(&my_pair) == 1);
}

