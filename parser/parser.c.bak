// Copyright (c) 2024, The MyFamily Developers
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <base/ekinds.h>
#include <base/option.h>
#include <base/tlmalloc.h>
#include <base/unit.h>
#include <parser/parser.h>
#include <stdlib.h>

void TokenStream_cleanup(TokenStream *strm) {}

bool is_white_space(char ch) {
	if (ch == '\n' || ch == '\t' || ch == '\r' || ch == '\v' ||
	    ch == '\f' || ch == ' ')
		return true;
	else
		return false;
}

bool is_ident_start(char ch) {
	if ((ch <= 'Z' && ch >= 'A') || (ch <= 'z' && ch >= 'a') || ch == '_') {
		return true;
	} else {
		return false;
	}
}

bool is_ident_secondary(char ch) {
	if (is_ident_start(ch) || (ch <= '9' && ch >= '0')) {
		return true;
	} else {
		return false;
	}
}

bool is_joint_possible(char ch) {
	if (ch == '.' || ch == '=' || ch == '/' || ch == '+' || ch == '&' ||
	    ch == '<' || ch == '-' || ch == '%' || ch == '^' || ch == '*' ||
	    ch == '>' || ch == '|' || ch == '!' || ch == ':') {
		return true;
	} else {
		return false;
	}
}

Result process_doc(TokenStream *strm) {
	TokenTree next = BUILD(TokenTree, GroupType);
	next._group._delimiter = Bracket;
	next._group._strm = tlmalloc(sizeof(TokenStream));
	if (next._group._strm == NULL) {
		Error err = ERROR(ALLOC_ERROR, "Could not allocate memory");
		return Err(err);
	}
	next._group._strm->_parent = strm;
	next._group._strm->_pos_offset = strm->_start_doc + strm->_pos_offset;
	next._group._strm->_file_path = NULL;
	next._group._strm->_pos = 0;
	next._group._strm->_line_num = strm->_line_num;
	int group_len = (strm->_end_doc - strm->_start_doc) + 6;
	next._group._strm->_bytes = tlmalloc(sizeof(char) * group_len);
	if (next._group._strm->_bytes == NULL) {
		free(next._group._strm);
		Error err = ERROR(ALLOC_ERROR, "Could not allocate memory");
		return Err(err);
	}
	next._group._strm->_bytes[0] = 'd';
	next._group._strm->_bytes[1] = 'o';
	next._group._strm->_bytes[2] = 'c';
	next._group._strm->_bytes[3] = '=';
	next._group._strm->_bytes[4] = '\"';
	memcpy(next._group._strm->_bytes + 5, strm->_bytes + strm->_start_doc,
	       group_len - 6);
	next._group._strm->_bytes[group_len - 1] = '\"';
	next._group._strm->_len = group_len;

	next._span._line_num = strm->_line_num;
	next._span._offset = strm->_start_doc + strm->_pos_offset;
	next._span._strm = strm;

	strm->_start_doc = -1;
	strm->_end_doc = -1;
	return Ok(next);
}

bool skip_comments_and_white_space(TokenStream *strm, TokenTree *next,
				   int len) {
	while (true) {
		// first loop until we're not in white space
		while (strm->_pos < len) {
			if (!is_white_space(strm->_bytes[strm->_pos])) {
				break;
			}
			if (strm->_bytes[strm->_pos] == '\n') {
				strm->_line_num += 1;
			}
			strm->_pos += 1;
		}

		// next check if we're at the begining of a comment
		if (strm->_pos < len - 1 && strm->_bytes[strm->_pos] == '/' &&
		    (strm->_bytes[strm->_pos + 1] == '/' ||
		     strm->_bytes[strm->_pos + 1] == '*')) {
			// we're in a comment see which kind
			if (strm->_bytes[strm->_pos + 1] == '/') {
				if (strm->_pos + 4 < len) {
					// this is a doc comment
					if (strm->_bytes[strm->_pos + 2] ==
						'/' &&
					    strm->_bytes[strm->_pos + 3] ==
						' ') {
						strm->_start_doc =
						    strm->_pos + 4;
						strm->_end_doc = strm->_pos;
					}
				}
				while (strm->_pos < len &&
				       strm->_bytes[strm->_pos] != '\n') {
					if (strm->_start_doc > 0) {
						strm->_end_doc += 1;
					}
					strm->_pos += 1;
				}
				if (strm->_start_doc > 0) {
					next->_token_type = PunctType;
					next->_punct._ch = '#';
					next->_punct._second_ch = 0;
					next->_punct._third_ch = 0;
					next->_span._strm = strm;
					next->_span._line_num = strm->_line_num;
					next->_span._offset =
					    strm->_pos + strm->_pos_offset;
					return true;
				}
			} else {
				while (strm->_pos < len &&
				       (strm->_bytes[strm->_pos - 1] != '*' ||
					strm->_bytes[strm->_pos] != '/')) {
					if (strm->_bytes[strm->_pos] == '\n') {
						strm->_line_num += 1;
					}
					strm->_pos += 1;
				}
				strm->_pos += 1;
			}

		} else {
			break;
		}
	}

	return false;
}

Result process_group(TokenStream *strm, TokenTree *next, int ret, int len,
		     Delimiter delimiter) {
	char open_ch;
	char close_ch;

	if (delimiter == Parenthesis) {
		open_ch = '(';
		close_ch = ')';
	} else if (delimiter == Bracket) {
		open_ch = '[';
		close_ch = ']';
	} else if (delimiter == Brace) {
		open_ch = '{';
		close_ch = '}';
	}

	strm->_pos += 1;
	int inner_char_count = 0;
	int in_lit = 0;
	while (strm->_pos < len) {
		if (strm->_bytes[strm->_pos] == close_ch &&
		    inner_char_count == 0 && !in_lit)
			break;
		if (strm->_bytes[strm->_pos] == open_ch && !in_lit)
			inner_char_count += 1;
		else if (strm->_bytes[strm->_pos] == close_ch && !in_lit)
			inner_char_count -= 1;
		else if ((strm->_bytes[strm->_pos] == '\"' ||
			  strm->_bytes[strm->_pos] == '\'') &&
			 !in_lit)
			in_lit = 1;
		else if ((strm->_bytes[strm->_pos] == '\"' ||
			  strm->_bytes[strm->_pos] == '\'') &&
			 in_lit)
			in_lit = 0;

		if (strm->_bytes[strm->_pos] == '\n')
			strm->_line_num += 1;
		strm->_pos += 1;
	}
	if (strm->_pos == len) {
		Error err = ERROR(PARSE_ERROR, "file ended with unclosed '%c'",
				  open_ch);
		return Err(err);
	}
	strm->_pos += 1;

	return Ok(UNIT);
}

Result process_punct(TokenStream *strm, TokenTree *next, int len, int ret) {
	char ch = strm->_bytes[strm->_pos];
	if (ch == ')' || ch == ']' || ch == '}') {
		Error err = ERROR(PARSE_ERROR, "unexpected token, '%c'", ch);
		return Err(err);
	}

	next->_token_type = PunctType;
	next->_punct._ch = strm->_bytes[strm->_pos];
	next->_punct._second_ch = 0;
	next->_punct._third_ch = 0;
	strm->_pos += 1;

	if (strm->_pos < len && is_joint_possible(next->_punct._ch)) {
		char cur = strm->_bytes[strm->_pos];
		if (next->_punct._ch == '!' && cur == '=') {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '%' && cur == '=') {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '&' &&
			   (cur == '&' || cur == '=')) {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '*' && cur == '=') {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '+' && cur == '=') {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '-' &&
			   (cur == '=' || cur == '>')) {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '/' && cur == '=') {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '^' && cur == '=') {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '|' &&
			   (cur == '=' || cur == '|')) {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '=' &&
			   (cur == '>' || cur == '=')) {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == ':' && cur == ':') {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
		} else if (next->_punct._ch == '<' &&
			   (cur == '<' || cur == '=')) {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
			if (strm->_pos < len && cur == '<') {
				cur = strm->_bytes[strm->_pos];
				if (cur == '=') {
					next->_punct._third_ch = cur;
					strm->_pos += 1;
				}
			}
		} else if (next->_punct._ch == '>' &&
			   (cur == '>' || cur == '=')) {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
			if (strm->_pos < len && cur == '>') {
				cur = strm->_bytes[strm->_pos];
				if (cur == '=') {
					next->_punct._third_ch = cur;
					strm->_pos += 1;
				}
			}
		} else if (next->_punct._ch == '.' && cur == '.') {
			next->_punct._second_ch = cur;
			strm->_pos += 1;
			if (strm->_pos < len) {
				cur = strm->_bytes[strm->_pos];
				if (cur == '.' || cur == '=') {
					next->_punct._third_ch = cur;
					strm->_pos += 1;
				}
			}
		}
	}
	return Ok(UNIT);
}

Result TokenStream_next(TokenStream *strm) {
	int len = strm->_len;
	char next_token[len + 1];
	int itt = 0;

	if (strm->_start_doc > 0) {
		Result r = process_doc(strm);
		TokenTree tree = *(TokenTree *)Try(r);
		Option ret = Some(tree);
		return Ok(ret);
	}

	if (strm->_pos >= len) {
		return Ok(None);
	}

	TokenTree next = BUILD(TokenTree);
	if (skip_comments_and_white_space(strm, &next, len)) {
		return Ok(next);
	}

	next._span._line_num = strm->_line_num;
	next._span._offset = strm->_pos + strm->_pos_offset;
	next._span._strm = strm;

	// if we're not an ident start we must be another type
	if (strm->_pos < len && !is_ident_start(strm->_bytes[strm->_pos])) {
		// it's either a literal, group or punct
		int is_literal = 0;
		int is_group = 0;
		int start_group_pos = 0;
		int end_group_pos = 0;
		Delimiter delimiter = Parenthesis;
		if (strm->_bytes[strm->_pos] == '(') {
			delimiter = Parenthesis;
			is_group = 1;
			start_group_pos = strm->_pos + 1;
			Result ret =
			    process_group(strm, &next, ret, len, delimiter);
			Try(ret);
			end_group_pos = strm->_pos - 1;
		} else if (strm->_bytes[strm->_pos] == '[') {
			delimiter = Bracket;
			is_group = 1;
			start_group_pos = strm->_pos + 1;
			Result ret =
			    process_group(strm, &next, ret, len, delimiter);
			Try(ret);
			end_group_pos = strm->_pos - 1;
		} else if (strm->_bytes[strm->_pos] == '{') {
			delimiter = Brace;
			is_group = 1;
			start_group_pos = strm->_pos + 1;
			Result ret =
			    process_group(strm, &next, ret, len, delimiter);
			Try(ret);
			end_group_pos = strm->_pos - 1;
		} else if (strm->_bytes[strm->_pos] == '\"') {
			is_literal = 1;
			next_token[itt] = strm->_bytes[strm->_pos];
			itt += 1;
			strm->_pos += 1;
			while (strm->_pos < len &&
			       strm->_bytes[strm->_pos] != '\"') {
				next_token[itt] = strm->_bytes[strm->_pos];
				strm->_pos += 1;
				itt += 1;
			}
			strm->_pos += 1;
			next_token[itt] = '\"';
			itt++;
			next_token[itt] = 0;
		} else if (strm->_bytes[strm->_pos] >= '0' &&
			   strm->_bytes[strm->_pos] <= '9') {
			is_literal = 1;
			next_token[itt] = strm->_bytes[strm->_pos];
			itt += 1;
			strm->_pos += 1;
			while (strm->_pos < len &&
				   (strm->_bytes[strm->_pos] >= '0' &&
				    strm->_bytes[strm->_pos] <= '9') ||
			       strm->_bytes[strm->_pos] == '.') {
				next_token[itt] = strm->_bytes[strm->_pos];
				strm->_pos += 1;
				itt += 1;
			}

			next_token[itt] = 0;
		} else if (strm->_bytes[strm->_pos] == '\'') {
			next_token[itt] = strm->_bytes[strm->_pos];
			itt += 1;
			strm->_pos += 1;
			while (strm->_pos < len &&
			       strm->_bytes[strm->_pos] != '\'') {
				next_token[itt] = strm->_bytes[strm->_pos];
				strm->_pos += 1;
				itt += 1;
			}
			strm->_pos += 1;
			next_token[itt] = '\'';
			itt++;
			next_token[itt] = 0;
			is_literal = 1;
		}

		if (is_group) {
			next._token_type = GroupType;
			next._group.delimiter = delimiter;
			next._group._strm = tlmalloc(sizeof(TokenStream));
			if (next._group._strm == NULL) {
				Error err = ERROR(ALLOC_ERROR,
						  "Could not allocate memory");
				return Err(err);
			}
			next._group._strm->parent = strm;
			next._group._strm->_pos_offset =
			    start_group_pos + strm->_pos_offset;
			next._group._strm->file_path = NULL;
			next._group._strm->line_num = strm->line_num;
			next._group._strm->_pos = 0;
			int group_len = end_group_pos - start_group_pos;
			next._group._strm->_bytes =
			    tlmalloc(sizeof(char) * group_len);
			if (next._group._strm->_bytes == NULL) {
				free(next._group._strm);
				Error err = ERROR(ALLOC_ERROR,
						  "Could not allocate memory");
				return Err(err);
			}
			memcpy(next._group._strm->_bytes,
			       strm->_bytes + start_group_pos, group_len);
			next._group._strm->_len = group_len;

		} else if (is_literal) {
			next._token_type = LiteralType;
			next.literal = malloc(sizeof(Literal));
			if (next.literal == NULL)
				return 2;
			next.literal->literal = malloc(sizeof(char) * itt);
			if (next.literal->literal == NULL) {
				free(next.literal);
				return 2;
			}
			strcpy(next.literal->literal, next_token);
		} else {
			// punct
			ret = process_punct(strm, next, len, ret);
		}
	} else {
		// ident start
		while (strm->_pos < len) {
			next_token[itt] = strm->_bytes[strm->_pos];

			if (!is_ident_secondary(strm->_bytes[strm->_pos])) {
				break;
			}

			strm->_pos += 1;
			itt += 1;
		}

		if (itt == 0) {
			ret = 0;
		}
		next_token[itt] = 0;
		next._token_type = IdentType;
		next._ident = tlmalloc(sizeof(Ident));
		if (next._ident == NULL) {
			return 2;
		}
		next._ident->value = malloc(sizeof(char) * itt);
		if (next._ident->value == NULL) {
			free(next._ident);
			return 2;
		}
		strcpy(next._ident->value, next_token);
	}

	if (ret == 0) {
		return Ok(None);
	} else {
		return Ok(next);
	}
}

Result TokenStream_parse(char *path, u64 debug_flags) {
	FILE *file = fopen(path, "r");
	if (file == NULL) {
		Error err =
		    ERROR(FILE_NOT_FOUND_ERROR, "failed to open '%s'", file);
		return Err(err);
	}
	long long file_size = 0;   // File size to zero before byte check
	fseek(file, 0L, SEEK_END); // seek to end
	file_size = ftell(file);   // find size of file by checking end
	rewind(file);		   // back to the beginning for reading
	char buffer[16];	   // We will read the file 16 bytes at a time
	TokenStreamPtr strm;
	strm._bytes = tlmalloc(file_size);

	if (strm._bytes == NULL || (debug_flags & DEBUG_FLAG_OOM) != 0) {
		fclose(file);
		Error err =
		    ERROR(ALLOC_ERROR, "could not allocate enough memory");
		return Err(err);
	}

	int ret = fread(strm._bytes, file_size, 1, file);
	if (ret != 1) {
		fclose(file);
		free(strm._bytes);
		Error err =
		    ERROR(IO_ERROR, "failed to read from file '%s'", path);
		return Err(err);
	}
	strm._len = file_size;
	fclose(file);
	strm._pos = 0;
	strm._line_num = 1;
	strm._start_doc = -1;
	strm._end_doc = -1;
	strm._file_path = tlmalloc(sizeof(char) * (strlen(path) + 1));
	if (strm._file_path == NULL) {
		free(strm._bytes);
		Error err =
		    ERROR(ALLOC_ERROR, "could not allocate enough memory");
		return Err(err);
	}
	strcpy(strm._file_path, path);
	strm._parent = NULL;
	strm._pos_offset = 0;

	return Ok(strm);
}

void Span_cleanup(Span *span) {}

Result Span_display(Span *span, ErrorLevel lvl, char *message) { todo() }

void Group_cleanup(Group *group) {}
void Ident_cleanup(Ident *ident) {}
void Literal_cleanup(Literal *literal) {}
void Punct_cleanup(Punct *punct) {}
void TokenTree_cleanup(TokenTree *tree) {}

