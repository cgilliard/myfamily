// logging module

Animal {
	void speak(&s);
	u32 fn2(&me, u32 x) {
		10
	}
}

#[derive(Something)]
Cat {
	x: u64;
	threads: u128 = 10;

	// variable arg *v
	u128 cat_stuff(u64 count) {
		1
	}

	#[something("ok", "ok")]
	Cat new() {
		Cat { x: 1 }
	}
}

Cat::Build {
	// This is the default builder which can be called with snake case bang syntax
        // to overload constants, etc
        Cat (&self) {
		if self.const().threads == 0 {
			return err!(MyKind, "test {}", 3);
		}
                Cat { x: 1 }
        }
}

Cat::Animal {
	void speak(&x) {
		// cat speak
		println!("this is a proc-macro like thing that gets us into c code (TBD)")?;
	}
}

Option<T> {
	value: T;

	Some(T),
	None,
}

Node <V> {
	next: Option<Node<V>>;
	prev: Option<Node<V>>;
	element: V;
}

Node::Build {
	Node (&self) {
		Node { next: None }
	}
}

List <V> {
	head: Option<Node<V>>;
	tail: Option<Node<V>>;

	void push(&self, V value) {
		match self.tail {
			Some(tail) => {
			}
			None => {
				self.tail = node!()!;
			}
		}
	}
}

Main {
	i32 main(char [][] argv) {
		Cat cat = Cat::new()!;
		cat.speak()!;

		Cat cat2 = cat!(Threads(2))?;
		cat.speak()!;

	}
}
